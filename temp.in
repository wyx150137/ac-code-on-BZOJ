Problem1008

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
long long mod = 100003;
long long quick(long long x,long long y)
{
    if(y==0)return 1;
    long long tmp = quick(x,y/2);
    if(y%2==1)return tmp*tmp%mod*x%mod;
    else return tmp*tmp%mod;
}
int main()
{
    long long n,m;
    scanf("%lld%lld",&m,&n);
    long long ans = quick(m,n);
    long long not_ = m*quick(m-1,n-1)%mod;
    printf("%lld\n",((ans-not_)%mod+mod)%mod);
    return 0;
}
Problem1010

#include <stdio.h>
#include <algorithm>
#include <stdlib.h>
#include <math.h>
using namespace std;
#define MaxN 50000+5
int n,l,L,R = 1;
long long sum[MaxN],F[MaxN],Y[MaxN];
int q[MaxN];
long long Z(int x){return F[x]+Y[x]*Y[x];}
long long G(int x){return Y[x]-l-1;}
double calc(int j1,int j2){return 1.0*(Z(j1)-Z(j2))/(Y[j1]-Y[j2]);}
int main()
{
    int x;
    scanf("%d%d",&n,&l);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&x);
        sum[i] = sum[i-1]+x;
        Y[i] = sum[i]+i;
    }
    for(int i = 1;i<= n;i++)
    {
        long long Gi = G(i);
        while(L+1<R&&calc(q[L],q[L+1])<=Gi*2)
            L++;
        F[i] = F[q[L]]+(Gi-Y[q[L]])*(Gi-Y[q[L]]);
        while(L+1<R&&calc(q[R-1],i)<=calc(q[R-2],q[R-1]))
            R--;
        q[R++] = i;
    }
    printf("%lld",F[n]);
    return 0;
}
Problem1014

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int sed = 37;
#define is(x) (son[fa[x]][1]==x)
typedef unsigned long long LL;
char start[N];
int digit[N];
LL power[N]={1};
struct node
{
	int root,n;
	LL hash[N];
	int val[N],fa[N],son[N][2],size[N];
	inline void update(int p)
	{
		size[p]=size[son[p][0]]+size[son[p][1]]+1;
		hash[p]=hash[son[p][0]]*power[size[son[p][1]]+1]+val[p]*power[size[son[p][1]]]+hash[son[p][1]];
	}
	inline void Build(int l,int r,int mid)
	{
		if(l<mid)		{
			int lmid=l+mid-1>>1;
			Build(l,mid-1,lmid);
			fa[lmid]=mid;
			son[mid][0]=lmid;
		}
		if(mid<r)
		{
			int rmid=mid+1+r>>1;
			Build(mid+1,r,rmid);
			fa[rmid]=mid;
			son[mid][1]=rmid;
		}
		val[mid]=digit[mid],update(mid);
	}
	inline void link(int x,int y,int d){son[y][d]=x;fa[x]=y;}
	inline void Rotate(int x)
	{
		int y=fa[x],z=fa[y],id=is(x),t=son[x][!id];
		if(t)fa[t]=y;son[y][id]=t;
		link(x,z,is(y));
		link(y,x,!id);
		update(y);
	}
	inline void Splay(int x,int k)
	{
		int y,z;
		while(fa[x]!=k)
		{
			y=fa[x];
			z=fa[y];
			if(z==k){Rotate(x);break;}
			if(is(x)==is(y))Rotate(y),Rotate(x);
			else Rotate(x),Rotate(x);
		}
		update(x);
		if(!k)root=x;
	}
	inline int Select(int rank,int k)
	{
		if(size[root]<rank)return -1;
		int x=root;
		while(size[son[x][0]]+1!=rank)
		{
			if(size[son[x][0]]+1>rank)x=son[x][0];
			else rank=rank-size[son[x][0]]-1,x=son[x][1];
		}
		Splay(x,k);
		return x;
	}
	inline void newnode(int &x,int y,int w)
	{
		x=++n;
		son[x][0]=son[x][1]=0;
		val[x]=w;
		fa[x]=y;
		size[x]=1;
	}
	inline void Insert(int x,int p)
	{
		int l=Select(x,0),r=Select(x+1,l);
		newnode(son[r][0],r,p);
		Splay(n,0);
	}
	inline void Change(int x,int p){x=Select(x,0),val[x]=p,Splay(x,0);}
	inline bool check(int a,int b,int len)
	{
		int x;
		Select(a-1,0);x=Select(a+len,root);
		if(x==-1)return 0;
		LL hash1=hash[son[x][0]];
		Select(b-1,0);x=Select(b+len,root);
		if(x==-1)return 0;
		LL hash2=hash[son[x][0]];
		return hash1==hash2;
	}
}tree;
char s[N];
int main()
{
	scanf("%s",s+1);
	int m,n=strlen(s+1);
	for(int i = 1;i<N;i++)power[i] = power[i-1]*sed;
	tree.n=n+2;
	for(int i = 2;i<= n+1;i++)
		digit[i] = s[i-1]-'a'+1;
	tree.root=(1+tree.n)>>1;
	tree.Build(1,tree.n,1+tree.n>>1);
	scanf("%d",&m);
	char a[10];
	int l,r;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",a);
		if(a[0]=='Q')
		{
			scanf("%d%d",&l,&r);
			int L = 0,R = tree.n,ans = 0;
			while(L<=R)
			{
				int mid = (L+R)>>1;
				if(tree.check(l+1,r+1,mid))L=mid+1,ans=mid;
				else R=mid-1;
			}
			printf("%d\n",ans);
		}else if(a[0]=='R')
		{
			scanf("%d%s",&l,a);
			tree.Change(l+1,a[0]-'a'+1);
		}else
		{
			scanf("%d%s",&l,a);
			tree.Insert(l+1,a[0]-'a'+1);
		}
	}
	return 0;
}
Problem1015

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 400005;
struct E
{int next,to;}e[N];
int head[N],tot,T;
int fa[N];
bool used[N];
void add_e(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;

	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int getfa(int x)
{
	if(fa[x]==x||!fa[x])
		return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void add_p(int x)
{
	int root = getfa(x);
	for(int i = head[x];i;i = e[i].next)
	{
		int q= getfa(e[i].to);
		if(used[e[i].to]&&q!=root){fa[q] = root;T--;}
	}
	return ;
}
int ask[N],ans[N],b[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		x++;y++;
		add_e(x,y);
	}
	int k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&ask[i]);
		ask[i]++;
		b[ask[i]] = 1;
	}
	for(int i = 1;i<= n;i++)
		if(b[i]==0)
		{
			T++;
			add_p(i);
			used[i] = true;
		}
	ans[k] = T;
	for(int i = k;i>=1;i--)
	{
		T++;
		add_p(ask[i]);
		used[ask[i]] =true;
		ans[i-1] = T;
	}
	for(int i = 0;i<= k;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem1016

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 1005;
const int mod = 31011;
struct E
{
	int u,v,l;
	bool operator<(const E &s)const
	{
		return l<s.l;
	}
}e[M];
int n,m;
int fa[N],U[N],vis[N];
int G[N][N],C[N][N];
vector<int>V[N];
int getfa(int x,int fa[])
{
	return fa[x]==x?x:fa[x]=getfa(fa[x],fa);
}
int gauss(int a[][N],int n)
{
	for(int i= 0;i<n;i++)
		for(int j = 0;j<n;j++)
			a[i][j]%=mod;
	int ans = 1;
	for(int i = 1;i<n;i++)
	{
		for(int j = i+1;j<n;j++)
			while(a[j][i])
			{
				int t = a[i][i]/a[j][i];
				for(int k = i;k<n;k++)
					a[i][k]=(a[i][k]-a[j][k]*t)%mod;
				for(int k = i;k<n;k++)
					swap(a[i][k],a[j][k]);
				ans = -ans;
			}
		if(a[i][i]==0)return 0;
		ans = ans*a[i][i]%mod;
	}
	if(ans<0)ans=-ans;
	return (ans+mod)%mod;
}
void solve()
{
	sort(e,e+m);
	for(int i = 1;i<= n;i++)fa[i]=i,vis[i]=0;
	int edge = -1,ans=1;
	for(int k = 0;k<= m;k++)
	{
		if(edge!=e[k].l||k==m)
		{
			for(int i = 1;i<= n;i++)
				if(vis[i])
				{
					int u = getfa(i,U);
					V[u].push_back(i);
					vis[i]=0;
				}
			for(int i = 1;i<= n;i++)
				if(V[i].size()>1)
				{
					for(int a = 1;a<=n;a++)
						for(int b = 1;b<=n;b++)
							C[a][b]=0;
					int len = V[i].size();
					for(int a = 0;a<len;a++)
						for(int b = a+1;b<len;b++)
						{
							int a1 = V[i][a],b1 = V[i][b];
							C[a][b] = (C[b][a]-=G[a1][b1]);
							C[a][a]+=G[a1][b1];
							C[b][b]+=G[a1][b1];
						}
					int tmp = gauss(C,len);
					ans = ans*tmp%mod;
					for(int a = 0;a<len;a++)
						fa[V[i][a]]=i;
				}
			for(int i = 1;i<= n;i++)
			{
				U[i] = fa[i] = getfa(i,fa);
				V[i].clear();
			}
			if(k==m)break;
			edge=e[k].l;
		}
		int a = e[k].u,b=e[k].v;
		int a1 = getfa(a,fa),b1=getfa(b,fa);
		if(a1==b1)continue;
		vis[a1]=vis[b1]=1;
		U[getfa(a1,U)]=getfa(b1,U);
		G[a1][b1]++;
		G[b1][a1]++;
	}
	bool flag = false;
	for(int i = 2;i<= n&&!flag;i++)
		if(U[i]!=U[i-1])
			flag = true;
	if(m==0)
		flag=1;
	printf("%d\n",flag?0:ans%mod);
}
int main()
{
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		memset(G,0,sizeof(G));
		for(int i = 1;i<= n;i++)
			V[i].clear();
		for(int i = 0;i<m;i++)
			scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].l);
		solve();
	}
	return 0;
}
Problem1017

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2005;
int kind[N],num[N],cost[N],power[N],ind[N];
int f[N][M][N*2];
int g[N][M];
struct E
{
	int val,next,to;
}e[N<<1];
int head[N],tot,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	if(head[x]==0)
	{
		num[x] = min(num[x],m/cost[x]);
		for(int j = 0;j<=num[x];j++)
			for(int k = 0;k<= j;k++)
				f[x][j*cost[x]][k] = power[x]*(j-k);
		return ;
	}
	num[x] = 105;
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		num[x] = min(num[x],num[e[i].to]/e[i].val);
		cost[x] += cost[e[i].to]*e[i].val;
	}
	num[x] = min(num[x],m/cost[x]);
	int cnt = 0;
	memset(g,-0x3f,sizeof(g));
    g[0][0]=0;	
	for(int l = num[x];l>= 0;l--)
	{
		cnt=0;
		for(int i = head[x];i;i = e[i].next)
		{
			cnt++;
			for(int j = 0;j<= m;j++)
				for(int k = 0;k<=j;k++)
					if(l*e[i].val<=num[e[i].to])
						g[cnt][j] = max(g[cnt][j],g[cnt-1][j-k]+f[e[i].to][k][l*e[i].val]);
		}
		for(int k = 0;k<= l;k++)
			for(int j = 0;j<= m;j++)
				f[x][j][k] = max(f[x][j][k],g[cnt][j]+power[x]*(l-k));
	}	
}
int main()
{
	memset(f,-0x3f,sizeof(f));
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&power[i]);
		char ju[3];
		scanf("%s",ju);
		if(ju[0]=='B')
			scanf("%d%d",&cost[i],&num[i]);
		else
		{
			int num,x,y;
			scanf("%d",&num);
			for(int	j = 1;j<= num;j++)
			{
				scanf("%d%d",&x,&y);
				add(i,x,y);ind[x]++;
			}
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(!ind[i])
		{
			dfs(i);
			for(int j = 0;j<= m;j++)
				for(int k = 0;k<= num[i];k++)
					ans = max(ans,f[i][j][k]);
		}
	printf("%d\n",ans);
	return 0;
}
Problem1023

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 2e6+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N],fa[N],a[N],dep[N],pos[N],low[N],q[N],Dfn,ans;
void solve(int x,int y)
{
	int cnt = dep[y]-dep[x]+1,h = 1,t = 1,i;
	for(i = y;i!=x;i = fa[i])a[cnt--]=f[i];a[1] = f[x];
	cnt = dep[y]-dep[x]+1,q[1] = 1;
	for(i=1;i<=cnt;i++)a[i+cnt]=a[i];
	for(i=2;i<=cnt+(cnt>>1);i++)
	{
		if(i-q[h]>(cnt>>1))h++;
		ans = max(ans,a[i]+i+a[q[h]]-q[h]);
		while(h<=t&&a[i]-i>=a[q[t]]-q[t])
			t--;
		q[++t] = i;
	}
	for(int i = 2;i<= cnt;i++)
		f[x] = max(f[x],a[i]+min(i-1,cnt-i+1));
}
void dfs(int x)
{
	pos[x] = low[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)
	{
		if(e[i].to==fa[x])continue;
		if(!pos[e[i].to])
		{
			fa[e[i].to] = x;
			dep[e[i].to] = dep[x]+1;
			dfs(e[i].to);
		}
		low[x] = min(low[x],low[e[i].to]);
		if(low[e[i].to]>pos[x])
		{
			ans = max(ans,f[e[i].to]+f[x]+1);
			f[x] = max(f[x],f[e[i].to]+1);
		}
	}
	for(int i = head[x];i;i=e[i].next)
		if(fa[e[i].to]!=x&&pos[x]<pos[e[i].to])
			solve(x,e[i].to);
}
int main()
{
	int n,m,cnt;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int x,y;
		scanf("%d",&cnt);
		scanf("%d",&x);
		for(int j = 2;j<= cnt;j++)
		{
			scanf("%d",&y);
			add(x,y);
			x = y;
		}
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}
Problem1026

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long f[15][15];
long long get_ans(long long x)
{
	int num[15] = {},cnt = 0;
	long long ans = 0;
	while(x)
	{
		num[++cnt] = x%10;
		x/=10;
	}
	for(int i = 1;i<= num[cnt]-1;i++)
		ans+=f[cnt][i];
	for(int i = cnt-1;i>=1;i--)
		for(int j = 1;j<= 9;j++)
			ans+=f[i][j];
	for(int i = cnt-1;i>= 1;i--)
	{
		for(int j = 0;j<= num[i]-1;j++)
			if(abs(j-num[i+1])>=2)
				ans+=f[i][j];
		if(abs(num[i+1]-num[i])<2)break;
	}
	return ans;
}
int main()
{
	long long a,b;
	scanf("%lld%lld",&a,&b);
	for(int i = 0;i<= 9;i++)
		f[1][i] = 1;
	for(int i = 2;i<= 10;i++)
		for(int j = 0;j<= 9;j++)
			for(int k = 0;k<=9;k++)
				if(abs(j-k)>=2)
					f[i][j]+=f[i-1][k];
	printf("%lld",get_ans(b+1)-get_ans(a));
	return 0;
}
Problem1027

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const double eps = 1e-7;
const int N = 505;
const int INF = 0x3f3f3f3f;
struct Point
{
	double x,y;
	Point(){}
	Point(double x,double y):x(x),y(y){}
	Point operator+(const Point &a)const
	{
		return Point(x+a.x,y+a.y);
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	double operator*(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
	double operator^(const Point &a)const
	{
		return x*a.x+y*a.y;
	}
}mtr[N],req[N];
struct Line
{
	Point p,v;
	Line(){}
	Line(const Point &a,const Point &b):p(a),v(b){}
};
int map[N][N];
void display()
{
	for(int i = 1;i<= 10;i++)
	{
		for(int j = 1;j<= 10;j++)
			if(map[i][j]==INF)printf("0");
			else printf("1");
		printf("\n");
	}
}
int main()
{
	memset(map,0x3f,sizeof(map));
	int n,m;
	double c;
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= m;i++)
		scanf("%lf%lf%lf",&mtr[i].x,&mtr[i].y,&c);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf%lf",&req[i].x,&req[i].y,&c);
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<=m;j++)
		{
			bool flag=true;
			for(int k = 1;k<= n;k++)
			{
				double cro = (mtr[i]-req[k])*(mtr[j]-req[k]);
				if(cro>eps){flag = false;break;}
				if(fabs(cro)<eps&&((mtr[i]-req[k])^(mtr[j]-req[k]))>eps)
					{flag = false;break;}
			}
			if(flag)map[i][j] = 1;
		}
	for(int k = 1;k<= m;k++)
		for(int i = 1;i<= m;i++)
			for(int j = 1;j<= m;j++)
				map[i][j] = min(map[i][j],map[i][k]+map[k][j]);
	int ans = INF;
	for(int i = 1;i<= m;i++)
		ans = min(ans,map[i][i]);
	if(ans!=INF)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem1030

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'A')
const int P = 6005;
const int N = 65;
const int Len = 105;
const int mod = 10007;
char s[Len];
int f[Len][P];
struct AC_Machine
{
	int ch[P][26],cnt,fail[P],q[P],h,t;
	bool danger[P];
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)ch[0][i] = 1;
	}
	void insert()
	{
		int now = 1,i = 0;
		while(s[i])
		{
			if(!ch[now][s(i)])ch[now][s(i)] = ++cnt;
			now = ch[now][s(i)];
			i++;
		}
		danger[now] = true;
	}
	void build()
	{
		h = t,t = -1;
		q[++t] = 1,fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				if(danger[fail[to]])
					danger[to] = true;
				q[++t] = to;
			}
		}
	}
	void dp(int x)
	{
		for(int i = 1;i<= cnt;i++)
		{
			if(danger[i]||!f[x-1][i])continue;
			for(int j = 0;j<26;j++)
			{
				int k=i;
				while(!ch[k][j])k=fail[k];
				(f[x][ch[k][j]]+=f[x-1][i])%=mod;
			}
		}
	}
}AC;
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	return tmp*tmp%mod;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int ans = quick_pow(26,m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		AC.insert();
	}
	AC.build();
	f[0][1] = 1;
	for(int i = 1;i<=m;i++)AC.dp(i);
	for(int i = 1;i<= AC.cnt;i++)
		if(!AC.danger[i])
			ans = (ans-f[m][i]+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
Problem1031

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Len = 200000+5;
char s[Len];
int c[Len],sa[Len],val[Len],q[Len],newval[Len];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)c[i]=0;
	for(i = 0;i<len;i++)c[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)c[i]+=c[i-1];
	for(i = len-1;i>=0;i--)sa[--c[val[i]]] = i;
	for(int d=1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;
		for(i = 0;i<lim;i++)c[i] = 0;
		for(i = 0;i<len;i++)c[val[q[i]]]++;
		for(i = 1;i<lim;i++)c[i]+=c[i-1];
		for(i = len-1;i>= 0;i--)sa[--c[val[q[i]]]] = q[i];
		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i = j+1;k<=j;k++)newval[sa[k]] = lim;
		}
		for(int i = 0;i<len;i++)val[i] = newval[i];
		if(lim==len)break;
	}
}
int main()
{
	scanf("%s",s);
	int len = strlen(s);
	for(int i = 0;i<len;i++)
		s[i+len] = s[i];
	build_sa(2*len,256);
	for(int i = 0;i< 2*len;i++)
		if(sa[i]<len)
			printf("%c",s[sa[i]+len-1]);
	return 0;
}
Problem1036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 30005;
int W[N],n;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int maxn[N<<2],sum[N<<2];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int son[N],size[N],deep[N],top[N],fa[N],w[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] =tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i= e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void update(int p,int l,int r,int x,int c)
{
	if(l==r){sum[p] = maxn[p] = c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)
		update(p<<1,l,mid,x,c);
	else update((p<<1)+1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
	maxn[p] = max(maxn[p<<1],maxn[(p<<1)+1]);
}
int getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return maxn[p];
	int mid = (l+r)>>1;
	int ans = -0x3f3f3f3f;
	if(a<=mid)
		ans = max(ans,getmax(p<<1,l,mid,a,b));
	if(b>mid)
		ans = max(ans,getmax((p<<1)+1,mid+1,r,a,b));
	return ans;
}
int getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)
		ans += getsum(p<<1,l,mid,a,b);
	if(b>mid)
		ans += getsum((p<<1)+1,mid+1,r,a,b);
	return ans;
}
int get_ans(int x,int y,int opt)
{
	int ans;
	if(opt==1)ans = 0;
	else ans = -0x3f3f3f3f;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)ans+=getsum(1,1,n,w[top[x]],w[x]);
		else ans = max(ans,getmax(1,1,n,w[top[x]],w[x]));
		x= fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)ans+=getsum(1,1,n,w[y],w[x]);
	else ans = max(ans,getmax(1,1,n,w[y],w[x]));
	return ans;
}
int main()
{
	memset(maxn,-0x3f,sizeof(maxn));
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i< n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	for(int i = 1;i<= n;i++)
		scanf("%d",&W[i]);
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(1,1,n,w[i],W[i]);
	int q;
	scanf("%d",&q);
	char j[10];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",j,&x,&y);
		if(j[1]=='H')update(1,1,n,w[x],y);
		else if(j[1]=='S')printf("%d\n",get_ans(x,y,1));
		else printf("%d\n",get_ans(x,y,0));
	}
	return 0;
}
Problem1036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 30005;
const int N = 30005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,a[N],n;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],son[N],top[N],fa[N],dep[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to]=x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
int dfn[N],seq[N],Dfn;
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int sum[N<<2],mx[N<<2];
void Push_up(int p)
{
	sum[p] = sum[p<<1]+sum[p<<1|1];
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = mx[p] = a[seq[l]];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	Push_up(p);
}
void update(int p,int l,int r,int pos,int val)
{
	if(l==r)
	{
		mx[p] = val;
		sum[p] = val;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,val);
	else update(p<<1|1,mid+1,r,pos,val);
	Push_up(p);
}
int Getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getsum(p<<1,l,mid,a,b);
	if(b>mid)ans+=Getsum(p<<1|1,mid+1,r,a,b);
	return ans;
}
int Getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	int ans = -INF;
	if(a<=mid)ans = max(ans,Getmax(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,Getmax(p<<1|1,mid+1,r,a,b));
	return ans;
}
int getsum(int x,int y)
{
	int ans = 0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=Getsum(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	if(dep[y]>dep[x])swap(x,y);
	ans += Getsum(1,1,n,dfn[y],dfn[x]);
	return ans;
}
int getmax(int x,int y)
{
	int ans = -INF;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans = max(ans,Getmax(1,1,n,dfn[top[x]],dfn[x]));
		x = fa[top[x]];
	}
	if(dep[y]>dep[x])swap(x,y);
	ans = max(ans,Getmax(1,1,n,dfn[y],dfn[x]));
	return ans;
}
int main()
{
	int x,y,q;
	scanf("%d",&n);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	scanf("%d",&q);
	char opt[10];
	while(q--)
	{
		scanf("%s",opt);
		if(opt[0]=='C')
		{
			scanf("%d%d",&x,&y);
			update(1,1,n,dfn[x],y);
			a[x] = y;
		}
		else if(opt[1]=='M')
		{
			scanf("%d%d",&x,&y);
			printf("%d\n",getmax(x,y));
		}else
		{
			scanf("%d%d",&x,&y);
			printf("%d\n",getsum(x,y));
		}
	}
	return 0;
}
Problem1040

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N],a[N],st[N],top;
LL f[N],g[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	return fa[x] = getfa(fa[x]);
}
void dfs(int x,int fa,int ban)
{
	for(int i = head[x];i;i = e[i].next)
		if(fa!=e[i].to)
			dfs(e[i].to,x,ban);
	f[x]= a[x],g[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		if(e[i].to==ban)
			f[x]+=g[e[i].to],g[x]+=g[e[i].to];
		else 
		{
			f[x]+=g[e[i].to];
			g[x]+=max(g[e[i].to],f[e[i].to]);
		}
	}
}
int main()
{
	int n,x;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a[i],&x);
		int fx = getfa(x),fy = getfa(i);
		if(fx==fy){st[++top] = x,st[++top] = i;continue;}
		fa[fx]= fy;
		add(x,i),add(i,x);
	}
	LL t_ans = 0;
	LL ans = 0;
	for(int i = 1;i<= top;i=i+2)
	{
		ans = 0;
		dfs(st[i],0,st[i+1]);
		ans = max(ans,max(f[st[i]],g[st[i]]));
		dfs(st[i+1],0,st[i]);
		ans = max(ans,max(f[st[i+1]],g[st[i+1]]));
		t_ans+=ans;
	}
	printf("%lld\n",t_ans);
	return 0;
}
Problem1042

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c[5],n[5],s;
long long f[100005],w[5];
long long getans(int sta)
{
	int tmp = s;
	long long fh = 1;
	for(int i = 0;i<4;i++)
		if((sta&(1<<i))!=0)
			{tmp-=w[i+1];fh = -fh;}
	if(tmp>=0)return fh*f[tmp];
	else return 0;
}
int main()
{
	int tot;
	for(int i = 1;i<= 4;i++)
		scanf("%d",&c[i]);
	scanf("%d",&tot);
	while(tot--)
	{
		memset(f,0,sizeof(f));
		for(int i = 1;i<= 4;i++)
			scanf("%d",&n[i]);
		scanf("%d",&s);
		for(int i = 1;i<= 4;i++)
			w[i] = c[i]*(n[i]+1);
		f[0] = 1;
		for(int i = 1;i<= 4;i++)
			for(int j = 0;j<= s;j++)
				if(j-c[i]>=0)f[j] += f[j-c[i]];
		long long ans = f[s];
		for(int i = 1;i<1<<4;i++)
			ans+=getans(i);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem1044

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
int Max_lth,maxn = 0,suml = 0;
int lth[50005],sum[50005];
int f[2][50005],n,m;
int line[50005];
bool check(int x)
{
    int tmp=0,sum=0;
    for(int i=1;i<=n;i++)
    {
        sum+=lth[i];
        if(sum>x){tmp++;sum=lth[i];}
        if(tmp>m)return 0;
        if(lth[i]>x)return 0;
    }
    return 1;
}
void solve()
{
	int l = maxn,r = suml+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(mid))r = mid;
		else l = mid+1;
	}
	Max_lth = l;
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&lth[i]);
		sum[i] = sum[i-1]+lth[i];
		suml+=lth[i];
		maxn = max(maxn,lth[i]);
	}
	solve();
	int ans = 0;
	f[0][0] = 1;
	for(int i = 1;i<= m;i++)
	{
		int last = (i-1)&1,now = i&1;
		int l = 1,r = 1,tot = f[last][0];line[1] = 0;
		for(int j = 1;j<= n;j++)
		{
			while(l<=r&&sum[j]-sum[line[l]]>Max_lth)
				{tot = (tot-f[last][line[l++]]+mod)%mod;}
			f[now][j] = tot;
			line[++r] = j;
			tot = (f[last][j]+tot)%mod;
		}
		for(int j = n-1;j>=1;j--)
		{
			if(suml-sum[j]>Max_lth)break;
			ans = (ans+f[now][j])%mod;
		}
		memset(f[last],0,sizeof(f[last]));
	}
	printf("%d %d",Max_lth,ans);
	return 0;
}
Problem1046

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int M = 1005;
int f[N],c[N],pos[N],a[N],cnt,n,m;
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r =mid;
	}
	return l;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = max(c[i],y);
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans = max(ans,c[i]);
	return ans;
}
int t_ans = 0;
void pre()
{
	for(int i = n;i>=1;i--)
	{
		int tmp = find(a[i]);
		tmp = n-tmp+1;
		f[i] = getans(tmp-1)+1;
		update(tmp,f[i]);
		t_ans = max(t_ans,f[i]);
	}
}
void solve(int x)
{
	int last = 0;
	for(int i = 1;i<= n;i++)
		if(f[i]>=x&&a[i]>last)
		{
			printf("%d",a[i]);
			if(x!=1)printf(" ");
			last = a[i];
			x--;
			if(!x)break;
		}
	printf("\n");
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		pos[i] = a[i];
	}
	sort(pos+1,pos+n+1);
	for(int i = 1;i<= n;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt] = pos[i];
	pre();
	scanf("%d",&m);
	int x;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&x);
		if(x>t_ans)printf("Impossible\n");
		else solve(x);
	}
	return 0;
}
Problem1047

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int f[13][1005][1005];
int g[13][1005][1005];
int log[1005];
int a,b,n,ans = 0x3f3f3f3f;
void init()
{
	for(int j = 1;j<= 12;j++)
		for(int l = 1;l+(1<<j)-1<= a;l++)
			for(int i = 1;i+(1<<j)-1<= b;i++)
			{
				f[j][l][i] = max(max(f[j-1][l][i],f[j-1][l][i+(1<<(j-1))]),
								 max(f[j-1][l+(1<<(j-1))][i],f[j-1][l+(1<<(j-1))][i+(1<<(j-1))]));
				g[j][l][i] = min(min(g[j-1][l][i],g[j-1][l][i+(1<<(j-1))]),
								 min(g[j-1][l+(1<<(j-1))][i],g[j-1][l+(1<<(j-1))][i+(1<<(j-1))]));
			}
	log[1] = 0;
	for(int i = 2;i<= 1000;i++)
		log[i] = log[i>>1]+1;
}
void ask(int x,int y)
{
	int xl = x,xr = x+n-1;
	int yl = y,yr = y+n-1;
	int m_ans = 0,n_ans = 0x3f3f3f3f;
	m_ans = max(f[log[n]][xl][yl],f[log[n]][xl][yr-(1<<log[n])+1]);
	m_ans = max(m_ans,max(f[log[n]][xr-(1<<log[n])+1][yl],f[log[n]][xr-(1<<log[n])+1][yr-(1<<log[n])+1]));
	n_ans = min(g[log[n]][xl][yl],g[log[n]][xl][yr-(1<<log[n])+1]);
	n_ans = min(n_ans,min(g[log[n]][xr-(1<<log[n])+1][yl],g[log[n]][xr-(1<<log[n])+1][yr-(1<<log[n])+1]));
	ans = min(ans,m_ans-n_ans);
}
int main()
{
	memset(g,0x3f,sizeof(g));
	int x;
	scanf("%d%d%d",&a,&b,&n);
	for(int i = 1;i<= a;i++)
	{
		for(int j = 1;j<= b;j++)
		{
			scanf("%d",&x);
			f[0][i][j] = g[0][i][j] = x;
		}
	}
	init();
	for(int i = 1;i<= a-n+1;i++)
		for(int j = 1;j<= b-n+1;j++)
			ask(i,j);
	printf("%d",ans);
	return 0;
}
Problem1051

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct M
{
    int next,to;
}edge[50005];
int head[50005],tot,cnt,zn,z[50005],dep[50005],low[50005],n,m;
bool in[10005],v[10005];
void add(int x,int y)
{
    edge[++tot].to = y;
    edge[tot].next = head[x];
    head[x] = tot;
}
int pn,t[10005],ln[10005],lnn[10005];
void tarjan(int x)
{
    v[x] = true;
    z[++zn] = x;
    in[x] = true;
    dep[x] = low[x] = ++cnt;
    for(int i = head[x];i;i=edge[i].next)
    {
        if(!v[edge[i].to])
            {tarjan(edge[i].to);low[x] = min(low[x],low[edge[i].to]);}
        else if(in[edge[i].to])
            {low[x] = min(low[x],dep[edge[i].to]);}
    }
    if(dep[x]==low[x])
    {
        pn++;
        int tmp;
        do
        {
            tmp = z[zn--];
            in[tmp] = false;
            ln[tmp] = pn;
            lnn[pn]++;
        }while(tmp!=x);
    }
    return ;
}
void dfs(int x)
{
    if(x==n+1)return ;
    for(int i = head[x];i;i = edge[i].next)
    {
        if(ln[x]!=ln[edge[i].to])
            t[ln[x]]++;
    }
    dfs(x+1);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 1;i<= m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
    }
    for(int i = 1;i<= n;i++)
        if(!v[i])tarjan(i);
    dfs(1);
    int ans = 0,tmp = 0;
    for(int i = 1;i<= pn;i++)
    {
        if(t[i]==0)
        {
            if(ans)
            {
                ans = 0;
                break;
            }
            ans=lnn[i]; 
        }
    }
    printf("%d",ans);
    return 0;
}
Problem1055

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c2n[256],num[5];
bool change[5][5][5];
int Able[205][205][5];
char str[205];
bool able(int l,int r,int target)
{
	if(r-l+1==2&&change[c2n[str[l]]][c2n[str[r]]][target])return true;
	else if(r-l+1==1&&target==c2n[str[l]])return true;
	if(Able[l][r][target]!=-1)return Able[l][r][target];
	for(int i = l;i<= r-1;i++)
		for(int k = 1;k<= 4;k++)
			for(int t = 1;t<= 4;t++)
				if(change[k][t][target]&&able(l,i,k)&&able(i+1,r,t))
					return Able[l][r][target] = 1;
	return Able[l][r][target] = 0;
}
int main()
{
	c2n['W'] = 1;
	c2n['I'] = 2;
	c2n['N'] = 3;
	c2n['G'] = 4;
	char s[3];
	for(int i = 1;i<= 4;i++)scanf("%d",&num[i]);
	for(int i = 1;i<= 4;i++)
		for(int j = 1;j<= num[i];j++)
		{
			scanf("%s",s);
			change[c2n[s[0]]][c2n[s[1]]][i] = true;
		}
	scanf("%s",str+1);
	int n = strlen(str+1);
	memset(Able,-1,sizeof(Able));
	bool flag = false;
	if(able(1,n,1))printf("W"),flag = true;
	if(able(1,n,2))printf("I"),flag = true;
	if(able(1,n,3))printf("N"),flag = true;
	if(able(1,n,4))printf("G"),flag = true;
	if(!flag)printf("The name is wrong!\n");
	return 0;
}
Problem1060

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N =  500005;
LL f[N];
struct E{int to,next,val;}e[N*2];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
LL ans = 0;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			f[x] = max(f[e[i].to]+e[i].val,f[x]);
		}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			ans += f[x]-f[e[i].to]-e[i].val;
		}	
}
int main()
{
	int n,x,y,z,s;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	dfs(s,0);
	printf("%lld",ans);
	return 0;
}
Problem1067

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
#define mod 10007
int n,m;
struct Y
{
    int year,rr;
}num[50005];
struct E
{
    int next,val,no;
}edge[50005];
int logx[50005];
int f[50005][20];
void init()
{
    for(int j = 1;j<= 19;j++)
    {
        for(int i = 1;i<=n;i++)
        {   
            if((i+(1<<(j-1)))<=n)
            {
                if(num[f[i][j-1]].rr>=num[f[i+(1<<(j-1))][j-1]].rr)
                    f[i][j] = f[i][j-1];
                else 
                    f[i][j] = f[i+(1<<(j-1))][j-1];
            }
            else f[i][j]= f[i][j-1];
        }
    }
    logx[1] = 0;
    for(int i = 2;i<= 50000;i++)
        logx[i] = logx[i>>1]+1;
    return ;
}
int check(int l,int r)
{
    if(l>r)return -1;
    int len = r-l+1;
    if(num[f[l][logx[len]]].rr>num[f[r-(1<<logx[len])+1][logx[len]]].rr)
        return f[l][logx[len]];
    else return f[r-(1<<logx[len])+1][logx[len]];
}
void ch(int st,int en)
{
    int l = 0,r = n+1,mid,poss,pose;
    while(l<r)
    {
        mid = (l+r)>>1;
        if(num[mid].year>=st)r = mid;
        else l = mid+1;
    }
    poss = l;
    l = 0;r = n+1;
    while(l<r)
    {
        mid = (l+r)>>1;
        if(num[mid].year>=en)r = mid;
        else l = mid+1;
    }
    pose = l;
    if(num[pose].year>en)
        pose--;
    //printf("%d %d\n",poss,pose);
    //printf("%d %d\n",num[poss].year,num[pose].year);
    if(num[pose].year!=en&&num[poss].year!=st)
    {
        printf("maybe\n");
        return ;
    }
    else if(num[pose].year==en&&num[poss].year!=st)
    {
        if(num[check(poss,pose)].year!=num[pose].year)
            printf("false\n");
        else printf("maybe\n");
    }
    else if(num[pose].year!=en&&num[poss].year==st)
    {
        if(num[check(poss+1,pose)].rr>=num[poss].rr)
            printf("false\n");
        else printf("maybe\n");
    }
    else
    {
        if(num[pose].rr>num[poss].rr)printf("false\n");
        else if(num[check(poss+1,pose)].year!=en)printf("false\n");
        else if(pose-poss!=en-st)printf("maybe\n");
        else printf("true\n");
    }
    return ;
}
int main()
{
    num[0].year = -0x3f3f3f3f;
    //freopen("rains.in","r",stdin);
    //freopen("rains.out","w",stdout);
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d%d",&num[i].year,&num[i].rr);
        f[i][0] = i;
    }
    /*for(int j = 1;j<= n;j++)
    {
        for(int i = head[hash(num[j].year)];i;i = edge[i].next)
            printf("%d ",edge[i].val);
        printf("\n");
    }*/
    init();
    scanf("%d",&m);
    for(int i = 1;i<= m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(x>y){printf("false\n");continue;}
        //int fx = find(x),fy = find(y);
        //printf("fx = %d fy = %d\n",fx,fy);
        //if(num[fy].rr>num[fx].rr){printf("false\n");continue;}
        //if(fx==-1||fy==-1||fy-fx!=y-x){printf("maybe\n");continue;}
        ch(x,y);
    }
    return 0;
}
Problem1070

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 605;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,f,c,from;}e[M];
int head[N],tot=1,st,end;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;e[tot].c=c;head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;e[tot].c=-c;head[y]=tot;
	e[tot-1].from=x;e[tot].from=y;
}
int dis[N],from[N];
bool v[N];
queue<int>Q;
bool spfa()
{
	for(int i = st;i<= end;i++)dis[i]=INF;
	Q.push(st);dis[st]=0;v[st]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[x]+e[i].c<dis[e[i].to])
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to]=i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[end]!=INF;
}
double ans;
void mcf()
{
	int x = INF;
	for(int i = from[end];i;i=from[e[i].from])
		x = min(e[i].f,x);
	for(int i = from[end];i;i=from[e[i].from])
		{e[i].f-=x;e[i^1].f+=x;ans+=e[i].c*x;}
}
int ti[61][10];
int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&ti[i][j]);
	st=0,end=n*(m+1)+1;
	for(int i = 1;i<= n*m;i++)
		add(st,i,1,0);
	for(int i = n*m+1;i<=n*m+n;i++)
		add(i,end,1,0);
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
				add((i-1)*n+j,n*m+k,1,ti[k][i]*j);
	while(spfa())mcf();
	printf("%.2f",ans/(double)n);
	return 0;
}
Problem1072

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1005;
const int M = 1<<10;
int f[M][N],buk[10],cnt[M];
LL p10[11];
char str[20];
void init()
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	return ;
}
int main()
{
	int d,n,t;
	init();
	p10[0] = 1;
	for(int i = 1;i<= 10;i++)
		p10[i] = p10[i-1]*10;
	scanf("%d",&t);
	while(t--)
	{
		memset(buk,0,sizeof(buk));
		memset(f,0,sizeof(f));
		scanf("%s%d",str+1,&d);
		n = strlen(str+1);
		for(int i = 1;i<= n;i++)
			buk[str[i]-'0']++;
		f[0][0] = 1;
		for(int i = 1;i<= n;i++)
		{
			for(int sta = 0;sta<1<<n;sta++)
			{
				if(cnt[sta]!=i-1)continue;
				for(int s = 1;s<= n;s++)
				{
					if((1<<(s-1))&sta)continue;
					for(int yu = 0;yu<d;yu++)
					{
						LL nm = ((str[s]-'0')*p10[i-1]+yu)%d;
						f[sta|(1<<(s-1))][nm]+=f[sta][yu];
					}
				}
			}
		}
		int ans = f[(1<<n)-1][0];
		for(int i = 0;i<=9;i++)
			for(int j = buk[i];j>=1;j--)
				ans/=j;
		printf("%d\n",ans);
	}
	return 0;
}
Problem1076

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int P = 1<<15;
const int N = 105;
double f[N][P];
int pre[N],val[N];
int main()
{
	int k,n,t,x;
	scanf("%d%d",&k,&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&val[i],&t);
		while(t)
		{
			pre[i]|=1<<(t-1);
			scanf("%d",&t);
		}
	}
	double p = 1.0/(double)n;
	for(int i = k;i>= 1;i--)
		for(int j = 0;j<1<<n;j++)
		{
			//double ans = 0;
			for(int k = 1;k<= n;k++)
				if((j&pre[k])==pre[k])
					f[i][j]+=max(f[i+1][j],f[i+1][j|(1<<(k-1))]+val[k]);
				else f[i][j]+=f[i+1][j];
			f[i][j]*=p;
		}
	printf("%.6f\n",f[1][0]);
	return 0;
}
Problem1079

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
typedef long long LL;
int f[6][16][16][16][16][16];
bool used[6][16][16][16][16][16];
int cnt[6];
int dp(int last,int a,int b,int c,int d,int e)
{
	if(!a&&!b&&!c&&!d&&!e)return 1;
	if(a<0||b<0||c<0||d<0||e<0)return 0;
	if(used[last][a][b][c][d][e])return f[last][a][b][c][d][e];
	LL ans = 0;
	ans+=(LL)(a+(last==2?-1:0))*dp(1,a-1,b,c,d,e)%mod;
	ans+=(LL)(b+(last==3?-1:0))*dp(2,a+1,b-1,c,d,e)%mod;
	ans+=(LL)(c+(last==4?-1:0))*dp(3,a,b+1,c-1,d,e)%mod;
	ans+=(LL)(d+(last==5?-1:0))*dp(4,a,b,c+1,d-1,e)%mod;
	ans+=(LL)e*dp(5,a,b,c,d+1,e-1)%mod;
	ans = ans%mod;
	used[last][a][b][c][d][e] = true;
	f[last][a][b][c][d][e] = ans;
	return ans;
}
int main()
{
	int k,x;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&x);
		cnt[x]++;
	}
	printf("%d\n",dp(0,cnt[1],cnt[2],cnt[3],cnt[4],cnt[5]));
	return 0;
}
Problem1082

#include<cstdio>
#include<cmath>
#include<ctime>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<set>
#define ll long long
#define inf 1000000000
using namespace std;
int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
bool flag;
int n,m,mid;
int a[55],b[1005],bl[1005];
ll sa;
int sb[1005];
void dfs(int ak,int bk,int w)
{
	if(bk==0)flag=1;
	while(ak<=n&&a[ak]<b[1]){w+=a[ak];ak++;}
	if(flag||ak>n)return;
	if(w+sb[mid]>sa)return;
	int t=ak,t1=ak,t2=bk,t3=w;
	if(b[bk]==b[bk+1]&&bk!=mid)t=bl[bk+1];
	for(int i=t;i<=n;i++)
		if(a[i]>=b[bk])
		{
			bl[bk]=i;a[i]-=b[bk];
			bk--;
			dfs(ak,bk,w);
			ak=t1;bk=t2;w=t3;a[i]+=b[t2];
		}
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	m=read();
	for(int i=1;i<=m;i++)b[i]=read();
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	while(b[m]>a[n])m--;
	int tot=0;
	for(int i=1;i<=n;i++)	
		if(a[i]>b[1])a[++tot]=a[i];
	n=tot;
	for(int i=1;i<=n;i++)sa+=a[i];
	for(int i=1;i<=m;i++)sb[i]=sb[i-1]+b[i];
	int l=1,r=m,ans=0;
	while(l<=r)
	{
		mid=(l+r)>>1;
		flag=0;dfs(1,mid,0);
		if(flag)ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1087

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long ans[10][82]=
{
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,9,16,8,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,16,78,140,79,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,25,228,964,1987,1974,978,242,27,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,36,520,3920,16834,42368,62266,51504,21792,3600,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,49,1020,11860,85275,397014,1220298,2484382,3324193,2882737,1601292,569818,129657,18389,1520,64,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,64,1806,29708,317471,2326320,12033330,44601420,119138166,229095676,314949564,305560392,204883338,91802548,25952226,4142000,281571,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,81,2968,65240,962089,10087628,77784658,450193818,1979541332,6655170642,17143061738,33787564116,50734210126,57647295377,49138545860,31122500764,14518795348,4959383037,1237072414,224463798,29275410,2673322,163088,6150,125,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	printf("%lld\n",ans[n][k]);
	return 0;
}
Problem1090

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
int dp[105][105];
char str[105];
int calc(int x)
{
	int cnt = 0;
	while(x)
	{
		x/=10;
		cnt++;
	}
	return cnt;
}
int Dp(int l,int r)
{
	if(r==l)return 1;
	if(dp[l][r]!=INF)return dp[l][r];
	for(int k = l;k< r;k++)
		dp[l][r] = min(dp[l][r],min(r-l+1,Dp(l,k)+Dp(k+1,r)));
	for(int k = 1;l+k<=r;k++)
	{
		bool flag = true;
		if((r-l+1)%k==0)
		{
			for(int t = 1;t<(r-l+1)/k;t++)
			{
				for(int p = 0;p<k;p++)
					if(str[l+p]!=str[l+t*k+p])
						{flag = false;break;}
				if(!flag)break;
			}
		}else continue;
		if(flag)dp[l][r] = min(dp[l][r],Dp(l,l+k-1)+2+calc((r-l+1)/k));
	}
	return dp[l][r];
}
int main()
{
	scanf("%s",str+1);
	int n = strlen(str+1);
	memset(dp,0x3f,sizeof(dp));
	printf("%d\n",Dp(1,n));
	return 0;
}
Problem1096

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
int x[N],p[N],c[N],q[N],l,r;
LL sum[N],os[N],f[N];
double calc(int j,int k)
{
	return (double)(f[k]-f[j]+sum[k]-sum[j])/(double)(os[k]-os[j]);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&x[i],&p[i],&c[i]);
	for(int i = 1;i<=n;i++)
		os[i] = os[i-1]+p[i];
	for(int i = 1;i<=n;i++)
		sum[i] = sum[i-1]+(LL)x[i]*p[i];
	for(int i = 1;i<= n;i++)
	{
		while(l<r&&calc(q[l],q[l+1])<x[i])l++;
		if(l<=r)f[i] = f[q[l]]+sum[q[l]]-sum[i]+(os[i]-os[q[l]])*x[i]+c[i];
		while(l<r&&calc(q[r-1],q[r])>calc(q[r],i))r--;
		q[++r] = i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem1097

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 200005;
const int N = 20005;
const int S = 1<<20;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M<<1];
struct H
{int pos,val;}heap[N<<2];
int head[N],tot,cnt,n,m,k;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	e[tot].val = f;
	head[y] = tot;
}
int f[25][N],v[N];
bool cmp(H a,H b){return a.val>b.val;}
void dijk(int st)
{
	memset(f[st],0x3f,sizeof(f[st]));
	memset(v,0,sizeof(v));
	f[st][st] = 0;
	heap[1].val = 0,heap[1].pos = st;
	cnt++;
	while(cnt)
	{
		int x = heap[1].pos;
		pop_heap(heap+1,heap+cnt+1,cmp);
		cnt--;
		if(v[x])continue;
		v[x] = true;
		for(int i = head[x];i;i = e[i].next)
		{
			int to = e[i].to;
			if(f[st][x]+e[i].val<f[st][to])
			{
				f[st][to] = f[st][x]+e[i].val;
				cnt++;
				heap[cnt].pos = to;heap[cnt].val = f[st][to];
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
	}
	return ;
}
int pre[25],ban[25],num[S],dp[25][S];
void init()
{
	for(int i = 0;i<S;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			num[i]++;
		}
	}
	memset(dp,-1,sizeof(dp));
	for(int i = 1;i<= k+1;i++)
		dijk(i);
	return ;
}
int dfs(int x,int y)
{
    if(dp[x][y]>=0)return dp[x][y];
    if(y==(1<<k)-1)return f[x][n];
    dp[x][y]=INF;
    for(int i= 2;i<= k+1;i++)
    	if((y&pre[i])==pre[i])
    		dp[x][y]=min(dp[x][y],f[x][i]+dfs(i,y|(1<<(i-2))));
    return dp[x][y];  
}
int main()
{
	int x,y,c,ord;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c);
	}
	init();
	scanf("%d",&ord);
	for(int i = 1;i<= ord;i++)
	{
		scanf("%d%d",&x,&y);
		ban[x]|=(1<<(y-2));
		pre[y]|=(1<<(x-2));
	}
	printf("%d\n",dfs(1,0));
	return 0;
}
Problem1103

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500000+5;
int c[N],cnt;
int in_w[N],out_w[N];
struct E{int next,to;}e[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa)
{
	in_w[x] = ++cnt;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	out_w[x] = ++cnt;
}
void update(int x,int dec)
{
	for(int i = x;i<=N;i +=(i&(-i)))
		c[i]+=dec;
	return ;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i -= (i&(-i)))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,m,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	dfs(1,0);
	for(int i = 1;i<= n;i++)
		{update(in_w[i],1);update(out_w[i],-1);}
	scanf("%d",&m);
	char ju[5];
	for(int i = 1;i<= n+m-1;i++)
	{
		scanf("%s",ju);
		if(ju[0]=='A')
		{
			scanf("%d%d",&x,&y);
			update(in_w[y],-1);update(out_w[y],1);
		}else
		{
			scanf("%d",&x);
			printf("%d\n",getans(in_w[x])-1);
		}
	}
	return 0;
}
Problem1106

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int c[N],mark[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= 2*n;i++)
	{
		scanf("%d",&x);
		if(mark[x])
		{
			ans += getans(i-1)-getans(mark[x]);
			update(mark[x],-1);
		}else
		{
			mark[x] = i;
			update(i,1);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1110

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int a[N],w[N],cnt[N],stack[N],top;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&a[i]);
	sort(a+1,a+m+1);
	int top = 0;
	for(int i = 1;i<= m;i++)
		if(i==1||a[i]!=a[i-1])
			stack[++top] = a[i];
	for(int i = 1;i<= n;i++)
		for(int j = top;j;j--)
			cnt[j]+=w[i]/stack[j],w[i]%=stack[j];
	int i,j,k;
	int ans = 0;
	for(i=1,j=1;i<=top;i++)
	{
		for(;j<=m&&a[j]==stack[i];j++)
		{
			if(cnt[i])
			{
				ans++,cnt[i]--;
				continue;
			}
			for(k=i+1;k<= top;k++)
				if(cnt[k])
					break;
			if(k==top+1)
			{
				printf("%d\n",ans);
				return 0;
			}
			for(;k>i;k--)  
                cnt[k]--,cnt[k-1]+=stack[k]/stack[k-1];  
            ++ans;--cnt[i];  
		}	
	}
	printf("%d\n",ans);
	return 0;
}
Problem1122

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
typedef long long LL;
int sum[N<<1],mn[N],Q[N<<1],l,r;
char opt[N];
LL Abs(LL x){return x>0?x:-x;}
int main()
{
	int n,p,q,x,y;
	scanf("%d%d%d%d%d",&n,&p,&q,&x,&y);
	scanf("%s",opt+1);
	for(int i = n*2;i>n;i--)
		sum[i] = sum[i+1]+(opt[i-n]=='+'?1:-1);
	for(int i = n;i>=1;i--)
		sum[i] = sum[i+1]+(opt[i]=='+'?1:-1);
	r = -1;
	for(int i = 2*n;i>=1;i--)
	{
		while(l<=r&&sum[i]>sum[Q[r]])r--;
		Q[++r] = i;
		while(l<=r&&Q[l]-i>=n)l++;
		if(i<=n)mn[i] = sum[i]-sum[Q[l]];
	}
	LL get = sum[n+1];
	LL cng = (q-p-get)/2;
	LL ans = 1e18;
	for(int i = 0;i<n;i++)
	{
		LL cost = Abs(cng)*x+(LL)y*i;
		if(i==0)
		{
			mn[1]+=p+max(cng,0ll)*2;
			if(mn[1]<0)cost += (LL)x*2*((1-mn[1])/2);
		}else
		{
			mn[n-i+1]+=p+max(cng,0ll)*2;
			if(mn[n-i+1]<0)cost += (LL)x*2*((1-mn[n-i+1])/2);
		}
		ans = min(ans,cost);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem1123

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 1000005;
typedef long long LL;
struct E
{int next,to;}e[M];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int dfn[N],low[N],top,cnt,size[N],n,m;
bool v[N];
LL ans[N];
void tarjan(int x,int l)
{
	v[x] = true;
	dfn[x] = low[x] = ++cnt;
	int tmp = 0;
	size[x] = 1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(!v[e[i].to])
		{
			tarjan(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			size[x]+=size[e[i].to];
			if(low[e[i].to]>=dfn[x])
			{
				ans[x]+=(LL)tmp*size[e[i].to];
				tmp+=size[e[i].to];
			}
		}else low[x] = min(low[x],dfn[e[i].to]);
	}
	ans[x]+=(LL)tmp*(n-tmp-1);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	tarjan(1,0);
	for(int i = 1;i<= n;i++)
		printf("%lld\n",(ans[i]+n-1)<<1);
	return 0;
}
Problem1124

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int degree[N],aim[N];
int ans1,ans2,n;
namespace Ans1
{
	int degree[N];
	bool vis[N],dead[N];
	void Solve()
	{
		static int q[N];
		int hd = 1,tl = 0;
		memcpy(degree,::degree,sizeof(degree));
		for(int i = 1;i<= n;i++)if(!degree[i])q[++tl]=i;
		while(hd<=tl)
		{
			int x = q[hd++];
			vis[x] = true;
			if(!dead[aim[x]])
			{
				dead[aim[x]] = vis[aim[x]] = true;ans1++;
				if(!--degree[aim[aim[x]]])
					q[++tl] = aim[aim[x]];
			}
		}
		for(int i =1;i<= n;i++)
			if(!vis[i])
			{
				int cnt = 0,x = i;
				while(!vis[x])
				{
					vis[x] = true;
					cnt++;
					x = aim[x];
				}
				ans1+=(cnt+1)>>1;
			}
	}
}
namespace Ans2
{
	struct E
	{int next,to;}e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	bool vis[N];
	int stack[N],top;
	void bfs(int x)
	{
		static int q[N];
		int hd = 1,tl = 0;
		q[++tl] = x;vis[x] = true;
		while(hd<=tl)
		{
			int cur = q[hd++];
			stack[++top] = cur;
			for(int i = head[cur];i;i=e[i].next)
				if(!vis[e[i].to])
					vis[e[i].to]=true,q[++tl] = e[i].to;
		}
	}
	void Solve()
	{
		for(int i = 1;i<= n;i++)
			add(i,aim[i]);
		for(int i = 1;i<= n;i++)
			if(!vis[i])
			{
				top = 0;
				bfs(i);
				if(top==1)ans2++;
				else
				{
					int cnt = 0,size = top;
					while(top)
						cnt+=degree[stack[top--]]==0;
					ans2+=size-max(1,cnt);
				}
			}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&aim[i]);
		degree[aim[i]]++;
	}
	Ans1::Solve();
	Ans2::Solve();
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem1132

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3005;
struct Point
{
	int x,y;
	double sl;
	Point(){}
	Point(int x,int y):x(x),y(y)
	{
		sl = x?(double)y/x:1e10;
	}
	bool operator<(const Point &a)const
	{
		if(x==a.x)
			return y<a.y;
		return x<a.x;
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
}a[N],poi[N];
bool cmp(const Point &a,const Point &b)
{
	return a.sl<b.sl;
}
int main()
{
	int n,tot;
	ll ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+n+1);
	for(int i = 1;i<= n;i++)
	{
		tot = 0;
		ll sumx = 0,sumy = 0;
		for(int j = i+1;j<= n;j++)
			poi[++tot]=a[j]-a[i];
		sort(poi+1,poi+tot+1,cmp);
		for(int j = 1;j<= tot;j++)
		{
			ans+=sumx*poi[j].y-sumy*poi[j].x;
			sumx+=poi[j].x;
			sumy+=poi[j].y;
		}
	}
	printf("%lld.%d",ans>>1,(ans&1)?5:0);
	return 0;
}
Problem1133

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 605;
const int K = 65;
int f[K][N];
int sum[N][N],pre[N][K];
int s(int x1,int y1,int x2,int y2)
{
	return sum[x2][y2]-sum[x1][y2]-sum[x2][y1]+sum[x1][y1];
}
int main()
{
	int n,K;
	scanf("%d%d",&n,&K);
	for(int i = 1;i<n;i++)
		for(int j = 1;i+j<= n;j++)
			scanf("%d",&sum[i][j+i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			sum[i][j] += sum[i][j-1];
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			sum[i][j]+=sum[i-1][j];
	memset(f,0xef,sizeof(f));
	f[0][0] = 0;
	for(int i = 1;i< n;i++)
		for(int j = 1;j<= K;j++)
			for(int k = 0;k<i;k++)
			{
				//f[i][j][k] = max(f[i][j][k],f[i-1][j][k]);
				int tmp = f[j-1][k]+s(k,i,i,n);
				if(tmp>f[j][i])
				{
					pre[i][j] = k;
					f[j][i] = tmp;
				}
			}
	int ans = 0xefefefef;
	int tmp = 0;
	for(int k = 0;k<= n;k++)
	{
		if(f[K][k]>ans)
			ans = f[K][k],tmp = k;
	}
	int stack[605],top=0;
	while(top<K)
	{
		stack[++top] = tmp;
		tmp = pre[tmp][K-top+1];
	}
	//printf("%d\n",ans);
	for(int i = top;i> 1;i--)
		printf("%d ",stack[i]);
	printf("%d\n",stack[1]);
	return 0;
}
Problem1143

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int M = 1e4+5;
const int INF = 0x3f3f3f3f;
int a[105][105],lk[105],n,m,u,v;
bool map[105][105],vis[105];
bool find(int x)
{
	for(int i = 1;i<= n;i++)
		if(a[x][i]&&!vis[i])
		{
			vis[i] = true;
			if(find(lk[i])||!lk[i])
			{
				lk[i] = x;
				return true;
			}
		}
	return false;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&u,&v);
		map[u][v] = true;
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				map[i][j]|=(map[i][k]&map[k][j]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(i!=j&&map[i][j])
				a[i][j] = true;
	int ans = n;
	for(int i = 1;i<= n;i++)
	{
		memset(vis,0,sizeof(vis));
		ans-=find(i);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1145

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int mod = 16777216;
typedef long long ll;
ll c[N],l[N],r[N];
int a[N],n;
ll getans(int x)
{
	ll ans =0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void update(int x,ll y)
{
	for(int i = x;i<=n;i+=i&(-i))
		(c[i]+=y+mod)%=mod;
}
int cnt1()
{
	memset(c,0,sizeof(c));
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = (ans+(l[i]*(i-2)-getans(a[i])-l[i]*(l[i]-1)/2)*((ll)n-i-r[i])%mod+mod)%mod;
		update(a[i],i-1);
	}
	return (int)ans;
}
int cnt2()
{
	memset(c,0,sizeof(c));
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = (ans+((ll)n-i-r[i])*getans(a[i])%mod+mod)%mod;
		update(a[i],l[i]);
	}
	return (int)ans;
}
int cnt3()
{
	memset(c,0,sizeof(c));
	ll ans =0;
	for(int i = n;i;i--)
	{
		ans = (ans+((ll)n-i-r[i])*(getans(a[i])-r[i]*(r[i]-1)/2)%mod+mod)%mod;
		update(a[i],a[i]-1);
	}
	return (int)ans;
}
int cnt4()
{
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans = (ans+(n-i-r[i])*(n-i-r[i]-1)*(n-i-r[i]-2)/6)%mod;
	return (int)ans;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<= n;i++)
	{
		l[i]=getans(a[i]);
		r[i]=a[i]-1-l[i];
		update(a[i],1);
	}
	ll ans = ((cnt1()+cnt2()+cnt3()-cnt4())%mod+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem1146

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
const int INF = 1e8+1;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,q;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],son[N],w[N],top[N],fa[N],cnt,id[N],d[N],dpt[N];
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x] = 1;
	dpt[x] = dpt[f]+1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==f)continue;
		dfs1(e[i].to,x);
		size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	id[cnt] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_rank(root[p],y);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,y);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,y);
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void build()
{
	for(int i = 1;i<=cnt;i++)
		build(1,1,cnt,i,d[id[i]]);
}
void get_rank(int x,int y,int k)
{
	while(top[x]!=top[y])
	{
		if(dpt[top[x]]<dpt[top[y]])swap(x,y);
		get_rank(1,1,n,w[top[x]],w[x],k);
		x = fa[top[x]];
	}
	if(dpt[x]<dpt[y])swap(x,y);
	get_rank(1,1,n,w[y],w[x],k);
}
void get_number(int x,int y,int k)
{
	int l = -INF,r = 1,ans;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		tmp = 1;
		get_rank(x,y,mid);
		if(tmp<=k){l = mid+1;ans= mid;}
		else r = mid-1;
	}
	if(ans!=1)printf("%d\n",-ans);
	else printf("invalid request!\n");
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){scanf("%d",&d[i]);d[i] = -d[i];}
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1,0);
	dfs2(1,1);
	build();
	int k,a,b;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&k,&a,&b);
		if(k==0)
		{
			change(1,1,n,w[a],d[a],-b);
			d[a] = -b;
		}else
			get_number(a,b,k);
	}
	return 0;
}
Problem1149

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int l[N],r[N],maxx,minx,n,ans;
void dfs(int x,int dep)
{
	if(x==-1){maxx = max(maxx,dep),minx = min(minx,dep);return ;}
	dfs(l[x],dep+1);
	dfs(r[x],dep+1);
}
int solve(int x,int dep)
{
	int a,b;
	if(x==-1)
	{
		if(dep==minx)return 1;
		else return 2;
	}
	a = solve(l[x],dep+1);
	b = solve(r[x],dep+1);
	if((a==1&&b==2)||(a==1&&b==3)||(a==3&&b==2))ans++;
	if(a==3&&b==3){printf("-1\n");exit(0);}
	return a|b;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&l[i],&r[i]);
	maxx = 0,minx = N*10;
	dfs(1,0);
	if(maxx-minx>=2)printf("-1\n");
	else if(maxx==minx)printf("0\n");
	else
	{
		solve(1,0);
		printf("%d\n",ans);
	}
	return 0;
}
Problem1150

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int INF = 0x3f3f3f3f;
struct Heap
{int no,val;}heap[N];
bool cmp(const Heap &a,const Heap &b)
{
	return a.val>b.val;
}
int len[N],pre[N],L[N],R[N];
int main()
{
	int n,k,y;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&y);
		len[i] = y-pre[i-1];
		pre[i] = y;
		L[i] = i-1,R[i]=i+1;
	}
	int cnt = 0;
	for(int i = 2;i<= n;i++)
	{
		heap[++cnt] = (Heap){i,len[i]};
		push_heap(heap+1,heap+cnt+1,cmp);
	}
	L[2] = 0,R[n]=0;
	int ans = 0;
	for(int i =1;i<= k;i++)
	{
		while(heap[1].val!=len[heap[1].no])
			pop_heap(heap+1,heap+cnt+1,cmp),cnt--;
		int x = heap[1].no;
		int l = L[x],r = R[x];
		pop_heap(heap+1,heap+cnt+1,cmp),cnt--;
		ans+=len[x];
		L[R[x] = R[r]]=x;
		R[L[x] = L[l]]=x;
		len[x] = (l&&r)?min(INF,len[l]+len[r]-len[x]):INF;
		len[l] = len[r] = INF;
		heap[++cnt] = (Heap){x,len[x]};
		push_heap(heap+1,heap+cnt+1,cmp);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1151

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<5;
const int N = 1e4+5;
int f[N][S],g[N][S],n,C;
bool ok[N*5][S];
struct P
{
	int pos;
	int f,l;
	int fear,love;
}c[N*5];
int mod(int x)
{
	return (x%n+n)%n;
}
int main()
{
	int x;
	scanf("%d%d",&n,&C);
	for(int i = 1;i<= C;i++)
	{
		scanf("%d%d%d",&c[i].pos,&c[i].f,&c[i].l);
		for(int j = 1;j<=c[i].f;j++)
		{
			scanf("%d",&x);
			c[i].fear|=(1<<mod(x-c[i].pos));
		}
		for(int j = 1;j<=c[i].l;j++)
		{
			scanf("%d",&x);
			c[i].love|=(1<<mod(x-c[i].pos));
		}
		for(int j = 0;j<S;j++)
			if((j&c[i].fear)||((31^j)&c[i].love))
				ok[i][j] = true,g[c[i].pos][j]++;
	}
	int ans = 0;
	for(int i = 0;i<1<<4;i++)
	{
		memset(f[0],200,sizeof(f[0]));
		f[0][i<<1] = 0;
		for(int j = 1;j<= n;j++)
			for(int k = 0;k<1<<5;k++)
				f[j][k] = max(f[j-1][(k&15)<<1],f[j-1][(k&15)<<1|1])+g[j][k];
		ans = max(ans,max(f[n][i<<1],f[n][i<<1|1]));
	}
	printf("%d\n",ans);
	return 0;
}
Problem1170

#include <stdio.h>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll mod1 = 1e9+7;
const ll mod2 = 1e9+9;
const ll base1 = 2591;
const ll base2 = 2593;
const int N = 1e3+5;
const int MOD = N*N;
ll sum1[N][N],sum2[N][N];
ll basel[3]={0,1,1},baser[3]={0,1,1};
char s[N][N];
ll ans_time,ans1,ans2;
struct Hash_list
{
	int next;
	ll hv1,hv2;
	int times;
}e[N*N];
int head[N*N],tot;
inline int& Hash(ll h1,ll h2)
{
	ll x = h1*h2%MOD;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].hv1==h1&&e[i].hv2==h2)
			return e[i].times;
	tot++;
	e[tot].next = head[x];e[tot].hv1 = h1,e[tot].hv2 = h2;
	e[tot].times = 0;head[x] = tot;
	return e[tot].times;
}
int n,m,a,b;
ll gethash1(int i,int j)
{
	return 
		((sum1[i][j]-
		sum1[i-a][j]*basel[1]-
		sum1[i][j-b]*baser[1]+
		sum1[i-a][j-b]*basel[1]%mod1*baser[1])%mod1+mod1)%mod1;
}
ll gethash2(int i,int j)
{
	return 
		((sum2[i][j]-
		sum2[i-a][j]*basel[2]-
		sum2[i][j-b]*baser[2]+
		sum2[i-a][j-b]*basel[2]%mod2*baser[2])%mod2+mod2)%mod2;
}
int main()
{
	//freopen("x.in","r",stdin);
	scanf("%d %d\n",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		fread(s[i]+1,m+1,1,stdin);
		for(int j = 1;j<= m;j++)
			sum1[i][j] = sum2[i][j] = s[i][j];
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			sum1[i][j]=(sum1[i][j]+sum1[i-1][j]*base1)%mod1,
			sum2[i][j]=(sum2[i][j]+sum2[i-1][j]*base1)%mod2;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			sum1[i][j]=(sum1[i][j]+sum1[i][j-1]*base2)%mod1,
			sum2[i][j]=(sum2[i][j]+sum2[i][j-1]*base2)%mod2;
	scanf("%d%d",&a,&b);
	printf("%d %d\n",a,b);
	for(int i = 1;i<= a;i++)
		basel[1]*=base1,basel[1]%=mod1,
		basel[2]*=base1,basel[2]%=mod2;
	for(int i = 1;i<= b;i++)
		baser[1]*=base2,baser[1]%=mod1,
		baser[2]*=base2,baser[2]%=mod2;
	ans_time = 0;
	for(int i = a;i<= n;i++)
		for(int j = b;j<= m;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			int &val = Hash(hash1,hash2);
			if(++val>ans_time)
			{
				ans_time = val;
				ans1 = hash1,ans2 = hash2;
			}
		}
	bool flag = true;
	for(int i = a;i<= n&&flag;i++)
		for(int j = b;j<= m&&flag;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			if(hash1==ans1&&hash2==ans2)
			{
				for(int k=i-a+1;k<=i;k++,puts(""))
					for(int l = j-b+1;l<=j;l++)
						putchar(s[k][l]);
				flag = false;
			}
		}
	printf("%lld\n",ans_time);
	for(int i = a;i<= n;i++)
		for(int j = b;j<= m;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			if(hash1==ans1&&hash2==ans2)
				printf("%d %d\n",i-a+1,j-b+1);
		}
	return 0;
}
Problem1181

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int INF = 1<<30;
int _a[N],a[N],b[N];
int s[N],ans[N];
bool cmp(int x,int y)
{
	return _a[x]>_a[y];
}
int f[2][N];
int V,n,m,tot;
bool check(int idx,int mid)
{
	for(int i = 0;i<= m;i++)
		f[0][i] = f[1][i] = INF;
	f[0][0] = 0;
	int now = 0;
	for(int i = 1;i<= min(n,21);i++)
	{
		if(i==idx)continue;
		for(int j = 0;j<= m;j++)
		{
			f[now^1][j] = INF;
			for(int k = 0;k<= j;k++)
			{
				int x = (a[idx]*k+mid)/(mid+1)-a[i];
				if(a[idx]*k%(mid+1)==0 && b[i]>b[idx] && k)
					x++;
				x = max(x,0);
				if (k && (a[i]+x)*20<V) 
					x+=(V+19-20*(a[i]+x))/20;
				f[now^1][j] = min(f[now^1][j],f[now][j-k]+x);
			}
		}
		now^=1;
	}
	return f[now][m-mid]<=V-tot;
}
int main()
{
	scanf("%d%d%d",&V,&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&_a[i]);
		b[i] = i;
		tot+=_a[i];
	}
	for(int i = 1;i<= n;i++)
	{
		_a[i]+=V-tot;
		for(int j = 1;j<= m;j++)
		{
			int mk = 0;
			for(int k = 1;k<= n;k++)
				if(_a[k]*20>=V&&(mk==0||_a[k]*(s[mk]+1)>_a[mk]*(s[k]+1)))
					mk = k;
			s[mk]++;
		}
		printf("%d",s[i]);
		if(i==n)printf("\n");else printf(" ");
		for(int j = 0;j<= n;j++)s[j]=0;
		_a[i]-=V-tot;
	}
	sort(b+1,b+n+1,cmp);
	for(int i = 1;i<= n;i++)a[i] = _a[b[i]];
	for(int i = 1;i<= n;i++)
	{
		if(a[i]*20<V){ans[b[i]]=0;continue;}
		int l = -1,r = m,mid;
		while(l+1<r)
		{
			mid = (l+r)>>1;
			if(check(i,mid))
				r = mid;
			else 
				l = mid;
		}
		ans[b[i]] = r;
	}
	for(int i = 1;i<= n;i++)
		printf("%d",ans[i]),printf("%c",i==n?'\n':' ');
	return 0;
}
Problem1187

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF=2e9;
const int MAXN=3005;
int i;
struct na
{
	int x,z;
	na(int _x,int _z):x(_x),z(_z){}
};
int n,m,x,y,z,a[21],k,p1,p2,en,t;
bool map[11][101];
int f[2][MAXN+1],ans=-INF,re[101][11];
int v[2][MAXN+1];
queue <na> q;
inline int gx(int x,int q1,int q2)
{
	k=0;
	for (register int i=m+1;i;i--) 
		k=k*3+(i==x?q1:(i==x+1?q2:a[i]));
	return k;
}
inline void up(int x,int z,int lj,int la)
{
	if (la) lj+=re[x/m+1][x%m+1];
	x++;
	k=x%2;
	if (v[k][z]!=x) v[k][z]=x,f[k][z]=-INF,q.push(na(x,z));
	if (f[k][z]<lj) f[k][z]=lj;
}
int main()
{
	int i,j,p;
	scanf("%d%d",&n,&m);
	memset(f,INF,sizeof(f));
	for (j=1;j<=n;j++)
	for (i=1;i<=m;i++)
	scanf("%d",&re[j][i]),map[i][j]=1;
	en=n*m-1;
	f[0][0]=0;
	v[0][0]=1;
	q.push(na(0,0));
	while(!q.empty())
	{
		p=0;
		na no=q.front();q.pop();
		int an=f[no.x%2][no.z];
		if(no.x%m==0) no.z*=3;
		x=no.x%m+1;y=no.x/m+1;
		for (i=1;i<=m+1;i++) a[i]=0;
		for (i=1,j=no.z;j;i++,j/=3)
		{
			a[i]=j%3;
			if (a[i]) p++;
		}
		if (a[x]==1&&a[x+1]==2)
		{
			if (ans<an+re[y][x]&&p==2) ans=an+re[y][x];
		}
		else if (a[x]==2&&a[x+1]==1) up(no.x,gx(x,0,0),an,1);
		else if (a[x]==0&&a[x+1]==0)
		{
			if (no.x!=en)
			{
				if (map[x][y+1]&&map[x+1][y]) up(no.x,gx(x,1,2),an,1);
				up(no.x,gx(x,0,0),an,0);
			}
		}
		else if (a[x]==0)
		{
			if (map[x+1][y]) up(no.x,gx(x,0,a[x+1]),an,1);
			if (map[x][y+1]) up(no.x,gx(x,a[x+1],0),an,1);
		}
		else if (a[x+1]==0)
		{
			if (map[x+1][y]) up(no.x,gx(x,0,a[x]),an,1);
			if (map[x][y+1]) up(no.x,gx(x,a[x],0),an,1);
		}
		else if (a[x]==a[x+1])
		{
			p1=p2=0;
			if (a[x]==1)
			for (j=0,i=x+2;i<=m+1;i++)
			{
				if (a[i]==1) j--;
				if (a[i]==2) j++;
				if (j>0&&!p1) p1=i,j--;
				if (j>0&&p1){p2=i;break;}
			}
			else
			for (j=0,i=x-1;i;i--)
			{
				if (a[i]==1) j++;
				if (a[i]==2) j--;
				if (j>0&&!p2) p2=i,j--;
				if (j>0&&p2){p1=i;break;}
			}
			a[p1]=1;a[p2]=2;up(no.x,gx(x,0,0),an,1);
		}
		//printf("%d\n",ans);
	}
	printf("%d\n",ans);
}
Problem1189

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define mid (l+r)/2
#define inf 0x3f3f3f3f
#define T n*n*m*m+2
const int N=25;
const int M=200000;
char s[N];
bool use[N][N],flag[N][N];
struct S{int x,y,c;}l[N*N];
struct Q{int st,en,va;}aa[M*2];
int n,m,map[N][N],f[N][N][N][N],sum,point[M],next[M*2],cur[M],dis[M],pre[M],gap[M],tot;
const int xi[4]={-1,0,0,1},yi[4]={0,-1,1,0};
inline void bfs(int xa,int ya)
{
	int i,h,t,k,x,y;
	memset(use,1,sizeof(use));
	h=t=1;l[h].x=xa;l[h].y=ya;l[h].c=0;
	while(h<=t){
		x=l[h].x;y=l[h].y;
		for(i=0;i<4;++i)
		{
			int xx=x+xi[i],yy=y+yi[i];
			if(xx>0&&xx<=n&&yy>0&&y<=m&&map[xx][yy]==1&&use[xx][yy])
			{
				l[++t].x=xx;l[t].y=yy;l[t].c=l[h].c+1;
				use[xx][yy]=false;
				f[xx][yy][xa][ya]=l[t].c;
				flag[xx][yy]=true;
			}
		}
		h+=1;
	}
}
inline void add(int x,int y,int z)
{
	tot+=1;next[tot]=point[x];point[x]=tot;
	aa[tot].st=x;aa[tot].en=y;aa[tot].va=z;
	tot+=1;next[tot]=point[y];point[y]=tot;
	aa[tot].st=y;aa[tot].en=x;aa[tot].va=0;
}
inline int ISAP(int ss,int tt)
{
	bool f;
	int minn,ans=0,i,u,y;
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	memset(pre,0,sizeof(pre));
	gap[0]=tt-ss+1; u=ss;
	for(i=ss;i<=tt;++i) cur[i]=point[i];
	while(dis[ss]<tt-ss+1)
	{
		f=false;
		for(i=cur[u];i;i=next[i])
			if(aa[i].va>0&&dis[u]==dis[aa[i].en]+1)
			{
			cur[u]=i;f=true;break;
			}
		if(f)
		{
			pre[u=aa[i].en]=i;
			if(u==tt)
			{
				minn=inf;
				for(i=u;i!=ss;i=aa[pre[i]].st)
					minn=min(minn,aa[pre[i]].va);
				ans+=minn;
				for(i=u;i!=ss;i=aa[pre[i]].st)
				{
					aa[pre[i]].va-=minn;
					aa[pre[i]^1].va+=minn;
				}
				u=ss;
			}   
		}
		else
		{
			--gap[dis[u]];
			if(!gap[dis[u]]) return ans;
			y=2*tt; cur[u]=point[u];
			for(i=point[u];i;i=next[i])
				if(aa[i].va>0) y=min(y,dis[aa[i].st]);
			++gap[dis[u]=y+1];
			if(u!=ss) u=aa[pre[u]].st;
		}
	}
	return ans;
}
inline bool check(int x)
{
	int i,j,p,q;
	tot=1;
	memset(point,0,sizeof(point));
	memset(next,0,sizeof(next));
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		{
		int now=((i-1)*m+j-1)*n*m;
		if(map[i][j]==0)
		{
			for(p=1;p<x;++p)
				add(now+p+1,now+p+2,inf),add(now+p+1,T,1);
			add(now+x+1,T,1);
		}
		if(map[i][j]==1)
		{
			add(1,now+1,1);
			for(p=1;p<=n;++p)
				for(q=1;q<=m;++q)
				if(f[i][j][p][q])
					add(now+1,((p-1)*m+q-1)*n*m+f[i][j][p][q]+1,1);
		}
		}
	return ISAP(1,T)==sum;
}
int main()
{
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)
	{
		scanf("%s",&s);
		for(j=0;j<m;++j)
		{
			if(s[j]=='D') map[i][j+1]=0;
			if(s[j]=='.') map[i][j+1]=1,sum+=1;
			if(s[j]=='X') map[i][j+1]=2;
		}
	}
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		if(map[i][j]==0)
			bfs(i,j);
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		if(!flag[i][j]&&map[i][j]==1)
		{
			printf("impossible\n");
			return 0;
		}
	int l=1,r=n*m,ans=inf;
	while(l<r)
	{
		if(check(mid)) ans=min(ans,mid),r=mid;
		else l=mid+1;
	}
	printf("%d\n",ans);
}
Problem1190

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 105;
ll f[35][1005];
int main()
{
	int n,w,x,v;
	while(scanf("%d%d",&n,&w)!=EOF)
	{
		if(n==-1&&w==-1)break;
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d",&x,&v);
			int tmp = 0;
			while(!(x&1))x>>=1,tmp++;
			for(int j = 1000;j>= x;j--)
				f[tmp][j] = max(f[tmp][j],f[tmp][j-x]+v);
		}
		for(int i = 0;i<= 30;i++)
			for(int j = 1;j<= 1000;j++)
				f[i][j]=max(f[i][j],f[i][j-1]);
		ll ans = 0;
		for(int j = 1;j<= min(1000,w);j++)ans = max(ans,f[0][j]);
		for(int i = 1;i<= 30&&(1<<i)<=w;i++)
			for(int j = min(1000,w>>i);j>= 0;j--)
			{
				for(int k = 0;k<= j;k++)
					f[i][j] = max(f[i][j],f[i][j-k]+f[i-1][min(k+k+((w>>i-1)&1),1000)]);
				ans = max(f[i][j],ans);
			}
		printf("%d\n",ans);

	}
	return 0;
}
Problem1194

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define fir first
#define sec second
const int N = 55;
const int L = 65540;
struct E
{int next,to;}e[N*N];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
vector<int>member[N];
int bel[N],cnt,dfn[N],low[N],Dfn,stack[N],top;
bool vis[N];
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	for(int i = head[x];i;i=e[i].next)
	{
		if(vis[e[i].to])continue;
		if(dfn[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}
	}
	if(dfn[x]==low[x])
	{
		++cnt;
		int tmp;
		do
		{
			tmp = stack[top--];
			bel[tmp] = cnt;
			member[cnt].push_back(tmp);
			vis[tmp] = true;
		}while(tmp!=x);
	}
}
struct AM
{
	int n,m;
	int trs[N][2],out[N];
	void Read()
	{
		int x;
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&x);
			out[x] = true;
		}
		for(int i = 0;i< n;i++)
			scanf("%d%d",&trs[i][0],&trs[i][1]);
	}
}a[N];
bool bfs(const AM &x,const AM &y)
{
	static pii q[L];
	static bool v[N][N];
	memset(v,0,sizeof(v));
	int hd=1,tl=0;
	q[++tl] = make_pair(0,0);
	v[0][0] = true;
	while(hd<=tl)
	{
		pii sta = q[hd++];
		if(x.out[sta.fir] && !y.out[sta.sec])
			return false;
		for(int i = 0;i<2;i++)
		{
			int xx = x.trs[sta.fir][i];
			int yy = y.trs[sta.sec][i];
			if(v[xx][yy])continue;
			v[xx][yy] = true;
			q[++tl] = make_pair(xx,yy);
		}
	}
	return true;
}
int f[N],ans,n;
void topo()
{
	static int q[N],deg[N];
	for(int i = 1;i<= n;i++)
		for(int j = head[i];j;j=e[j].next)
			if(bel[i]!=bel[e[j].to])
				deg[bel[e[j].to]]++;
	int hd = 1,tl = 0;
	for(int i = 1;i<= cnt;i++)
		if(!deg[i])
			q[++tl] = i;
	while(hd<=tl)
	{
		int tmp = q[hd++];
		f[tmp]+=member[tmp].size();
		for(int id = 0;id<member[tmp].size();id++)
		{
			int x = member[tmp][id];
			for(int i = head[x];i;i=e[i].next)
			{
				if(bel[e[i].to]==tmp)continue;
				f[bel[e[i].to]] = max(f[bel[e[i].to]],f[tmp]);
				if(!--deg[bel[e[i].to]])q[++tl] = bel[e[i].to];
			}
		}
		ans = max(ans,f[tmp]);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		a[i].Read();
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(i!=j&&bfs(a[i],a[j]))
				add(i,j);
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	topo();
	printf("%d\n",ans);
	return 0;
}
Problem1196

#include <cstdio> 
#include <cstring> 
#include <iostream> 
#include <algorithm> 
#define MAX 20010 
using namespace std;  
struct Edge{
 	int x,y; 	
	int cost,_cost;  	
	bool operator <(const Edge &a)const 
	{ 		
		return cost < a.cost; 	
	} 	
	void Read() 
	{ 		
		scanf("%d%d%d%d",&x,&y,&cost,&_cost); 	
	} 
}edge[MAX];  
int points,k,edges; 
int father[MAX];  
int Find(int x) 
{ 	
	if(father[x] == x)	
	return x; 	
	return father[x] = Find(father[x]); 
}  
inline bool Judge(int ans) 
{ 	
	for(int i = 1; i <= points; ++i) 		
		father[i] = i; 	
	int first = 0,added = 0; 	
	for(int i = 1; i <= edges; ++i) 
	{ 		
		int fx = Find(edge[i].x);
		int fy = Find(edge[i].y); 		
		if(fx != fy)
		 { 			
		 	if(edge[i].cost <= ans)
			{ 				
				++first,++added;
				father[fx] = fy; 			
			} 			
			else if(edge[i]._cost <= ans) 
			{ 				
				++added; 				
				father[fx] = fy;
 			} 		
		 } 	
	 } 	
	 return first >= k && added == points - 1;
  }  
int main() 
{ 	
	cin >> points >> k >> edges; 	
	for(int i = 1; i <= edges - 1; ++i)  	
		edge[i].Read(); 	
	sort(edge + 1,edge + edges + 1); 	
	int l = 0,r = 30000,ans = 30000; 	
	while(l <= r) 
	{ 		
		int mid = (l + r) >> 1; 		
		if(Judge(mid)) 			
			ans = mid,r = mid - 1; 		
		else	
			l = mid + 1; 	
	} 	
	cout << ans << endl;
 	return 0; 
 }
 
Problem1202

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int fa[105];
int pos[105];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else
	{
		int tmp = getfa(fa[x]);
		pos[x] = pos[fa[x]]+pos[x];
		return fa[x] = tmp;
	}
}
void work()
{
	memset(fa,0,sizeof(fa));
	memset(pos,0,sizeof(pos));
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	int flag = true;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		int fx = getfa(x),fy = getfa(y+1);
		if(fx==fy)
		{
			if(pos[y+1]-pos[x]!=c)flag = false;
		}
		else
		{
			fa[fy] = x;
			pos[fy] = c-pos[y+1];
		}
	}
	if(flag)printf("true\n");
	else printf("false\n");
	return ;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
		work();
	return 0;
}
Problem1208

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL INF = 1e18;
const int mod = 1e6;
struct Treap
{
	Treap *ls,*rs;
	int key,cnt,size;
	LL val;
	Treap(int x);
	void push_up();
}*root0,*root1;
Treap :: Treap(int x)
{
	ls = rs = NULL;
	key = rand();
	val = x;
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key<x->key)
			go_right(x);
	}else
	{
		insert(x->rs,y);
		if(x->rs->key<x->key)
			go_left(x);
	}
	x->push_up();
}
void dele(Treap *&x,int y)
{
	if(y<x->val)
		dele(x->ls,y);
	else if(y>x->val)
		dele(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)
			x = x->rs;
		else if(!x->rs)
			x = x->ls;
		else
		{
			go_left(x);
			dele(x->ls,y);
			if(x->ls && x->ls->key<x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
LL ans;
void ask_pro(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<y)
	{
		ans = max(ans,x->val);
		ask_pro(x->rs,y);
	}
	else ask_pro(x->ls,y);
}
void ask_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>y)
	{
		ans = min(ans,x->val);
		ask_sub(x->ls,y);
	}
	else ask_sub(x->rs,y);
}
int main()
{
	int n,a,b;
	scanf("%d",&n);
	LL sum = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a,&b);
		if(a==0&&!root1)
			insert(root0,b);
		else if(a==1&&!root0)
			insert(root1,b);
		else
		{
			if(a==0)
			{
				ans = 0;
				ask_pro(root1,b);
				int tmp1 = ans;
				ans = INF;
				ask_sub(root1,b);
				int tmp2 = ans;
				if(tmp1==0){sum+=abs(b-tmp2);dele(root1,tmp2);}
				else if(tmp2==INF){sum+=abs(b-tmp1);dele(root1,tmp1);}
				else if(abs(b-tmp1)>abs(b-tmp2)){sum+=abs(b-tmp2);dele(root1,tmp2);}
				else if(abs(b-tmp1)<abs(b-tmp2)){sum+=abs(b-tmp1);dele(root1,tmp1);}
				else{sum+=abs(b-tmp1);dele(root1,tmp1);}
			}else
			{
				ans = 0;
				ask_pro(root0,b);
				int tmp1 = ans;
				ans = INF;
				ask_sub(root0,b);
				int tmp2 = ans;
				if(tmp1==0){sum+=abs(b-tmp2);dele(root0,tmp2);}
				else if(tmp2==INF){sum+=abs(b-tmp1);dele(root0,tmp1);}
				else if(abs(b-tmp1)>abs(b-tmp2)){sum+=abs(b-tmp2);dele(root0,tmp2);}
				else if(abs(b-tmp1)<abs(b-tmp2)){sum+=abs(b-tmp1);dele(root0,tmp1);}
				else{sum+=abs(b-tmp1);dele(root0,tmp1);}
			}
		}
	}
	printf("%lld\n",sum%mod);
	return 0;
}
Problem1212

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int Len = 1<<20;
char w[Len+5];
char s[35];
	int ch[305][26],fail[305],cnt,q[305],h,t;
	bool end[305];
	int len[305];
	void init()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i] =1;
	}
	void insert()
	{
		int now = 1,i = 0;
		while(s[i])
		{
			if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
			now = ch[now][s(i)];
			i++;
		}
		len[now] = i;
	}
	void build()
	{
		int h = 0,t = -1;
		q[++t] = 1,fail[0] =1;
		while(h<=t)
		{
			int x=q[h++];
			for(int i = 0;i<26;i++)
			{
				int j=ch[x][i];
				if(!j)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[j] = ch[k][i];
				end[j]|=end[fail[j]];
				q[++t]=j;
			}
		}
	}
bool v[Len+5];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	init();
	for(int i = 1;i<=n;i++)
	{
		scanf("%s",s);
		insert();
	}
	build();
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",w+1);
		int lth = strlen(w+1);
		int now = 1,ans = 0;
		v[0]=true;
		for(int j = 1;j<=lth;j++)
		{
			while(now!=1&&!ch[now][w[j]-'a'])
				now = fail[now];
			if(ch[now][w[j]-'a'])
			{
				now = ch[now][w[j]-'a'];
				for(int tmp = now;tmp!=1;tmp = fail[tmp])
					if(len[tmp])
					{
						v[j]|=v[j-len[tmp]];
						if(v[j])break;
					}
			}
			if(v[j])ans =max(ans,j);
		}
		for(int j = 1;j<=lth;j++)v[j] = false;
		printf("%d\n",ans);
	}
	return 0;
}
Problem1226

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int S = 1<<8;
const int INF = 0x3f3f3f3f;
#define f(i,j,k) (f[i][j][k+8])
int t[N],b[N];
int f[N][S][20];
int v(int pos1,int pos2)
{
	if(pos1==0)return 0;
	return (t[pos1]^t[pos2]);
}
void work()
{
int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
		scanf("%d%d",&t[i],&b[i]);
	for(int i = 1;i<= n+1;i++)
		for(int j = 0;j<1<<8;j++)
			for(int k = -8;k<= 7;k++)
				f(i,j,k) = INF;
	f(1,0,-1) = 0;
	for(int i = 1;i<= n;i++)
		for(int s = 0;s<1<<8;s++)
			for(int k = -8;k<=7;k++)
			{
				if(!(f(i,s,k)<INF))continue;
				if(s&1)f(i+1,s>>1,k-1) = min(f(i,s,k),f(i+1,s>>1,k-1));
				else
				{
					int r = INF;
					for(int l = 0;l<= 7;l++)
						if(!(s&(1<<l)))
						{
							if(i+l>r)break;
							r = min(r,i+b[i+l]+l);
							f(i,s|(1<<l),l)=min(f(i,s|(1<<l),l),f(i,s,k)+v(i+k,i+l));
						}
				}
			}
	int ans = 0x3f3f3f3f;
	for(int i = -8;i<=-1;i++)
		ans = min(ans,f(n+1,0,i));
	printf("%d\n",ans);
	return ;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem1227

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 2147483647;
int d[N];
int sum[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		d[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=d[i];
	return ans;
}
struct P
{int x,y,l,r,u,d;}p[N];
bool cmp(const P &a,const P &b)
{
	return a.y<b.y||(a.y==b.y&&a.x<=b.x);
}
int fac[N],env[N];
int c[N][20];
void init()
{
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0]=1;
		for(int j=1;j<=10;j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j];
	}
}
int id[N],X[N];
int find(int x)
{
	int l = 1,r = id[0]+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l=mid+1;
		else r=mid;
	}
	return l;
}
int main()
{
	int n,m,w,k;
	init();
	scanf("%d%d%d",&n,&m,&w);
	for(int i = 1;i<= w;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		X[i] = p[i].x;
	}
	scanf("%d",&k);
	sort(X+1,X+w+1);
	id[id[0]=1]=X[1];
	for(int i = 2;i<= w;i++)
		if(X[i]!=X[i-1])
			id[++id[0]]=X[i];
	sort(p+1,p+w+1,cmp);
	int tmp = 0;
	for(int i = 1;i<= w;i++)p[i].x=find(p[i].x);
	for(int i = 1;i<= w;i++)
	{
		if(p[i].y==p[i-1].y)tmp++;else tmp=1;
		p[i].l=tmp;
		sum[p[i].x]++;
		p[i].u=sum[p[i].x];
	}
	tmp = 0;
	for(int i = w;i>=1;i--)
	{
		if(p[i].y==p[i+1].y)tmp++;else tmp=1;
		p[i].r=tmp;
		p[i].d=sum[p[i].x]-p[i].u;
	}
	int ans = 0;
	for(int i = 1;i<= w;i++)
	{
		update(p[i].x,c[p[i].u][k]*c[p[i].d][k]-getans(p[i].x)+getans(p[i].x-1));
		if(i>1&&p[i].y==p[i-1].y)
			ans+=c[p[i-1].l][k]*c[p[i].r][k]*(getans(p[i].x-1)-getans(p[i-1].x));
	}
	printf("%d\n",ans&mod);
	return 0;
}
Problem1231

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1<<16;
long long f[2][N][17];
int cnt[N],s[17];
int abs(int x){return x<0?-x:x;}
void init()
{
	for(int i = 0;i<N;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	return ;
}
int main()
{
	int n,k;
	init();
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&s[i]);
	for(int i = 0;i< n;i++)
		f[1][1<<i][i+1] = 1;
	for(int i = 2;i<= n;i++)
	{
		int I = i&1,I_=(i-1)&1;
		for(int sta = 0;sta<1<<n;sta++)
		{
			if(cnt[sta]!=i-1)continue;
			for(int l = 1;l<= n;l++)
			{
				if(!(sta&(1<<(l-1))))continue;
				for(int t = 1;t<= n;t++)
				{
					if(sta&(1<<(t-1)))continue;
					if(abs(s[t]-s[l])<=k)continue;
					f[I][sta|(1<<(t-1))][t]+=f[I_][sta][l];
				}
			}
		}
		memset(f[I_],0,sizeof(f[I_]));
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=f[n&1][(1<<n)-1][i];
	printf("%lld\n",ans);
	return 0;
}
Problem1251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
struct Splay 
{
	Splay *ls,*rs,*fa;
	int lazy_add,max_val,val;
	int size;
	bool lazy_rev;
	Splay(int x);
	void push_down();
	void push_up();
}*null = new Splay(0xefefefef),*root = null;
Splay :: Splay (int x)
{
	ls = rs = fa = null;
	lazy_add = lazy_rev = 0;
	max_val = val = x;
	size = null?1:0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	max_val = max(max(ls->max_val,rs->max_val),val);
}
void Splay :: push_down()
{
	if(this==null)return ;
	if(lazy_add)
	{
		if(ls!=null)
		{
			ls->lazy_add += lazy_add;
			ls->max_val+=lazy_add;
			ls->val+=lazy_add;
		}
		if(rs!=null)
		{
			rs->lazy_add += lazy_add;
			rs->max_val+=lazy_add;
			rs->val+=lazy_add;
		}
		lazy_add = 0;
	}
	if(lazy_rev)
	{
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		ls->lazy_rev^=1;
		rs->lazy_rev^=1;
		lazy_rev = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *tar)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y = y-x->ls->size;
			if(y==1)
				break;
			y--;
			x = x->rs;
		}
	}
	splay(x,tar);
}
void update()
{
	int l,r,c;
	scanf("%d%d%d",&l,&r,&c);
	Find(root,l,null);
	Find(root,r+2,root);
	root->rs->ls->val+=c;
	root->rs->ls->max_val+=c;
	root->rs->ls->lazy_add+=c;
	//root->rs->push_up();
	//root->push_up();
}
void reverse()
{
	int l,r;
	scanf("%d%d",&l,&r);
	Find(root,l,null);
	Find(root,r+2,root);
	Splay *tmp = root->rs->ls;
	tmp->lazy_rev^=1;
	swap(tmp->ls,tmp->rs);
}
void get_max()
{
	int l,r;
	scanf("%d%d",&l,&r);
	Find(root,l,null);
	Find(root,r+2,root);
	printf("%d\n",root->rs->ls->max_val);
}
/*
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}*/
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = new Splay(0);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa = x;
	if(x->rs!=null)x->rs->fa = x;
	x->push_up();
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int opt;
	root = new Splay(Inv);
	root->rs = new Splay(Inv);
	build(root->rs->ls,1,n);
	root->rs->ls->fa = root->rs;
	root->rs->fa =root;
	root->rs->push_up();
	root->push_up();
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)update();
		else if(opt==2)reverse();
		else get_max();
	}
	return 0;
}
Problem1261

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double INF = 1e9+1;
double dp[35][35][35];
int rt[35][35][35];
int d[35],n;
double k,c;
double dfs(int l,int r,int dep)
{
	if(l==r)
		return (k*(dep+1)+c)*d[l];
	if(r<l)return 0;
	if(dp[l][r][dep]<1e9+1)return dp[l][r][dep];
	for(int i = l;i<= r;i++)
	{
		double tmp1 = dfs(l,i-1,dep+1);
		double tmp2 = dfs(i+1,r,dep+1);
		if(tmp1+tmp2+(k*(dep+1)+c)*d[i]<dp[l][r][dep])
		{
			dp[l][r][dep] = tmp1+tmp2+(k*(dep+1)+c)*d[i];
			rt[l][r][dep] = i;
		}
	}
	return dp[l][r][dep];
}
/*void print(int l,int r,int dep)
{
	if(l==r)
	{
		printf("%d")
	}
	int t = rt[l][r][dep];

}*/
int main()
{
	int sum = 0;
	for(int i = 0;i<= 31;i++)
		for(int j = 0;j<= 31;j++)
			for(int k = 0;k<= 31;k++)
				dp[i][j][k] = INF;
	scanf("%d%lf%lf",&n,&k,&c);
	for(int i = 1;i<= n;i++)
		{scanf("%d",&d[i]);sum+=d[i];}
	double ans = dfs(1,n,0);
	ans = ans/(double)sum;
	printf("%.3f",ans);
	//print(1,n,0);
	return 0;
}
Problem1264

#include<stdio.h>
int pos[20005][6];
int dna2[100005];
int cnt[20005];
int a[1000005];
int f[100005];
int find(int x,int end)
{
	int l=1,r = end+1,mid;
	while(l<r)
	{
		mid = (l+r)/2;
		if(f[mid]>=x)
		{
			r = mid;
		}else
		{
			l = mid+1;
		}
	}
	return l;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= 5*n;i++)
	{
		int x;
		scanf("%d",&x);
		pos[x][5-cnt[x]] = i;
		cnt[x]++;
	}
	for(int i = 1;i<= 5*n;i++)
	{
		scanf("%d",&dna2[i]);
		for(int j = 1;j<=5;j++)
		{
			a[(i-1)*5+j] = pos[dna2[i]][j];
		}
	}
	int ans = 0;
	for(int i = 1;i<= 25*n;i++)
	{
		if(a[i]>f[ans])
		{
			ans++;
			f[ans] = a[i];
		}else
		{
			f[find(a[i],ans)] = a[i];
		}
	}
	printf("%d",ans);
	return 0;
}
Problem1266

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 3e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;};
int d[N],dis[N];
bool v[N];
queue<int>Q;
struct G
{
	E e[M];
	int head[N],tot;
	void init()
	{
		memset(head,0,sizeof(head));
		tot=1;
	}
	void addE(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].f = f;
		head[x] = tot;
	}
	void addF(int x,int y,int f)
	{
		e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;head[x]=tot;
		e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;head[y]=tot;
	}
	void spfa(int s)
	{
		memset(dis,0x3f,sizeof(dis));
		dis[s]=0;v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f+dis[x]<dis[e[i].to])
				{
					dis[e[i].to]=dis[x]+e[i].f;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
		}
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[t]=0;
		Q.push(t);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(d[e[i].to]==-1&&e[i^1].f)
				{
					d[e[i].to]=d[x]+1;
					Q.push(e[i].to);
				}
		}
		return d[s]!=-1;
	}
	int get_maxflow(int s,int t,int mf)
	{
		if(s==t)return mf;
		int last = mf;
		for(int i = head[s];i;i=e[i].next)
			if(d[e[i].to]==d[s]-1&&e[i].f)
			{
				int tof = get_maxflow(e[i].to,t,min(e[i].f,last));
				if(tof)
				{
					e[i].f-=tof;
					e[i^1].f+=tof;
					if(!(last-=tof))return mf;
				}
			}
		d[s]=-1;
		return mf-last;
	}
	int dinic(int s,int t)
	{
		int ans=0,nowflow;
		while(bfs(s,t))
			while((nowflow=get_maxflow(s,t,INF)))
				ans+=nowflow;
		return ans;
	}
}G,F;
int x[M],y[M],c[M],t[M];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x[i],&y[i],&t[i],&c[i]);
		G.addE(x[i],y[i],t[i]),G.addE(y[i],x[i],t[i]);
	}
	G.spfa(1);
	printf("%d\n",dis[n]);
	F.init();
	for(int i = 1;i<= m;i++)
	{
		if(dis[x[i]]+t[i]==dis[y[i]])
			F.addF(x[i],y[i],c[i]);
		if(dis[y[i]]+t[i]==dis[x[i]])
			F.addF(y[i],x[i],c[i]);
	}
	int ans = F.dinic(1,n);
	printf("%d\n",ans);
	return 0;
}
Problem1269

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct splay
{
	splay *ls,*rs,*fa;
	bool rev;
	int size;char c;
	splay(char c);
	void push_up();
	void push_down();
	void reverse();
}*null=new splay(0),*root=null;
splay :: splay(char C)
{
	ls = rs = fa = null;
	rev = false;
	size = C?1:0;
	c = C;
}
void splay :: push_up()
{
	size = ls->size+(c!=0)+rs->size;
}
void splay :: push_down()
{
	if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = false;
	}
}
void splay :: reverse()
{
	rev^=1;
	swap(ls,rs);
}
void go_left(splay *x)
{
	splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa=y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void go_right(splay *x)
{
	splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void Splay (splay *x,splay *tar)
{
	while(true)
	{
		splay *y = x->fa,*z = x->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(y==x->ls)go_right(x);
			else go_left(x);
			break;
		}else
		{
			if(x==y->ls)
			{
				if(y==z->ls)go_right(y);
				go_right(x);
			}else
			{
				if(y==z->rs)go_left(y);
				go_left(x);
			}
		}
	}
}
void find(splay *x,int y,splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;x=x->rs;
		}
	}
	Splay(x,z);
}
char s[1<<21];
void build(splay *&x,int l,int r)
{
	if(l>r)return ;
	int mid = (l+r)>>1;
	x = new splay(s[mid]);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa=x;
	if(x->rs!=null)x->rs->fa=x;
	x->push_up();
}
int pointer;
int main()
{
	char opt[20];
	int m,lth;
	scanf("%d",&m);
	root=new splay('\n');
	root->rs=new splay('\n');
	root->rs->fa= root;
	root->push_up();
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='M')
			scanf("%d",&pointer);
		else if(opt[0]=='I')
		{
			scanf("%d",&lth);
			do s[0]=getchar();while(s[0]=='\n'||s[0]=='\r');
			if(lth^1)gets(s+1);
			find(root,pointer+1,null);
			find(root,pointer+2,root);
			build(root->rs->ls,0,lth-1);
			root->rs->ls->fa=root->rs;
			root->rs->push_up();
			root->push_up();
		}else if(opt[0]=='D')
		{
			scanf("%d",&lth);
			find(root,pointer+1,null);
			find(root,pointer+lth+2,root);
			root->rs->ls=null;
			root->rs->push_up();
			root->push_up();
		}else if(opt[0]=='R')
		{
			scanf("%d",&lth);
			find(root,pointer+1,null);
			find(root,pointer+lth+2,root);
			root->rs->ls->reverse();
		}else if(opt[0]=='G')
		{
			find(root,pointer+2,null);
			printf("%c\n",root->c);
		}else if(opt[0]=='P')
			pointer--;
		else pointer++;
	}
	return 0;
}
Problem1293

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x7fffffff
using namespace std;
int n,k,cnt,ans=inf;
int head[65];
int next[1000005],v[1000005],a[1000005];
inline int read()
{
    char ch=getchar();
    int f=1,x=0;
    while(!(ch>='0'&&ch<='9')){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+(ch-'0');ch=getchar();}
    return x*f;
}
bool cal(int x)
{
	int mx=0;
	for(int i=1;i<=k;i++)
	{
		while(v[head[i]]>x)
		{
		    if(!next[head[i]])return 0;
			head[i]=next[head[i]];
			}
		if(v[head[i]]<=x)mx=max(mx,x-v[head[i]]);
	}
	ans=min(ans,mx);
	return 1;
}
int main()
{
	n=read();k=read();
	for(int i=1;i<=k;i++)
	{
		int x=read();
		for(int j=1;j<=x;j++)
		{
			int y=read();
			v[++cnt]=y;
			next[cnt]=head[i];
			head[i]=cnt;
			a[cnt]=y;
		}
	}
	sort(a+1,a+cnt+1);
	for(int i=cnt;i>0;i--)
	{
		if(a[i]!=a[i+1])
		if(!cal(a[i]))break;
	}
	printf("%d",ans);
	return 0;
}
Problem1296

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int map[55][55];
int stack[55],top;
int f[2501];
int g[55][55][55][2];
int w[55][55];
int main()
{
	int n,m,t;
	scanf("%d%d%d",&n,&m,&t);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%1d",&map[i][j]);
	for(int x = 1;x<= n;x++)
		for(int y = 1;y<= m;y++)
		{
			for(int i = min(m,t);i>=1;i--)
			{
				g[x][y][i][0] = max(g[x][y][i][0],g[x][y-1][i][0]+(map[x][y]==0));
				g[x][y][i][0] = max(g[x][y][i][0],g[x][y-1][i-1][1]+(map[x][y]==0));
				g[x][y][i][1] = max(g[x][y][i][1],g[x][y-1][i][1]+(map[x][y]==1));
				g[x][y][i][1] = max(g[x][y][i][1],g[x][y-1][i-1][0]+(map[x][y]==1));
			}
		}
	for(int x = 1;x<=n;x++)
		for(int i = 1;i<= min(m,t);i++)
		{
			int num = 0;
			for(int y = 1;y<= m;y++)
			{
				num = max(num,g[x][y][i][0]);
				num = max(num,g[x][y][i][1]);
			}
			w[x][i] = num;
		}
	for(int x = 1;x<=n;x++)
		for(int j = t;j>=0;j--)
			for(int i = 1;i<= min(m,t);i++)
				if(j>=i)f[j] = max(f[j],f[j-i]+w[x][i]);
	printf("%d\n",f[t]);
	return 0;
}
Problem1305

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 405;
const int M = 4e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int cntb[N],cntg[N];
char map[N][N];
void debug()
{
	for(int i = 0;i<= 7;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].f);
		printf("\n");
	}
}
void build(int n,int mid,int k)
{
    tot=1;memset(head,0,sizeof(head));
    for(int i=1;i<=n;i++)add(0,i*2-1,mid);
    for(int i=1;i<=n;i++)add(i*2-1,i*2,k);
    for(int i=1;i<=n;i++)add(n*2+i*2,n*2+i*2-1,k);
    for(int i=1;i<=n;i++)add(n*2+i*2-1,4*n+1,mid);
    for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
		{
			if(map[i][j]=='N')
				add(i*2,n*2+j*2,1);
			else
				add(i*2-1,2*n+j*2-1,1);
		}
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%s",map[i]+1);
	int st = 0,end = 4*n+1;
	int l = 0,r = n,ans=0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		build(n,mid,k);
		if(dinic(st,end)>=n*mid)l=mid+1,ans=mid;
		else r = mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1324

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x]=tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y]=tot;
}
int d[N],n,m;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_MF(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow&&d[e[i].to]==d[s]-1)
		{
			int tof = get_MF(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,NF;
	while(bfs(s,t))
		while((NF=get_MF(s,t,INF)))
			ans+=NF;
	return ans;
}
int getid(int x,int y)
{
	return (x-1)*m+y;
}
int main()
{
	int x,sum=0;
	scanf("%d%d",&n,&m);
	int st = 0,end = n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			sum+=x;
			if((i+j)&1)add(getid(i,j),end,x);
			else
			{
				add(st,getid(i,j),x);
				if(i!=1)add(getid(i,j),getid(i-1,j),INF);
				if(j!=1)add(getid(i,j),getid(i,j-1),INF);
				if(i!=n)add(getid(i,j),getid(i+1,j),INF);
				if(j!=m)add(getid(i,j),getid(i,j+1),INF);
			}
		}
	printf("%d\n",sum-dinic(st,end));
	return 0;
}
Problem1342

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int a[N],ans[N],top;
int Q[N],P[N],hq,tq,hp,tp;
int main()
{
	int n,m,c;
	scanf("%d%d%d",&n,&m,&c);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	hq = 0,tq = -1,hp = 0,tp = -1;
	//Q[0] = P[0] = 1;
	for(int i = 1;i<= n;i++)
	{
		while(hq<=tq&&a[Q[tq]]<=a[i])tq--;
		Q[++tq] = i;
		while(hp<=tp&&a[P[tp]]>=a[i])tp--;
		P[++tp] = i;
		while(hq<=tq&&Q[hq]<i-m+1)hq++;
		while(hp<=tp&&P[hp]<i-m+1)hp++;
		if(i>=m&&a[Q[hq]]-a[P[hp]]<=c)
			ans[++top] = i-m+1;
	}
	for(int i = 1;i<= top;i++)
		printf("%d\n",ans[i]);
	if(top==0)printf("NONE\n");
	return 0;
}
Problem1369

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int f[N][16];
void dp(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dp(e[i].to,x);
	for(int t = 1;t<= 15;t++)
	{
		f[x][t] = t;
		for(int i = head[x];i;i = e[i].next)
		{
			if(fa==e[i].to)continue;
			int tmp = 0x3f3f3f3f;
			for(int k = 1;k<= 15;k++)
			{
				if(t==k)continue;
				tmp = min(tmp,f[e[i].to][k]);
			}
			f[x][t] = f[x][t]+tmp;
		}
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dp(1,0);
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= 15;i++)
		ans = min(ans,f[1][i]);
	printf("%d\n",ans);
	return 0;
}
Problem1396

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
struct Seg_Tree
{
	int minn[N<<2],lazy[N<<2];
	void build(int p,int l,int r)
	{
		lazy[p]=minn[p]=INF;
		if(l==r)return ;
		int mid = (l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
	}
	void push_down(int p,int l,int r)
	{
		if(lazy[p]==INF||l==r)return ;
		minn[p<<1] = min(minn[p<<1],lazy[p]);
		minn[p<<1|1] = min(minn[p<<1|1],lazy[p]);
		lazy[p<<1] = min(lazy[p<<1],lazy[p]);
		lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
		lazy[p] = INF;
	}
	void update(int p,int l,int r,int a,int b,int x)
	{
		push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			minn[p] = min(minn[p],x);
			lazy[p] = min(lazy[p],x);
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,x);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,x);
		minn[p]=min(minn[p<<1],minn[p<<1|1]);
	}
	int getans(int p,int l,int r,int x)
	{
		push_down(p,l,r);
		if(l==r)return minn[p];
		int mid=(l+r)>>1;
		if(x<=mid)return getans(p<<1,l,mid,x);
		else return getans(p<<1|1,mid+1,r,x);
	}
}T1,T2;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1];
	bool end[N<<1];
	int cnt,last;
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p = last,np=++cnt,q,nq;
		last = np,len[np]=len[p]+1;
		end[np] = true;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	void getans(int n)
	{
		for(int i = 1;i<= cnt;i++)
			end[fa[i]] = false;
		for(int i = 1;i<= cnt;i++)
			if(end[i])
			{
				int l = len[i]-len[fa[i]],r = len[i];
				T1.update(1,1,n,l,r,r-l+1);
				if(l>1)T2.update(1,1,n,1,l-1,r);
			}
		for (int i=1;i<=n;i++)
			printf("%d\n",min(T1.getans(1,1,n,i),T2.getans(1,1,n,i)-i+1));
	}
}sam;
char s[N];
int main()
{
	sam.init();
	scanf("%s",s+1);
	int lth = strlen(s+1);
	for(int i = 1;i<=lth;i++)
		sam.insert(s[i]-'a');
	T1.build(1,1,lth);
	T2.build(1,1,lth);
	sam.getans(lth);
	return 0;
}
Problem1396

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
struct Seg_Tree
{
	int mn[N<<2],lazy[N<<2];
	void build(int p,int l,int r)
	{
		lazy[p] = mn[p] = INF;
		if(l==r)return ;
		int mid = (l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
	}
	void push_down(int p,int l,int r)
	{
		if(lazy[p]==INF||l==r)return ;
		mn[p<<1] = min(mn[p<<1],lazy[p]);
		mn[p<<1|1] = min(mn[p<<1|1],lazy[p]);
		lazy[p<<1] = min(lazy[p<<1],lazy[p]);
		lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
		lazy[p] = INF;
	}	
	void Update(int p,int l,int r,int a,int b,int c)
	{
		push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			lazy[p] = min(lazy[p],c);
			mn[p] = min(mn[p],c);
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)Update(p<<1,l,mid,a,b,c);
		if(b >mid)Update(p<<1|1,mid+1,r,a,b,c);
		mn[p] =min(mn[p<<1],mn[p<<1|1]);
	}
	int Getans(int p,int l,int r,int x)
	{
		push_down(p,l,r);
		if(l==r)return mn[p];
		int mid = (l+r)>>1;
		if(x<=mid)return Getans(p<<1,l,mid,x);
		else return Getans(p<<1|1,mid+1,r,x);
	}
}t1,t2;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1];
	bool end[N<<1];
	int cnt,last;
	void init()
	{
		cnt = last = 1;
	}
	void insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np] = len[p]+1;
		end[np] =true;
		for(;p&&!trs[p][x];p = fa[p])trs[p][x] = np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] =q;
			else
			{
				fa[nq =++cnt] =fa[q];
				len[nq] = len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p =fa[p])trs[p][x] = nq;
			}
		}
	}
	void getans(int n)
	{
		for(int i = 1;i<= cnt;i++)
			end[fa[i]] =false;
		for(int i = 1;i<= cnt;i++)
			if(end[i])
			{
				int l =len[i]-len[fa[i]],r = len[i];
				t1.Update(1,1,n,l,r,r-l+1);
				if(l>1)t2.Update(1,1,n,1,l-1,r);
			}
		for(int i = 1;i<= n;i++)
			printf("%d\n",min(t1.Getans(1,1,n,i),t2.Getans(1,1,n,i)-i+1));
	}
}sam;
char s[N];
int main()
{
	sam.init();
	scanf("%s",s+1);
	int n = strlen(s+1);
	t1.build(1,1,n);
	t2.build(1,1,n);
	for(int i = 1;i<= n;i++)
		sam.insert(s[i]-'a');
	sam.getans(n);	
	return 0;
}
Problem1406

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int stack[50005],ans[10000005];
int main()
{
	int top = 0,cnt = 0;
	ll n;
	scanf("%lld",&n);
	for(ll i = 1;i*i<=n;i++)
		if(n%i==0)
			stack[++top]=n/i;
	for(int i = 1;i<= top;i++)
	{
		for(ll j = stack[i];j<=n;j+=stack[i])
		{
			if((j-2)%(n/stack[i])==0)
				ans[++cnt] = (j-1)%n;
			if((j+2)%(n/stack[i])==0)
				ans[++cnt] = (j+1)%n;
		}
	}
	sort(ans+1,ans+cnt+1);
	top = 0;
	for(int i = 1;i<= cnt;i++)
		if(ans[i]!=ans[top])
			ans[++top]=ans[i];
	for(int i = 1;i<= top;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem1408

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int mod = 10000;
int p[N],e[N];
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{
	int k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
		scanf("%d%d",&p[i],&e[i]);
	int ans1=0,ans2=0,ans3,tmp1,tmp2;
	for(int i = 1;i<= k;i++)
	{
		if(p[i]==2)continue;
		tmp1 = (ans1+ans2*(p[i]-1)%mod)%mod;
		tmp2 = (ans2+(ans1+1)*(p[i]-1)%mod)%mod;
		ans1 = tmp1,ans2 = tmp2;
	}
	int m = 1;
	for(int i = 1;i<= k;i++)
		m = m*quick_pow(p[i]%mod,e[i])%mod;
	ans3 = (((m-1)-ans1-ans2)%mod+mod)%mod;
	printf("%d\n%d\n%d\n",ans1,ans2,ans3);
	return 0;
}
Problem1415

#include <stdio.h>
#include <queue>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const double eps = 1e-8;
struct Edge{int next,to;}e[N<<1];
int head[N],tot,cnt[N],v[N],dis[N];
int step[N][N];
double f[N][N];
queue <int>Q;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void spfa(int sta)
{
	memset(v,0,sizeof(v));
	memset(dis,0x3f,sizeof(dis));
	Q.push(sta);
	v[sta] = true;
	dis[sta] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i = e[i].next)
		{
			if(dis[x]+1<dis[e[i].to]||(dis[x]+1==dis[e[i].to]&&x<step[sta][e[i].to]))
			{
				step[sta][e[i].to] = x;
				dis[e[i].to] = dis[x]+1;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
		}
	}
	return ;
}
double dfs(int x,int y)
{
	if(x==y)return f[x][y] = 0;
	if(f[x][y]>eps)return f[x][y];
	if(step[y][x]==y||step[y][step[y][x]]==y)return f[x][y] = 1.0;
	int tmp = step[y][step[y][x]];
	double ans = dfs(tmp,y);
	for(int i=head[y];i;i = e[i].next)
		ans+=dfs(tmp,e[i].to);
	ans = ans/(double)(cnt[y]+1)+1;
	f[x][y] = ans;
	return ans;
}
int main()
{
	int n,E,c,m;
	scanf("%d%d%d%d",&n,&E,&c,&m);
	int x,y;
	for(int i = 1;i<= E;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
		cnt[x]++;cnt[y]++;
	}
	for(int i = 1;i<= n;i++)
		spfa(i);
	//printf("warning\n");
	memset(f,0xc2,sizeof(f));
	printf("%.3f",dfs(c,m));
	return 0;
}
Problem1419

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const double eps = 5e-7;
double f[2][N];
int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	for(int i = 1;i<=a;i++)
	{
		int I = i&1,I_ = (i-1)&1;
		f[I][0] = i;
		for(int j = 1;j<=b;j++)
		f[I][j] = 
			max(0.0,(double)i/(double)(i+j)*(f[I_][j]+1)+(double)j/(double)(i+j)*(f[I][j-1]-1));
	}
	printf("%.6f",f[a&1][b]-eps);
	return 0;
}
Problem1433

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 2e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
queue<int>Q;
int d[N],map[N][N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans=0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF)))
			ans+=nowflow;
	return ans;
}
int is_sch[N];
void debug()
{
	for(int i = 0;i<=7;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].flow);
		printf("\n");
	}
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 1;
}
void work()
{
	init();
	int n,x,num=0;
	scanf("%d",&n);
	int st = 0,end = 2*n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&is_sch[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(is_sch[i])
			{if(!x)add(st,i,1),num++;}
		else if(!is_sch[i])add(st,i,1),num++;
	}
	for(int i = 1;i<= n;i++)if(is_sch[i])add(i+n,end,1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&map[i][j]);
			if((map[i][j]&&is_sch[j])||(i==j&&is_sch[i]))
				add(i,j+n,1);
		}
	int ans = dinic(st,end);
	if(ans>=num)printf("^_^\n");
	else printf("T_T\n");
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem1444

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'A')
const int N = 105;
const double eps = 1e-6;
const double EPS = 1e-4;
int p[15],q[15],cnt;
int ch[N][15],n,m,l,pos[N];
char s[15];
int fail[N],danger[N];
void init()
{
	cnt = 1;
	for(int i = 0;i<m;i++)
		ch[0][i] = 1;
}
void insert(int id)
{
	int now = 1,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
		now = ch[now][s(i)];
		i++;
	}
	danger[now] = true;
	pos[id] = now;
}
int Q[N],h,t;
void build()
{
	h = 0,t = -1;
	Q[++t]=1,fail[0]=1;
	while(h<=t)
	{
		int x=Q[h++];
		for(int i = 0;i<m;i++)
		{
			int j = ch[x][i];
			if(j)
			{
				Q[++t] = j;
				int r = fail[x];
				while(!ch[r][i])r = fail[r];
				fail[j] = ch[r][i];
				danger[j]|=danger[fail[j]];
			}
			else ch[x][i] = ch[fail[x]][i];
		}
	}
}
struct Matrix 
{
	int w,h;
	double d[105][105];
	Matrix(){}
	Matrix(int _w,int _h):w(_w),h(_h){memset(d,0,sizeof(d));}
	void operator*=(const Matrix &S)
	{
		Matrix res(w,S.h);
		for(int i = 1;i<=res.w;i++)
			for(int j = 1;j<=res.h;j++)
			{
				res.d[i][j] = 0;
				for(int k = 1;k<=h;k++)
					res.d[i][j]+=d[i][k]*S.d[k][j];
			}
		*this = res;		
	}
};
void debug(const Matrix &f)
{
	for(int i = 1;i<= 6;i++)
	{
		for(int j = 1;j<= 6;j++)
			printf("%5.2f",f.d[i][j]);
		printf("\n");
	}
}
int main()
{
	scanf("%d%d%d",&n,&l,&m);
	for(int i = 0;i< m;i++)
		scanf("%d%d",&p[i],&q[i]);
	init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		insert(i);
	}
	build();
	Matrix f(cnt,cnt);
	for(int i= 1;i<= cnt;i++)
	{
		if(danger[i])
			f.d[i][i]=1;
		else
			for(int j =0;j<m;j++)
				f.d[i][ch[i][j]]+=(double)p[j]/(double)q[j];
	}
	for(int i = 1;i<= 50;i++)
		f*=f;
	for(int i = 1;i<= n;i++)
		printf("%.2f\n",f.d[1][pos[i]]);
	return 0;
}
Problem1452

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 301;
struct T
{
	int c[N][N];
	T()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y,int v)
	{
		for(int i= x;i<N;i+=i&(-i))
			for(int j = y;j<N;j+=j&(-j))
				c[i][j]+=v;
	}
	int getans(int x,int y)
	{
		int ans= 0;
		for(int i= x;i>0;i-=i&(-i))
			for(int j = y;j>0;j-=j&(-j))
				ans+=c[i][j];
		return ans;
	}
}tree[105];
int map[N][N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&map[i][j]);
			tree[map[i][j]].update(i,j,1);
		}
	int q,opt,a,b,c,d,v;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&a,&b,&v);
			tree[map[a][b]].update(a,b,-1);
			tree[v].update(a,b,1);
			map[a][b] = v;
		}else
		{
			int ans = 0;
			scanf("%d%d%d%d%d",&a,&b,&c,&d,&v);
			ans = ans+tree[v].getans(b,d);
			ans = ans-tree[v].getans(b,c-1);
			ans = ans-tree[v].getans(a-1,d);
			ans = ans+tree[v].getans(a-1,c-1);
			printf("%d\n",ans);
		}
	}
	return 0;
}
Problem1457

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int P = 105;
const int C = 10005;
const int N = 1005;
int sg[P][P];
int vis[C];
void Init()
{
	int cnt = 0;
	for(int i = 1;i<= 100;i++)
		for(int j = 1;j<=100;j++)if(i!=j)
		{
			++cnt;
			for(int k = 1;k<i;k++)if(j!=(i-k))vis[sg[i-k][j]]=cnt;
			for(int k = 1;k<j;k++)if(i!=(j-k))vis[sg[i][j-k]]=cnt;
			for(int k = min(i,j)-1;k>=1;k--)vis[sg[i-k][j-k]]=cnt;
			for(int k = 0;k<C;k++)
				if(vis[k]!=cnt)
					{sg[i][j]=k;break;}
		}
}
int main()
{
	Init();
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		bool flag = false;
		int n,x,y,ans = 0;
		scanf("%d",&n);
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d",&x,&y);
			if(!x || !y|| x==y)flag = true;
				ans^=sg[x][y];
		}
		if(flag)printf("^o^\n");
		else 
		{
			if(ans>0)printf("^o^\n");
			else printf("T_T\n");
		}
	}
	return 0;
}
Problem1458

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e4+5;
const int M = 8e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
}
queue<int>Q;
int d[N],st,end;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int r[105],c[105],map[105][105];
int R[105],C[105];
int main()
{
	int m,n,k;
	scanf("%d%d%d",&m,&n,&k);
	int st = 0,end = n*m+1;
	for(int i = 1;i<= m;i++)r[i]=n,scanf("%d",&R[i]);
	for(int i = 1;i<= n;i++)c[i]=m,scanf("%d",&C[i]);
	int x,y;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y]++;
		r[x]--;c[y]--;
	}
	int ans = 0;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			if(!map[i][j])
				ans++,add(i,j+m,1);
	for(int i = 1;i<=m;i++)if(r[i]<R[i]){printf("JIONG!\n");return 0;}
	for(int i = 1;i<=n;i++)if(c[i]<C[i]){printf("JIONG!\n");return 0;}
	for(int i = 1;i<=m;i++)add(st,i,r[i]-R[i]);
	for(int i = 1;i<=n;i++)add(i+m,end,c[i]-C[i]);
	ans-=dinic(st,end);
	//for(int i = head[0];i;i=e[i].next)
	//	if(e[i].flow)
	//		{printf("JIONG!\n");return 0;}
	printf("%d\n",ans);
	return 0;
}
Problem1484

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 5005;
const int INF = 0x7f7f7f7f;
LL a[N],b[N];
LL Abs(LL a){return a>0?a:-a;}
void work()
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	int n,d;
	scanf("%d%d",&n,&d);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	if(Abs(a[n]-a[1])>(LL)(n-1)*d){printf("impossible\n");return ;}
	b[1]=a[1];
	for(int i = 2;i<= n;i++)
		b[i] = b[i-1]-d;
	LL s,x,delta,minx,tmp;
	while(a[n]!=b[n])
	{
		s = 0,minx = INF;
		delta = INF,tmp = -INF;
		for(int i=n;i>1;i--)
		{
			if(a[i]>b[i])s++,minx = min(minx,a[i]-b[i]);
			else s--;
			if(tmp<s&&b[i-1]+d>b[i])
				tmp = s,x = i,delta = minx;
		}
		delta = min(delta,b[x-1]+d-b[x]);
		for(int i = x;i<= n;i++)b[i]+=delta;
	}
	LL ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=Abs(b[i]-a[i]);
	printf("%lld\n",ans);
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)work();
	return 0;
}
Problem1491

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
double map[N][N],sol[N][N];
double imp[N];
int main()
{
	for(int i = 1;i<N;i++)
		for(int j = 1;j<N;j++)
			map[i][j] = 1e9;
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		map[x][y] = map[y][x] = c;
		sol[x][y] = sol[y][x] = 1;
	}
	for(int k = 1;k<= n;k++)
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= n;j++)
			{
				if(i==j||j==k||i==k)continue;
				if(map[i][k]+map[k][j]<map[i][j])
				{
					map[i][j] = map[i][k]+map[k][j];
					sol[i][j] = sol[i][k]*sol[k][j];
				}else if(map[i][k]+map[k][j]==map[i][j])
					sol[i][j]+=sol[i][k]*sol[k][j];
			}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int v = 1;v<= n;v++)
			{
				if(i==j||j==v||i==v)continue;
				if(map[i][v]+map[v][j]!=map[i][j]||sol[i][j]<=0)continue;
				imp[v] += sol[i][v]*sol[v][j]/sol[i][j];
			}
	for(int i = 1;i<= n;i++)
		printf("%.3f\n",imp[i]);
	return 0;
}
Problem1492

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef double db;
typedef pair<db,db>PA;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
db f[N];
struct P
{
	db a,b,rate,slope;
	int pos;
	bool operator<(const P &s)const
	{
		return slope<s.slope;
	}
}q[N],nq[N];
PA p[N],np[N];
int st[N],top,n;
double getslope(PA x,PA y)
{
	if(x.first==y.first)
		return y.second>=x.second?INF:-INF;
	return (y.second-x.second)/(y.first-x.first);
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)
	{
		f[mid] = max(f[mid],f[mid-1]);
		p[mid].first = f[mid]/(q[mid].a+q[mid].b/q[mid].rate);
		p[mid].second = f[mid]/(q[mid].a*q[mid].rate+q[mid].b);
		return ;
	}
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if(q[i].pos<=mid)
			nq[l1++] = q[i];
		else nq[l2++] = q[i];
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	CDQ(l,mid);
	top = 0;
	for(int i = l;i<= mid;i++)
	{
		while(top>1&&getslope(p[st[top-1]],p[st[top]])<getslope(p[st[top]],p[i]))
			st[top--] = 0;
		st[++top] = i;
	}
	for(int i = mid+1;i<= r;i++)
	{
		while(top>1&&getslope(p[st[top-1]],p[st[top]])<q[i].slope)
			st[top--] =0;
		f[q[i].pos] = max(f[q[i].pos],q[i].a*p[st[top]].first+q[i].b*p[st[top]].second);
	}
	CDQ(mid+1,r);
	l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if((p[l1]<p[l2]||l2>r)&&l1<=mid)
			np[i] = p[l1++];
		else np[i] = p[l2++];
	memcpy(p+l,np+l,sizeof(p[0])*(r-l+1));
}
int main()
{
	scanf("%d%lf",&n,&f[0]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf%lf",&q[i].a,&q[i].b,&q[i].rate);
		q[i].slope = -q[i].a/q[i].b;
		q[i].pos = i;
	}
	sort(q+1,q+n+1);
	CDQ(1,n);
	printf("%.3lf",f[n]);
	return 0;
}
Problem1493

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
int n,m;
struct col_seg
{
	int cnt,lc,rc;
	col_seg(int x)
	{
		cnt = 1;
		if(!x)
			cnt = 0;
		lc = rc = x;
	}
	col_seg();
	col_seg uni(col_seg x,col_seg y)
	{
		col_seg re(0);
		re.lc = x.lc?x.lc:y.lc;
		re.rc = y.rc?y.rc:x.rc;
		re.cnt = x.cnt+y.cnt-(x.rc==y.lc);
		return re;
	}
};
col_seg operator + (const col_seg x,const col_seg y)
{
	col_seg re(0);
	re.lc = x.lc?x.lc:y.lc;
	re.rc = y.rc?y.rc:x.rc;
	re.cnt = x.cnt+y.cnt-(x.rc==y.lc);
	return re;
}
struct Splay
{
	int num,size;
	Splay *ls,*rs,*fa;
	col_seg *col;
	int lazy_r,lazy_c;
	Splay(int x);
	void push_up();
	void push_down();
}*null = new Splay(0),*root = null;
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	num = x;
	size = x?1:0;
	lazy_r = lazy_c = 0;
	col = new col_seg(x);
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	*col = (*ls->col)+col_seg(num)+(*rs->col);
}
void Splay :: push_down()
{
	if(lazy_r)
	{
		ls->lazy_r ^= 1;
		rs->lazy_r ^= 1;
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		swap(ls->col->lc,ls->col->rc);
		swap(rs->col->lc,rs->col->rc);
		lazy_r = 0;
	}
	if(lazy_c)
	{
		if(ls!=null)
		{	
			ls->num = ls->lazy_c = lazy_c;
			*ls->col = col_seg(lazy_c);
		}
		if(rs!=null)
		{
			rs->num = rs->lazy_c = lazy_c;
			*rs->col = col_seg(lazy_c);
		}
		lazy_c = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
void R()
{
	int x;
	scanf("%d",&x);
	Find(root,n-x+1,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
	Find(root,1,null);
	Find(root,2,root);
	root->rs->ls = tmp;
	tmp->fa = root->rs;
	root->rs->push_up();
	root->push_up();
}
void F()
{
	Find(root,2,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	tmp->lazy_r ^= 1;
	swap(tmp->ls,tmp->rs);
	swap(tmp->col->lc,tmp->col->rc);
}
void S()
{
	int x,y;
	scanf("%d%d",&x,&y);
	if(x==y)return ;
	else if(x>y)swap(x,y);
	Find(root,x+1,null);
	Find(root,y+1,root);
	swap(root->rs->num,root->num);
}
void P()
{
	int x,y,z;
	scanf("%d%d%d",&x,&y,&z);
	if(x<=y)
	{
		Find(root,x,null);
		Find(root,y+2,root);
		Splay *tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
	}else
	{
		Find(root,x,null);
		Find(root,n+2,root);
		Splay *tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
		Find(root,1,null);
		Find(root,y+2,root);
		tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
	}
}
void C()
{
	Find(root,1,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	int z = tmp->col->cnt-(tmp->col->lc==tmp->col->rc);
	if(!z)z++;
	printf("%d\n",z);
}
void CS()
{
	int x,y;
	scanf("%d%d",&x,&y);
	if(x<=y)
	{
		Find(root,x,null);
		Find(root,y+2,root);
		Splay *tmp = root->rs->ls;
		printf("%d\n",tmp->col->cnt);
	}
	else
	{
		Find(root,x,null);
		Find(root,n+2,root);
		Splay *tmp = root->rs->ls;
		col_seg stmp = *tmp->col;
		Find(root,1,null);
		Find(root,y+2,root);
		tmp = root->rs->ls;
		stmp = stmp+(*tmp->col);
		printf("%d\n",stmp.cnt);
	}
}
int main()
{
	int x,c;
	char opt[10];
	scanf("%d%d",&n,&c);
	Insert(root,Inv,null);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	Insert(root,Inv,null);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='R')R();
		else if(opt[0]=='F')F();
		else if(opt[0]=='S')S();
		else if(opt[0]=='P')P();
		else if(opt[0]=='C'&&!opt[1])C();
		else CS();
	}
	return 0;
}
Problem1497

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
const int M = 4e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF)))
			ans+=nowflow;
	return ans;
}
int p[N];
int main()
{
	int n,m,sum=0;
	scanf("%d%d",&n,&m);
	int s = 0,end = n+m+1;
	for(int i = 1;i<= n;i++)scanf("%d",&p[i]);
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		sum+=z;
		add(s,i+n,z);
		add(i+n,x,INF),add(i+n,y,INF);
	}
	for(int i = 1;i<= n;i++)
		add(i,end,p[i]);
	printf("%d\n",sum-dinic(s,end));
	return 0;
}
Problem1499

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int INF = 0x3f3f3f3f;
using namespace std;
const int N = 205;
struct pos{
	int x,y;
	pos(int a,int b){x = a;y = b;}
	pos(){}
};
int f[N][N],g[N][N],L,R;
char map[N][N];
pos line[N];
int n,m;
int dis(pos t,pos z)
{
	return abs(t.x-z.x)+abs(t.y-z.y);
}
int getans(pos t,int len)
{
	while(L<=R&&dis(t,line[L])>len)L++;
	if(L>R)return -INF;
	return f[line[L].x][line[L].y]+dis(t,line[L]);
}
void Insert(pos t)
{
	while(L<=R&&dis(t,line[R])<=f[t.x][t.y]-f[line[R].x][line[R].y])R--;
	line[++R] = t;
}
void go_up(int lth)
{
	for(int j = 1;j<= m;j++) 
	{
		L = 1,R = 0;
		for(int i = n;i;i--)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_down(int lth)
{
	for(int j = 1;j<= m;j++)
	{
		L = 1,R = 0;
		for(int i = 1;i<= n;i++)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_left(int lth)
{
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = 0;
		for(int j = m;j;j--)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_right(int lth)
{
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = 0;
		for(int j = 1;j<=m;j++)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
int main()
{
	int sx,sy,t,x,y,z;
	scanf("%d%d%d%d%d",&n,&m,&sx,&sy,&t);
	for(int i = 1;i<= n;i++)
		scanf("%s",map[i]+1);
	memset(f,128,sizeof(f));
	memset(g,128,sizeof(g));
	f[sx][sy] = 0;
	for(int i = 1;i<= t;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(z==1)go_up(y-x+1);
		else if(z==2)go_down(y-x+1);
		else if(z==3)go_left(y-x+1);
		else go_right(y-x+1);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			ans = max(ans,f[i][j]);
	printf("%d\n",ans);
	return 0;
}
Problem1500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Minm = 0xefefefef;
const int Inv = 20000307;
struct Max_s
{
	int l_max,r_max,all_max,sum;
	void init(int x,int y)
	{
		if(x>0)l_max = r_max = all_max = sum = x*y;
		else
		{
			l_max = r_max = all_max = x;
			sum = x*y;
		}
	}
	void uni(const Max_s &x,const Max_s &y)
	{
		all_max = max(x.all_max,y.all_max);
		all_max = max(all_max,x.r_max+y.l_max);
		l_max = max(x.l_max,x.sum+y.l_max);
		r_max = max(y.r_max,y.sum+x.r_max);
		sum = x.sum+y.sum;
	}
};
struct Splay
{
	Splay *ls,*rs,*fa;
	int size,num,max_num;
	int lazy_c,lazy_r;
	Max_s ms;
	Splay(int x);
	Splay();
	void push_up();
	void push_down();
}*null = new Splay(),*root = null,*Z,*tmp;
int Y;
Splay :: Splay ()
{
	num = max_num = Minm;
	size = 0;
	fa = ls = rs = this;
	ms.init(Minm,0);
}
Splay :: Splay (int x)
{
	num = max_num = x;
	size = 1;
	ls = rs = fa = null;
	ms.init(x,1);
	lazy_c = Inv,lazy_r = 0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	max_num = max(max(ls->max_num,rs->max_num),num);
	ms.init(num,1);
	ms.uni(ls->ms,ms);
	ms.uni(ms,rs->ms);
}
void Splay :: push_down()
{
	if(this==null)return ;
	else
	{
		if(lazy_c!=Inv)
		{
			ls->lazy_c = rs->lazy_c = lazy_c;
			ls->num = ls->max_num = lazy_c;
			rs->num = rs->max_num = lazy_c;
			ls->ms.init(lazy_c,ls->size);
			rs->ms.init(lazy_c,rs->size);
			lazy_c = Inv;
		}
		if(lazy_r!=0)
		{
			ls->lazy_r^=1;
			rs->lazy_r^=1;
			swap(ls->ls,ls->rs);
			swap(rs->ls,rs->rs);
			swap(ls->ms.l_max,ls->ms.r_max);
			swap(rs->ms.l_max,rs->ms.r_max);
			lazy_r = 0;
		}
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x)
{
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==Z)break;
		if(z==Z)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(x);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(x);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x)
{
	while(true)
	{
		x->push_down();
		if(Y<=x->ls->size)x = x->ls;
		else
		{
			Y-=x->ls->size;
			if(Y==1)break;
			Y--;
			x = x->rs;
		}
	}
	splay(x);
}
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		Z = null;
		splay(x);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
void Free(Splay *x)
{
	if(x==null)return ;
	Free(x->ls);
	Free(x->rs);
	free(x);
}
void INSERT()
{
	int tot,pos;
	scanf("%d%d",&pos,&tot);
	Y = pos+1;Z = null;Find(root);
	Y = pos+2;Z = root;Find(root);
	tmp = root;root = null;
	int x;
	for(int i = 1;i<= tot;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	tmp->rs->ls = root;
	root->fa = tmp->rs;
	root = tmp;
	root->rs->push_up();
	root->push_up();
}
void DELETE()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	tmp = root->rs->ls;
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
	Free(tmp);
}
void update()
{
	int pos,tot,c;
	scanf("%d%d%d",&pos,&tot,&c);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	root->rs->ls->lazy_c = c;
	tmp = root->rs->ls;
	tmp->num = tmp->max_num = c;
	tmp->ms.init(c,tmp->size);
	root->rs->push_up();
	root->push_up();
}
void reverse()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	tmp = root->rs->ls;
	tmp->lazy_r ^=1;
	swap(tmp->ls,tmp->rs);
	swap(tmp->ms.l_max,tmp->ms.r_max);
}
void get_sum()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	printf("%d\n",root->rs->ls->ms.sum);
}
void get_max()
{
	Y = 1;Z = null;Find(root);
	Y = root->size;Z = root;Find(root);
	printf("%d\n",root->rs->ls->ms.all_max);
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	Insert(root,0,null);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	char opt[20];
	Insert(root,0,null);
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='G')get_sum();
		else if(opt[0]=='I')INSERT();
		else if(opt[0]=='D')DELETE();
		else if(opt[0]=='R')reverse();
		else
		{
			if(opt[2]=='K')update();
			else get_max();
		}
	}
	return 0;
}
/*
那时候，日子也正长
过了今天，还有明天，过了今年，还有明年。
过了春还有夏，过了秋还有冬。
过了冬又能望见来年春到,依旧桃花满梢油菜黄。
*/
Problem1500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define maxn 1001000
#define inf 2147483646
using namespace std;
int c[maxn][2],fa[maxn];
int a[maxn],key[maxn],sum[maxn],la[maxn],ra[maxn],ma[maxn],cov[maxn],size[maxn];
int q[maxn];
bool rev[maxn];
int n,m,tot,num,rot,st,ed,tail;

void update(int x)
{
        if (!x) return;
        la[x]=max(la[c[x][0]],sum[c[x][0]]+key[x]+max(0,la[c[x][1]]));
        ra[x]=max(ra[c[x][1]],sum[c[x][1]]+key[x]+max(0,ra[c[x][0]]));
        ma[x]=max(max(ma[c[x][0]],ma[c[x][1]]),key[x]+max(0,ra[c[x][0]])+max(0,la[c[x][1]]));
        sum[x]=sum[c[x][0]]+sum[c[x][1]]+key[x];
        size[x]=size[c[x][0]]+size[c[x][1]]+1;
}

void reverse(int x)
{
        if (!x) return;
        swap(c[x][0],c[x][1]);
        swap(la[x],ra[x]);
        rev[x]^=1;
}

void recover(int x,int z)
{
        if (!x) return ;
        key[x]=cov[x]=z;
        sum[x]=size[x]*z;
        la[x]=ra[x]=ma[x]=max(z,sum[x]);
}

void down(int x)
{
        if (!x) return;
        if (rev[x])
        {
                reverse(c[x][0]);
                reverse(c[x][1]);
                rev[x]=0;
        }
        if (cov[x]!=-inf)
        {
                recover(c[x][0],cov[x]);
                recover(c[x][1],cov[x]);
                cov[x]=-inf;
        }
}

void relax(int x,int rot)
{
        if (x!=rot) relax(fa[x],rot);
        down(x);
}

void rotate(int x,int &rot)
{
        int y=fa[x],z=fa[y];
        int p=(c[y][1]==x),q=p^1;
        if (y==rot) rot=x; 
        else if (c[z][0]==y) c[z][0]=x; else c[z][1]=x;
        fa[x]=z; fa[y]=x; fa[c[x][q]]=y;
        c[y][p]=c[x][q]; c[x][q]=y;
        update(y);
}

void splay(int x,int &rot)
{
        relax(x,rot);
        while (x!=rot)
        {
                int y=fa[x], z=fa[y];
                if (y!=rot)
                        if ((c[y][0]==x)xor(c[z][0]==y)) rotate(x,rot); 
                    else rotate(y,rot);
                rotate(x,rot);
        }
        update(x);
}

int pick()
{
        if (tail) return q[tail--];
        else return ++num;
}

int setup(int x)
{
        int t=pick();
        key[t]=a[x];
        cov[t]=-inf;
        rev[t]=0;
        la[t]=ra[t]=ma[t]=-inf;
        return t;
}

int build(int l,int r)
{
        int mid=(l+r)>>1,left=0,right=0;
        if (l<mid)      left=build(l,mid-1);
        int t=setup(mid);
        if (r>mid)      right=build(mid+1,r);
        if (left)       c[t][0]=left,fa[left]=t;
        if (right)c[t][1]=right,fa[right]=t;
        update(t);
        return t;
}

int find(int t,int k)
{
        down(t);
        if (k==size[c[t][0]]+1) return t;
        if (k<size[c[t][0]]+1) return find(c[t][0],k);
        if (k>size[c[t][0]]+1) return find(c[t][1],k-size[c[t][0]]-1);
}

void del(int &x)
{
        if (!x) return;
        q[++tail]=x;
        fa[x]=0;
        del(c[x][0]);
        del(c[x][1]);
        la[x]=ra[x]=ma[x]=-inf;
        x=0;
}

int main()
{
        scanf("%d %d",&n,&m);
        for (int i=2;i<=n+1;i++)
        {
                scanf("%d",&a[i]);      
        }
        a[st=1]=0; a[ed=n+2]=0;
        ra[0]=la[0]=ma[0]=-inf;
        rot=build(1,n+2);
        char sign[20];
        int x,y,l,r,z,ans;
        for (int i=1;i<=m;i++)
        {
                scanf("%s",&sign);
                if (sign[0]=='I')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x+1); r=find(rot,x+2);
                        splay(r,rot); splay(l,c[rot][0]);
                        for (int j=1;j<=y;j++) 
                                scanf("%d",&a[j]);
                        int tmp=build(1,y);
                        fa[tmp]=l; c[l][1]=tmp;                 
                        update(l); update(r);
                }
                if (sign[0]=='D')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x);  r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        del(c[l][1]);
                        update(l); update(r);
                }                       
                if (sign[0]=='M'&&sign[2]=='K')
                {
                        scanf("%d %d %d",&x,&y,&z);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        recover(c[l][1],z);
                }
                if (sign[0]=='R')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        reverse(c[l][1]);
                }
                if (sign[0]=='G')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        ans=sum[c[l][1]];
                        printf("%d\n",ans);
                }
                if (sign[0]=='M'&&sign[2]=='X')
                {
                        splay(ed,rot); splay(st,c[rot][0]);
                        ans=ma[c[st][1]];
                        printf("%d\n",ans);
                }
        }
        return 0;
}
Problem1503

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Treap
{
	Treap *ls,*rs;
	int val,size,cnt,key;
	Treap(){}
	Treap(int x)
	{
		ls = rs = NULL;
		val = x;
		size = cnt = 1;
		key = rand();
	}
	void push_up()
	{
		size = cnt;
		if(ls)size+=ls->size;
		if(rs)size+=rs->size;
	}
}*root = NULL;
int DEC = 0,PER = 0,go_away;
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs= y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x= y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&now,int x)
{
	if(!now) {now = new Treap(x);return ;}
	if(now->val==x)now->cnt++;
	else if(x<now->val)
	{
		Insert(now->ls,x);
		if(now->ls->key > now->key)
			go_right(now);
	}
	else 
	{
		Insert(now->rs,x);
		if(now->rs->key > now->key)
			go_left(now);
	}
	now->push_up();
}
int Delete(Treap *&now,int x)
{
	int ans = 0;
	if(!now)return 0;
	if(now->val+DEC>=x)
	{
		ans = Delete(now->ls,x);
		now->size-=ans;
	}
	else
	{
		if(now->ls)ans+=now->ls->size;
		ans+= now->cnt;
		now = now->rs;
		ans=ans+Delete(now,x);
	}		
	if(now)now->push_up();
	return ans;
}
int get_rank(Treap *x,int k)
{
	if(x->ls!=NULL&&k<=x->ls->size)return get_rank(x->ls,k);
	if(x->ls!=NULL)k-=x->ls->size;
	if(k<=x->cnt)return x->val;
	k-=x->cnt;
	return get_rank(x->rs,k);
}
int main()
{
	int n,Min,k;
	scanf("%d%d",&n,&Min);
	char ju[3];
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",ju,&k);
		if(ju[0]=='I')
		{
			if(k>=Min)
				Insert(root,k-DEC);
		}else if(ju[0]=='A')DEC+=k;
		else if(ju[0]=='S')
		{
			DEC-=k;
			int tmp = Delete(root,Min);
			go_away+=tmp;
		}
		else 
		{
			if(root==NULL||k>root->size)printf("-1\n");
			else printf("%d\n",get_rank(root,root->size-k+1)+DEC);
		}
	}
	printf("%d\n",go_away);
	return 0;
}
Problem1505

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 101;
const int INF = 1e9;
double g[N][N],f[N][N][N];
int l_k[N][N][N],l_j[N][N][N];
int main()
{
	double k1,k2;
	int n,m;
	scanf("%lf%lf%d%d",&k1,&k2,&m,&n);
	for(int i = 0;i<N;i++)
		for(int j = 0;j<N;j++)
			g[i][j] = INF;
	for(int i = 0;i<N;i++)
		for(int j = 0;j<N;j++)
			for(int k = 0;k<N;k++)
				f[i][j][k] = INF;
	g[0][0] = 0;
	for(int i = 1;i<= 100;i++)
		for(int j = 1;j<= i;j++)
			for(int k = j-1;k<i;k++)
				g[i][j] = min(g[i][j],g[k][j-1]+(double)(i-k)*(i-k)*k2);
	f[0][0][0] = 0;
	for(int k = 1;k<= 100;k++)
		for(int i = 1;i<= m;i++)
			for(int j = 1;j<= n;j++)
				for(int lk = l_k[k][i-1][j];lk<k;lk++)
					for(int lj = l_j[k][i-1][j];lj<j;lj++)
						if(f[lk][i-1][lj]+(k-lk)*(k-lk)*k1+g[k-lk][j-lj]<f[k][i][j])
						{
							f[k][i][j] = f[lk][i-1][lj]+(double)(k-lk)*(k-lk)*k1+g[k-lk][j-lj];
							l_k[k][i][j] = lk;
							l_j[k][i][j] = lj;
						}
	printf("%.1f\n",f[100][m][n]);
	return 0;
}
Problem1507

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Splay
{
	Splay *ls,*rs,*fa;
	char c;
	int size;
	Splay(char S);
	void push_up();
}*null =new Splay(0),*root = null;
Splay :: Splay (char S)
{
	ls = rs = fa = null;
	c = S;
	size = c?1:0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
char s[1<<21];
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = new Splay(s[mid]);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)
		x->ls->fa = x;
	if(x->rs!=null)
		x->rs->fa = x;
	x->push_up();
}
int now;
void print(Splay *x)
{
	if(x==null)return ;
	print(x->ls);
	putchar(x->c);
	print(x->rs);
}
int main()
{
	int m,x;
	char opt[105];
	scanf("%d",&m);
	root = new Splay('\n');
	root->rs = new Splay('\n');
	root->rs->fa = root;
	root->push_up();
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d",&x);
			for(int j= 0;j<x;j++)
			{
				do s[j] = getchar();while(s[j]<32||s[j]>126);
			}
			Find(root,now+1,null);
			Find(root,now+2,root);
			build(root->rs->ls,0,x-1);
			root->rs->ls->fa = root->rs;
			root->rs->push_up();
			root->push_up();
		}
		else if(opt[0]=='D')
		{
			scanf("%d",&x);
			Find(root,now+1,null);
			Find(root,min(now+2+x,root->size),root);
			root->rs->ls = null;
			root->rs->push_up();
			root->push_up();
		}
		else if(opt[0]=='G')
		{
			scanf("%d",&x);
			Find(root,now+1,null);
			Find(root,min(now+2+x,root->size),root);
			print(root->rs->ls);
			puts("");
		}
		else if(opt[0]=='M')
			scanf("%d",&now);
		else if(opt[0]=='P')
			now--;
		else now++;
	}
	return 0;
}
Problem1512

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+100;
const int M = 1e6+100;
const int INF = 36500;
struct E
{int next,to;};
bool v[N],ins[N],tag[N];
int stack[N],dep[N],low[N],dfn,bel[N],scc,top;
int ind[N],f[N];
queue<int>Q;
struct G
{
	int head[N],tot;
	E e[N];
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}	
	void tarjan(int x)
	{
		v[x] = ins[x] = true;
		stack[++top] = x;
		dep[x] = low[x] = ++dfn;
		for(int i = head[x];i;i = e[i].next)
		{
			if(!v[e[i].to])
				{tarjan(e[i].to);low[x] = min(low[x],low[e[i].to]);}
			else if(ins[e[i].to])
				{low[x] = min(low[x],dep[e[i].to]);}
		}
		if(dep[x]==low[x])
		{
			scc++;
			int tmp = -1;
			do
			{
				tmp = stack[top--];
				ins[tmp] = false;
				bel[tmp] = scc;
			}while(tmp!=x);
		}
	}
	void topo(int n)
	{
		f[bel[n+1]] = 1;
		if(tag[bel[n+1]])f[bel[n+1]]+=INF;
		for(int i = 1;i<= scc;i++)
			if(ind[i]==0)
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i = e[i].next)
			{
				f[e[i].to]+=f[x];
				if(f[e[i].to]>INF)f[e[i].to]=INF+1;
				if(!--ind[e[i].to])
				{
					if(tag[e[i].to]&&f[e[i].to]>0)f[e[i].to] = INF+1;
					Q.push(e[i].to);
				}
			}
		}
	}
}g1,g2;
void rebuild(int n)
{
	for(int i = 1;i<= n+1;i++)
	{
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			int u = i,t = g1.e[j].to;
			if(bel[u]==bel[t]){tag[bel[u]] = true;continue;}
			g2.add(bel[u],bel[t]);
			ind[bel[t]]++;
		}
	}
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		g1.add(y,x);
	}
	for(int i = 1;i<= n+1;i++)
		if(!v[i])
			g1.tarjan(i);
	rebuild(n);
	g2.topo(n);
	int maxn = 0;
	for(int i = 1;i<= n;i++)
		if(f[bel[i]]>maxn)
			maxn = f[bel[i]];
	if(maxn>36500)printf("zawsze\n");
	else printf("%d\n",maxn);
	top = 0;
	for(int i = 1;i<= n;i++)
		if(f[bel[i]]==maxn)
			stack[++top] = i;
	printf("%d\n",top);
	for(int i = 1;i<= top;i++)
		printf("%d ",stack[i]);
	printf("\n");
	return 0;
}
Problem1513

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e3+5;
int S,D,lx,rx,sy,xy;
struct X_seg
{
	int val[N],lazy[N];
	void update(int p,int l,int r,int a,int b,int k)
	{
		val[p] = max(val[p],k);
		if(l>=a&&r<=b){lazy[p] = max(lazy[p],k);return ;}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,k);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,k);
	}
	int getans(int p,int l,int r,int a,int b)
	{
		if(l>=a&&r<=b)return val[p];
		int mid = (l+r)>>1;
		int ans = lazy[p];
		if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
		if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
		return ans;
	}
};
struct Y_seg
{
	X_seg val[N],lazy[N];
	void update(int p,int l,int r,int a,int b,int y)
	{
		val[p].update(1,1,S,xy,sy,y);
		if(l>=a&&r<=b){lazy[p].update(1,1,S,xy,sy,y);return ;}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,y);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,y);
	}
	int getans(int p,int l,int r,int a,int b)
	{
		if(l>=a&&r<=b)return val[p].getans(1,1,S,xy,sy);
		int mid = (l+r)>>1;
		int ans = lazy[p].getans(1,1,S,xy,sy);
		if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
		if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
		return ans;
	}
}M;
int main()
{
	int n,d,s,x,y,t;
	scanf("%d%d%d",&D,&S,&n);
	for(int i =1;i<= n;i++)
	{
		scanf("%d%d%d%d%d",&d,&s,&t,&x,&y);
		lx = x+1,rx = x+d,xy = y+1,sy = y+s;
		int ans = M.getans(1,1,D,lx,rx);
		M.update(1,1,D,lx,rx,ans+t);
	}
	xy = 1,sy = S;
	printf("%d\n",M.getans(1,1,D,1,D));
	return 0;
}
Problem1529

#include <stdio.h> 
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int main()
{
	int n,x;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)fa[i] = i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		uni(x,i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i)
			ans++;
	printf("%d\n",ans);
	return 0;
}
Problem1537

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct P
{int x,y,p;}pos[N];
int id[N],n,m,k,f[N];
bool cmp(P a,P b)
{
	if(a.y!=b.y)
		return a.y<b.y;
	return a.x<b.x;
}
struct Tree
{
	int c[N];
	Tree()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			c[i] = max(c[i],y);
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans = max(ans,c[i]);
		return ans;
	}
}C;
int find(int x)
{
	int l = 1,r = k+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l= mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%d",&pos[i].x,&pos[i].y,&pos[i].p);
		id[i] = pos[i].x;
	}
	sort(id+1,id+k+1);
	sort(pos+1,pos+k+1,cmp);
	int ans = 0;
	for(int i = 1;i<= k;i++)
	{
		f[i] = C.getans(find(pos[i].x))+pos[i].p;
		ans = max(ans,f[i]);
		C.update(find(pos[i].x),f[i]);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1552

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#define pa pair<int,int>
#define inf 1000000000
#define ll long long 
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,root,top;
int ans[100005],s[100005];
int fa[100005],c[100005][2];
int v[100005],mn[100005],size[100005],pos[100005];
bool rev[100005];
struct data{int pos,v;}a[100005];
inline bool operator<(const data &a,const data &b)
{return a.pos<b.pos;}
inline bool cmp(const data &a,const data &b)
{return a.v<b.v||(a.v==b.v&&a.pos<b.pos);}
void update(int x)
{
	int l=c[x][0],r=c[x][1];
	mn[x]=v[x];pos[x]=x;
	if(mn[l]<mn[x]){mn[x]=mn[l];pos[x]=pos[l];}
	if(mn[r]<mn[x]){mn[x]=mn[r];pos[x]=pos[r];}
	size[x]=size[l]+size[r]+1;
}
void pushdown(int x)
{
    int l=c[x][0],r=c[x][1];
	rev[x]^=1;rev[l]^=1;rev[r]^=1;
	swap(c[x][0],c[x][1]);
}
void rotate(int x,int &k)
{
    int y=fa[x],z=fa[y],l,r;
    if(c[y][0]==x)l=0;else l=1;r=l^1;
    if(y==k)k=x;
    else {if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
    fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
    c[y][l]=c[x][r];c[x][r]=y;
    update(y);update(x);
}
void splay(int x,int &k)
{
	top=0;s[++top]=x;
    for(int i=x;fa[i];i=fa[i])
        s[++top]=fa[i];
    for(int i=top;i;i--)
        if(rev[s[i]])pushdown(s[i]);
    while(x!=k)
    {
        int y=fa[x],z=fa[y];
        if(y!=k)
        {    
            if(c[y][0]==x^c[z][0]==y)
                rotate(x,k);
            else rotate(y,k);
        }
        rotate(x,k);
    }
}
int find(int x,int rk)
{
	if(rev[x])pushdown(x);
	int l=c[x][0],r=c[x][1];
	if(size[l]+1==rk)return x;
	else if(size[l]>=rk)return find(l,rk);
	else return find(r,rk-size[l]-1);
}
int querymn(int L,int R)
{
	int x=find(root,L),y=find(root,R+2);
	splay(x,root);splay(y,c[x][1]);
	int z=c[y][0];
	return pos[z];
}
void rever(int L,int R)
{
	int x=find(root,L),y=find(root,R+2);
	splay(x,root);splay(y,c[x][1]);
	int z=c[y][0];
	rev[z]^=1;
}
void build(int l,int r,int f)
{
	if(l>r)return;
	if(l==r)
	{
		fa[l]=f;size[l]=1;
		mn[l]=v[l]=a[l].v;pos[l]=l;
		if(l<f)c[f][0]=l;
		else c[f][1]=l;
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid-1,mid);build(mid+1,r,mid);
	fa[mid]=f;v[mid]=a[mid].v;update(mid);
	if(mid<f)c[f][0]=mid;
	else c[f][1]=mid;
}
int main()
{
    n=read();
    a[1].v=a[n+2].v=inf;mn[0]=inf;
	for(int i=2;i<=n+1;i++)
	{
		scanf("%d",&a[i].v);
		a[i].pos=i;
	}
	sort(a+2,a+n+2,cmp);
	for(int i=2;i<=n+1;i++)a[i].v=i-1;
	sort(a+2,a+n+2);
	build(1,n+2,0);
	root=(n+3)>>1;
	for(int i=1;i<=n;i++)
	{
		int x=querymn(i,n);
		splay(x,root);
		ans[i]=size[c[x][0]];
		rever(i,ans[i]);
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d",ans[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem1565

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1,ind[N],d[N],f[N];
int ans,m,n,st,end;
bool Can[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
	ind[x]++;
}
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i].flow&&d[e[i].to]==-1&&Can[e[i].to])
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int dinic(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow&&last)
		{
			int tof = dinic(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}else d[e[i].to]=-1;
		}
	d[s] = -1;
	return mf-last;
}
int get_maxflow(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=dinic(s,t,INF);
	return ans;
}
void topo()
{
	for(int i = st;i<=end;i++)
		if(!ind[i])
			Q.push(i);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		if(f[x]>0)ans+=f[x];
		Can[x] = true;
		for(int i=head[x];i;i=e[i].next)
			if(i&1)
				if(!--ind[e[i].to])
					Q.push(e[i].to);
	}
}
void debug()
{
	for(int i = st;i<= end;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].flow);
		printf("\n");
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	st = 0,end = n*m+1;
	for(int i = 1;i<end;i++)
	{
		scanf("%d",&f[i]);
		if(f[i]>0)add(st,i,f[i]);
		else add(i,end,-f[i]);
		int k,r,c;
		scanf("%d",&k);
		while(k--)
		{
			scanf("%d%d",&r,&c);
			add(r*m+c+1,i,INF);
		}
		if(i%m)
			add(i,i+1,INF);
	}
	topo();
	ans-=get_maxflow(st,end);
	printf("%d\n",ans);
	return 0;
}
Problem1570

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5010;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1,n,m,T;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(s);
	d[s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
vector<int>to[N],val[N];
int main()
{
	scanf("%d%d%d",&n,&m,&T);
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		to[x].push_back(y);
		val[x].push_back(z);
	}
	int st=0,ed=N-1,ans =0;
	add(st,1,T);
	for(int day = 1;;day++)
	{
		for(int i = 1;i<= n;i++)
			for(int j = 0;j<to[i].size();j++)
				add(n*(day-1)+i,n*day+to[i][j],val[i][j]);
		for(int i = 1;i<= n;i++)
			add(n*(day-1)+i,n*day+i,INF);
		add(n*day+n,ed,INF);
		if((ans+=dinic(st,ed))==T)
		{
			printf("%d\n",day);
			return 0;
		}
	}
	return 0;
}
Problem1579

#include <queue>
#include <stack>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <limits.h>
#include <string.h>
#include <string>
#include <algorithm>

using namespace std;

const int MAX = 10010;
struct NODE{int to,len;NODE *next;};
NODE *p[MAX],node[MAX*10];
int cou;
int dis[25][MAX],L;
void init()
{
	cou = 0;
	memset(node,'\0',sizeof(node));
	memset(p,'\0',sizeof(p));
}
void Add(int x,int y,int w)
{
	node[cou].len = w;
	node[cou].to = y;
	node[cou].next = p[x];
	p[x] = &node[cou++];
}
struct cmp{
	bool operator()(int a,int b)
	{
		return dis[L][a] > dis[L][b];
	}
};
void Dijkstra(int s,int n,int *dis)
{
	bool used[MAX];
	memset(used,0,sizeof(used));
	used[s] = true;
	dis[s] = 0; int now = s;
	for(int i=0; i<n-1; i++)
	{
		NODE *head = p[now];
		while( head )
		{
			if( dis[head->to] > dis[now] + head->len )
				dis[head->to] = dis[now] + head->len;
			head = head->next;
		}
		int mmin = INT_MAX;
		for(int k=1; k<=n; k++)
			if( !used[k] && mmin > dis[k] )
				mmin = dis[now = k];
		used[now] = true;
	}
}
void Dijkstra1(int s,int n,int l)
{
	priority_queue<int,vector<int>,cmp> q;
	bool used[MAX];
	memset(used,0,sizeof(used));
	used[s] = true;
	int now = s;
	dis[l][s] = 0;
	q.push(s);
	while( !q.empty() )
	{
		int now = q.top(); used[now] = true;
		NODE *head = p[now]; q.pop();
		while( head )
		{
			if( dis[l][head->to] > min( dis[l-1][now],dis[l][now] + head->len ) )
			{
				dis[l][head->to] = min( dis[l-1][now],dis[l][now] + head->len );
				q.push(head->to);
			}
			head = head->next;
		}
	}
}

int main()
{
	int n,m,K,x,y,w;
	
	while( ~scanf("%d%d%d",&n,&m,&K) )
	{
		while( m-- )
		{
			scanf("%d%d%d",&x,&y,&w);
			Add(x,y,w); Add(y,x,w);
		}
		for(int k=0; k<=K; k++)
			for(int i=1; i<=n; i++)
				dis[k][i] = 500000000;
		Dijkstra(1,n,dis[0]);
		
		for(L=1; L<=K; L++)
			Dijkstra1(1,n,L);
		printf("%d\n",dis[K][n]);
	}

return 0;
}
Problem1588

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
struct Treap{
	Treap *ls,*rs;
	int key,val,cnt,size;
	Treap(int x)
	{
		ls = rs = NULL;
		key = rand();
		cnt = size = 1;
		val = x;
	}
	void push_up()
	{
		size = cnt;
		if(ls)size+=ls->size;
		if(rs)size+=rs->size;
	}
}*root = NULL;
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y>x->val)
	{
		Insert(x->rs,y);
		if(x->rs->key > x->key)
			go_left(x);
	}
	else
	{
		Insert(x->ls,y);
		if(x->ls->key > x->key)
			go_right(x);
	}
	x->push_up();
}
int get_pre(Treap *x,int y)
{
	if(!x)return -0x3f3f3f3f;
	if(x->val>y)return get_pre(x->ls,y);
	else return max(x->val,get_pre(x->rs,y));
}
int get_suc(Treap *x,int y)
{
	if(!x)return 0x3f3f3f3f;
	if(x->val<y)return get_suc(x->rs,y);
	else return min(x->val,get_suc(x->ls,y));
}
int main()
{
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(i==1){ans+=x;Insert(root,x);}
		else
		{
			int tmp = get_pre(root,x),minn = INF;
			if(tmp!=-INF) minn = x-tmp;
			tmp = get_suc(root,x);
			if(tmp!=INF)minn = min(minn,tmp-x);
			ans+=minn;
			Insert(root,x);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1597

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 50005;
struct LAND{int wid,lth;}ld[N];
int line[N],L,R;
int l[N],w[N];
LL f[N];
bool cmp(LAND a,LAND b)
{
    if(a.lth!=b.lth)return a.lth>b.lth;
    return a.wid<b.wid;
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
        scanf("%d%d",&ld[i].wid,&ld[i].lth);
    sort(ld+1,ld+n+1,cmp);
    int cnt = 0;
    for(int i = 1;i<= n;i++)
    {
        if(cnt==0||ld[i].wid>w[cnt])
        {
            cnt++;
            w[cnt] = ld[i].wid;
            l[cnt] = ld[i].lth;
        }
    }
    int L = 1,R = 1;line[L] =0;
    for(int i = 1;i<= cnt;i++)
    {
        while(L<R&&(LL)(l[line[L+1]+1]-l[line[L]+1])*w[i]<f[line[L]]-f[line[L+1]])
            L++;
        f[i] = f[line[L]]+(LL)l[line[L]+1]*w[i];
        while(L<R&&(LL)(l[line[R]+1]-l[i+1])*(f[line[R]]-f[line[R-1]])>(LL)(l[line[R-1]+1]-l[line[R]+1])*(f[i]-f[line[R]]))
            R--;
        line[++R] = i;
    }
    printf("%lld\n",f[cnt]);
    return 0;
}
Problem1645

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 40005;
typedef long long LL;
struct L
{int pos,h,f;}line[N<<1];
int cnt,id[N],x[N],y[N],v[N],tp[N];
bool cmp(L a,L b)
{
	return a.pos<b.pos;
}
bool cmi(int a,int b)
{
	return v[a]<v[b];
}
int sum[N<<2],lazy[N<<2];
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	int mid = (l+r)>>1;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	sum[p<<1]+=lazy[p]*(mid-l+1);
	sum[p<<1|1]+=lazy[p]*(r-mid);
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sum[p]+=(r-l+1)*c;
		lazy[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int getans(int p,int l,int r)
{
	push_down(p,l,r);
	if(l==r)
	{
		if(sum[p])return l;
		else return l-1;
	}
	int mid = (l+r)>>1;
	if(!sum[p<<1|1])return getans(p<<1,l,mid);
	else return getans(p<<1|1,mid+1,r);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&v[i]);
		id[i] = i;
	}
	sort(id+1,id+n+1,cmi);
	for(int i = 1;i<= n;i++)
		tp[id[i]] = i;
	for(int i = 1;i<= n;i++)
	{
		line[++cnt].pos = x[i];line[cnt].h = tp[i];line[cnt].f = 1;
		line[++cnt].pos = y[i],line[cnt].h = tp[i];line[cnt].f =-1;
	}
	sort(line+1,line+cnt+1,cmp);
	int last = 0;
	LL ans = 0;
	for(int i = 1;i<= cnt;i++)
	{
		ans+=(LL)v[id[last]]*(line[i].pos-line[i-1].pos);
		update(1,1,n,1,line[i].h,line[i].f);
		last = getans(1,1,n);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem1672

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int Mn = 86399+5;
const int N = 1e4+5;
const LL INF = 1e18;
struct C
{int s,t,c;}cl[N];
bool cmp(C a,C b)
{
	return a.s<b.s;
}
LL f[Mn],t[Mn<<2];
void build(int p,int l,int r)
{
	t[p] = INF;
	if(l==r)
	{
		f[l] = INF;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
}
void push_down(int p,int l,int r)
{
	if(t[p]==INF)return ;
	if(l==r){f[l] = min(f[l],t[p]);t[p] = INF;return ;}
	t[p<<1] = min(t[p],t[p<<1]);
	t[p<<1|1] = min(t[p],t[p<<1|1]);
	t[p] = INF;
}
void update(int p,int l,int r,int a,int b,LL c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		t[p] = min(t[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	return ;
}
LL getans(int p,int l,int r,int x)
{
	push_down(p,l,r);
	if(x<=0)return 0;
	if(l==r)return f[l];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int main()
{
	int n,m,e;
	scanf("%d%d%d",&n,&m,&e);
	m++,e++;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&cl[i].s,&cl[i].t,&cl[i].c);
		cl[i].s++;cl[i].t++;
	}
	sort(cl+1,cl+n+1,cmp);
	build(1,1,e);
	update(1,1,e,1,m,0);
	for(int i = 1;i<= n;i++)
	{
		int s = cl[i].s,t = cl[i].t,v = cl[i].c;
		LL tmp = getans(1,1,e,s-1);
		if(tmp>=INF){printf("-1\n");return 0;}
		update(1,1,e,s,t,tmp+v);
	}
	printf("%lld\n",getans(1,1,e,e));
	return 0;
}
Problem1688

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 1<<16;
int cow[N];
int sta[M],cnt;
void init(int k)
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i,c = 0;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			c++;
		} 
		if(c==k)
			sta[++cnt] = i;
	}
	return ;
}
int main()
{
	int n,d,k;
	scanf("%d%d%d",&n,&d,&k);
	init(k);
	for(int i = 1;i<= n;i++)
	{
		int c,x;
		scanf("%d",&c);
		for(int j = 1;j<= c;j++)
		{
			scanf("%d",&x);
			cow[i]|=(1<<(x-1));
		}
	}
	int t_ans = 0;
	for(int i= 1;i<= cnt;i++)
	{
		int ans = 0;
		for(int j = 1;j<= n;j++)
		{
			if((cow[j]|sta[i])!=sta[i])continue;
			else ans++;
		}
		t_ans = max(ans,t_ans);
	}
	printf("%d\n",t_ans);
	return 0;
}
Problem1692

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
char s[N];
int cnt[N],q[N],v[N],nv[N],sa[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int lim,int len)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl=1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
int main()
{
	int n;
	char ch;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
	{
		ch = getchar();while(ch<'A'||ch>'Z')ch = getchar();
		s[i]=ch;
	}
	int len = n;
	s[len]='$';
	for(int i = n-1;i>=0;i--)
		s[++len]=s[i];
	len++;
	build_sa(256,len);
	build_rank(len);
	int l = 0,r = n+1;
	for(int i = 0;i<n;i++)
	{
		if(r>=len||rnk[l]<rnk[r])
			{printf("%c",s[l]);l++;}
		else {printf("%c",s[r]);r++;}
		if(i%80==79)printf("\n");
	}
	return 0;
}
Problem1717

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int maxN = 1000001;
int cnt[maxN],q[N],sa[N],h[N],rnk[N],v[N],nv[N];
int s[N],n,k;
bool is_same(int a,int b,int ln,int len)
{
	return (v[a]==v[b])&&((a+ln>len&&b+ln>len)||(a+ln<len&&b+ln<len&&v[a+ln]==v[b+ln]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]] = i;
	for(int d = 1;;d++)
	{
		int ln = 1<<(d-1),id = 0;
		for(i = len-ln;i<len;i++)q[id++]=i;
		for(i = 0;i<len;i++)if(sa[i]>=ln)q[id++]=sa[i]-ln;

		for(i = 0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[v[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],ln,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
bool check(int mid,int len)
{
	int tmp = 0;
	for(int i = 1;i<len;i++)
	{
		if(h[i]>=mid)tmp++;
		else tmp = 0;
		if(tmp>=k-1)return true;
	}
	return false;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 0;i< n;i++)scanf("%d",&s[i]);
	build_sa(n,maxN);
	build_rank(n);
	build_height(n);
	int l = 0,r = n,ans=0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(check(mid,n))l=mid+1,ans=mid;
		else r = mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<12;
const int mod = 100000000;
int f[13][N];
int map[13];
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<m;j++)
		{
			scanf("%d",&x);
			map[i] |= (x^1)<<j;
		}
	f[0][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		for(int last = 0;last< 1<<m;last++)
		{
			if((last&map[i-1])||(last&(last<<1))||(last&(last>>1)))continue;
			for(int now = 0;now<1<<m;now++)
			{
				if((now&map[i])||(now&(now<<1))||(now&(now>>1)))continue;
				if(now&last)continue;
				f[i][now] = (f[i][now]+f[i-1][last])%mod;
			}
		}
	}
	int ans = 0;
	for(int i = 0;i<1<<m;i++)
		ans = (ans+f[n][i])%mod;
	printf("%d\n",ans);
	return 0;
}
Problem1742

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
long long f[N][N][2];
int pos[N],n,s;
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%d",&pos[i]);
	pos[++n] = s;
	sort(pos+1,pos+n+1);
	s = find(s);
	memset(f,0x3f,sizeof(f));
	f[s][1][0] = f[s][1][1] = 0;
	for(int len = 2;len <= n;len++)
	{
		for(int l = 1;l+len-1<= n;l++)
		{
			int r = l+len-1;
			f[l][len][1] = min(f[l][len][1],min(f[l+1][len-1][1]+(n-len+1)*(pos[l+1]-pos[l]),f[l+1][len-1][0]+(n-len+1)*(pos[r]-pos[l])));
			f[l][len][0] = min(f[l][len][0],min(f[l][len-1][0]+(n-len+1)*(pos[r]-pos[r-1]),f[l][len-1][1]+(n-len+1)*(pos[r]-pos[l])));
		}
	}
	printf("%lld\n",min(f[1][n][0],f[1][n][1]));
	return 0;
}
Problem1778

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
const double eps = 1e-9;
double f[N][N],cnt[N],ans[N];
int n,m,x,y;
double p,q;
void swapn(int x,int y)
{
	for(int i = 1;i<= n+1;i++)
		swap(f[x][i],f[y][i]);
	return ;
}
void work()
{
	for(int i = 1;i<= n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swapn(xn,i);
		for(int line = i+1;line<=n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = i;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n;i>= 1;i--)
	{
		for(int j = n;j>i;j--)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%lf%lf",&p,&q);
	double rate = p/q;
	if(rate>1)rate = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		f[x][y]+=1;f[y][x]+=1;
		cnt[x]+=1;cnt[y]+=1;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(fabs(cnt[j])>eps)
				f[i][j]/=cnt[j];
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			f[i][j]*=rate-1;
	for(int i = 1;i<= n;i++)
		f[i][i]+=1;
	f[1][n+1] = rate;
	work();
	for(int i = 1;i<= n;i++)
		printf("%.9f\n",fabs(ans[i]));	
	return 0;
}
Problem1782

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,c[N],w[N],son[N],size[N],cnt,p[N],top[N],end[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void dfs1(int x,int fa)
{
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
void dfs2(int x,int fa,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],x,tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&e[i].to!=son[x])
			dfs2(e[i].to,x,e[i].to);
	end[x] = cnt;
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs1(1,0);
	dfs2(1,0,1);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d",&p[i]);
		printf("%d\n",getans(w[p[i]]));
		update(w[p[i]],1);
		update(end[p[i]]+1,-1);
	}
	return 0;
}
Problem1798

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int M = 100005;
int mod;
int mul_tag[N<<2],add_tag[N<<2];
int sum[N<<2];
void build(int p,int l,int r)
{
	mul_tag[p] = 1,add_tag[p] = 0;
	if(l==r)
	{
		scanf("%d",&sum[p]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = (sum[p<<1]+sum[p<<1|1])%mod;
}
void push_down(int p,int l,int r)
{
	if(l==r||(mul_tag[p]==1&&add_tag[p]==0))return ;
	int mid = (l+r)>>1;
	sum[p<<1] = ((LL)sum[p<<1]*mul_tag[p]%mod+(LL)add_tag[p]*(mid-l+1)%mod)%mod;
	sum[p<<1|1] = ((LL)sum[p<<1|1]*mul_tag[p]%mod+(LL)add_tag[p]*(r-mid)%mod)%mod;
	mul_tag[p<<1] = (LL)mul_tag[p<<1]*mul_tag[p]%mod;
	mul_tag[p<<1|1] = (LL)mul_tag[p<<1|1]*mul_tag[p]%mod;
	add_tag[p<<1] = ((LL)add_tag[p<<1]*mul_tag[p]+add_tag[p])%mod;
	add_tag[p<<1|1] = ((LL)add_tag[p<<1|1]*mul_tag[p]+add_tag[p])%mod;
	mul_tag[p] = 1;
	add_tag[p] = 0;	
}
void update(int p,int l,int r,int a,int b,int c,int opt)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		if(opt)
			{add_tag[p]+=c;sum[p] = (sum[p]+(LL)c*(r-l+1)%mod)%mod;}
		else
		{
			add_tag[p] = (LL)add_tag[p]*c%mod;
			mul_tag[p] = (LL)mul_tag[p]*c%mod;
			sum[p] = (LL)sum[p]*c%mod;
		}
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c,opt);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c,opt);
	sum[p] = (sum[p<<1]+sum[p<<1|1])%mod;
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans = (ans+getans(p<<1,l,mid,a,b))%mod;
	if(b>mid)ans = (ans+getans(p<<1|1,mid+1,r,a,b))%mod;
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&mod);
	build(1,1,n);
	int opt,l,r,c;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt<=2)
		{
			opt--;
			scanf("%d%d%d",&l,&r,&c);
			update(1,1,n,l,r,c,opt);
		}else
		{
			scanf("%d%d",&l,&r);
			printf("%d\n",getans(1,1,n,l,r));
		}
	}
	return 0;
}
Problem1806

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,ans,f[2][4][4][4][4];
inline int Get_Char()
{
	char c;
	do c=getchar(); while(c!='M'&&c!='F'&&c!='B');
	switch(c)
	{
		case 'M':return 1;
		case 'F':return 2;
		case 'B':return 3;
	}
}
inline int Score(int x,int y)
{
	if(x==0) return 1;
	return x==y?1:2;
}
inline int Score(int x,int y,int z)
{
	int temp=x*y*z;
	switch(temp)
	{
		case 6:return 3;
		case 1:
		case 8:
		case 27:return 1;
		case 0:return Score(y,z);
		default: return 2;
	}
}
int main()
{
	scanf("%d",&n);
	memset(f,0xef,sizeof f);
	f[0][0][0][0][0]=0;
	for(int i=1;i<=n;i++)
	{
		int temp=Get_Char();
		memset(f[i&1],0xef,sizeof(f[i&1]));
		for(int a1=0;a1<=3;a1++)
			for(int a2=(a1?1:0);a2<=3;a2++)
				for(int b1=0;b1<=3;b1++)
					for(int b2=(b1?1:0);b2<=3;b2++)
						if(f[~i&1][a1][a2][b1][b2]>=0)
						{
							f[i&1][a2][temp][b1][b2]=max(f[i&1][a2][temp][b1][b2]
														,f[~i&1][a1][a2][b1][b2]+Score(a1,a2,temp));
							f[i&1][a1][a2][b2][temp]=max(f[i&1][a1][a2][b2][temp]
														,f[~i&1][a1][a2][b1][b2]+Score(b1,b2,temp));
						}
	}
	for(int a1=0;a1<=3;a1++)
		for(int a2=(a1?1:0);a2<=3;a2++)
			for(int b1=0;b1<=3;b1++)
				for(int b2=(b1?1:0);b2<=3;b2++)
					ans=max(ans,f[n&1][a1][a2][b1][b2]);
	printf("%d\n",ans);
	return 0;
}
Problem1816

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 60
#define inf 0x3f3f3f3f
using namespace std;
int n,m,a[N],ans;
bool check(int mid)
{
    int remain=min(m,mid);
    for(int i=1;i<=n;i++)
    {
        if(a[i]>=mid)continue;
        remain-=mid-a[i];
        if(remain<0)return 0;
    }
    return 1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    int l=0,r=inf,mid,ans;
    while(l<=r)
    {
        if(r-l<=3)
        {
            ans=0;
            for(int i=l;i<=r;i++)
                if(check(i))ans=i;
            printf("%d\n",ans);
            return 0;
        }
        mid=(l+r)>>1;
        if(check(mid))l=mid;
        else r=mid-1;
    }
    printf("%d\n",ans);
    return 0;
}
Problem1821

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
using namespace std;
struct E	
{
	int x,y;
	double val;
	bool operator < (const E &s) const
	{
		return val < s.val;
	}
}edge[2000005];
int tot,fa[1005];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])
		return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int x[1005],y[1005];
int main()
{
	//freopen("group.in","r",stdin);
	//freopen("group.out","w",stdout);
	int n,k;
	scanf("%d%d",&n,&k);
	int cnt = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	for(int i = 1;i<= n;i++)
	{
		for(int j = i+1;j<= n;j++)
		{
			edge[++tot].x = i;
			edge[tot].y = j;
			edge[tot].val = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
			edge[++tot].x = j;
			edge[tot].y = i;
			edge[tot].val = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
		}
	}
	double ans = 0;
	std::sort(edge+1,edge+tot+1);
	for(int i = 1;i<= tot;i++)
	{
		int fx = getfa(edge[i].x);
		int fy = getfa(edge[i].y);
		if(fx==fy)continue;
		if(cnt>=n-k)
		{
			ans = edge[i].val;
			break;
		}
		cnt++;
		uni(fx,fy);
	}
	printf("%.2lf",ans);
	return 0;
}
Problem1823

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2e4+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool ins[N];
int dfn[N],low[N],stack[N],top,cnt,bel[N],dcc;
void tarjan(int x)
{
	low[x] = dfn[x] = ++cnt;
	stack[++top] = x;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
int getnum(char s[10])
{
	int now = 1;
	int ans = 0;
	while(s[now])
	{
		ans=ans*10+s[now]-'0';
		now++;
	}
	return ans*2;
}
void work()
{
	memset(head,0,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(bel,0,sizeof(bel));
	tot = cnt = dcc = top = 0;
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	char s1[10],s2[10];
	for(int i=1;i<=m;i++)
	{
		scanf("%s%s",s1,s2);
		x = getnum(s1),y = getnum(s2);
		if(s1[0]=='m')x++;
		if(s2[0]=='m')y++;
		add(x^1,y);
		add(y^1,x);
	}
	for(int i = 2;i<= 2*n+1;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i = 1;i<= n;i++)
	{
		if(bel[i<<1]==0||bel[i<<1|1]==0)continue;
		if(bel[i<<1]==bel[i<<1|1])
			{printf("BAD\n");return ;}
	}
	printf("GOOD\n");
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)work();
	return 0;
}
Problem1828

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
int mn[N<<2],lazy[N<<2];
struct Q
{
	int l,r;
}ask[N];
bool cmp(Q a,Q b)
{
	return a.r<b.r;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		scanf("%d",&mn[p]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
}
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	mn[p<<1] = mn[p<<1]+lazy[p];
	mn[p<<1|1] = mn[p<<1|1]+lazy[p];
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		mn[p]--;
		lazy[p]--;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b);
	if(b>mid)update(p<<1|1,mid+1,r,a,b);
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return mn[p];
	int mid = (l+r)>>1;
	int ans = INF;
	if(a<=mid)ans = min(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)ans = min(ans,getans(p<<1|1,mid+1,r,a,b));
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
	return ans;
}
int main()
{
	int n,m,ans = 0;
	scanf("%d%d",&n,&m);
	build(1,1,n);
	for(int i = 1;i<= m;i++)
		scanf("%d%d",&ask[i].l,&ask[i].r);
	sort(ask+1,ask+m+1,cmp);
	for(int i = 1;i<= m;i++)
	{
		if(getans(1,1,n,ask[i].l,ask[i].r)>=1)
		{
			update(1,1,n,ask[i].l,ask[i].r);
			ans++;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1833

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL f[15][10][10];
LL p10[15],ans[10][2];
void solve(LL x,int opt)
{
	if(x==0)return ;
	int num[15] = {};
	int cnt = 0;
	LL tmp = x;
	while(x)
	{
		num[++cnt] = x%10;
		x/=10;
	}
	for(int i = 1;i<=num[cnt]-1;i++)
		for(int j = 0;j<= 9;j++)
			ans[j][opt]+=f[cnt][i][j];
	ans[num[cnt]][opt]+=tmp%p10[cnt-1]+1;
	for(int i = cnt-1;i>=1;i--)
		for(int j = 1;j<= 9;j++)
			for(int k = 0;k<= 9;k++)
				ans[k][opt]+=f[i][j][k];
	for(int i = cnt-1;i>=1;i--)
	{
		for(int j = 0;j<= num[i]-1;j++)
			for(int k = 0;k<= 9;k++)
				ans[k][opt]+=f[i][j][k];
		ans[num[i]][opt]+=tmp%p10[i-1]+1;
	}
	return ;
}
int main()
{
	p10[0] = 1;
	for(int i = 1;i<= 12;i++)p10[i] = p10[i-1]*10;
	LL a,b;
	scanf("%lld%lld",&a,&b);
	for(int i = 0;i<= 9;i++)
		for(int j = 0;j<=9;j++)
			if(i==j)f[1][i][j] = 1;
	for(int i = 2;i<= 12;i++)
		for(int j = 0;j<= 9;j++)
			for(int k = 0;k<= 9;k++)
			{
				for(int l = 0;l<= 9;l++)
					f[i][j][k]+=f[i-1][l][k];
				if(k==j)f[i][j][k]+=p10[i-1];		
			}
	solve(a-1,0);
	solve(b,1);
	for(int i = 0;i< 9;i++)printf("%lld ",ans[i][1]-ans[i][0]);
	printf("%lld\n",ans[9][1]-ans[9][0]);
	return 0;
}
Problem1834

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 5e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int nxt,to,fr,f,c;}e[M];
int head[N],tot=1,from[N];
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].nxt=head[x];head[x]=tot;
	e[tot].f=f,e[tot].c=c,e[tot].fr=x;
	e[++tot].to=x;e[tot].nxt=head[y];head[y]=tot;
	e[tot].f=0,e[tot].c=-c,e[tot].fr=y;
}
bool v[N];
int dis[N],S,T;
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	Q.push(S);
	v[S] = true;dis[S] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].nxt)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans =0,mxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	mxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int a[M],b[M],C[M],W[M];
int main()
{
	//freopen("x.in","r",stdin);
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i= 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a[i],&b[i],&C[i],&W[i]);
		add(a[i],b[i],C[i],0);
	}
	S = 1,T = n;
	while(spfa())mcf();
	printf("%d",mxf);
	add(0,1,k,0);
	S = 0;
	memset(from,0,sizeof(from));
	ans = mxf = 0;
	for(int i = 1;i<= m;i++)
		add(a[i],b[i],INF,W[i]);
	while(spfa())mcf();
	printf(" %d\n",ans);
	return 0;
}
Problem1854

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
int fa[N];
int vis[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		int fx = getfa(x),fy = getfa(y);
		if(fx==fy)
			vis[fx] = true;
		else
		{
			if(fx>fy){vis[fy] = true;fa[fy] = fx;}
			else {vis[fx] = true;fa[fx] = fy;}
		}
	}
	for(int i = 1;i<= N+1;i++)
		if(!vis[i])
			{printf("%d\n",i-1);break;}
	return 0;
}
Problem1855

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int T = 2005;
const int P = 2005;
int asi[T],bsi[T],api[T],bpi[T];
int f[T][P];
int line[P],L,R;
int main()
{
	memset(f,128,sizeof(f));
	int t,maxp,w;
	scanf("%d%d%d",&t,&maxp,&w);
	for(int i = 1;i<= t;i++)
		scanf("%d%d%d%d",&api[i],&bpi[i],&asi[i],&bsi[i]);
	for(int i = 1;i<= t;i++)
	{
		
		for(int j = 0;j <= asi[i];j++)f[i][j] = -api[i]*j;
		for(int j = 0;j <= maxp;j++)
			f[i][j] = max(f[i][j],f[i-1][j]);
		int t = i-w-1;
		if(t>=0)
		{
			L = 1,R = 0;
			for(int j = 0;j<=maxp;j++)
			{
				while(L<=R&&j-line[L]>asi[i])L++;
				int tmp = f[t][j]+j*api[i];
				while(L<=R&&tmp>=f[t][line[R]]+line[R]*api[i])
					R--;
				line[++R]= j;
				if(L<=R)f[i][j] = max(f[i][j],f[t][line[L]]+line[L]*api[i]-j*api[i]);
			}
			L = 1,R = 0;
			for(int j = maxp;j>= 0;j--)
			{
				while(L<=R&&line[L]-j>bsi[i])L++;
				int tmp = f[t][j]+j*bpi[i];
				while(L<=R&&tmp>=f[t][line[R]]+line[R]*bpi[i])
					R--;
				line[++R]= j;
				if(L<=R)f[i][j] = max(f[i][j],f[t][line[L]]+line[L]*bpi[i]-j*bpi[i]);
			}
		}
	}
	int ans = -1e9;
	for(int i = 0;i<= maxp;i++)
		ans = max(ans,f[t][i]);
	printf("%d",ans);
	return 0;
}
Problem1861

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
const int N = 2e5;
struct Splay
{
	Splay *ls,*rs,*fa;
	int size,num;
	Splay (int x);
	void push_up();
}*null = new Splay(0),*root,*tree[N];
int a[N],n,m;
Splay :: Splay (int x)
{
	ls = rs = fa = null;
	size = x?1:0;
	num = x;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)
				go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		if(x->ls->size>=y)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
int get_rank(Splay *x)
{
	int ans = x->ls->size;
	for(;x!=root;x = x->fa)
		if(x==x->fa->rs)
			ans+=x->fa->ls->size+1;
	return ans;
}
void Insert(Splay *x,int y)
{
	Find(root,y,null);
	Find(root,y+1,root);
	root->rs->ls = x;
	x->fa = root->rs;
	root->rs->push_up();
	root->push_up();
}
void Delete(int y)
{
	Find(root,y,null);
	Find(root,y+2,root);
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
}
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = tree[a[mid]];
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa = x;
	if(x->rs!=null)x->rs->fa = x;
	x->push_up();
}
void init()
{
	root = new Splay(Inv);
	root->rs = new Splay(Inv);
	build(root->rs->ls,1,n);
	root->rs->ls->fa = root->rs;
	root->rs->push_up();
	root->rs->fa = root;
	root->push_up();
}
void top()
{
	int pos;
	scanf("%d",&pos);
	int tmp = get_rank(tree[pos]);
	Delete(tmp);
	Insert(tree[pos],1);
}
void bot()
{
	int pos;
	scanf("%d",&pos);
	int tmp = get_rank(tree[pos]);
	Delete(tmp);
	Insert(tree[pos],n);
}
void Change()
{
	int x,y;
	scanf("%d%d",&x,&y);
	int tmp = get_rank(tree[x]);
	Delete(tmp);
	Insert(tree[x],tmp+y);
}
void Ask()
{
	int x;
	scanf("%d",&x);
	printf("%d\n",get_rank(tree[x])-1);
}
void Query()
{
	int x;
	scanf("%d",&x);
	Find(root,x+1,null);
	printf("%d\n",root->num);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		tree[i] = new Splay(i);
	init();
	char opt[10];
	for(int i = 1;i<=m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')Query();
		else if(opt[0]=='A')Ask();
		else if(opt[0]=='T')top();
		else if(opt[0]=='B')bot();
		else if(opt[0]=='I')Change();
	}
	return 0;
}
Problem1861

#include<iostream>
#include<cstdio>
#include<cstring>
#define inf 1000000000
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,rt,sz;
int c[80005][2],fa[80005],deep[80005];
int a[80005],size[80005],v[80005],pos[80005];
void update(int k)
{
	size[k]=size[c[k][0]]+size[c[k][1]]+1;
}
void rotate(int x,int &k)
{
	int y=fa[x],z=fa[y],l,r;
	if(c[y][0]==x)l=0;else l=1;r=l^1;
	if(y==k)k=x;
	else {if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
	fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
	c[y][l]=c[x][r];c[x][r]=y;
	update(y);update(x);
}
void splay(int x,int &k)
{
	while(x!=k)
	{
		int y=fa[x],z=fa[y];
		if(y!=k)
		{	
			if(c[y][0]==x^c[z][0]==y)
				rotate(x,k);
			else rotate(y,k);
		}
		rotate(x,k);
	}
}
void build(int l,int r,int f)
{
	if(l>r)return;
	int now=l,last=f;
	if(l==r)
	{
		v[now]=a[l];size[now]=1;fa[now]=last;
		if(l<f)c[last][0]=now;
		else c[last][1]=now;
		return;
	}
	int mid=(l+r)>>1;now=mid;
	build(l,mid-1,mid);build(mid+1,r,mid);
	v[now]=a[mid];fa[now]=last;update(now);
	if(mid<f)c[last][0]=now;
	else c[last][1]=now;
}
int find(int k,int rank)
{
	int l=c[k][0],r=c[k][1];
	if(size[l]+1==rank)return k;
	else if(size[l]>=rank)return find(l,rank);
	else return find(r,rank-size[l]-1);
}
void del(int k)
{
	int x,y,z;
	x=find(rt,k-1);y=find(rt,k+1);
	splay(x,rt);splay(y,c[x][1]);
	z=c[y][0];c[y][0]=0;fa[z]=size[z]=0;
	update(y);update(x);
}
void move(int k,int val)
{
	int x,y,z=pos[k],rank;
	splay(z,rt);rank=size[c[z][0]]+1;
	del(rank);
	if(val==inf)x=find(rt,n),y=find(rt,n+1);
	else if(val==-inf)x=find(rt,1),y=find(rt,2);
	else x=find(rt,rank+val-1),y=find(rt,rank+val);
	splay(x,rt);splay(y,c[x][1]);
	size[z]=1;fa[z]=y;c[y][0]=z;
	update(y);update(x);
}
int main()
{
	n=read();m=read();
	for(int i=2;i<=n+1;i++)
		a[i]=read(),pos[a[i]]=i;
	build(1,n+2,0);
	rt=(3+n)>>1;
	char ch[10];int S,T;
	for(int i=1;i<=m;i++)
	{
		scanf("%s",ch);S=read();
		switch(ch[0])
		{
		case 'T':move(S,-inf);break;
		case 'B':move(S,inf);break;
		case 'I':T=read();move(S,T);break;
		case 'A':splay(pos[S],rt);printf("%d\n",size[c[pos[S]][0]]-1);break;
		case 'Q':printf("%d\n",v[find(rt,S+1)]);break;
		}
	}
	return 0;
}
Problem1878

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int M = 200005;
int a[N],last[1000005],next[N];
int num[N],c[N];
struct ask{int x,y,ans,no;}A[M];
bool cmp(ask a,ask b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
bool cmp1(ask a,ask b){return a.no<b.no;}
void update(int x)
{
	if(x==0)return ;
	for(int i = x;i<=N;i+=i&(-i))
		c[i]++;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		if(last[a[i]]!=0)next[last[a[i]]] = i;
		else update(i);
		last[a[i]] = i;
	}
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&A[i].x,&A[i].y);
		A[i].no = i;
	}
	sort(A+1,A+m+1,cmp);
	int l = 1;
	for(int i = 1;i<= m;i++)
	{
		while(l<A[i].x)
		{
			update(next[l]);
			l++;
		}
		int tmp = getans(A[i].y);
		A[i].ans = tmp-getans(A[i].x-1);
	}
	sort(A+1,A+m+1,cmp1);
	for(int i = 1;i<= m;i++)
		printf("%d\n",A[i].ans);
	return 0;
}
Problem1901

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int INF = 1e9+1;
int n,m;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	size = cnt = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(x->val<y)
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}else
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)
		Delete(x->ls,y);
	else if(y>x->val)
		Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)
			tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_rank(root[p],y);return ;}
	int mid=(l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,y);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,y);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF;int ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans = mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int a[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	char opt[3];int x,y,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')
		{
			scanf("%d%d%d",&x,&y,&k);
			get_number(x,y,k);
		}else
		{
			scanf("%d%d",&x,&k);
			change(1,1,n,x,a[x],k);
			a[x] = k;
		}
	}
	return 0;
}
Problem1911

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
LL sum[N];
LL f[N];
int Q[N],L,R,n,a,b,c,x;
LL Y(int x)
{
    return f[x]+sum[x]*sum[x]*a;
}
int main()
{
    //memset(f,128,sizeof(f));
    scanf("%d%d%d%d",&n,&a,&b,&c);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&x);
        sum[i] = sum[i-1]+x;
    }
    L = R = 1;
    Q[L] = 0;
    for(int i = 1;i<= n;i++)
    {
        while(L<R&&-(sum[i]*2*a+b)>(double)(Y(Q[L])-Y(Q[L+1]))/(double)(sum[Q[L+1]]-sum[Q[L]]))
            L++;
        f[i] = f[Q[L]]+
               (sum[i]-sum[Q[L]])*(sum[i]-sum[Q[L]])*a+(sum[i]-sum[Q[L]])*b+c;
        while(L<R&&(double)(Y(Q[R-1])-Y(Q[R]))/(double)(sum[Q[R]]-sum[Q[R-1]])>(double)(Y(Q[R])-Y(i))/(double)(sum[i]-sum[Q[R]]))
            R--;
        Q[++R] = i;
    }
    printf("%lld",f[n]);
    return 0;
}
Problem1912

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot = 1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = 1;
	head[x] = tot;
}
int max_dep,end;
int pre[N],prp[N];
void dfs(int x,int fa,int pe,int dep)
{
	pre[x] = pe;
	prp[x] = fa;
	if(dep>max_dep)
	{
		max_dep = dep;
		end = x;
	}
	for(int i = head[x];i;i =e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,i,dep+e[i].val);
}
int md[N],stack[N],top;
bool cmp(int a,int b){return a>b;}
void dp(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			dp(e[i].to,x);
			md[x] = max(md[x],md[e[i].to]+e[i].val);
		}
	top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&md[e[i].to]+e[i].val>=0)
			stack[++top] = md[e[i].to]+e[i].val;
	sort(stack+1,stack+top+1,cmp);
	if(top>=2)max_dep = max(max_dep,stack[1]+stack[2]);
	else if(top>=1)max_dep = max(max_dep,stack[1]);
}
int main()
{
	int n,k,x,y;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0,0,0);
	int tmp = end;
	max_dep = 0;
	dfs(end,0,0,0);
	int len1 = max_dep;
	if(k==1)printf("%d\n",2*(n-1)-max_dep+1);
	else
	{
		max_dep = 0;
		while(tmp!=end)
		{
			e[pre[end]].val = -1;
			e[pre[end]^1].val = -1;
			end = prp[end];
		}
		dp(1,0);
		printf("%d\n",2*(n-1)-len1+1-max_dep+1);
	}
	return 0;
}
Problem1917

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,c[N],g[N],mrk[N],Ans[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	c[y]--;
}
int ans = 0;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			int tmp = min(c[x],c[e[i].to]);
			c[x]-=tmp,c[e[i].to]-=tmp,ans+=tmp<<1;
			if(c[e[i].to])g[x]=e[i].to;
		}
}
void solve(int x,int fa)
{
	Ans[x]=ans;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			if(c[x]){c[x]--,ans++,mrk[x]=0;}
			else if(g[e[i].to]){c[g[e[i].to]]--,ans++,mrk[x]=1;}
			else {c[e[i].to]++,ans--,mrk[x]=2;}
			solve(e[i].to,x);
			if(mrk[x]==0){c[x]++,ans--;}
			else if(mrk[x]==1){c[g[e[i].to]]++,ans--;}
			else {c[e[i].to]--,ans++;}
		}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		x++,y++;
		add(x,y),add(y,x);
	}
	ans = (n-1)<<1;
	dfs(1,0);solve(1,0);
	for(int i = 1;i<= n;i++)
		printf("%d\n",Ans[i]);
	return 0;
}
Problem1927

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,f,c,from;}e[M];
int head[N],tot=1;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	e[tot].f=f;e[tot].c=c;e[tot].from=x;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;
	e[tot].f=0;e[tot].c=-c;e[tot].from=y;
}
queue<int>Q;
int dis[N],from[N];bool v[N];
 bool spfa(int s,int t)
{
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	v[s]=true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to]=i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to]=true;
				}
			}
	}
	return dis[t]!=INF;
}
int ans,st,end;
void mcf()
{
	int x = INF;
	for(int i = from[end];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[end];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int a[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	st = 0,end = 2*n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		add(st,i,1,0);
		add(i+n,end,1,0);
		add(0,i+n,1,a[i]);
	}
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(x>y)swap(x,y);
		add(x,y+n,1,z);
	}
	while(spfa(st,end))mcf();
	printf("%d\n",ans);
	return 0;
}
Problem1930

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f,c;}e[N*N];
int head[N<<1],tot = 1;
void add(int x,int y,int f,int c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].f = f,e[tot].c = c;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	e[tot].f = 0;e[tot].c = -c;
}
int dis[N<<1],n;bool vis[N<<1];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = s;i<= t;i++)dis[i] = -1;
	dis[s] = 0;
	vis[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]<dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=-1;
}
bool visit[N<<1];
int getflow(int p,int s,int t,int mf)
{
	if(p==t)return mf;
	visit[p] = true;
	int last = mf;
	for(int i = head[p];i;i=e[i].next)
		if(e[i].f&&dis[p]+e[i].c==dis[e[i].to]&&(!visit[e[i].to]||e[i].to==t))
		{
			int tof = getflow(e[i].to,s,t,min(last,e[i].f));
			e[i].f-=tof;
			e[i^1].f+=tof;
			last-=tof;
			if(!last)
				return mf;
		}
	return mf-last;
}
int Maxcost(int s,int t)
{
	int res = 0;
	while(spfa(s,t))
	{
		memset(visit,0,sizeof(visit));
		res+=getflow(s,s,t,INF)*dis[t];
	}
	return res;
}
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
	void read()
	{
		scanf("%d%d",&x,&y);
	}
	bool operator <(const Point &s)const
	{
		return x<s.x||(x==s.x&&y<s.y);
	}
}p[N];
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		p[i].read();
	sort(p+1,p+n+1);
	add(0,1,2,0);
	int S = 1,T = 2*n+2;
	for(int i = 1;i<= n;i++)
		add(S,i<<1,1,0),
		add(i<<1|1,T,1,0),
		add(i<<1,i<<1|1,1,1),
		add(i<<1,i<<1|1,1,0);
	for(int i = 1;i<= n;i++)
	{
		int Min = INF;
		for(int j = i+1;j<= n;j++)
		{
			if(p[j].y<Min&&p[j].y>=p[i].y)
				add(i<<1|1,j<<1,2,0);
			if(p[j].y>=p[i].y)
				Min = min(Min,p[j].y);
		}
	}
	printf("%d\n",Maxcost(0,T));
	return 0;
}
Problem1935

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const int M = 500005;
int id[N*3],n,m;
struct Tree
{
	int c[N];
	Tree()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			c[i]+=y;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans+=c[i];
		return ans;
	}
}C;
struct A
{int x,y,no,ans;}ask[M<<2];
bool cmp(A a,A b)
{return a.y<b.y;}
bool fir(A a,A b)
{return a.no<b.no;}
struct T
{int x,y;}tr[N];
bool cmt(T a,T b)
{
	if(a.y!=b.y)
		return a.y<b.y;
	return a.x<b.x;
}
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l = mid+1;
		else r = mid;
	}
	if(id[l]>x)return --l;
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&tr[i].x,&tr[i].y);
		tr[i].x+=2;tr[i].y+=2;
		id[i] = tr[i].x;
	}
	sort(tr+1,tr+n+1,cmt);
	sort(id+1,id+n+1);
	int a,b,c,d,cnt = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		a+=2,b+=2,c+=2,d+=2;
		ask[++cnt].x = c;ask[cnt].y = d;ask[cnt].no = cnt;
		ask[++cnt].x = a-1;ask[cnt].y = d;ask[cnt].no = cnt;
		ask[++cnt].x = c;ask[cnt].y = b-1;ask[cnt].no = cnt;
		ask[++cnt].x = a-1;ask[cnt].y = b-1;ask[cnt].no = cnt;
	}
	sort(ask+1,ask+cnt+1,cmp);
	int j = 1;
	for(int i = 1;i<= cnt;i++)
	{
		while(tr[j].y<=ask[i].y&&j<=n)
		{
			C.update(find(tr[j].x),1);
			j++;
		}
		ask[i].ans = C.getans(find(ask[i].x));
	}
	sort(ask+1,ask+cnt+1,fir);
	for(int i = 1;i<= m;i++)
	{
		int t = (i-1)*4;
		printf("%d\n",ask[t+1].ans-ask[t+2].ans-ask[t+3].ans+ask[t+4].ans);
	}
}
Problem1951

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL mod[5] = {0,2,3,4679,35617};
LL fac[5][40000];
LL env[5][40000];
LL c(int n,int m,int modn)
{
    LL tmp = fac[modn][m]*fac[modn][n-m]%mod[modn];
    return fac[modn][n]*env[modn][tmp]%mod[modn];
}
LL lucas(int n,int m,int m_n)
{
    LL ans = 1;
    while(n&&m&&ans) 
    {
        ans = (ans*c(n%mod[m_n],m%mod[m_n],m_n))%mod[m_n];
        n /= mod[m_n];
        m /= mod[m_n];
    }
    return ans;
}
LL xx,yy,d;
void ex_gcd(LL a,LL b)
{
    if(b==0)
    {
        xx = 1;
        yy = 0;
        d = a;
        return ;
    }
    ex_gcd(b,a%b);
    LL tmp = xx;
    xx = yy;
    yy = tmp-a/b*xx;
}
LL M[15],Mt = 999911658ll,ans;
LL a[15],envM[5];
LL remain()
{
    LL ans = 0;
    for(int i = 1;i<= 4;i++)
        ans =(ans+envM[i]*a[i]*M[i]%Mt)%Mt;
    return ans;
}
LL p = 0;
void div(LL x)
{
    LL i;
    for(i = 1;i*i<= x;i++)
    {
        //printf("%lld:\n",i);
        if(x%i==0)
        {
            for(int j = 1;j<= 4;j++)
            {
                a[j] = lucas(x,i,j);
                //printf("%lld ",a[j]);
            }
            p = (p+remain())%Mt;
            //printf("\nnow_ans = %lld\n",p);
            //printf("%lld:\n",x/i);
            if(i*i!=x)
            {
                for(int j = 1;j<= 4;j++)
                {
                    a[j] = lucas(x,x/i,j);
                    //printf("%lld ",a[j]);
                }
                p = (p+remain())%Mt;
                //printf("\nnow_ans = %lld\n",p);
            }
        }
    }
}
LL quick(LL x,LL y)
{
    if(y==0)return 1;
    LL tmp = quick(x,y/2);
    if(y%2==1)return tmp*tmp%(Mt+1)*x%(Mt+1);
    else return tmp*tmp%(Mt+1);
}
int main()
{
    long long n,g;
    scanf("%lld%lld",&n,&g);
    for(int i = 1;i<= 4;i++)
    {
        M[i] = Mt/mod[i];
        ex_gcd(M[i],mod[i]);
        xx = (xx%mod[i]+mod[i])%mod[i];
        envM[i] = xx;
    }
    for(int i = 1;i<= 4;i++)
    {
        fac[i][0] = env[i][1] = 1;
        for(LL j = 1;j<= mod[i]+1;j++)
        {
            //if(j==0){fac[i][j] = 1;env[i][j] = 1;continue;}
            fac[i][j] = fac[i][j-1]*j%mod[i];
            if(j!=1)env[i][j] = ((mod[i]-mod[i]/j)*env[i][mod[i]%j])%mod[i];
        }
    }
    /*for(int i = 1;i<= 4;i++)
    {
        for(LL j = 1;j<= 4;j++)
        {
            printf("%lld %lld:%lld\n",fac[i][j],env[i][j],j*env[i][j]%mod[i]);
        }
    }*/
    div(n);
    p = p+Mt;
    printf("%lld\n",quick(g,p));
    return 0;
}
Problem1976

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 7e4+5;
const int M = 7e5+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot=1;
void add(int x,int y,int f1,int f2)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f1;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=f2;
}
queue<int>Q;
int pos[45][45][45];
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int main()
{
	int n,id = 0;
	scanf("%d",&n);
	int st = 0,end = n*n*n+1;
	for(int i=1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
				pos[i][j][k]=++id;
	for(int i= 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
			{
				if(i!=n)add(pos[i][j][k],pos[i+1][j][k],1,1);
				if(j!=n)add(pos[i][j][k],pos[i][j+1][k],1,1);
				if(k!=n)add(pos[i][j][k],pos[i][j][k+1],1,1);
			}
	char ch;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
			{
				ch = getchar();while(ch!='P'&&ch!='N'&&ch!='?')ch = getchar();
				if(ch=='P')
				{
					if((i+j+k)&1)add(st,pos[i][j][k],INF,0);
					else add(pos[i][j][k],end,INF,0);
				}else if(ch=='N')
				{
					if((i+j+k)&1)add(pos[i][j][k],end,INF,0);
					else add(st,pos[i][j][k],INF,0);
				}
			}
	int ans = dinic(st,end);
	printf("%d",3*n*n*(n-1)-ans);
	return 0;
}
Problem1997

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 2e6+5;
struct E
{int next,to;}e[M];
int head[N],tot,c[N],pos[N],u[10005],v[10005];
inline void add(int x,int y)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;}
int dfn[N],Dfn,low[N],bel[N],stack[N],top,dcc;
bool ins[N];
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	tot = Dfn = dcc = top = 0;
}
struct data
{
	int l,r;
	data(int _l=0,int _r=0):l(_l),r(_r){}
}qj[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n,m;
		scanf("%d%d",&n,&m);
		init();
		for(int i = 1;i<= m;i++)scanf("%d%d",&u[i],&v[i]);
		for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
		for(int i = 1;i<= n;i++)pos[c[i]] = i;
		if(m>3*n-6){puts("NO");continue;}
		int cnt = 0,x,y;
		for(int i = 1;i<= m;i++)
		{
			x = pos[u[i]],y = pos[v[i]];
			if(x>y)swap(x,y);
			if(y-x==1||(x==1&&y==n))continue;
			qj[++cnt] = data(x,y);
		}
		m = cnt;
		for(int i = 1;i<= m;i++)
			for(int j = i+1;j<= m;j++)
				if((qj[i].l<qj[j].l&&qj[j].l<qj[i].r&&qj[i].r<qj[j].r)||
					(qj[j].l<qj[i].l&&qj[i].l<qj[j].r&&qj[j].r<qj[i].r))
				{
					add(i<<1,j<<1|1);
					add(i<<1|1,j<<1);
					add(j<<1,i<<1|1);
					add(j<<1|1,i<<1);
				}
		for(int i = 2;i<= (m<<1|1);i++)
			if(!dfn[i])tarjan(i);
		bool flag = true;
		for(int i = 1;i<= m&&flag;i++)
			if(bel[i<<1]==bel[i<<1|1])flag = false;
		if(flag)puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem1999

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 5e5+5;
struct E
{int next,to,val;}e[M<<1];
int head[M],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].val  = f;
	e[tot].next = head[x];
	head[x] = tot;
}
queue <int>Q;
int pre[M];
int path[M],cnt,v[M];
LL dis[M],dep[M],Mdep[M],lth[M];
int line[M],L,R;
int end,n,s;
void bfs(int s)
{
	Q.push(s);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!dis[e[i].to]&&e[i].to!=s)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(dis[e[i].to]>dis[end])end = e[i].to;
				Q.push(e[i].to);
			}
	}
	int st = end;
	memset(dis,0,sizeof(dis));
	Q.push(st);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!dis[e[i].to]&&e[i].to!=st)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				pre[e[i].to] = x;
				if(dis[e[i].to]>dis[end])end = e[i].to;
				Q.push(e[i].to);
			}
	}
	int x = end;
	while(x!=st)
	{
		path[++cnt] = x;
		lth[cnt] = dis[end]-dis[x];
		v[x] = true;
		x = pre[x];
	}
	path[++cnt] = x;
	v[x] = true;
	lth[cnt] = dis[end]-dis[x];
	return ;
}
void get_Maxdep(int st,int no)
{
	dep[st] = 0;
	Q.push(st);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		Mdep[no] = max(Mdep[no],dep[x]);
		for(int i = head[x];i;i = e[i].next)
			if(!v[e[i].to]&&!dep[e[i].to])
				dep[e[i].to] = dep[x]+e[i].val,Q.push(e[i].to);
	}
}
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c);
		add(y,x,c);
	}
	bfs(1);
	for(int i = 1;i<= cnt;i++)
		get_Maxdep(path[i],i);
	int j = 1;
	LL ans = 1e18+1;
	L = 0,R = -1;
	for(int i = 1;i<= cnt;i++)
	{
		while(L<=R&&lth[i]-lth[line[L]]>s)L++;
		while(i>=j&&lth[i]-lth[j]>s)j++;
		while(L<=R&&Mdep[i]>=Mdep[line[R]])R--;
		line[++R] = i;
		ans = min(ans,max(Mdep[line[L]],max(lth[j],lth[cnt]-lth[i])));
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2001

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 0x3f3f3f3f;
typedef long long ll;
int fa[N],Fa[N];
void Init(int n)
{
	for(int i = 1;i<=n;i++)fa[i] = i;
}
int getfa(int x)
{
	return fa[x]==x?x:(fa[x]=getfa(fa[x]));
}
struct P
{
	int x,y,w,k,id;
	bool operator<(const P &s)const 
		{return w<s.w;}
}e[20][N];
struct C
{
	int x,to;
}chg[N];
int pos[N],dis[N],pa[N];
void init(int m)
{
	for(int i = 1;i<= m;i++)
		dis[e[0][i].id] = e[0][i].w;
}
void solve(int d,int L,int R,int n,int m,ll ans = 0ll)
{
	for(int i = 1;i<= m;i++)
	{
		P &a = e[d][i],a2 = e[d-1][i];
		a = (P){a2.x,a2.y,dis[a2.id],0,a2.id};
		pos[a.id] = i;
	}
	if(L==R)
	{
		C &b = chg[L];
		e[d][pos[b.x]].w = dis[b.x] = b.to;
		Init(n);
		sort(e[d]+1,e[d]+m+1);
		for(int i = 1;i<= m;i++)
		{
			P &tmp = e[d][i];
			int x = getfa(tmp.x),y = getfa(tmp.y);
			if(x==y)continue;
			fa[y] = x;
			ans+=tmp.w;
		}
		printf("%lld\n",ans);
		return ;
	}
	int mid = (L+R)>>1;
	for(int i = L;i<=R;i++)e[d][pos[chg[i].x]].k = 1;
	Init(n);
	sort(e[d]+1,e[d]+m+1);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			a.k = 2;
		}
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==1)e[d][i].w = -INF;
	Init(n);
	sort(e[d]+1,e[d]+m+1);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k!=0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			if(a.k!=1)a.k = 3;
		}
	Init(n);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==3)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			ans+=a.w;
		}
	int newn = 0,newm = 0;
	for(int i = 0;i<= n;i++)Fa[i] = 0;
	for(int i = 1;i<= n;i++)
	{
		int x = getfa(i);
		if(!Fa[x])Fa[x] = ++newn;
	}
	for(int i = 1;i<= m;i++)
		if(e[d][i].k!=0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			e[d][++newm] = (P){Fa[x],Fa[y],a.w,a.k,a.id};
		}
	solve(d+1,L,mid,newn,newm,ans);
	solve(d+1,mid+1,R,newn,newm,ans);
}
int main()
{
	int n,m,q;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&e[0][i].x,&e[0][i].y,&e[0][i].w);
		e[0][i].id = i;
	}
	for(int i = 1;i<= q;i++)
		scanf("%d%d",&chg[i].x,&chg[i].to);
	init(m);
	solve(1,1,q,n,m);
	return 0;
}
Problem2002

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 2e5+5;
struct Splay{
	Splay *fa,*ls,*rs;
	int size;
	void push_up();
	Splay();
}*null = new Splay(),tree[M];
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
Splay :: Splay()
{
	ls = rs = fa = null;
	size = 1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==x->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void link(Splay *x,Splay *y)
{
	access(x);
	splay(x);
	x->ls->fa = null;
	x->ls = null;
	x->fa = y;
	x->push_up();
}
int main()
{
	null->ls = null->rs = null->fa = null;
	null ->size = 0;
	int n,x;
	Splay *root;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(i+x<=n)
			tree[i].fa = &tree[i+x];
	}
	int m,p,y;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&p);
		if(p==1)
		{
			scanf("%d",&x);x++;
			access(&tree[x]);
			splay(&tree[x]);
			printf("%d\n",tree[x].size);
		}else
		{
			scanf("%d%d",&x,&y);x++;
			if(x+y<=n)root = &tree[x+y];
			else root = null;
			link(&tree[x],root);
		}
	}
	return 0;
}
Problem2004

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<set>
#include<ctime>
#include<vector>
#include<queue>
#include<algorithm>
#include<map>
#include<cmath>
#define mod 30031
#define inf 1000000000
#define rad 100000000
#define pa pair<int,int>
#define ll long long 
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int bin[20];
int n,K,P,cnt;
int v[205];
struct M{
	ll v[205][205];
	M(){
		memset(v,0,sizeof(v));
	}
	friend M operator*(M a,M b){
		M c;
		for(int i=1;i<=cnt;i++)
			for(int j=1;j<=cnt;j++)
			{
				for(int k=1;k<=cnt;k++)
					c.v[i][j]+=a.v[i][k]*b.v[k][j];
				c.v[i][j]%=mod;
			}
		return c;
	}
	friend M operator^(M a,int b){
		M ans;
		for(int i=1;i<=cnt;i++)ans.v[i][i]=1;
		for(int i=b;i;i>>=1,a=a*a)
			if(i&1)ans=ans*a;
		return ans;
	}
}a,b,ans;
int lowbit(int x)
{
	return x&(-x);
}
void dfs(int now,int num,int sta)
{
	if(num==K)
	{
		v[++cnt]=sta;
		return;
	}
	for(int i=now-1;i;i--)
		dfs(i,num+1,sta+bin[i-1]);
}
void pre()
{
	for(int i=1;i<=cnt;i++)
		for(int j=1;j<=cnt;j++)
		{
			int x=(v[i]<<1)^bin[P]^v[j];
			if(x==lowbit(x))
			    b.v[i][j]=1;
		}
}
int main()
{
	bin[0]=1;for(int i=1;i<20;i++)bin[i]=bin[i-1]<<1;
	n=read();K=read();P=read();
	dfs(P,1,bin[P-1]);
	pre();
	ans.v[1][1]=1;
	M t=b^(n-K);
	ans=ans*t;
	printf("%d\n",ans.v[1][1]);
	return 0;
}
Problem2005

#include<stdio.h>
typedef long long LL;
long long f[100005];
LL min(LL a,LL b)
{
    if(a>b)return b;
    return a;
}
int main()
{
    LL n,m;
    scanf("%lld%lld",&n,&m);
    LL tmp = min(n,m);
    LL ans = 0;
    for(LL i = tmp;i>=1;i--)
    {
        f[i] = (n/i)*(m/i);
        for(LL j = 2;j<= n/i;j++)
        {
            f[i] = f[i] - f[i*j];
        }
        ans = ans+f[i]*(2*i-1);
    }
    printf("%lld",ans);
    return 0;
}
Problem2007

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
//int map[N][N][4];
struct E{int to,next,val;}e[N*N*9];
int head[N*N],tot,cnt,st,end,n;
struct H{int v;long long p;}P[N*N*4];
void go_up(int x)
{
	int i = x;
	while((i>>1)>=1&&P[i].v<P[i>>1].v)
	{
		swap(P[i],P[i>>1]);
		i = i>>1;
	}
}
int getnum(int i,int j){return (i-1)*n+j;}
bool cmp(H a,H b){return a.v>b.v;}
void go_down(int x)
{
	int i = x;
	while(((i<<1)|1)<=cnt)
	{
		if(P[i].v>P[i<<1].v&&P[i].v>P[(i<<1)|1].v)
		{
			swap(P[i],P[i<<1].v>P[(i<<1)|1].v?P[(i<<1)|1]:P[i<<1]);
			i = P[i<<1].v>P[(i<<1)|1].v?((i<<1)|1):(i<<1);
		}else if(P[i].v>P[i<<1].v)
		{
			swap(P[i],P[i<<1]);
			i = i<<1;
		}
		else if(P[i].v>P[i<<1|1].v)
		{
			swap(P[i],P[i<<1|1]);
			i = i<<1|1;
		}
		else break;
	}
	if((i<<1)<=cnt&&P[i<<1].v<P[i].v)
		swap(P[i],P[i<<1]);
}
void insert(int per,long long lth)
{
	H tmp;
	tmp.v = lth;tmp.p = per;
	P[++cnt] = tmp;
	go_up(cnt);
}
int pop()
{
	int tmp = P[1].p;
	swap(P[1],P[cnt]);
	cnt--;
	go_down(1);
	return tmp;
}
long long f[N*N];
bool in[N*N];
void dijk()
{
	memset(f,0x3f,sizeof(f));
	f[st] = 0;
	P[1].v = 0,P[1].p = st;
	cnt++;
	//insert(st,0);
	while(cnt)
	{
		int x = P[1].p;
		pop_heap(P+1,P+cnt+1,cmp);
		cnt--;
		if(in[x])continue;
		in[x] = true;
		for(int i = head[x];i;i = e[i].next)
		{
			int y = e[i].to;
			if(f[x]+e[i].val<f[y])
			{
				f[y] = f[x]+e[i].val;
				cnt++;
				P[cnt].p = y;P[cnt].v = f[y];
				push_heap(P+1,P+cnt+1,cmp);
				//insert(y,f[y]);
			}
		}
	}
	return ;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void show_edge(int x)
{
    for(int i = head[x];i;i = e[i].next)
        printf("%d %d:%d\n",x,e[i].to,e[i].val);
}
int main()
{
	scanf("%d",&n);
	int a;
	st = n*n+1,end = n*n+2;
    for(int i=1;i<=n;i++){scanf("%d",&a);add(st,getnum(1,i),a);}
    for(int i=1;i<n;i++)
        for(int j=1;j<=n;j++) 
            {scanf("%d",&a);add(getnum(i,j),getnum(i+1,j),a);}
    for(int i=1;i<=n;i++)
        {scanf("%d",&a);add(getnum(n,i),end,a);}
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        add(getnum(i,1),end,a);
        for(int j=2;j<=n;j++) {scanf("%d",&a);add(getnum(i,j),getnum(i,j-1),a);}
        scanf("%d",&a);
    	add(st,getnum(i,n),a);
    }
    for(int i=1;i<=n;i++) scanf("%d",&a);
    for(int i=1;i<n;i++)
        for(int j=1;j<=n;j++) 
        	{scanf("%d",&a);add(getnum(i+1,j),getnum(i,j),a);}
    for(int i=1;i<=n;i++) scanf("%d",&a);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        for(int j=2;j<=n;j++){scanf("%d",&a);add(getnum(i,j-1),getnum(i,j),a);}
        scanf("%d",&a);
    }
	dijk();
	printf("%lld\n",f[end]);
	return 0;
}
Problem2038

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 50100;
int n,q,size;
int pos[N],c[N];
ll s[N];
ll sqr(ll x){return x*x;}
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
struct Ask
{
	int l,r,bel;
	ll up,dwn;
	bool operator <(const Ask &s)const
	{
		if(pos[l]==pos[s.l])return r<s.r;
		else return l<s.l;
	}
}ask[N];
bool cmp(const Ask &a,const Ask &b)
{
	return a.bel<b.bel;
}
ll ans;
void update(int x,int add)
{
	ans-=sqr(s[c[x]]);
	s[c[x]]+=add;
	ans+=sqr(s[c[x]]);
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	size = sqrt(n)+1;
	for(int i = 1;i<= n;i++)
		pos[i] = i/size;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].bel = i;
	}
	sort(ask+1,ask+m+1);
	int l = 1,r = 0;
	for(int i = 1;i<= m;i++)
	{
		while(r<ask[i].r)r++,update(r,1);
		while(r>ask[i].r)update(r,-1),r--;
		while(l>ask[i].l)l--,update(l,1);
		while(l<ask[i].l)update(l,-1),l++;
		if(ask[i].l==ask[i].r)
			ask[i].up = 0,ask[i].dwn = 1;
		else
		{
			ask[i].up = ans-(ask[i].r-ask[i].l+1);
			ask[i].dwn = (ll)(ask[i].r-ask[i].l+1)*(ask[i].r-ask[i].l);
			ll g = gcd(ask[i].up,ask[i].dwn);
			ask[i].up/=g,ask[i].dwn/=g;
		}
	}
	sort(ask+1,ask+m+1,cmp);
	for(int i = 1;i<= m;i++)
		printf("%lld/%lld\n",ask[i].up,ask[i].dwn);
	return 0;
}
Problem2049

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
struct Splay
{
	Splay *ls,*rs,*fa;
	bool rev;
	Splay();
	void reverse();
	void push_down();
}*null = new Splay(),tree[N];
void Splay :: push_down()
{
	if(fa->ls==this||fa->rs==this)
		fa->push_down();
	if(rev)
	{
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		ls->rev^=1;
		rs->rev^=1;
		rev = 0;
	}
}
Splay :: Splay()
{
	ls = rs = fa = null;
	rev = false;
}
void Splay :: reverse()
{
	swap(ls,rs);
	rev^=1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void splay(Splay *x)
{
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else 
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
Splay* find_root(Splay *x)
{
	while(x->fa!=null)
		x = x->fa;
	return x;
}
void link(Splay *x,Splay *y)
{
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	x->fa = null;
	y->ls = null;
}
int main()
{
	null->ls = null->rs = null->fa = null;
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	char opt[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		scanf("%d%d",&x,&y);
		if(opt[0]=='C')link(&tree[x],&tree[y]);
		else if(opt[0]=='D')cut(&tree[x],&tree[y]);
		else
		{
			Splay *tmp = find_root(&tree[x]);
			if(tmp==find_root(&tree[y]))printf("Yes\n");
			else printf("No\n");
		}
	}
	return 0;
}
Problem2055

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f,c,from;
}e[M];
int head[N],tot = 1;
int in[N],out[N],ans;
void add(int x,int y,int lr,int ur,int c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].f = ur-lr,e[tot].c = c,e[tot].from = x;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	e[tot].f = 0;e[tot].c = -c;e[tot].from = y;
	out[x]+=lr,in[y]+=lr;
	ans+=lr*c;
}
bool vis[N];
int dis[N],from[N];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = 1;i<= t;i++)dis[i] = INF,vis[i] = false;
	Q.push(s);
	dis[s] = 0;
	vis[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=INF;
}
void get_mcf(int s,int t)
{
	int x = INF;
	for(int i = from[t];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[t];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=x*e[i].c;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int SS = n+n+2,TT = n+n+3,S = n+n+4,T = n+n+5;
	add(SS,n+n+1,0,m,0);
	for(int i = 1;i<= n;i++)
		add(n+n+1,i,0,INF,0),add(i+n,TT,0,INF,0);
	int x;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		add(i,i+n,x,x,0);
	}
	for(int i = 1;i< n;i++)
		for(int j = 1;j<=n-i;j++)
		{
			scanf("%d",&x);
			if(x==-1)continue;
			add(n+i,i+j,0,INF,x);
		}
	add(TT,SS,0,INF,0);
	for(int i = 1;i<= TT;i++)
		if(in[i]<out[i])
			add(i,T,0,out[i]-in[i],0);
		else if(out[i]<in[i])
			add(S,i,0,in[i]-out[i],0);
	while(spfa(S,T))get_mcf(S,T);
	printf("%d\n",ans);
	return 0;
}
Problem2064

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1<<10;
const int INF = 0x3f3f3f3f;
int cnt[M];
int f[M][M],logn[15];
int a[15],b[15],suma[M],sumb[M];
void dfs(int k,int state,int *t,int s,int *ans)
{
    if(k==t[0]+1)return ;
    ans[state<<(t[0]-k)]=s;
    dfs(k+1,state*2+1,t,s+t[k+1],ans);
    dfs(k+1,state*2,t,s,ans);
}
void init()
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	for(int i = 2;i<= 10;i++)
		logn[i] = logn[i>>1]+1;
	dfs(0,0,a,0,suma);
    dfs(0,0,b,0,sumb);
}
int main()
{
	//memset(f,0x3f,sizeof(f));
	scanf("%d",&a[0]);
	for(int i = 1;i<= a[0];i++)
		scanf("%d",&a[i]);
	scanf("%d",&b[0]);
	for(int i = 1;i<= b[0];i++)
		scanf("%d",&b[i]);
	init();
	for(int i = 1;i<1<<a[0];i++)
	{
		for(int j = 1;j<1<<b[0];j++)
		{
			for(int k = 1;k<= a[0];k++)
			{
				int tmp = 1<<(k-1);
				if((i&tmp)>0)f[i][j] = max(f[i][j],f[i-tmp][j]);
			}
			for(int k = 1;k<= b[0];k++)
			{
				int tmp = 1<<(k-1);
				if((j&tmp)>0)f[i][j] = max(f[i][j],f[i][j-tmp]);
			}
			if(suma[i]==sumb[j])f[i][j]++;
		}
	}
	printf("%d\n",a[0]+b[0]-2*f[(1<<a[0])-1][(1<<b[0])-1]);
	return 0;
}
Problem2073

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 17;
const int S = 1<<16;
int w[N],t[N],cnt,v[S],f[S];
int gt[S],n,W;
void init()
{
	for(int i = 0;i<1<<n;i++)
	{
		int Gw = 0,Gt = 0;
		for(int j = 0;j<n;j++)
			if(i&(1<<j))
			{
				Gw+=w[j+1];
				Gt = max(Gt,t[j+1]);
			}
		if(Gw<=W)
		{
			gt[++cnt] = Gt;
			v[i] = cnt;
		}
	}
}
int main()
{
	memset(f,0x3f,sizeof(f));
	scanf("%d%d",&W,&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&t[i],&w[i]);
	init();
	f[0] = 0;
	for(int i = 0;i<1<<n;i++)
	{
		for(int k = i;k;k = (k-1)&i)
			if(v[k])
				f[i] = min(f[i],f[i-k]+gt[v[k]]);
	}
	printf("%d\n",f[(1<<n)-1]);
	return 0;
}
Problem2079

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		uni(x,y);
	}
	bool flag = true;
	for(int i = 1;i<= n;i++)
		if(fa[i]==0)
			flag = false;
	if(flag)printf("TAK\n");
	else printf("NIE\n");
	return 0;
}
Problem2084

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int s[N],a[N<<1];
int no[N<<1],p[N<<1];
long long ans;
int maxp,id;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%1d",&s[i]);
	int len = 0;
	for(int i = 1;i<=n;i++)
	{
		a[++len]=s[i];
		no[len]=i;
		if(i!=n)a[++len]=-1;
	}
	maxp = 1,id = 1;
	for(int i = 1;i<= len;i++)
	{
		if(i<=maxp)p[i]=min(p[id*2-i],maxp-i);
		while(i+p[i]<=len&&i-p[i]>=1&&(a[i+p[i]]+a[i-p[i]]==1||a[i+p[i]]+a[i-p[i]]==-2))p[i]++;
		p[i]--;
		if(i+p[i]>maxp){maxp = i+p[i];id = i;}
		ans+=(no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1])-(no[i]?no[i]:no[i+1])+1;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2086

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
int stack[N],top;
int a[N];
LL sum[N];
int main()
{
	int n,m,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	while(m--)
	{
		scanf("%d",&k);
		for(int i = 1;i<= n;i++)
			sum[i] = sum[i-1]+a[i]-k;
		for(int i = 1;i<= n;i++)
			if(sum[i]<sum[stack[top]])
				stack[++top] = i;
		int ans = 0;
		for(int i = n;i>=0;i--)
		{
			while(top&&sum[i]>=sum[stack[top-1]])top--;
			ans = max(ans,i-stack[top]);
		}
		if(m)printf("%d ",ans);
		else printf("%d\n",ans);
	}
	return 0;
}
Problem2095

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2005;
const int EM = 1e6+5;
const int INF = 0x3f3f3f3f;
struct Edge
{
	int x,y,a,b;
	Edge(int x=0,int y=0,int a=0,int b=0):x(x),y(y),a(a),b(b){}
}ed[M];
struct E
{int next,to,f;}e[EM];
int head[N],tot=1,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int fa[N],cnt;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
	cnt--;
}
int dgr[N],S,T;
bool judge(int ans)
{
	memset(fa,0,sizeof(fa));cnt=n;
	memset(head,0,sizeof(head));tot = 1;
	memset(dgr,0,sizeof(dgr));
	for(int i = 1;i<= m;i++)
	{
		if(ed[i].b<=ans)
		{
			uni(ed[i].x,ed[i].y);
			dgr[ed[i].x]++;
			dgr[ed[i].y]--;
			add(ed[i].x,ed[i].y,1);
		}
		else if(ed[i].a<=ans)
		{
			uni(ed[i].x,ed[i].y);
			dgr[ed[i].x]--;
			dgr[ed[i].y]++;
		}
	}
	if(cnt>=2)return false;
	for(int i = 1;i<= n;i++)
	{
		if(dgr[i]&1)return false;
		if(dgr[i]>0)
			add(S,i,dgr[i]>>1);
		else add(i,T,(-dgr[i])>>1);
	}
	dinic(S,T);
	for(int i =head[S];i;i=e[i].next)
		if(e[i].f)
			return false;
	return true;
}
int main()
{
	scanf("%d%d",&n,&m);
	S = 0,T = n+1;
	int x,y,a,b,max_num = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&a,&b);
		if(a>b)swap(a,b),swap(x,y);
		ed[i]=Edge(x,y,a,b);
		max_num = max(max_num,b);
	}
	int l = 1,r = max_num+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(judge(mid))r = mid;
		else l = mid+1;
	}
	if(l!=max_num+1)printf("%d\n",l);
	else printf("NIE\n");
	return 0;
}
Problem2096

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3000005;
int q1[N],q2[N],l1,l2,r1,r2;
int a[N];
int main()
{
	int n,k,ans = 0;
	scanf("%d%d",&k,&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&a[q1[r1]]<a[i])r1--;q1[++r1] = i;
		while(l2<=r2&&a[q2[r2]]>a[i])r2--;q2[++r2] = i;
		while(a[q1[l1]]-a[q2[l2]]>k)
		{
			j++;
			while(l1<=r1&&q1[l1]<j)l1++;
			while(l2<=r2&&q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2097

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int stack[N],cnt,a[N];
bool cmp(int a,int b){return a>b;}
int dp(int x,int fa,int lim)
{
	int top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			a[e[i].to] = dp(e[i].to,x,lim);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			stack[++top] = a[e[i].to];
	sort(stack+1,stack+top+1,cmp);
	int max_dep = 0;
	if(top)
	{
		int i;
		for(i = 1;i<= top;i++)
		{
			if(stack[i]+1>lim)
				cnt++;
			else if(i<top&&stack[i]+stack[i+1]+2>lim)
				cnt++;
			else break;
		}
		if(i<=top)max_dep = stack[i]+1;
	}
	return max_dep;
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	int L = 0,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		cnt = 0;
		dp(1,0,mid);
		if(cnt>k)L = mid+1;
		else R = mid;
	}
	printf("%d\n",L);
	return 0;
}
Problem2115

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2e5+5;
const int N = 5e4+5;
typedef long long ll;
struct E
{
	int to,next;
	ll val;
}e[N<<1];
int head[N],tot;
void add(int x,int y,ll f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
ll sum[N];
void dfs(int x,int f)
{
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=f)
	{
		sum[e[i].to] = sum[x]^e[i].val;
		dfs(e[i].to,x);
	}
}
int st[M],end[M];
ll a[M],p[70],dis[M];
bool on_tree[M];
int father[N];
int getfa(int x)
{
	if(father[x]==x)return x;
	else return father[x] = getfa(father[x]);
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)father[i] = i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%lld",&st[i],&end[i],&dis[i]);
		int fx = getfa(st[i]),fy = getfa(end[i]);
		if(fx==fy)continue;
		add(st[i],end[i],dis[i]);
		on_tree[i] = true;
		father[fx] = fy;
	}
	dfs(1,0);
	ll ans = sum[n];
	int tot = 0;
	for(int i = 1;i<= m;i++)
		if(!on_tree[i])
			a[++tot] = sum[st[i]]^sum[end[i]]^dis[i];
	for(int i = 1;i<= tot;i++)
		for(int j = 63;j>= 0;j--)
			if((a[i]>>j)&1)
			{
				if(!p[j]){p[j] = a[i];break;}
				else a[i]^=p[j];
			}
	for(int i = 63;i>= 0;i--)if((ans^p[i])>ans)ans = ans^p[i];
	printf("%lld\n",ans);
	return 0;
}
Problem2121

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int dp[155][35],f[155],p[155][35],len[35],bin[25],n,m;
bool ok[155][155];
char s[35][25],str[155];

int main()
{
	scanf("%s",str+1);
	m = strlen(str+1);
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s[i]+1);
		len[i] = strlen(s[i]+1);
	}
	bin[0] = 1;
	for(int i = 1;i<= 22;i++)
		bin[i] = bin[i-1]<<1;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= len[j];k++)
				if(str[i]==s[j][k])
					p[i][j]|=bin[k];
	for(int i = m;i;i--)
	{
		for(int j = 1;j<= n;j++)dp[i-1][j] = 1;
		for(int j = i;j<= m;j++)
		for(int k = 1;k<= n;k++)
		{
			dp[j][k]=(dp[j-1][k]<<1)&p[j][k];
            for (int x=i; x<j; x++) if (ok[x+1][j]) dp[j][k]|=dp[x][k];
			if  (dp[j][k]&bin[len[k]]) ok[i][j]=1;
		}
	}
	for(int i = 1;i<= m;i++)
	{
		f[i] = f[i-1]+1;
		for(int j = 1;j<= i;j++)
			if(ok[j][i])
				f[i] = min(f[i],f[j-1]);
	}
	printf("%d\n",f[m]);
	return 0;
}
Problem2124

#include<iostream>  
#include<cstdio>  
#include<cstring>  
#define ll long long  
#define mod 1000000007  
#define N 10005  
using namespace std;  
  
int n,a[N],pw[N];  
struct bit_node
{  
	int c[N];  
	void clr()
	{ memset(c,0,sizeof(c)); }  
	void add(int x)
	{  
		int i; for (i=x; i<=n; i+=i&-i) c[i]=(c[i]+pw[i-x])%mod;  
	}  
	int getsum(int x)
	{  
		int i,t=0; for (i=x; i; i^=i&-i) t=((ll)c[i]*pw[x-i]+t)%mod;  
		return t;  
	}  
	int qry(int x,int y)
	{  
		int p=getsum(x-1),q=getsum(y);  
		return (q-(ll)p*pw[y-x+1]%mod+mod)%mod;  
	}  
}bit1,bit2;  
int main()
{  
	int cas,i;
	scanf("%d",&cas);  
	pw[0]=1;
	for(i=1; i<=10000; i++) 
		pw[i]=(ll)pw[i-1]*12347%mod;  
	while (cas--)
	{  
		scanf("%d",&n); 
		int x;  
		for (i=1; i<=n; i++) 
			scanf("%d",&a[i]);  
		bit1.clr(); bit2.clr();  
		for (i=1; i<=n; i++)
		{  
			x=min(a[i]-1,n-a[i]);  
			if (x && bit1.qry(a[i]-x,a[i]-1)!=bit2.qry(n-a[i]-x+1,n-a[i])) break;  
			bit1.add(a[i]); bit2.add(n-a[i]+1);  
		}  
		puts((i>n)?"N":"Y");  
	}  
	return 0;  
}  
Problem2125

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,m,q;
namespace Cactus
{
	struct E
	{int next,to,val;}e[N];
	int head[N],tot=1;
	int fa[N],dep[N],dfn[N],Dfn;
	bool on_ring[N];
}
namespace RST
{
	struct E
	{
		int next,to,dis,val;
	}e[N];
	int head[N],tot=1,size[N],dis[N],n;
	int fa[N][18],dep[N];
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void getinfo(int x,int pre)
	{
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<= 17;i++)
			fa[x][i] =fa[fa[x][i-1]][i-1];
		if(x<=::n)
		{
			for(int i = head[x];i;i=e[i].next)
				if(i^pre^1)
				{
					if(e[i].to<=::n)e[i].dis = e[i].val = abs(Cactus::dep[e[i].to]-Cactus::dep[x]);
					else e[i].val = e[i].dis = 0;
				}
		}else
		{
			for(int i = head[x];i;i=e[i].next)
				if(i^pre^1)
				{
					e[i].dis = (Cactus::dep[e[i].to]-Cactus::dep[fa[x][0]]+size[x])%size[x];
					e[i].val = min(e[i].dis,size[x]-e[i].dis);
				}
		}
		for(int i = head[x];i;i=e[i].next)
			if(pre^i^1)
			{
				fa[e[i].to][0] = x;
				dis[e[i].to] = dis[x]+e[i].val;
				getinfo(e[i].to,i);
			}
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 17;i>= 0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 17;i>= 0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	int go_up(int x,int d)
	{
		for(int i = 17;i>= 0;i--)
			if((d>>i)&1)x = fa[x][i];
		return x;
	}
	int getans(int x,int y)
	{
		int lca = getlca(x,y);
		if(lca<=::n)return dis[x]+dis[y]-dis[lca]*2;
		else
		{
			int tx = go_up(x,dep[x]-dep[lca]-1);
			int ty = go_up(y,dep[y]-dep[lca]-1);
			int tmp = ((Cactus::dep[tx]-Cactus::dep[ty])%size[lca]+size[lca])%size[lca];
			return dis[x]+dis[y]-dis[tx]-dis[ty]+min(tmp,size[lca]-tmp);
		}
	}
}
namespace Cactus
{
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
	}
	void dfs(int x,int pre)
	{
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)if(i^pre^1)
		{
			if(!dfn[e[i].to])
			{
				fa[e[i].to] = x;
				dep[e[i].to] = dep[x]+e[i].val;
				on_ring[x] = false;
				dfs(e[i].to,i);
				if(!on_ring[x])
					RST::add(x,e[i].to);
			}else
			{
				if(dfn[e[i].to]>dfn[x])
					continue;
				int tmp = x;
				++RST::n;
				while(true)
				{
					RST::add(RST::n,tmp);
					on_ring[tmp] = true;
					if(tmp==e[i].to)break;
					tmp = fa[tmp];
				}
				RST::size[RST::n] = dep[x]-dep[e[i].to]+e[i].val;
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	RST::n = n;
	int x,y,z;
	while(m--)
	{
		scanf("%d%d%d",&x,&y,&z);
		Cactus::add(x,y,z);
	}
	Cactus::dfs(1,0);
	RST::getinfo(1,0);
	while(q--)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",RST::getans(x,y));
	}
	return 0;
}
Problem2130

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int mx[N<<2],lmx[N<<2],rmx[N<<2];
int F[N<<2];
void Push_up(int p)
{
	lmx[p] = lmx[p<<1];
	rmx[p] = rmx[p<<1|1];
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
int sa[N],sb[N],sc[N],a[N],b[N],c[N],pb[N],pc[N],K[N],f[N];
void update(int p,int r,int v)
{
	lmx[p] = rmx[p] = F[p] = v;
	mx[p] = v+sb[r];
}
void build(int p,int l,int r)
{
	F[p] = -1;
	if(l==r)
	{
		lmx[p] = rmx[p] = f[l];
		mx[p] = f[l]+sb[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	Push_up(p);
}
void Update(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b)
	{
		if(lmx[p]<=v)return ;
		if(rmx[p]>=v){update(p,r,v);return ;}
	}
	int mid = (l+r)>>1;
	if(F[p]!=-1)
		update(p<<1,mid,F[p]),update(p<<1|1,r,F[p]),F[p]=-1;
	if(a<=mid)Update(p<<1,l,mid,a,b,v);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,v);
	Push_up(p);
}
int main()
{
	char opt[3];
	scanf("%s",opt);
	int cas,i;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		for(i = 1;i<= n;i++)scanf("%d",&K[i]);
		for(i = 1;i<= n;i++)scanf("%d",&a[i]);
		for(i = 1;i<= n;i++)scanf("%d",&b[i]),pb[b[i]]=i;
		for(i = 1;i<= n;i++)scanf("%d",&c[i]),pc[c[i]]=i;
		for(i = 1;i<= n;i++)scanf("%d",&sa[i]),sa[i]+=sa[i-1];
		for(i = 1;i<= n;i++)scanf("%d",&sb[i]),sb[i]+=sb[i-1];
		for(i = 1;i<= n;i++)scanf("%d",&sc[i]),sc[i]+=sc[i-1];
		f[0] = sc[n];
		for(int i = 1;i<= n;i++)
			if(K[b[i]]==1)
				f[i] = min(f[i-1],sc[pc[b[i]]-1]);
			else
				f[i] = f[i-1];
		build(1,0,n);
		int ans = mx[1];
		for(int i = 1;i<= n;i++)
		{
			if(K[a[i]]==1)
			{
				Update(1,0,n,pb[a[i]],n,-1<<30);
				Update(1,0,n,0,n,sc[pc[a[i]]-1]);
			}else
				Update(1,0,n,pb[a[i]],n,sc[pc[a[i]]-1]);
			ans = max(ans,sa[i]+mx[1]);
		}
		printf("%d",ans);
		puts("");
	}
	return 0;
}
Problem2134

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10000005;
int a[N];
int main()
{
	int n,A,B,C;
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1); 
	for(int i=2;i<=n;i++) 
		a[i] = ((long long)a[i-1]*A+B)%100000001; 
	for(int i=1;i<=n;i++) 
		a[i] = a[i]%C+1; 
	double ans = 1.0/(double)max(a[1],a[n]);
	for(int i = 2;i<= n;i++)
		ans+=1.0/(double)max(a[i],a[i-1]);
	printf("%.3f\n",ans);
	return 0;
}
Problem2141

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->rs)x = x->ls;
		else if(!x->ls)x = x->rs;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int get_less(Treap *x,int y)
{
	int tmp = 0;
	if(!x)return tmp;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return tmp;
	}else if(y<x->val)return get_less(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_less(x->rs,y);
	}
}
int get_lessnqul(Treap *x,int y)
{
	int tmp = 0;
	if(!x)return tmp;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		tmp+=x->cnt;
		return tmp;
	}else if(y<x->val)return get_lessnqul(x->ls,y);
	else 
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_lessnqul(x->rs,y);
	}
}
int get_bigger(int p,int l,int r,int a,int b,int y)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)return r-l+1-get_lessnqul(root[p],y);
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=get_bigger(p<<1,l,mid,a,b,y);
	if(b >mid)ans+=get_bigger(p<<1|1,mid+1,r,a,b,y);
	return ans;
}
int get_smaller(int p,int l,int r,int a,int b,int y)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)return get_less(root[p],y);
	int mid=(l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=get_smaller(p<<1,l,mid,a,b,y);
	if(b >mid)ans+=get_smaller(p<<1|1,mid+1,r,a,b,y);
	return ans;
}
void update(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,a,b);
	else update(p<<1|1,mid+1,r,pos,a,b);
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
int a[N];
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		build(1,1,n,i,a[i]);
	int ans = 0;
	for(int i=1;i<=n;i++)
		ans+=get_bigger(1,1,n,1,i-1,a[i]);
	int x,y;
	scanf("%d",&m);
	while(m--)
	{
		printf("%d\n",ans);
		scanf("%d%d",&x,&y);
		if(a[x]==a[y]||x==y)continue;
		int flag =((x<y&&a[x]>a[y])||(x>y&&a[x]<a[y]));
		ans+=flag;
		ans-=get_bigger(1,1,n,1,x-1,a[x])+get_smaller(1,1,n,x+1,n,a[x]);
		ans-=get_bigger(1,1,n,1,y-1,a[y])+get_smaller(1,1,n,y+1,n,a[y]);
		update(1,1,n,x,a[x],a[y]);update(1,1,n,y,a[y],a[x]);
		swap(a[x],a[y]);
		ans+=get_bigger(1,1,n,1,x-1,a[x])+get_smaller(1,1,n,x+1,n,a[x]);
		ans+=get_bigger(1,1,n,1,y-1,a[y])+get_smaller(1,1,n,y+1,n,a[y]);
		ans-=(1-flag);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2143

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define fir first
#define sec second
#define mp make_pair
#define N 160
#define inf 1000000000

const int dx[4]={-1,1,0,0};
const int dy[4]={0,0,-1,1};
int m,n,len;
int stix1,stix2,stix3,stiy1,stiy2,stiy3,t1,t2,t3;
int a[N][N],b[N][N],dis[N][N][N<<1];
bool vis[N][N][N<<1];
struct node{ int x,y,z,d; };
priority_queue<node> q;
bool operator <(const node &u,const node &v){ return u.d>v.d; }
void solve(int sx,int sy)
{
	while (!q.empty()) q.pop();
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++)
			for (int k=0; k<=len; k++)
			{
				vis[i][j][k]=0; 
				dis[i][j][k]=inf;
			}
	dis[sx][sy][0]=0;
	node u,v; u.x=sx; u.y=sy; u.z=u.d=0; 
	q.push(u);
	while (!q.empty() && !(vis[stix1][stiy1][0] && vis[stix2][stiy2][0] && vis[stix3][stiy3][0]))
	{
		u=q.top(); q.pop();
		if (vis[u.x][u.y][u.z]) continue; vis[u.x][u.y][u.z]=1;
		if (u.z)
		{
			for (int k=0; k<4; k++)
			{
				int i=u.x+dx[k];int j=u.y+dy[k];
				if (i>0 && i<=m && j>0 && j<=n && u.d<dis[i][j][u.z-1])
				{
					dis[i][j][u.z-1]=v.d=u.d;
					v.x=i; v.y=j; v.z=u.z-1; q.push(v);
				}
			}
			v=u; v.z--;
			if (v.d<dis[v.x][v.y][v.z]){ dis[v.x][v.y][v.z]=v.d; q.push(v); }
		} else 
		{
			v=u; v.z=a[v.x][v.y]; v.d+=b[v.x][v.y];
			if (v.d<dis[v.x][v.y][v.z])
			{
				dis[v.x][v.y][v.z]=v.d; q.push(v);
			}
		}
	}
}
int main()
{
	scanf("%d%d",&m,&n);
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++)
		{
			scanf("%d",&a[i][j]); 
			a[i][j]=min(a[i][j],max(i-1,m-i)+max(j-1,n-j)+1);
			len=max(len,a[i][j]);
		}
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++) 
			scanf("%d",&b[i][j]);
	scanf("%d%d%d%d%d%d",&stix1,&stiy1,&stix2,&stiy2,&stix3,&stiy3);
	solve(stix1,stiy1); 
	t2+=dis[stix2][stiy2][0]; t3+=dis[stix3][stiy3][0];
	solve(stix2,stiy2); 
	t1+=dis[stix1][stiy1][0]; t3+=dis[stix3][stiy3][0];
	solve(stix3,stiy3); 
	t1+=dis[stix1][stiy1][0]; t2+=dis[stix2][stiy2][0];
	int ans=min(min(t1,t2),t3);
	if (ans<inf)
	{
		puts((ans==t1)?"X":(ans==t2)?"Y":"Z");
		printf("%d\n",ans);
	} else puts("NO");
	return 0;
}

Problem2146

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
typedef long long ll;
struct P
{
	ll x,y;
	P(){}
	P(ll x,ll y):x(x),y(y){}
	bool operator <(const P &s)const
	{
		if(x!=s.x)
			return x< s.x;
		return y<s.y;
	}
}p[N];
int n;
ll max_y=-INF,min_y=INF,area;
void get_area()
{
	static P *stack[N];
	int i,top=0;
	for(i=1;i<=n;i++)
	{
		if(!top||p[i].y>=stack[top]->y)
			stack[++top] = &p[i];
		if(p[i].y==max_y)
			break;
	}
	for(i++;i<=n;i++)
	{
		while(p[i].y>stack[top]->y)
			stack[top--]=NULL;
		stack[++top] = &p[i];
	}
	for(i = 2;i<= top;i++)
		area+=min(stack[i]->y,stack[i-1]->y)*(stack[i]->x-stack[i-1]->x);
	top = 0;
	for(i=1;i<= n;i++)
	{
		if(!top||p[i].y<=stack[top]->y)
			stack[++top] = &p[i];
		if(p[i].y==min_y)
			break;
	}
	for(i++;i<=n;i++)
	{
		while(p[i].y<stack[top]->y)
			stack[top--]=NULL;
		stack[++top] = &p[i];
	}
	for(i = 2;i<= top;i++)
		area-=max(stack[i]->y,stack[i-1]->y)*(stack[i]->x-stack[i-1]->x);
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld",&p[i].x,&p[i].y);
		max_y = max(max_y,p[i].y);
		min_y = min(min_y,p[i].y);
	}
	sort(p+1,p+n+1);
	printf("%lld\n",(max_y-min_y+p[n].x-p[1].x)<<1);
	get_area();
	printf("%lld\n",area);
	return 0;
}
Problem2152

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 2e4+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool used[N];
int sum,root,size[N],f[N];
void get_root(int x,int fa)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int dep[N];
LL cnt[4];
void get_dep(int x,int fa)
{
	cnt[dep[x]]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		dep[e[i].to] = (dep[x]+e[i].val)%3;
		get_dep(e[i].to,x);
	}
}
LL cal(int x,int now)
{
	dep[x] = now%3;
	cnt[1] = cnt[0] = cnt[2] = 0;
	get_dep(x,0);
	return cnt[1]*cnt[2]*2+cnt[0]*cnt[0];
}
LL ans;
void work(int x)
{
	ans+=cal(x,0);
	used[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		if(used[e[i].to])continue;
		ans-=cal(e[i].to,e[i].val);
		sum = size[e[i].to];
		root = 0;
		get_root(e[i].to,0);
		work(root);
	}
}
LL gcd(LL a,LL b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z),add(y,x,z);
	}
	f[0] = 0x3f3f3f3f;
	sum = n;
	get_root(1,0);
	work(root);
	LL t = gcd(ans,(LL)n*n);
	printf("%lld/%lld\n",ans/t,n*n/t);
	return 0;
}
Problem2154

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
const int mod = 20101009;
int mu[N],prime[N/10],cnt;
bool vis[N];
ll sum[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
				mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = (sum[i-1]+(ll)i*i*mu[i])%mod;
}
ll Sum(ll x)
{
	x %= mod;
	return x*(x+1)%mod*10050505%mod;
}
ll F(int x,int y)
{
	int last;
	ll ans = 0;
	for(int i = 1;i<=x&&i<=y;i=last+1)
	{
		last = min(x/(x/i),y/(y/i));
		(ans+=Sum(x/i)*Sum(y/i)%mod*(sum[last]-sum[i-1]))%=mod;
	}
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int last;
	quick_mu();
	ll ans = 0;
	for(int i = 1;i<= n&&i<= m;i=last+1)
	{
		last = min(n/(n/i),m/(m/i));
		(ans+=F(n/i,m/i)*(Sum(last)-Sum(i-1)))%=mod;
	}
	printf("%lld\n",(ans%mod+mod)%mod);
	return 0;
}
Problem2157

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int INF = 0x3f3f3f3f;
int minn[N<<2],maxn[N<<2],sum[N<<2];
bool f[N<<2];
struct E{int next,to;}e[N<<1];
int w[N],deep[N],son[N],size[N],fa[N],top[N],cnt;
int x[N],y[N],val[N];
int head[N],tot,n;
void add(int x,int y)
{
    e[++tot].to = y;
    e[tot].next = head[x];
    head[x] = tot;
}
bool v[N];
void dfs1(int x,int dep)
{
    v[x] = true;
    deep[x] = dep;
    size[x]++;
    for(int i = head[x];i;i = e[i].next)
    {
        int tmp = e[i].to;
        if(!v[tmp])
        {
            dfs1(tmp,dep+1);
            fa[tmp] = x;
            size[x]+=size[tmp];
            if(size[tmp]>size[son[x]])son[x] = tmp;
        }
    }
}
void dfs2(int x,int tp)
{
    top[x] = tp;
    w[x] = ++cnt;
    if(son[x]!=0)dfs2(son[x],tp);
    for(int i = head[x];i;i = e[i].next)
        if(e[i].to!=fa[x]&&e[i].to!=son[x])
            dfs2(e[i].to,e[i].to);
}
int quan[N];
void push_up(int p)
{
    minn[p] = min(minn[p<<1],minn[(p<<1)+1]);
    maxn[p] = max(maxn[p<<1],maxn[(p<<1)+1]);
    sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
void push_down(int p,int l,int r)
{
    if(l==r){f[p] = 0;return ;}
    f[p<<1] ^=1;
    f[(p<<1)+1] ^=1;
    sum[p<<1] = -sum[p<<1];sum[(p<<1)+1] = -sum[(p<<1)+1];
    swap(minn[p<<1],maxn[p<<1]);swap(minn[(p<<1)+1],maxn[(p<<1)+1]);
    minn[p<<1] = -minn[p<<1];maxn[p<<1] = -maxn[p<<1];
    minn[(p<<1)+1] = -minn[(p<<1)+1];maxn[(p<<1)+1] = -maxn[(p<<1)+1];
    f[p] = false;
}
int getans(int p,int l,int r,int a,int b,int opt)
{
    if(f[p])push_down(p,l,r);
    if(l>=a&&r<=b)
    {
        if(opt==1)return sum[p];
        else if(opt==2)return maxn[p];
        else return minn[p];
    }
    int ans;
    if(opt==1)ans= 0;
    else if(opt==2)ans = -INF;
    else ans = INF;
    int mid = (l+r)>>1;
    if(a<=mid)
    {
        if(opt==1)ans += getans(p<<1,l,mid,a,b,opt);
        else if(opt==2)ans = max(ans,getans(p<<1,l,mid,a,b,opt));
        else ans = min(ans,getans(p<<1,l,mid,a,b,opt));
    }
    if(b>mid)
    {
        if(opt==1)ans += getans((p<<1)+1,mid+1,r,a,b,opt);
        else if(opt==2)ans = max(ans,getans((p<<1)+1,mid+1,r,a,b,opt));
        else ans = min(ans,getans((p<<1)+1,mid+1,r,a,b,opt));
    }
    return ans;
}
void update(int p,int l,int r,int x,int c)
{
    if(f[p])push_down(p,l,r);
    if(l==r)
    {
        minn[p] = maxn[p] = sum[p] = c;
        return ;
    }
    int mid = (l+r)>>1;
    if(x<=mid)update(p<<1,l,mid,x,c);
    else update((p<<1)+1,mid+1,r,x,c);
    push_up(p);
}
void up_N(int p,int l,int r,int a,int b)
{
    if(f[p])push_down(p,l,r);
    if(l>=a&&r<=b)
    {
        f[p]^=1;
        minn[p] = -minn[p];maxn[p] = -maxn[p];sum[p] = -sum[p];
        swap(minn[p],maxn[p]);
        return ;
    }
    int mid = (l+r)>>1;
    if(a<=mid)up_N(p<<1,l,mid,a,b);
    if(b>mid)up_N((p<<1)+1,mid+1,r,a,b);
    push_up(p);
}
int qurey(int x,int y,int opt)
{
    int ans;
    if(opt==1)ans= 0;
    else if(opt==2)ans = -INF;
    else ans = INF;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        if(opt==1)ans += getans(1,1,n,w[top[x]],w[x],opt);
        else if(opt==2) ans = max(ans,getans(1,1,n,w[top[x]],w[x],opt));
        else if(opt==3) ans = min(ans,getans(1,1,n,w[top[x]],w[x],opt));
        else up_N(1,1,n,w[top[x]],w[x]);
        x = fa[top[x]];
    }
    if(x==y)return ans;
    if(deep[x]<deep[y])swap(x,y);
    if(opt==1)ans += getans(1,1,n,w[son[y]],w[x],opt);
    else if(opt==2) ans = max(ans,getans(1,1,n,w[son[y]],w[x],opt));
    else if(opt==3) ans = min(ans,getans(1,1,n,w[son[y]],w[x],opt));
    else up_N(1,1,n,w[son[y]],w[x]);
    return ans;
}
int main()
{
    int m,xx,yy;
    scanf("%d",&n);
    for(int i = 1;i<n;i++)
    {
        scanf("%d%d%d",&x[i],&y[i],&val[i]);
        x[i]++;y[i]++;
        add(x[i],y[i]);
        add(y[i],x[i]);
    }
    dfs1(1,1);
    dfs2(1,1);
    for(int i = 1;i<n;i++)
    {
        if(deep[x[i]]>deep[y[i]])update(1,1,n,w[x[i]],val[i]);
        else update(1,1,n,w[y[i]],val[i]);
    }
    scanf("%d",&m);
    char ju[5];
    for(int i = 1;i<= m;i++)
    {
        scanf("%s%d%d",ju,&xx,&yy);
        if(ju[0]=='C')
        {
            if(deep[x[xx]]>deep[y[xx]])update(1,1,n,w[x[xx]],yy);
            else update(1,1,n,w[y[xx]],yy);
        }else if(ju[0]=='N')
            qurey(xx+1,yy+1,4);
        else if(ju[0]=='S')
            printf("%d\n",qurey(xx+1,yy+1,1));
        else if(ju[1]=='A')
            printf("%d\n",qurey(xx+1,yy+1,2));
        else printf("%d\n",qurey(xx+1,yy+1,3));
    }
    return 0;
}
Problem2163

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e4+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
queue<int>Q;
int d[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int in[N],out[N];
int main()
{
	int node = 0;
	int S = 0,T;
	int n,m,F,sum=0;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)in[i]=++node;
	for(int i = 1;i<= n;i++)out[i]=++node;
	T = ++node;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&F);sum+=F;
		add(S,in[i],F),add(out[i],T,F);
	}
	int u,v;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&u,&v,&F);
		add(in[u],out[v],F);
	}
	printf("%d\n",sum-dinic(S,T));
	return 0;
}
Problem2176

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e7+5;
unsigned char s[N];
int mp(int n)
{
	int i,j,k,N = n<<1;
	i = 1,j = 2;
	while(i<n&&j<n)
	{
		k = 0;
		while(s[i+k]==s[j+k])k++;
		if(k==n)return min(i,j);
		if(s[i+k]>s[j+k])i = max(j+1,i+k+1);
		else j = max(i+1,j+k+1);
	}
	if(i<n)return i;else return j;
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
		s[i+n]=s[i];
	int st = mp(n);
	for(int i = st;i<st+n;i++)
		printf("%c",s[i]);
	return 0;
}
Problem2179

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
typedef double db;
typedef long long ll;
using namespace std;
const int N = 2e5;
const db PI = 3.14159265358979323;
struct cp
{
	db x,y;
	cp(){}
	cp(db x,db y):x(x),y(y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
int ans[N<<1];
void FFT(cp *a,int len,int type)
{
	int t=0;
	for(int i=0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j=len>>1;(t^=j)<j;j>>=1);
	}
	for(int i=2;i<=len;i<<=1)
	{
		cp wn=cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j=0;j<len;j+=i)
		{
			cp t,w(1,0);
			for(int k=0;k<(i>>1);k++,w=w*wn)
			{
				t=w*a[j+k+(i>>1)];
				a[j+k+(i>>1)]=a[j+k]-t;
				a[j+k]=a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i=0;i<len;i++)a[i].x/=len;
}
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i=0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i=0;i<len;i++)
	ans[i]=(int)(c[i].x+0.1);
}
char A[N],B[N];
int Ans[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",A);scanf("%s",B);
	int tmp = 0;
	for(int i = n-1;i>= 0;i--)
		x[n-i-1]=cp(A[i]-'0',0);
	tmp = 0;
	for(int i = n-1;i>=0;i--)
		y[n-i-1]=cp(B[i]-'0',0);
	//n = n*2;
	int t=1;
	while(t<=n)t = t<<1;
	n= t<<1;
	conv(x,y,z,n);
	int len = 0;
	ll x = 0;
	for(int i = 0;i<n;i++)
	{
		x+=ans[i];
		Ans[i]=x%10,x/=10;
	}
	for (;n&&!Ans[n];n--);
	printf("%d",Ans[n--]);
	for (int i=n;i>=0;i--) printf("%01d",Ans[i]);
	puts("");
	return 0;
}
Problem2179

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 4e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(){}
	cp(double x,double y):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y); 
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp&b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int type,int len)
{
	int t=0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp tmp,w = cp(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,1,len);FFT(b,1,len);
	for(int i = 0;i<len;i++)
		c[i] = a[i]*b[i];
	FFT(c,-1,len);
	for(int i = 0;i<len;i++)
		ans[i] = (int)(c[i].x+0.1);
}
int Ans[N];
char s[N],A[N],B[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s);
	for(int i = n-1;i>=0;i--)
		x[n-i-1]=cp(s[i]-'0',0);
	scanf("%s",s);
	for(int i = n-1;i>=0;i--)
		y[n-i-1]=cp(s[i]-'0',0);
	int l;
	for(l=1;l<=n;l=l<<1);
	l =l<<1;
	conv(x,y,z,l);
	long long x = 0;
	for(int i = 0;i<l;i++)
	{
		x = x+ans[i];
		Ans[i] = x%10,x/=10;
	}
	for(;l&&!Ans[l];l--);
	printf("%d",Ans[l--]);
	for(int i = l;i>=0;i--)
		printf("%01d",Ans[i]);
	printf("\n");
	return 0;
}
Problem2186

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int Maxn = 10000000+5; 
long long fac[Maxn],ans[Maxn],rev[Maxn];
int prime[Maxn/10],t_p;
bool v[Maxn];
long long mod;
int n,m;
void quick_prime()
{
	for(int i = 2;i< Maxn;i++)
	{
		if(!v[i])
		{
			t_p++;
			prime[t_p] = i;
		}
		for(int j = 1;j<= t_p&&prime[j]*i<Maxn;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j]==0)
				break;
		}
	}
	fac[1]=1; 
	int i; 
    for(i=2;i<=Maxn;i++)  
        fac[i]=fac[i-1]*i%mod;  
    rev[1]=1;  
    for(i=2;i<=Maxn&&i<mod;i++)  
        rev[i]=(mod-mod/i)*rev[mod%i]%mod;  
    ans[1]=1;  
    for(i=2;i<=Maxn;i++)  
    {  
        if(!v[i])  
            ans[i]=ans[i-1]*(i-1)%mod*rev[i%mod]%mod;  
        else  
            ans[i]=ans[i-1];  
    }
}
int main()
{
	int T;
	scanf("%d%lld",&T,&mod);
	quick_prime();
	while(T--)
	{
		scanf("%d%d",&n,&m);
		long long t_ans = fac[n];
		t_ans = t_ans*ans[m]%mod;
		printf("%lld\n",t_ans);
	}
	return 0;
}
Problem2194

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef double db;
const int N = 4e5+5;
const db PI = 3.14159265358979323;
int ans[N];
struct cp
{
	db x,y;
	cp(){}
	cp(db x,db y):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn=cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp tmp,w(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k]=a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)
		ans[i]=(int)(c[i].x+0.1);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 0;i< n;i++)scanf("%lf%lf",&x[i].x,&y[i].x);
	for(int i = 0;i<n/2;i++)swap(y[i],y[n-i-1]);
	int len = 1;
	while(len<=n)len<<=1;
	len<<=1;
	conv(x,y,z,len);
	for(int i = -1;i<n-1;i++)
		printf("%d\n",ans[i+n]);
	return 0;
}
Problem2213

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Q = 27;
const int N = 1e6+5;
int f[Q][Q],L[Q][Q],tot[Q],C[Q][Q],sec[Q][Q];
char s[N];
int ans;
void update(int x,int y)
{
	if(C[x][y]!=tot[y])ans = max(ans,f[x][y]-L[x][y]);
	else ans = max(ans,f[x][y]-sec[x][y]);
	if(f[x][y]<L[x][y])
	{
		if(C[x][y]==tot[y])L[x][y] = f[x][y];
		else
		{
			sec[x][y] = L[x][y];
			L[x][y] = f[x][y];
			C[x][y] = tot[y];
		}
	}else if(f[x][y]<sec[x][y])
		if(C[x][y]!=tot[y])
			sec[x][y] = L[x][y];
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	memset(sec,0x3f,sizeof(sec));
	for(int i = 1;i<= n;i++)
	{
		s[i] = s[i]-'a';
		tot[s[i]]++;
		for(int j = 0;j<26;j++)
		{
			if(j==s[i])continue;
			f[j][s[i]]--;
			update(j,s[i]);
			f[s[i]][j]++;
			update(s[i],j);
		}
	}
	printf("%d\n",ans);
}
Problem2215

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const int M = 50000050;
inline int p0(int i){return i*2;}
inline int p1(int i){return i*2+1;}
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<1)+(x<<3) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct E
{int next,to;}e[M];
int head[N<<1],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool v[N<<1],ins[N<<1],r[N][N];
int stack[N<<1],top,dep[N<<1],low[N<<1],bel[N<<1],dfn,scc;
void tarjan(int x)
{
	v[x] = true;
	low[x] = dep[x] = ++dfn;
	stack[++top] =x ;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!v[e[i].to])
			{tarjan(e[i].to);low[x] = min(low[x],low[e[i].to]);}
		else if(ins[e[i].to])
			{low[x] = min(low[x],dep[e[i].to]);}
	}
	if(low[x]==dep[x])
	{
		scc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = scc;
		}while(tmp!=x);
	}
}
void Read()
{
	scanf("%d",&n);
	int k,x;
	for(int i = 1;i<= n;i++)
	{
		k = read();
		for(int j = 1;j<= k;j++)
			{x = read();r[i][x] = r[x][i] = true;}
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<i;j++)
		{
			if(r[i][j])add(p1(i),p0(j)),add(p1(j),p0(i));
			else add(p0(i),p1(j)),add(p0(j),p1(i));
		}
}
int ans[N],cnt[N],dir[N],Ans;
void work()
{
	for(int i = 2;i<= 2*n+1;i++)
		if(!v[i])
			tarjan(i);
	for(int i = 1;i<= n;i++)if(bel[p1(i)]==bel[p0(i)])return ;
	int cnt1 = 0,cnt0 = 0;
	for(int i = 1;i<= n;i++)
	{
		ans[i] = (bel[p0(i)]>bel[p1(i)]);
		if(ans[i])cnt1++;else cnt0++;
	}
	Ans = (cnt1&&cnt0);
	int t0 = 0,t1 = 0;
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])
		{
			for(int j = 1;j<= n;j++)
				if(i!=j&&!ans[j]&&!r[i][j])
					cnt[i]++,dir[i] = j;
		}
		else
		{
			for(int j = 1;j<= n;j++)
				if(i!=j&&ans[j]&&r[i][j])
					cnt[i]++,dir[i] = j;
		}
	}
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])
		{
			if(!cnt[i]&&cnt1>1)Ans++;
			if(!cnt[i])t1++;
			if(cnt[i]==1&&((cnt[dir[i]]==1&&dir[dir[i]]==i&&i<dir[i])||!cnt[dir[i]]))
				Ans++;
		}
		else
		{
			if(!cnt[i]&&cnt0>1)Ans++;
			if(!cnt[i])t0++;
			if(cnt[i]==1&&((cnt[dir[i]]==1&&dir[dir[i]]==i&&i<dir[i])||!cnt[dir[i]]))
				Ans++;
		}
	}
	Ans+=t0*t1;
}
int main()
{
	Read();
	work();
	printf("%d\n",Ans);
	return 0;
}
Problem2216

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
struct E
{int l,r,p;}que[N];
int a[N],n;
double f[N],g[N];
double cal(int j,int i)
{
	return a[j]+sqrt(abs(i-j))-a[i];
}
int L,R;
int find(E a,int x)
{
	int l = a.l,r = a.r;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(cal(a.p,mid)>cal(x,mid))l = mid+1;
		else r = mid;
	}
	return l;
}
void work(double *F)
{
	L = 0,R = -1;
	for(int i = 1;i<= n;i++)
	{
		que[L].l++;
		while(L<=R&&que[L].l>que[L].r)L++;
		if(L>R||cal(i,n)>cal(que[R].p,n))
		{
			while(L<=R&&cal(que[R].p,que[R].l)<cal(i,que[R].l))
				R--;
			if(L>R)
				que[++R] = (E){i,n,i};
			else
			{
				int t = find(que[R],i);
				que[R].r = t-1;
				que[++R] = (E){t,n,i};
			}
		}
		F[i] = cal(que[L].p,i);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	work(f);
	for(int i = 1;i<=(n>>1);i++)swap(a[i],a[n-i+1]);
	work(g);
	for(int i = 1;i<= n;i++)
		printf("%d\n",max(0,(int)ceil(max(g[n-i+1],f[i]))));
	return 0;
}
Problem2217

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e6+5;
int ansl[N],ansr[N];
char s[N>>1];
int ex2[N>>1];
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	scanf("%s",s+1);
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		sum+=s[i]=='W'?1:2;
		ansr[sum] = i;
		ansl[sum] = 1;
	}
	for(int i = n;i>=1;i--)
		if(s[i]=='T')
			ex2[i] = ex2[i+1]+1;
	for(int i = 1;i<= 2*n;i++)
	{
		if(i>sum)break;
		if(!ansl[i])
		{
			int tmp = ansr[i+1];
			if(ex2[1]<ex2[tmp])
			{
				ansr[i] = tmp+ex2[1];
				ansl[i] = 2+ex2[1];
				continue;
			}
			if(tmp+ex2[tmp]==n+1)continue;
			ansr[i] = tmp+ex2[tmp];
			ansl[i] = 1+ex2[tmp];
		}
	}
	int x;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&x);
		if(!ansl[x])
			printf("NIE\n");
		else 
			printf("%d %d\n",ansl[x],ansr[x]);
	}
	return 0;
}
Problem2219

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 100005;
const ll INF = 0x7fffffffffffffffll;
int cas,num;
ll A,B,K;
ll prime[10005];
struct Hash
{
	#define mod 100007
	int head[mod],nxt[N],id[N],tot;
	ll val[N];
	void clear()
	{
		tot = 0;
		memset(head,0,sizeof(head));
	}
	int Insert(ll x,int k)
	{
		int tmp = x%mod;
		for(int i = head[tmp];i;i=nxt[i])
			if(val[i]==x)
				return id[i];
		if(k==-1)return -1;
		val[++tot] = x;
		id[tot] = k;
		nxt[tot] = head[tmp];
		head[tmp] = tot;
	}
}hmp;
ll quick_pow(ll x,ll y,ll p=INF)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res = res*x%p;
		x = x*x%p;
		y>>=1;
	}
	return res;
}
bool check(int x,ll p,ll k)
{
	for(int i = 1;i<= num;i++)
		if(quick_pow(x,k/prime[i],p)==1)
			return false;
	return true;
}
void get_fac(ll p)
{
	num = 0;
	for(ll i = 2;i*i<= p;i++)
		if(p%i==0)
		{
			prime[++num] = i;
			while(p%i==0)p/=i;
		}
	if(p>1)prime[++num] = p;
}
ll get_root(ll p,ll x)
{
	get_fac(x);
	for(int i = 2;;i++)
		if(check(i,p,x))return i;
}
void ex_gcd(ll a,ll b,ll &x,ll &y,ll &d)
{
	if(b==0)
	{
		d = a;
		x = 1;
		y = 0;
		return ;
	}
	ex_gcd(b,a%b,y,x,d);
	y-=a/b*x;
}
ll get_inv(ll a,ll b)
{
	ll x,y,d;
	ex_gcd(a,b,x,y,d);
	b/=d;
	return (x%b+b)%b;
}
ll BSGS(ll a,ll g,ll p)
{
	hmp.clear();
	ll m = sqrt(p)+1,tmp=1;
	for(int i = 0;i<m;i++,tmp=tmp*g%p)hmp.Insert(tmp,i);
	ll Inv = get_inv(tmp,p);
	int k;
	for(int i = 0;i<m;i++,a=a*Inv%p)
	{
		k = hmp.Insert(a,-1);
		if(k!=-1)return m*i+k;
	}
}
ll gcd(ll a,ll b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
ll solve(ll a,ll b,ll p,ll t)
{
	ll MOD = quick_pow(p,t),ret=0,phi,g,ind,tmp;
	b = b%MOD;
	if(!b)return quick_pow(p,t-((t-1)/a+1));
	while(b%p==0)ret++,b/=p;
	if(ret%a)return 0;
	t-=ret;
	MOD = quick_pow(p,t);
	phi = MOD-MOD/p;
	g = get_root(MOD,phi);ind = BSGS(b,g,MOD);
	tmp = gcd(a,phi);
	if(ind%tmp)return 0;
	return tmp*quick_pow(p,ret-ret/a);
}
int main()
{
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%lld%lld%lld",&A,&B,&K);
		ll ans = 1;
		K = 2*K+1;
		for(ll i= 2;i*i<= K;i++)
			if(K%i==0)
			{
				int ret = 0;
				while(K%i==0)K/=i,ret++;
				ans*=solve(A,B,i,ret);
			}
		if(K>1&&ans)ans*=solve(A,B,K,1);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem2223

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 1e7+5;
int root[N];
int ls[M],rs[M],sum[M];
int cnt,n,m,lim;
void update(int l,int r,int rt1,int &rt2,int v)
{
	rt2 = ++cnt;
	sum[rt2] = sum[rt1]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[rt2] = ls[rt1],rs[rt2] = rs[rt1];
	if(v<=mid)update(l,mid,ls[rt1],ls[rt2],v);
	else update(mid+1,r,rs[rt1],rs[rt2],v);
}
int ask(int L,int R)
{
	int l,r,tmp = (R-L+1)>>1;
	int rt1 = root[L-1],rt2 = root[R];
	l = 1,r = lim;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[rt2]-sum[rt1]<=tmp)return 0;
		if(sum[ls[rt2]]-sum[ls[rt1]]>tmp)
		{
			r = mid;
			rt1 = ls[rt1],rt2 = ls[rt2];
		}else if(sum[rs[rt2]]-sum[rs[rt1]]>tmp)
		{
			l = mid+1;
			rt1 = rs[rt1],rt2 = rs[rt2];
		}
		else return 0;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&lim);
	for(int i = 1;i<= n;i++)
	{
		int x;
		scanf("%d",&x);
		update(1,lim,root[i-1],root[i],x);
	}
	scanf("%d",&m);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		int tmp = ask(x,y);
		if(tmp!=0)printf("yes %d\n",tmp);
		else printf("no\n");
	}
	return 0;
}
Problem2226

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int phi[1000005],a[100005],tot;
long long f[1000005];
bool not_prime[1000005];
void oula(int n)
{
	for(int i = 2;i<= n;i++)
	{
		if(!not_prime[i])
		{
			a[++tot] = i;
			phi[i] = i-1;
		}
		for(int j = 1;j<= tot&&a[j]*i<=n;j++)
		{
			not_prime[i*a[j]] = true;
			if(i%a[j]==0){phi[i*a[j]] = phi[i]*a[j];break;}
			else phi[i*a[j]] = phi[i]*(a[j]-1);
		}
	}
}
long long ans(int i)
{
	long long re = 0;
	for(int j = 1;j*j<= i;j++)
	{
		if(i%j==0&&j*j!=i)
			{re+=f[i/j]+f[j];}
		else if(j*j==i)
			re+=f[j];
	}
	return re;
}
int main()
{
	int T,x;
	scanf("%d",&T);
	oula(1000001);
	f[1] = 1;
	for(int i = 1;i<= 1000001;i++)
		if(i!=1)f[i] = (long long)i*phi[i]/2;
	for(int i = 1;i<= T;i++)
	{
		scanf("%d",&x);
		printf("%lld\n",ans(x)*x);
	}
	return 0;
}
Problem2229

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200;
const int M = 6005;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot=1,a[N],b[N],d[N],n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f;
}
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int ans[N][N];
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] =-1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
void reset()
{
	for(int i = 2;i<= tot;i+=2)
		e[i].f = e[i^1].f = (e[i].f+e[i^1].f)>>1;
}
bool v[N];
void dfs(int x)
{
	v[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!v[e[i].to])
			dfs(e[i].to);
}
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(v,0,sizeof(v));
	dfs(s);
	for(int i = 1;i<= n;i++)
		if(v[i])
			for(int j = 1;j<= n;j++)
				if(!v[j])
					ans[i][j] = ans[j][i] = min(ans[i][j],tmp);
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(v[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)
		a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 1;
	memset(ans,0x3f,sizeof(ans));
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		int u,v,c;
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)a[i]=i;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d%d",&u,&v,&c);
			add(u,v,c);
		}
		solve(1,n);
		int q;
		scanf("%d",&q);
		for(int i = 1;i<= q;i++)
		{
			scanf("%d",&c);int Ans =0;
			for(int j = 1;j<= n;j++)
				for(int k = j+1;k<= n;k++)
					Ans+=(ans[j][k]<=c);
			printf("%d\n",Ans);
		}
		if(cas)printf("\n");
	}
	return 0;
}
Problem2243

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
struct T
{int lc,rc,num,f;}t[N<<3];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int deep[N],top[N],fa[N],son[N],size[N],w[N],c[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	size[x]++;
	deep[x] =dep;
	for(int i= head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void init(int no,int l,int r)
{
	t[no].f = -1;
	if(l==r)
	{
		t[no].num = 1;
		return ;
	}
	int mid= (l+r)>>1;
	init(no<<1,l,mid);
	init((no<<1)+1,mid+1,r);
	return ;
}
void push_down(int p)
{
	t[p<<1].num = t[(p<<1)+1].num = 1;
	t[p<<1].f = t[(p<<1)+1].f = t[p].f;
	t[p<<1].lc = t[(p<<1)+1].lc = t[p].lc;
	t[p<<1].rc = t[(p<<1)+1].rc = t[p].f;
	t[p].f = -1;
}
void update(int p,int l,int r,int a,int b,int c)
{
	if(t[p].f!=-1)push_down(p);
	if(l>=a&&r<=b)
		{t[p].lc = t[p].rc = t[p].f = c;t[p].num = 1;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)
		update(p<<1,l,mid,a,b,c);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b,c);
	if(t[p<<1].rc==t[(p<<1)+1].lc)t[p].num = t[p<<1].num+t[(p<<1)+1].num-1;
	else t[p].num = t[p<<1].num+t[(p<<1)+1].num;
	t[p].lc = t[p<<1].lc;t[p].rc = t[(p<<1)+1].rc;
}
T getans(int p,int l,int r,int a,int b)
{
	if(t[p].f!=-1)push_down(p);
	if(l>=a&&r<=b)
		return t[p];
	int mid = (l+r)>>1;
	T x,y,c;
	if(b<=mid)
		c = getans(p<<1,l,mid,a,b);
	else if(a>mid)
		c = getans((p<<1)+1,mid+1,r,a,b);
	else
	{
		x = getans(p<<1,l,mid,a,b);y = getans((p<<1)+1,mid+1,r,a,b);
		c.lc = x.lc;c.rc = y.rc;
		c.num = x.num+y.num;
		if(x.rc==y.lc)c.num--;
	}
	return c;
}
int t_ans;
void get_update(int x,int y,int c,int opt)
{
	T ta;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)update(1,1,n,w[top[x]],w[x],c);
		else
		{
			ta = getans(1,1,n,w[top[x]],w[x]);
			t_ans+=ta.num;
			if(ta.lc==getans(1,1,n,w[fa[top[x]]],w[fa[top[x]]]).lc)t_ans--;
		}
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)update(1,1,n,w[y],w[x],c);
	else
	{
		ta = getans(1,1,n,w[y],w[x]);
		t_ans+=ta.num;
	} 
}
int main()
{
	int m,x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	init(1,1,n);
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)get_update(i,i,c[i],1);
	char j[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",j);
		if(j[0]=='C')
		{
			scanf("%d%d%d",&x,&y,&z);
			get_update(x,y,z,1);
		}else
		{
			t_ans = 0;
			scanf("%d%d",&x,&y);
			get_update(x,y,0,0);
			printf("%d\n",t_ans);
		}
	}
	return 0;
}
Problem2251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
int s[N];
int sa[N],q[N],v[N],nv[N],cnt[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i=0;i<lim;i++)cnt[i]=0;
	for(i=0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i=len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim=0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j  =0;
			if(i)j=max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
		scanf("%1d",&s[i]);
	build_sa(n,2);
	build_rank(n);
	build_height(n);
	int l,r;
	for(int i = 0;i< n;i++)
		for(int j = h[i]+1;sa[i]+j-1<n;j++)
		{
			for(l=i;l>=0&&h[l]>=j;l--);
			for(r=i+1;r<n&&h[r]>=j;r++);
			if(r-l>1)printf("%d\n",r-l);
		}
	return 0;
}
Problem2257

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e7+5;
int divs[N];
bool cmp(const int &a,const int &b){return a>b;}
int main()
{
	int n,k,x,top = 0;
	scanf("%d%d",&n,&k);
	while(n--)
	{
		scanf("%d",&x);
		for(int i = 1;i*i<= x;i++)
			if(x%i==0)
			{
				divs[++top] = i;
				if(i*i!=x)divs[++top]=x/i;
			}
	}
	sort(divs+1,divs+top+1,cmp);
	int cnt = 1;
	for(int i = 1;i<= top;i++)
	{
		if(divs[i]!=divs[i-1])cnt=1;
		else cnt++;
		if(cnt>=k){printf("%d\n",divs[i]);break;}
	}
	return 0;
}
Problem2260

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2505;
const int INF = 0x3f3f3f3f;
const double eps = 1e-7;
struct E
{int u,v;double val;}e[M];
int p[N],num[N],pre[N],vis[N],mark[N];
double c[N],in[N];
double work(int root,int n,int m)
{
	double ans = 0;
	while(true)
	{
		for(int i = 1;i<= n;i++)in[i] = INF;
		for(int i = 1;i<= m;i++)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].val<in[v])
			{
				in[v] = e[i].val;
				pre[v] = u;
			}
		}
		for(int i = 1;i<= n;i++)
		{
			if(i==root)continue;
			if(fabs(in[i]-INF)<eps)return -1;
		}
		memset(mark,-1,sizeof(mark));
		memset(vis,-1,sizeof(vis));
		in[root] = 0;int cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			ans+=in[i];
			int v=i;
			while(v!=root&&mark[v]==-1&&vis[v]!=i)
			{
				vis[v] = i;
				v = pre[v];
			}
			if(v!=root&&mark[v]==-1)
			{
				++cnt;
				for(int u = pre[v];u!=v;u = pre[u])
					mark[u] = cnt;
				mark[v] = cnt;
			}
		}
		if(cnt==0)break;
		for(int i = 1;i<= n;i++)
			if(mark[i]==-1)mark[i]=++cnt;
		for(int i = 1;i<=m;i++)
		{
			int u = e[i].u,v = e[i].v;
			e[i].u = mark[u],e[i].v = mark[v];
			if(e[i].u!=e[i].v)
				e[i].val-=in[v];
		}
		n=cnt,root = mark[root];
	}
	return ans;
}
int main()
{
	int n,m=0;
	scanf("%d",&n);
	int tmp = n;n = 1;
	double x;int t;
	for(int i = 1;i<= tmp;i++)
	{
		scanf("%lf%d",&x,&t);
		if(t)
		{
			p[i]=++n;
			e[++m] = (E){1,n,x};
			c[n] = x;num[n] = t;
		}
	}
	int a,b,k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%lf",&a,&b,&x);
		if(p[a]&&p[b])
		{
			e[++m] = (E){p[a],p[b],x};
			c[p[b]] = min(c[p[b]],x);
		}
	}
	double ans = work(1,n,m);
	for(int i = 2;i<= n;i++)
		if(num[i]>1)ans+=c[i]*(num[i]-1);
	printf("%.2f\n",ans);
	return 0;
}
Problem2275

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll f[100];
int main()
{
	ll n;
	scanf("%lld",&n);
	f[0] = 0,f[1] = 1;
	int cnt = 1;
	while(f[cnt]<=n)
	{
		++cnt;
		f[cnt] = f[cnt-1]+f[cnt-2];
	}
	while(cnt)
	{
		if(f[cnt]==n)
			return printf("%lld\n",n),0;
		if(n>f[cnt])
			n-=f[cnt];
		cnt--;
	}
	return 0;
}
Problem2276

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
int q1[N],q2[N],l1,l2,r1,r2;
int m[N],x[N];
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&m[i],&x[i]);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&m[i]>m[q1[r1]])r1--;q1[++r1] = i;
		//while(l2<=r2&&x[i]<x[q2[r2]])r2--;q2[++r2] = i;
		while(m[q1[l1]]>x[i]&&j<=n)
		{
			j++;
			while(l1<=r1&&q1[l1]<j)l1++;
			//while(l2<=r2&&q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2277

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 250005;
LL gcd(LL x,LL y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
LL stack[N],top,a[N],n,k;
int main()
{
	scanf("%lld%lld",&n,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%lld",&a[i]);
		if(i!=k)stack[++top] = gcd(a[i],n);
	}
	sort(stack+1,stack+top+1);
	int tmp = top,top = 0;
	for(int i = 1;i<= tmp;i++)
		if(stack[top]!=stack[i])
			stack[++top] = stack[i];
	LL m = gcd(n,a[k]);
	LL ans = m;
	for(LL i = 1;i*i<=m;i++)
	{
		if(m%i==0)
		{
			int j;
			for(j = 1;j<= top;j++)
				if(stack[j]%i==0)
					break;
			if(j==top+1){ans = min(ans,i);break;}
			LL k = m/i;
			for(j = 1;j<= top;j++)
				if(stack[j]%k==0)
					break;
			if(j==top+1)ans = min(ans,k);
		}
	}
	printf("%lld\n",n/ans);
	return 0;
}
Problem2278

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<cmath>
#include<algorithm>
#include<iomanip>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<queue>
#include<stack>
using namespace std;
#define MAXN 100010
#define MAXM 2000010
#define INF 1000000000
#define MOD 1000000007
#define eps 1e-8
#define ll long long
struct vec{
    int to;
    int fro;
};
vec mp[MAXM];
int tai[MAXN],cnt=1;
bool vis[MAXM];
int st[MAXN],tp;
bool ist[MAXN];
vector<int>ans[MAXM];
int ANS;
int n,m;
int d[MAXN];
inline void be(int x,int y){
    mp[++cnt].to=y;
    mp[cnt].fro=tai[x];
    tai[x]=cnt;
}
inline void bde(int x,int y){
    be(x,y);
    be(y,x);
}
void dfs(int x){
    int y;
    if(ist[x]){
        int t=0;
        ANS++;
        while(t!=x){
            ist[t=st[tp--]]=0;
            ans[ANS].push_back(t);
        }
    }
    for(int &i=tai[x];i;i=mp[i].fro){
        y=mp[i].to;
        if(!vis[i]){
            vis[i]=vis[i^1]=1;
            ist[st[++tp]=x]=1;
            dfs(y);
        }
    }
}
int main(){
    int i,j,x,y,t,tt;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d%d%d%d",&x,&y,&t,&tt);
        if(t^tt){
            bde(x,y);
            d[x]++;
            d[y]++;
        }
    }
    for(i=1;i<=n;i++){
        if(d[i]&1){
            printf("NIE\n");
            return 0;
        }
    }
    for(i=1;i<=n;i++){
        dfs(i);
    }
    printf("%d\n",ANS);
    for(i=1;i<=ANS;i++){
        printf("%d ",ans[i].size());
        for(j=0;j<ans[i].size();j++){
            printf("%d ",ans[i][j]);
        }
        printf("%d\n",ans[i][0]);
    }
    return 0;
}

/*

*/
Problem2278

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2000010;
const int N = 100010;
struct E
{
	int next,to;
}e[M];
int head[N],tot = 1;
vector<int>Ans[M];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[M],ins[N],vis[N];
int stack[M],top,cnt,j;
void dfs(int x)
{
	vis[x] = true;
	if(ins[x])
	{
		cnt++;
		Ans[cnt].push_back(x);
		while(stack[top]!=x)
		{
			Ans[cnt].push_back(stack[top]);
			ins[stack[top]] = false;
			top--;
		}
		ins[stack[top]] = false;
		Ans[cnt].push_back(stack[top]);
		top--;
	}
	for(j = head[x];j;j = head[x])
	{
		head[x] = e[j].next;
		if(!used[j])
		{
			used[j] = used[j^1] = true;
			ins[x] = true;
			stack[++top] = x;
			dfs(e[j].to);
		}
	}
}
int d[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int x,y,u,w;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		if(u==w)continue;
		d[x]++,d[y]++;
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]&1)
		{
			printf("NIE\n");
			return 0;
		}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			dfs(i);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		printf("%d",Ans[i].size()-1);
		for(int k = 0;k<Ans[i].size();k++)
			printf(" %d",Ans[i][k]);
		printf("\n");
	}
	return 0;
}
Problem2278

#include <stdio.h>
#include <cctype>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2000010;
const int N = 100010;
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
inline int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
struct E
{
	int next,to;
}e[M];
int head[N],tot = 1;
vector<int>Ans[M];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[M],ins[N],vis[N];
int stack[M],top,cnt,j;
void dfs(int x)
{
	vis[x] = true;
	if(ins[x])
	{
		cnt++;
		Ans[cnt].push_back(x);
		while(stack[top]!=x)
		{
			Ans[cnt].push_back(stack[top]);
			ins[stack[top]] = false;
			top--;
		}
		ins[stack[top]] = false;
		Ans[cnt].push_back(stack[top]);
		top--;
	}
	for(j = head[x];j;j = head[x])
	{
		head[x] = e[j].next;
		if(!used[j])
		{
			used[j] = used[j^1] = true;
			ins[x] = true;
			stack[++top] = x;
			dfs(e[j].to);
		}
	}
}
int d[N];
int main()
{
	int n,m;
	n = read();m = read();
	int x,y,u,w;
	for(int i = 1;i<= m;i++)
	{
		x = read();y = read();u = read();w = read();
		if(u==w)continue;
		d[x]++,d[y]++;
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]&1)
		{
			printf("NIE\n");
			return 0;
		}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			dfs(i);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		printf("%d",Ans[i].size()-1);
		for(int k = 0;k<Ans[i].size();k++)
			printf(" %d",Ans[i][k]);
		printf("\n");
	}
	return 0;
}
Problem2286

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250010;
typedef long long ll;
struct E
{int next,to,val;};
int dep[N],fa[N][22],dfn[N],Dfn;
vector<int>to[N];
vector<int>val[N];
ll f[N],mn[N];
int stack[N],top,num[N];
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].val=f;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].val=f;
	}
	void dfs(int x,int f,int dp)
	{
		fa[x][0] = f;
		dep[x] = dp;
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=f)
			{
				mn[e[i].to] = min(mn[x],(ll)e[i].val);
				dfs(e[i].to,x,dp+1);
			}
	}
	void init(int n)
	{
		for(int j = 1;j<= 21;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 21;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 21;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
}tree;
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
void add(int x,int y)
{
	if(x==y)return ;
	to[x].push_back(y);
	to[y].push_back(x);
}
void dfs(int x,int ff)
{
	ll tmp = 0;
	int sz = to[x].size();
	f[x] = mn[x];
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
		{
			dfs(t,x);
			tmp+=f[t];
		}
	}
	if(tmp&&tmp<=f[x])f[x]=tmp;
	to[x].clear();
}
int main()
{
	int n,m,k;
	scanf("%d",&n);
	int x,y,c;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		tree.add(x,y,c);
	}
	mn[1]=1ll<<60;
	tree.dfs(1,0,1);
	tree.init(n);
	scanf("%d",&m);
	while(m--)
	{
		scanf("%d",&k);
		for(int i = 1;i<= k;i++)
			scanf("%d",&num[i]);
		sort(num+1,num+k+1,cmp);
		int tmp = k;
		num[k=1] = num[1];
		for(int i = 2;i<= tmp;i++)
			if(tree.getlca(num[k],num[i])!=num[k])
				num[++k]=num[i];
		top = 0;
		stack[++top]=1;
		for(int i = 1;i<= k;i++)
		{
			int v = num[i];
			int lca = tree.getlca(stack[top],v);
			while(true)
			{
				if(dep[lca]>=dep[stack[top-1]])
					{add(lca,stack[top--]);break;}
				add(stack[top-1],stack[top]);
				top--;
			}
			if(stack[top]!=lca)stack[++top]=lca;
			if(stack[top]!=v)stack[++top] = v;
		}
		for(int i = 1;i<=top-1;i++)
			add(stack[i],stack[i+1]);
		dfs(1,0);
		printf("%lld\n",f[1]);
	}
	return 0;
}
Problem2301

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int mu[N],prime[N],cnt,sum[N];
bool vis[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i= 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+mu[i];
}
typedef long long ll;
ll calc(int x,int y)
{
	if(x<0||y<0)return 0;
	ll ans = 0;
	int last = 0;
	for(int i = 1;i<=x&&i<=y;i = last+1)
	{
		last = min(y/(y/i),x/(x/i));
		ans+=(ll)(x/i)*(y/i)*(sum[last]-sum[i-1]);
	}
	return ans;
}
int main()
{
	quick_mu();
	int a,b,c,d,k;
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);
		ll ans = 0;
		ans+=calc(b/k,d/k);
		ans-=calc((a-1)/k,d/k);
		ans-=calc(b/k,(c-1)/k);
		ans+=calc((a-1)/k,(c-1)/k);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem2302

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
typedef long long ll;
int f[N][N];
int cnt[N],sum[N];
int C[N][N],n,m,x,y,mod;
void Init()
{
	memset(f,0,sizeof(f));
	memset(cnt,0,sizeof(cnt));
	memset(sum,0,sizeof(sum));
	C[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		C[i][0] = 1;
		for(int j = 1;j<=i;j++)
			C[i][j] = (C[i-1][j-1]+C[i-1][j])%mod;
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	//init();
	while(cas--)
	{
		scanf("%d%d%d",&n,&m,&mod);
		Init();
		sum[0] = n-m;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			cnt[y]++;
		}
		bool flag = false;
		for(int i = 1;i<= n;i++)
		{
			sum[i] = sum[i-1]+cnt[i];
			if(sum[i]<i)
			{
				puts("NO");
				flag = true;
				break;
			}
		}
		if(flag)continue;
		f[0][0]=1;
		for(int i = 1;i<= n;i++)
			for(int j = i;j<= sum[i];j++)
				for(int k = j-i+1;k>= cnt[i];k--)
					(f[i][j]+=(ll)f[i-1][j-k]*C[sum[i]-cnt[i]-j+k][k-cnt[i]]%mod)%=mod;
		printf("YES %d\n",f[n][n]);
	}
	return 0;
}
Problem2303

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e6+5;
const int mod = 1e9;
int fa[N],g[N];
struct P
{int x,y,z;}p[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	int tmp = getfa(fa[x]);
	g[x]^=g[fa[x]];
	return fa[x] = tmp;
}
int n,m,q;
int calc()
{
	for(int i = 1;i<= n+m;i++)fa[i]=i,g[i]=0;
	fa[m+1] = 1;
	for(int i = 1;i<= q;i++)
	{
		int u= getfa(p[i].x),v = getfa(p[i].y+m);
		int tmp = g[p[i].x]^g[p[i].y+m]^p[i].z;
		if(u!=v){fa[u]=v,g[u]=tmp;}
		else if(tmp)return 0;
	}
	int ans = -1;
	for(int i=1;i<=m+n;i++)
		if(getfa(i)==i)
		{
			if(ans==-1)ans=1;
			else
			{
				ans = ans<<1;
				if(ans>=mod)
					ans-=mod;
			}
		}
	return ans;
}
int main()
{
	scanf("%d%d%d",&m,&n,&q);
	bool f[2] = {true,true};
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&p[i].x,&p[i].y,&p[i].z);
		if(p[i].x==1&&p[i].y==1)
			{f[p[i].z] = false,i--,q--;continue;}
		if(!(p[i].x&1||p[i].y&1))p[i].z^=1;
	}
	int ans = 0;
	if(f[1])ans= calc();
	if(f[0])
	{
		for(int i = 1;i<= q;i++)
			if(p[i].x>1&&p[i].y>1)
				p[i].z^=1;
		ans+=calc();
	}
	if(ans>=mod)ans-=mod;
	printf("%d\n",ans);
	return 0;
}
Problem2306

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
int n,m,s;
double p,ans,f[N][N],g[N][N],a[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%lf",&a[i]);
	scanf("%d%lf",&s,&p);
	memset(f,0xc2,sizeof(f));
	for(int i = 1;i<= n;i++)
		f[i][i] = 0;
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		f[x][y] = a[y];
	}
	double pow = p;
	int T=70;
	while(T--)
	{
		memset(g,0xc2,sizeof(g));
		for(int k = 1;k<= n;k++)
			for(int i = 1;i<= n;i++)
				for(int j= 1;j<= n;j++)
					g[i][j]=max(g[i][j],f[i][k]+f[k][j]*pow);
		memcpy(f,g,sizeof(f));
		pow*=pow;
	}
	ans = 0;
	for(int i = 1;i<= n;i++)
		ans = max(ans,f[s][i]);
	printf("%.1lf",ans*p+a[s]);
	return 0;
}
Problem2314

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int mod = 1032992941;
ll f[N][2],g[N][2],h[N][2];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	f[x][0] = 1,g[x][0] = INF,h[x][0] = 0;
	f[x][1] = g[x][1] = h[x][1] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			int mn = min(f[e[i].to][0],min(g[e[i].to][0],h[e[i].to][0]));
			ll tmp = 0;
			if(f[e[i].to][0]==mn)tmp+=f[e[i].to][1];
			if(g[e[i].to][0]==mn)tmp+=g[e[i].to][1];
			if(h[e[i].to][0]==mn)tmp+=h[e[i].to][1];
			f[x][0]+=mn,f[x][1]=f[x][1]*tmp%mod;

			mn = min(min(g[x][0]+f[e[i].to][0],g[x][0]+g[e[i].to][0]),h[x][0]+f[e[i].to][0]);
			tmp = 0;
			if(g[x][0]+f[e[i].to][0]==mn)tmp+=(g[x][1]*f[e[i].to][1])%mod;
			if(g[x][0]+g[e[i].to][0]==mn)tmp+=(g[x][1]*g[e[i].to][1])%mod;
			if(h[x][0]+f[e[i].to][0]==mn)tmp+=(h[x][1]*f[e[i].to][1])%mod;
			g[x][0] = mn;
			g[x][1] = tmp%mod;

			h[x][0]+=g[e[i].to][0];
			h[x][1] = h[x][1]*g[e[i].to][1]%mod;
		}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	int ans1,ans2=0;
	ans1 = min(f[1][0],g[1][0]);
	if(f[1][0]==ans1)ans2+=f[1][1];
	if(g[1][0]==ans1)ans2+=g[1][1];
	ans2%=mod;
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2329

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct pas_seq
{
	int sum,lmax,rmax,lmin,rmin;
	void exc()
	{
		sum = -sum;
		swap(lmax,lmin);
		swap(rmax,rmin);
		lmax=-lmax,rmax=-rmax;
		lmin=-lmin,rmin=-rmin;
	}
	void rev()
	{
		swap(lmax,rmax);
		swap(lmin,rmin);
	}
	pas_seq(int x,int siz)
	{
		sum =siz*x;
		if(x==1)
			lmax=rmax=sum,lmin=rmin=0;
		else 
			lmin=rmin=sum,lmax=rmax=0;
	}
	friend pas_seq operator+(const pas_seq &a,const pas_seq &b)
	{
		pas_seq res(0,0);
		res.sum = a.sum+b.sum;
		res.lmax = max(a.lmax,a.sum+b.lmax);
		res.rmax = max(b.rmax,b.sum+a.rmax);
		res.lmin = min(a.lmin,a.sum+b.lmin);
		res.rmin = min(b.rmin,b.sum+a.rmin);
		return res;
	}
};
struct Splay
{
	Splay *ls,*rs,*fa;
	int cng,exc,size,val;
	bool rev;
	pas_seq *seq;
	Splay(int x);
	void push_up();
	void push_down();
}*null = new Splay(0),*root=null;
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	cng = exc = rev = 0;
	val = x,size = (val==0?0:1);
	seq = new pas_seq(x,size);
}
void Splay :: push_up()
{
	size = ls->size+(val==0?0:1)+rs->size;
	*seq = (*ls->seq)+pas_seq(val,1)+(*rs->seq);
}
void Splay :: push_down()
{
	if(cng)
	{
		ls->val = ls->cng = cng;
		rs->val = rs->cng = cng;
		*ls->seq = pas_seq(cng,ls->size);
		*rs->seq = pas_seq(cng,rs->size);
		ls->rev = ls->exc = 0;
		rs->rev = rs->exc = 0;
		cng = 0;
	}
	if(rev)
	{
		ls->rev^=1;
		rs->rev^=1;
		ls->seq->rev();
		rs->seq->rev();
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		rev = 0;
	}
	if(exc)
	{
		ls->exc^=1;
		rs->exc^=1;
		ls->val=-ls->val;
		rs->val=-rs->val;
		ls->seq->exc();
		rs->seq->exc();
		exc = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa= x;
	y->push_up();
	if(root==y)root=x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
void Insert(Splay *&x,int y,Splay *z)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = z;
		x->push_up();
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
char s[N];
int main()
{
	int n,m,l,r;
	char opt[10];
	scanf("%d%d",&n,&m);
	scanf("%s",s+1);
	Insert(root,-2,null);
	for(int i = 1;i<= n;i++)
		Insert(root,s[i]=='('?1:-1,null);
	Insert(root,2,null);
	while(m--)
	{
		scanf("%s%d%d",opt,&l,&r);
		find(root,l,null);
		find(root,r+2,root);
		Splay *tmp = root->rs->ls;
		if(opt[0]=='R')
		{
			scanf("%s",opt);
			int v = opt[0]=='('?1:-1;
			tmp->cng = tmp->val = v;
			*tmp->seq = pas_seq(v,tmp->size);
			tmp->exc = tmp->rev = 0;
		}else if(opt[0]=='S')
		{
			tmp->rev^=1;
			swap(tmp->ls,tmp->rs);
			tmp->seq->rev();
		}else if(opt[0]=='I')
		{
			tmp->exc^=1;
			tmp->val=-tmp->val;
			tmp->seq->exc();
		}else
		{
			l=(int)ceil(abs(tmp->seq->lmin)/2.0);
	           	r=(int)ceil(abs(tmp->seq->rmax)/2.0);
            		printf("%d\n",l+r);
		}
	}
	return 0;
}
Problem2333

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int INF = 0x3f3f3f3f;
int n,m,r1,r2;
struct Ask
{
	int o,x,y;
	void scanA()
	{
		char opt[3];
		scanf("%s",opt);
		if(opt[0]=='U')
			o = 1,scanf("%d%d",&x,&y);
		else if(opt[0]=='A')
		{
			if(opt[1]=='1')o = 2,scanf("%d%d",&x,&y);
			else if(opt[1]=='2')o = 3,scanf("%d%d",&x,&y);
			else o = 4,scanf("%d",&x);
		}else
		{
			if(opt[1]=='1')o = 5,scanf("%d",&x);
			else if(opt[1]=='2')o = 6,scanf("%d",&x);
			else o =7;
		}
	} 
}ask[N];
int maxn[N<<2],lazy[N<<2];
int fa[N<<2],ed[N<<2],next[N<<2],w[N<<2],save[N<<2],a[N];
int tot;
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int y)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		maxn[p]+=y;
		lazy[p]+=y;
		return ;
	}
	int mid=(l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,y);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,y);	
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)return maxn[p];
	int mid=(l+r)>>1,ans = -INF;
	if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		maxn[p] = save[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int id;
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		fa[i] = i,ed[i] = i;
	scanf("%d",&m);
	for(int i= 1;i<= m;i++)
	{
		ask[i].scanA();
		if(ask[i].o==1)
		{
			r1 = getfa(ask[i].x),r2 = getfa(ask[i].y);
			if(r1==r2)continue;
			fa[r2] = r1;
			next[ed[r1]] = r2;
			ed[r1] = ed[r2];
		}
	}
	for(int i = 1;i<= n;i++)
		if(getfa(i)==i)
			for(int j = i;j;j = next[j])
			{
				id++;
				w[j] = id;
				save[id] = a[j];
			}
	build(1,1,n);
	for(int i= 1;i<= n;i++)
		fa[i] = i,ed[i] = i;
	for(int i = 1;i<= m;i++)
	{
		if(ask[i].o==1)
		{
			r1=getfa(ask[i].x),r2=getfa(ask[i].y);
			if(r1==r2)continue;
			fa[r2] = r1;
			ed[r1] = ed[r2];
		}
		else if(ask[i].o==2)update(1,1,n,w[ask[i].x],w[ask[i].x],ask[i].y);
		else if(ask[i].o==3)update(1,1,n,w[getfa(ask[i].x)],w[ed[getfa(ask[i].x)]],ask[i].y);
		else if(ask[i].o==4)update(1,1,n,1,n,ask[i].x);
		else if(ask[i].o==5)printf("%d\n",getans(1,1,n,w[ask[i].x],w[ask[i].x]));
		else if(ask[i].o==6)printf("%d\n",getans(1,1,n,w[getfa(ask[i].x)],w[ed[getfa(ask[i].x)]]));
		else printf("%d\n",getans(1,1,n,1,n));
	}
	return 0;
}
Problem2337

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned int UI;
const int N = 105;
const double eps = 1e-8;
int n;
double f[N][N],ans[N],cnt[N];
struct E
{int next,to,val;}e[N*N*2];
int head[N],tot;
void add(int x,int y,int f)
{
	cnt[x]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void work()
{
	for(int i = 1;i< n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(f[xn],f[i]);
		for(int line = i+1;line<= n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = 1;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n-1;i>= 1;i--)
	{
		for(int j = i+1;j<= n;j++)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	int m,x,y;
	UI c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%u",&x,&y,&c);
		add(x,y,c);
		if(x!=y)add(y,x,c);
	}
	double t_ans = 0;
	for(int pos = 0;pos<32;pos++)
	{
		memset(f,0,sizeof(f));
		for(int i = 1;i< n;i++)
			for(int j = head[i];j;j = e[j].next)
			{
				if(e[j].val&(1<<pos))f[i][e[j].to]+=1.0,f[i][n+1]+=1.0;
				else f[i][e[j].to]-=1.0;
			}
		for(int i = 1;i< n;i++)
			f[i][i]+=cnt[i];
		memset(ans,0,sizeof(ans));
		work();
		t_ans+=ans[1]*(1<<pos);
	}
	printf("%.3f\n",t_ans);
	return 0;
}
Problem2338

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1505;
struct Point
{
	ll x,y;
	Point(){}
	Point(ll x,ll y):x(x),y(y){}
	bool operator ==(const Point &a)const
	{
		return (a.x==x&&a.y==y);
	}
	Point operator -(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	ll operator *(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
}poi[N];
struct Line
{
	Point *p1,*p2;
	Point midp;
	ll len;
	bool operator==(const Line &a)const
	{
		return (a.len==len&&a.midp==midp);
	}
	bool operator<(const Line &a)const
	{
		if(a.len==len)
		{
			if(a.midp.x==midp.x)
				return midp.y<a.midp.y;
			return midp.x<a.midp.x;
		}
		return len<a.len;
	}
}line[(N*N)>>1];
ll dis(const Point &p1,const Point &p2)
{
	return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);
}
ll Abs(ll x)
{
	return x>0?x:-x;
}
int tot;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld",&poi[i].x,&poi[i].y);
		for(int j = 1;j<i;j++)
		{
			line[++tot].len = dis(poi[i],poi[j]);
			line[tot].p1 = &poi[i];
			line[tot].p2 = &poi[j];
			line[tot].midp = Point(poi[i].x+poi[j].x,poi[i].y+poi[j].y);
		}
	}
	sort(line+1,line+tot+1);
	int i,j;
	ll ans = 0;
	for(i = 1;i<= tot;i++)
	{
		for(j = i-1;j&&line[j]==line[i];j--)
			ans = max(ans,Abs( ((*line[i].p1)-(*line[j].p1))*((*line[i].p1)-(*line[j].p2)) ) );
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2342

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int p[N],q[N];
char s[N];
set<int>t;
bool cmp(int a,int b)
{
	return a-p[a]<b-p[b];
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	s[0]='#';
	int maxp = 0,id = 0;
	for(int i = 1;i<= n;i++)
	{
		if(maxp>=i)p[i]=min(p[id*2-i],maxp-i);
		else p[i]=0;
		for(;s[i+p[i]+1]==s[i-p[i]];p[i]++);
		if(p[i]+i>maxp)maxp = p[i]+i,id=i;
	}
	for(int i = 1;i<= n;i++)q[i]=i;
	sort(q+1,q+n+1,cmp);
	int now = 1,ans = 0;
	for(int i = 1;i<= n;i++)
	{
		while(now<=n&&q[now]-p[q[now]]<=i)
		{
			t.insert(q[now]);
			now++;
		}
		set<int>::iterator tmp=t.upper_bound(i+p[i]/2);
		if(tmp!=t.begin())
		{
			ans=max(ans,(*--tmp-i)*4);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem2393

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3005;
int t,vis[N];
ll l,r,n,m;
ll a[N];
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
void getnum(ll x,ll y)
{
	if(y>r)
		return ;
	if(x>1)
		a[++m]=y;
	if(x>t)
		return ;
	getnum(x+1,y*10+2);
	getnum(x+1,y*10+9);
}
ll ans;
void dfs(ll x,ll y,ll z)
{
	if(x>n)
	{
		if(y&1)
			ans+=r/z-(l-1)/z;
		else
			if(y)
				ans-=r/z-(l-1)/z;
		return ;
	}
	dfs(x+1,y,z);
	ll next = a[x]*z/gcd(a[x],z);
	if(next<=r)
		dfs(x+1,y+1,next);
	return ;
}
int b[N];
int main()
{
	scanf("%lld%lld",&l,&r);
	t = (int)(log10(r)+1);
	getnum(1,0);
	sort(a+1,a+m+1);
	for(int i = 1;i<= m;i++)
		if(!vis[i])
		{
			b[++n] = a[i];
			for(int j = i+1;j<= m;j++)
				if(a[j]%a[i]==0)
					vis[j] = 1;
		}
	for(int i = 1;i<= n;i++)
		a[n-i+1]=b[i];
	dfs(1,0,1);
	printf("%lld\n",ans);
	return 0;
}
Problem2427

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 505;
struct E
{
	int next,to;
}edge[N],e[N];
int h1[N],h2[N],tot1,tot2,ind[N];
void add1(int x,int y)
{
	edge[++tot1].to = y;
	edge[tot1].next = h1[x];
	h1[x] = tot1;
}
void add2(int x,int y)
{
	ind[y]++;
	e[++tot2].to = y;
	e[tot2].next = h2[x];
	h2[x] = tot2;
}
int dep[N],low[N],dfn,stack[N],top,scc,id[N],W[N],V[N];
int w[N],v[N],n,m;
bool ins[N],vis[N];
void tarjan(int x)
{
	vis[x] = true;
	low[x] = dep[x] = ++dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = h1[x];i;i = edge[i].next)
	{
		if(!vis[edge[i].to])
			{tarjan(edge[i].to);low[x] = min(low[x],low[edge[i].to]);}
		else if(ins[edge[i].to])
			low[x] = min(low[x],dep[edge[i].to]);
	}
	if(low[x]==dep[x])
	{
		scc++;
		int tmp;
		do{
			tmp = stack[top--];
			ins[tmp] = false;
			id[tmp] = scc;
			W[scc]+=w[tmp],V[scc]+=v[tmp];
		}while(tmp!=x);
	}
}
bool map[N][N];
void rebuild()
{
	for(int i = 1;i<= n;i++)
		for(int j = h1[i];j;j = edge[j].next)
			if(id[i]!=id[edge[j].to]&&!map[id[i]][id[edge[j].to]])
			{
				add2(id[i],id[edge[j].to]);
				map[id[i]][id[edge[j].to]] = true;
			}
}
int f[N][M];
void dp(int x,int fa)
{
	if(W[x]<=m)f[x][W[x]] = V[x];
	for(int i = h2[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dp(e[i].to,x);
	for(int i = h2[x];i;i = e[i].next)
		for(int j = m;j>=0;j--)
			for(int k = 0;k<= j;k++)
				if(f[x][j-k]!=-1&&f[e[i].to][k]!=-1)
					f[x][j] = max(f[x][j],f[x][j-k]+f[e[i].to][k]);
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&v[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(x==0)continue;
		add1(x,i);
	}

	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	//printf("warning\n");
	rebuild();
	int root = 0;
	for(int i = 1;i<= scc;i++)
		if(ind[i]==0)
			add2(root,i);
	memset(f,-1,sizeof(f));
	int ans = 0;
	dp(root,-1);
	for(int i = m;i>=0;i--)
		ans = max(f[root][i],ans);
	printf("%d\n",ans);
	return 0;
}
Problem2434

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 1e5+5;
char s[N];
struct Gragh
{int next,to;}e[N<<1];
int head[N],tot,Dfn;
void add(int x,int y)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;}
struct P
{int no,x;};
int dfn[N],end[N];
void dfs(int x)
{
	dfn[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	end[x] = Dfn;
}
int c[N],id[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
vector<P>ask[N];
int ans[N];
struct AC_Machine
{
	int ch[N][26],sum[N],fail[N],from[N];
	int q[N],h,t,cnt;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i] = 1;
	}
	void insert()
	{
		scanf("%s",s);
		int now = 1,i = 0,num = 0;
		while(s[i])
		{
			if(s[i]=='P')
			{
				num++;
				id[num] = now;
				sum[now]++;i++;continue;
			}
			if(s[i]=='B'){now = from[now];i++;continue;}
			if(!ch[now][s(i)])
				{ch[now][s(i)]=++cnt;from[cnt]=now;}
			now = ch[now][s(i)];
			i++;
		}
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1,fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				q[++t] = to;
				add(fail[to],to);
			}
		}
	}
}AC;
int main()
{
	AC.insert();
	AC.build();
	dfs(1);
	int m,x,y;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		ask[y].push_back((P){i,x});
	}
	int num = 0,n = strlen(s)-1,now = 1;
	for(int i =0;i<=n;i++)
	{
		if(s[i]=='P')
		{
			num++;
			int sz = ask[num].size();
			for(int j = 0;j<sz;j++)
			{
				int x = id[ask[num][j].x];
				ans[ask[num][j].no] = getans(end[x])-getans(dfn[x]-1);
			}
			continue;
		}
		if(s[i]=='B'){update(dfn[now],-1);now = AC.from[now];continue;}
		now = AC.ch[now][s(i)];
		update(dfn[now],1);
	}
	for(int i = 1;i<= m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem2442

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long LL;
LL sum[N],f[N];
int line[N],l,r;
int main()
{
	int n,k,x;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		sum[i] = sum[i-1]+x;
	}
	line[0] = 0;
	for(int i = 1;i<= n+1;i++)
	{
		while(l<=r&&i-line[l]-1>k)l++;
		if(l<=r)
			f[i] = max(f[i],f[line[l]]-sum[line[l]]+sum[i-1]);
		while(l<=r&&f[i]-sum[i]>f[line[r]]-sum[line[r]])
			r--;
		line[++r] = i;
	}
	printf("%lld\n",f[n+1]);
	return 0;
}
Problem2453

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int C = 1e6+5;
const int INF = 0x3f3f3f3f;
int n,m;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2],*col[C];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_less(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_less(x->ls,y);
	else
	{
		if(x->ls)tmp+=x->ls->size;
		tmp+=x->cnt;
		get_less(x->rs,y);
	}
}
void get_less(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_less(root[p],y);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_less(p<<1,l,mid,a,b,y);
	if(b >mid)get_less(p<<1|1,mid+1,r,a,b,y);
}
int tt;
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)get_pre(x->ls,y);
	else
	{
		tt = max(tt,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)get_sub(x->rs,y);
	else
	{
		tt = min(tt,x->val);
		get_sub(x->ls,y);
	}
}
int pre[N],last[C],color[N];
void build(int p,int l,int r,int pos,int val)
{
	Insert(root[p],val);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,val);
	else build(p<<1|1,mid+1,r,pos,val);
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int main()
{
	scanf("%d%d",&n,&m);
	int cc = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&color[i]);
		pre[i] = last[color[i]];
		last[color[i]] = i;
		Insert(col[color[i]],i);
		cc = max(cc,color[i]);
	}
	for(int i = 1;i<= n;i++)
		build(1,1,n,i,pre[i]);
	for(int i=1;i<=1000000;i++)
		Insert(col[i],0),Insert(col[i],n+1);
	char opt[2];
	int x,y;
	while(m--)
	{
		scanf("%s%d%d",opt,&x,&y);
		if(opt[0]=='Q'){tmp = 0;get_less(1,1,n,x,y,x);printf("%d\n",tmp);}
		else
		{
			tt = INF;get_sub(col[color[x]],x);
			int nextA = tt;
			tt = 0;get_pre(col[y],x);
			int lastB = tt;
			tt = INF;get_sub(col[y],x);
			int nextB = tt;
			if(nextA!=n+1)change(1,1,n,nextA,x,pre[x]);
			change(1,1,n,x,pre[x],lastB);
			if(nextB!=n+1)change(1,1,n,nextB,lastB,x);
			Delete(col[color[x]],x);Insert(col[y],x);
			color[x] = y;
			if(nextA!=n+1)pre[nextA] = pre[x];
			pre[x] =lastB;
			if(nextB!=n+1)pre[nextB] = x;
		}
	}
	return 0;
}
Problem2460

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
typedef long long ll;
struct B
{
	ll no,val;
	bool operator <(const B &s)const
	{
		return val>s.val;
	}
}stone[N];
ll a[N],p[70];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		ll x,y;
		scanf("%lld%lld",&x,&y);
		stone[i].no = x,stone[i].val = y;
	}
	sort(stone+1,stone+1+n);
	for(int i = 1;i<= n;i++)a[i]=stone[i].no;
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 63;j>=0;j--)
			if((a[i]>>j)&1)
			{
				if(!p[j]){p[j] = a[i];break;}
				else a[i]^=p[j];
			}
		if(a[i])ans+=stone[i].val;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2467

#include <stdio.h>
int ans[]={0,4,40,300,2000,458,741,1981,1285,1458,518,842,1491,1888,1675,1662,836,929,432,1165,850,1452,1298,764,1281,1738,1411,765,473,1661,771,304,1828,645,890,803,1836,292,1174,426,1001,1367,687,793,790,117,1490,1940,213,1798,613,1320,1889,1946,333,841,85,1902,839,980,867,226,655,900,653,86,591,1753,748,1788,1187,1289,1278,625,391,327,1523,1034,363,1864,1537,882,500,1013,1644,1150,505,384,1250,893,1764,1336,1372,390,1712,1349,795,316,1348,1566,23};
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		printf("%d\n",ans[n]);
	}
	return 0;
}
Problem2500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
LL f[N],t[N],hap[N];
int Q1[N],Q2[N],f_no[N],l1,l2,r1,r2;
struct E
{
	int next,to,val;
}e[N];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		if(f[e[i].to]+e[i].val>f[x])
		{
			t[x] = f[x];
			f[x] = f[e[i].to]+e[i].val;
			f_no[x] = e[i].to;
		}else if(f[e[i].to]+e[i].val>t[x])
			t[x] = f[e[i].to]+e[i].val;
	}
}
void redfs(int x,LL v)
{
	hap[x] = max(f[x],v);
	for(int i = head[x];i;i = e[i].next)
	{
		LL tmp = f_no[x]==e[i].to?t[x]:f[x];
		redfs(e[i].to,max(v,tmp)+e[i].val);
	}
}
int main()
{
	int n,m,x,y,ans = 0;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		//if(x==i)root = i;
		add(x,i,y);
	}
	dfs(1);
	redfs(1,0);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&hap[i]>hap[Q1[r1]])r1--;
		Q1[++r1] = i;
		while(l2<=r2&&hap[i]<hap[Q2[r2]])r2--;
		Q2[++r2] = i;
		while(hap[Q1[l1]]-hap[Q2[l2]]>m)
		{
			j++;
			while(l1<=r1&&Q1[l1]<j)l1++;
			while(l2<=r2&&Q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
LL f[N],t[N],hap[N];
int Q1[N],Q2[N],f_no[N],l1,l2,r1,r2;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
struct E
{
	int next,to,val;
}e[N];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		if(f[e[i].to]+e[i].val>f[x])
		{
			t[x] = f[x];
			f[x] = f[e[i].to]+e[i].val;
			f_no[x] = e[i].to;
		}else if(f[e[i].to]+e[i].val>t[x])
			t[x] = f[e[i].to]+e[i].val;
	}
}
void redfs(int x,LL v)
{
	hap[x] = max(f[x],v);
	for(int i = head[x];i;i = e[i].next)
	{
		LL tmp = f_no[x]==e[i].to?t[x]:f[x];
		redfs(e[i].to,max(v,tmp)+e[i].val);
	}
}
int main()
{
	int n,m,x,y,ans = 0;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		x = read();y = read();
		//if(x==i)root = i;
		add(x,i,y);
	}
	dfs(1);
	redfs(1,0);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&hap[i]>hap[Q1[r1]])r1--;
		Q1[++r1] = i;
		while(l2<=r2&&hap[i]<hap[Q2[r2]])r2--;
		Q2[++r2] = i;
		while(hap[Q1[l1]]-hap[Q2[l2]]>m)
		{
			j++;
			while(l1<=r1&&Q1[l1]<j)l1++;
			while(l2<=r2&&Q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2525

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int f[N],sta[N],cnt,ans,d[N],n,m;
void dfs(int x,int fa)
{
	int nf = -1,fw= d[x]-1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			if(sta[e[i].to]==0)
				nf = max(nf,f[e[i].to]-1);
			else if(sta[e[i].to]==1)
				fw = max(fw,f[e[i].to]+1);
		}
	if(nf<fw)
	{
		if(fw==ans)
		{
			cnt++;
			f[x] = ans;
			sta[x] = 0;
		}else
		{
			f[x] = fw;
			sta[x] = 1;
		}
	}else if(nf!=-1)
	{
		f[x] = nf;
		sta[x] = 0;
	}else
	{
		f[x] = 0;
		sta[x] = 2;
	}
}
int check()
{
	int l = 0,r = n+1;
	while(l<r)
	{
		ans = (l+r)>>1;
		memset(f,0,sizeof(f));
		memset(sta,-1,sizeof(sta));
		cnt = 0;
		dfs(1,0);
		if(sta[1]==1)cnt++;
		if(cnt>m)l = ans+1;
		else r = ans;
	}
	return l;
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&d[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	printf("%d\n",check());
	return 0;
}
Problem2527

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
typedef long long LL;
struct E
{int next,to;}e[N],k[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int pos[N],Cnt,n,m,K;
void Add(int x,int y)
{
	k[++Cnt].to = y;
	k[Cnt].next = pos[x];
	pos[x] = Cnt;
}
struct A
{int l,r,mid;}ask[N];
LL c[N];
struct R
{int s,t,a;}rain[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
LL getans(int x)
{
	LL ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void UP(int i)
{
	if(rain[i].s>rain[i].t)
	{
		update(1,rain[i].a);update(rain[i].t+1,-rain[i].a);
		update(rain[i].s,rain[i].a);update(m+1,-rain[i].a);
	}else
		update(rain[i].s,rain[i].a),update(rain[i].t+1,-rain[i].a);
}
LL p[N];
void check()
{
	memset(c,0,sizeof(c));
	memset(head,0,sizeof(head));
	tot = 0;
	for(int i = 1;i<= n;i++)
	{
		ask[i].mid = (ask[i].l+ask[i].r)>>1;
		add(ask[i].mid,i);
	}
	for(int i = 1;i<= K;i++)
	{
		UP(i);
		for(int j = head[i];j;j = e[j].next)
		{
			LL ans = 0;
			for(int t = pos[e[j].to];t;t = k[t].next)
			{
				ans+=getans(k[t].to);
				if(ans>p[e[j].to])break;
			}
			if(ans<p[e[j].to])
				ask[e[j].to].l = ask[e[j].to].mid+1;
			else
				ask[e[j].to].r = ask[e[j].to].mid;
		}
	}
}
int main()
{
	//freopen("met.in","r",stdin);
	//freopen("met.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int x;
		scanf("%d",&x);
		Add(x,i);
	}
	for(int i = 1;i<= n;i++)
		scanf("%lld",&p[i]);
	scanf("%d",&K);
	for(int i = 1;i<= K;i++)
		scanf("%d%d%d",&rain[i].s,&rain[i].t,&rain[i].a);
	for(int i = 1;i<= n;i++)
		ask[i].l = 1,ask[i].r = K+1;
	for(int i = 1;i<= 20;i++)
		check();
	for(int i = 1;i<= n;i++)
	{
		if(ask[i].mid<=K)
			printf("%d\n",ask[i].mid);
		else printf("NIE\n");
	}
	return 0;
}
Problem2529

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
struct S
{int lth,col;}stick[N],a[4];
bool cmp(S a,S b)
{
	return a.lth<b.lth;
}
int main()
{
	int k,x,tot = 0;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&x);
		for(int j = 1;j<= x;j++)
		{
			tot++;
			scanf("%d",&stick[tot].lth);
			stick[tot].col = i;
		}
	}
	sort(stick+1,stick+tot+1,cmp);
	for(int i = 1;i<= tot;i++)
	{
		int j;
		for(j = 1;j<= 3;j++)
			if(stick[i].col==a[j].col)
				{a[j] = stick[i];break;}
		if(j==4)a[1] = stick[i];
		sort(a+1,a+4,cmp);
		if(a[1].col!=0)
			if(a[1].lth+a[2].lth>a[3].lth)
			{
				printf("%d %d %d %d %d %d\n",a[1].col,a[1].lth,a[2].col,a[2].lth,a[3].col,a[3].lth);
				return 0;
			}
	}
	printf("NIE\n");
	return 0;
}
Problem2530

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
bool map[N][N];
bool v[N];
int main()
{	
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y] = map[y][x] = true;
	}
	int cnt = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i])
			for(int j = i+1;j<= n;j++)
				if(!v[j]&&!map[i][j])
				{
					v[i] = v[j] = true;
					break;
				}
	for(int i = 1;i<= n;i++)
	{
		if(!v[i])
			printf("%d%c",i,++cnt==n/3?' ':'\n');
		if(cnt==n/3)break;
	}
	return 0;
}
Problem2539

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
typedef long long ll;
const int maxm=100000,inf=1061109567;
const ll mod=1000000007;
map<ll,int>id;  char str[30];   ll hash[100];
int h[100],p[maxm],c[maxm],cost[maxm],n1[maxm],q[maxm],sp[100],inq[100];
int D,n,S,T,TT,An=0,path[maxm],w[100][100],pre[100],tot=0,px[100],py[100];
inline void ae(int a,int b,int cc,int co)
{
	p[tot]=b; c[tot]=cc; cost[tot]=co;  n1[tot]=h[a]; h[a]=tot++;
	p[tot]=a; c[tot]=0;  cost[tot]=-co; n1[tot]=h[b]; h[b]=tot++;
}
inline int spfa()
{
	memset(sp,63,sizeof(sp));   
	memset(inq,0,sizeof(inq));
	int head=0,tail=1; 
	sp[S]=0; q[0]=S; 
	inq[S]=1; pre[S]=-1;
	while(head!=tail)
	{
		int u=q[head++]; 
		if(head>=maxm) 
			head-=maxm; 
		inq[u]=0;
		for(int i=h[u];~i;i=n1[i])
			if(c[i]>0&&sp[p[i]]>sp[u]+cost[i])
			{
				path[p[i]]=i, pre[p[i]]=u, sp[p[i]]=sp[u]+cost[i];
				if(!inq[p[i]])
				{ 
					inq[p[i]]=1, q[tail++]=p[i]; 
					if(tail>=maxm) 
						tail-=maxm;
				}
			}
	}
	return sp[T]!=inf;
}
inline int aug()
{
	int delta=inf,  flow=0;
	for(int i=T;pre[i]!=-1;i=pre[i]) delta=min(delta,c[path[i]]);
	for(int i=T;pre[i]!=-1;i=pre[i])
	{
		c[path[i]]-=delta, c[path[i]^1]+=delta;
		flow+=cost[path[i]]*delta;
	}
	return flow;
}
inline int cf()
{
	int ret=0; 
	while(spfa()) 
		ret+=aug(); 
	return ret;
}
inline ll gethash(char *str)
{
	ll tmp=0; int len=strlen(str);
	for(int j=0;j<len;j++) 
		if(str[j]>='A' && str[j]<='Z') 
			str[j]=str[j]+32; 
	for(int j=0;j<len;j++)
	{
		tmp=tmp*29+str[j];
		if(tmp>=mod) tmp%=mod;
	}
	return tmp;
}
inline int ok(int u,int v)
{
	if((px[u]-px[v])*(px[u]-px[v])+(py[u]-py[v])*(py[u]-py[v])>D*D) return 0;
	for(int i=1;i<=n<<1;i++)
	{
		if(i==u||i==v) continue;
		if((px[i]-px[u])*(px[i]-px[v])>0) continue;
		if((py[i]-py[u])*(py[i]-py[v])>0) continue;
		if((px[i]-px[u])*(py[v]-py[i])==(py[i]-py[u])*(px[v]-px[i])) return 0;
	}
	return 1;
}
int main()
{
	scanf("%d%d",&D,&n);
	S=0;TT=n<<1|1;T=TT+1;
	memset(h,0xff,sizeof(h));
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%s",&px[i],&py[i],str);
		px[i]+=50;py[i]+=50;
		id[hash[i]=gethash(str)]=i;
		ae(S,i,1,0);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%s",&px[n+i],&py[n+i],str);
		px[n+i]+=50;py[n+i]+=50;
		id[hash[n+i]=gethash(str)]=n+i;
		ae(n+i,T,1,0);
	}
	int u,v;
	for(int i=1;i<=n<<1;i++) 
		for(int j=1;j<=n<<1;j++) 
			w[i][j]=1;
	while(1)
	{
		scanf("%s",str);    
		if(!strcmp("End",str)) break;   
		u=id[gethash(str)];
		scanf("%s",str);    v=id[gethash(str)];
		scanf("%d",&w[u][v]);   w[v][u]=w[u][v];
	}
	for(int i=1;i<=n;i++) 
		for(int j=n+1;j<=n<<1;j++) 
			if(ok(i,j)) 
				ae(i,j,1,-w[i][j]);
	printf("%d\n",-cf()); 
	return 0;
}
Problem2547

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define vx v.x
#define ux u.x
#define vy v.y
#define uy u.y
const int N = 115;
const int INF = 0x3f3f3f3f;
int h[N][N],dis[N][N],n,m,par[N],tot,mp[N][N],cnt,pt;
struct P
{
	int x,y;
	P(int x=0,int y=0):x(x),y(y){}
}a[N],b[N];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
bool vis[N][N],bo[N];
queue<P>Q;
void spfa(int sx,int sy,int p)
{
	memset(dis,0x3f,sizeof(dis));
	dis[sx][sy]=0;
	vis[sx][sy]=true;
	Q.push(P(sx,sy));
	P u,v;
	int t;
	while(!Q.empty())
	{
		u = Q.front();
		Q.pop();
		vis[ux][uy]=false;
		for(int i = 0;i<4;i++)
		{
			vx = ux+dx[i],vy=uy+dy[i];
			if(vx<=0||vy<=0||vx>n||vy>m)continue;
			if(p^(dis[ux][uy]&1))
				{if(h[vx][vy]<=h[ux][uy])t=0;else t=1;}
			else
				{if(h[vx][vy]>=h[ux][uy])t=0;else t=1;}
			if(dis[ux][uy]+t<dis[vx][vy])
			{
				dis[vx][vy]=dis[ux][uy]+t;
				if(!vis[vx][vy])
				{
					Q.push(P(vx,vy));
					vis[vx][vy]=true;
				}
			}
		}
	}
}
bool get_partner(int x,int lim)
{
	for(int i = 1;i<= tot;i++)
		if(bo[i]&&mp[x][i]<=lim)
		{
			bo[i]=false;
			if(!par[i]||get_partner(par[i],lim))
			{
				par[i]=x;
				return true;
			}
		}
	return false;
}
bool check(int x)
{
	int tmp = 0;
	memset(par,0,sizeof(par));
	for(int i= 1;i<= cnt<<1;i++)
	{
		memset(bo,1,sizeof(bo));
		if(get_partner(i,x))tmp++;
	}
	return tmp+x>=(cnt<<1);
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&cnt,&pt);
	int x,y,t;
	for(int i = 1;i<=(cnt<<1|1);i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	for(int i = 1;i<=pt;i++)
	{
		scanf("%d%d%d",&x,&y,&t);
		while(t--)
			b[++tot].x=x,b[tot].y=y;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&h[i][j]);
	for(int i = 1;i<= cnt<<1;i++)
	{
		if(i<=cnt)spfa(a[i].x,a[i].y,0);
		else spfa(a[i].x,a[i].y,1);
		for(int j = 1;j<= tot;j++)mp[i][j]=dis[b[j].x][b[j].y];
	}
	int l = 0,r = cnt*2;
	while(l<r)
	{
		int mid =(l+r)>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem2553

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
#define s(no,i) s[no][i]-'a'
typedef long double ld;
const int P = 81;
int n,L,k;
struct Matrix
{
	int w,h;
	ld d[P][P];
	Matrix(){}
	Matrix(int _w,int _h):w(_w),h(_h){}

	void operator*=(const Matrix &S)
	{
		Matrix res(w,S.h);
		for(int i = 0;i<res.w;i++)
			for(int j = 0;j<res.h;j++)
			{
				res.d[i][j] = 0;
				for(int k = 0;k<h;k++)
					res.d[i][j]+=d[i][k]*S.d[k][j];
			}
		*this = res;
	}
};
int len[6];
char s[6][20];
bool cover(int a,int b)
{
	if(len[a]<len[b])return false;
	for(int i = 1;i+len[b]-1<=len[a];i++)
	{
		bool flag = true;
		for(int j = 1;j<= len[b];j++)
			if(s[a][i+j-1]!=s[b][j])
				{flag=false;break;}
		if(flag)return true;
	}
	return false;
}
struct AC_Machine
{
	int ch[P][26],fail[P];
	int cnt,q[P],h,t;
	bool end[P];
	void insert(int no)
	{
		int now = 0,i = 1;
		while(s[no][i])
		{
			if(!ch[now][s(no,i)])ch[now][s(no,i)] = ++cnt;
			now = ch[now][s(no,i)];
			i++;
		}
		end[now]=true;
	}
	void build()
	{
		h = 0,t = -1;
		for(int i = 0;i<k;i++)
			if(ch[0][i])
				q[++t] = ch[0][i];
		while(h<=t)
		{
			int x=q[h++];
			for(int i = 0;i<k;i++)
			{
				int j = ch[x][i];
				if(j)
				{
					q[++t] = j;
					int r = fail[x];
					while(r&&!ch[r][i])r = fail[r];
					fail[j] = ch[r][i];
					end[j]|=end[fail[j]];
				}
				else ch[x][i] = ch[fail[x]][i];
			}
		}
	}
}AC;
bool covered[6];
int main()
{
	scanf("%d%d%d",&n,&L,&k);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	for(int i = 1;i<= n;i++)
		len[i] = strlen(s[i]+1);
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			if(cover(i,j))
				covered[i] = true;
	bool a_c = true;
	for(int i = 1;i<= n;i++)
		if(!covered[i])a_c = false;
	if(a_c)covered[1] = false;
	AC.cnt = 0;
	for(int i = 1;i<= n;i++)
		if(!covered[i])
			AC.insert(i);
	AC.build();
	int cnt = AC.cnt;
	Matrix res(1,cnt+2);
	res.d[0][0] = 1;
	Matrix add(cnt+2,cnt+2);add.d[cnt+1][cnt+1] = 1;
	for(int i = 0;i<=cnt;i++)
		for(int j = 0;j<k;j++)
			if(AC.end[AC.ch[i][j]])add.d[i][cnt+1]+=(ld)1/(ld)k,add.d[i][0]+=(ld)1/(ld)k;
			else add.d[i][AC.ch[i][j]]+=(ld)1/(ld)k;
	for(;L;L>>=1,add*=add)if(L&1)res*=add;
	double ans = res.d[0][cnt+1];
	printf("%.6lf\n",ans);
	return 0;
}
Problem2555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1200005;
char s[N];
int mask;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,add_mark;
	Splay();
	void push_down();
	void Add(int x);
}*null = new Splay;
Splay :: Splay ()
{
	ls = rs = fa = null;
	val = add_mark = 0;
}
void Splay :: push_down()
{
	if(fa->ls==this||fa->rs==this)
		fa->push_down();
	if(add_mark)
	{
		ls->Add(add_mark);
		rs->Add(add_mark);
		add_mark = 0;
	}
}
void Splay :: Add(int x)
{
	val+=x;
	add_mark+=x;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa= x;
}
void splay(Splay *x)
{
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
}
void Access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		y = x,x = x->fa;
	}
}
void Cut(Splay *x)
{
	Access(x);
	splay(x);
	x->ls->fa = null;
	x->ls = null;
}
void Link(Splay *x,Splay *y)
{
	Cut(x);
	x->fa = y;
}
struct SAM
{
	int trs[N][26],fa[N],len[N];
	int cnt,last;
	Splay *tree[N];
	void init(){cnt=last=1;tree[1] = new Splay;}
	void insert(int x)
	{
		int p,newp,q,newq;
		p = last,newp = ++cnt,last = cnt;
		tree[cnt] = new Splay;
		len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)
		{
			fa[newp] = 1;
			Link(tree[newp],tree[1]);
		}
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)
			{
				fa[newp] = q;
				Link(tree[newp],tree[q]);
			}
			else
			{
				newq = ++cnt;
				tree[newq] = new Splay;
				fa[newq] = fa[q];
				Link(tree[newq],tree[fa[q]]);
				memcpy(trs[newq],trs[q],sizeof(trs[q]));
				len[newq] = len[p]+1;
				fa[newp] = fa[q] = newq;
				Link(tree[q],tree[newq]);
                Link(tree[newp],tree[newq]);
                tree[q]->push_down();
                tree[newq]->val = tree[q]->val;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = newq;
			}
		}
		Access(tree[newp]);
        splay(tree[newp]);
        tree[newp]->Add(1);
	}
	void Insert()
	{
		for(int i = 1;s[i];i++)
			insert(s[i]-'A');
	}
	int Query(char *s)
    {
        int p = 1;
        for(;p;p=trs[p][(*s++)-'A'])
            if(!*s) return tree[p]->push_down(),tree[p]->val;
        return 0;
    }
}sam;
void Decode(char s[],int mask)
{
    int i,n=strlen(s);
    for(i=0;i<n;i++)
    {
        mask=(mask*131+i)%n;
        swap(s[i],s[mask]);
    }
}
int main()
{
	int q;
	char opt[10];
	sam.init();
	scanf("%d",&q);
	scanf("%s",s+1);
	sam.Insert();
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%s",opt,s+1);
		Decode(s+1,mask);
		if(opt[0]=='A')sam.Insert();
		else
		{
			int tmp = sam.Query(s+1);
			mask^=tmp;
			printf("%d\n",tmp);
		}
	}
	return 0;
}
Problem2557

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1e6+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[N],pass[N];
int fa[N];
bool dfs(int x)
{
	for(int i=head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			used[e[i].to] = true;
			if(!fa[e[i].to]||dfs(fa[e[i].to]))
			{
				fa[e[i].to] = x;
				return true;
			}
		}
	return false;
}
int main()
{
	int n,m,r,t,k,x,y;
	scanf("%d%d%d%d%d",&n,&m,&r,&t,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	int ans1 = 0,ans2 = 0;
	for(int j = r;j<=t;j = j+r)
	{
		for(int i = 1;i<= n;i++)
			if(!pass[i])
			{
				memset(used,0,sizeof(used));
				if(dfs(i))ans1++,ans2+=j;
				else pass[i] = true;
			}
	}
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem2560

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<16;
const int mod = 1e9+7;
int c[20][20];
int f[S],g[S],n;
int main()
{
	int now;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
		for(int j = 0;j<n;j++)
			scanf("%d",&c[i][j]);
	int end = 1<<n;
	for(int i = 1;i<end;i++)
	{
		g[i] = 1;
		for(int j = 0;j<n;j++)if(i&(1<<j))
			for(int k = j+1;k<n;k++)if(i&(1<<k))
				g[i] = (ll)g[i]*(c[j][k]+1)%mod;
		for(int j = n-1;j>= 0;j--)
			if(i&(1<<j)){now = j;break;}
		f[i] = g[i];
		now = i^(1<<now);
		for(int j = now;j;j=(j-1)&now)
			(f[i]+=mod-(ll)g[j]*f[i^j]%mod)%=mod;
	}
	printf("%d\n",f[end-1]);
	return 0;
}
Problem2563

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 1e5+5;
struct E
{int next,to,val;}e[M<<1];
int head[N],tot,w[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
struct data
{
	int id,val;
	bool operator <(const data &s)const
	{
		return val>s.val;
	}
}p[N];
int main()
{
	long long ans = 0;
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]),ans-=w[i];
	int a,b,c;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c),ans-=c;
	}
	for(int i = 1;i<= n;i++)
	{
		p[i].id = i;
		p[i].val = 2*w[i];
		for(int j = head[i];j;j=e[j].next)
			p[i].val+=e[j].val;
	}
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i+=2)
		ans+=p[i].val;
	printf("%lld\n",ans);
	return 0;
}
Problem2588

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 8000005;
typedef long long ll;
struct E
{int next,to;}e[N<<1];
inline int read() 
{
	int f = 1; ll x = 0; char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) f = ch == '-' ? -1 : 1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';
	return f * x;
}
int head[N],tot,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N][20],dep[N],line[N],tail;
int cnt,root[N],ls[M],rs[M];
int sum[M],val[N],pos[N],top,ans;
int getpos(int x)
{
	int l = 1,r = top+1;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void init()
{
	for(int j = 1;j<= 18;j++)
		for(int i = 1;i<=n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 18;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 18;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void update(int &p,int l,int r,int pos,int val,int pre)
{
	p = ++cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)
		update(ls[p],l,mid,pos,val,ls[pre]);
	else
		update(rs[p],mid+1,r,pos,val,rs[pre]);
	//sum[p] = sum[ls[p]]+sum[rs[p]];
}
int a[N],b[N];
void build(int &p,int l,int r)
{
	p = ++cnt;
	if(l==r)return ;
	int mid = (l+r)>>1;
	build(ls[p],l,mid);
	build(rs[p],mid+1,r);
}
void dfs(int x)
{
	update(root[x],1,n,a[x],1,root[fa[x][0]]);
	dep[x] = dep[fa[x][0]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			fa[e[i].to][0] = x;
			dfs(e[i].to);
		}
}
void solve(int x,int y,int k)
{
	int u = getlca(x,y);
	int v = fa[u][0];
	int l = 1,r = n,ret;
	x = root[x],y = root[y],u = root[u],v = root[v];
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(sum[ls[x]]+sum[ls[y]]-sum[ls[u]]-sum[ls[v]]>=k)
		{
			x = ls[x],y = ls[y];
			u = ls[u],v = ls[v];
			r = mid;
		}else
		{
			k-=sum[ls[x]]+sum[ls[y]]-sum[ls[u]]-sum[ls[v]];
			x = rs[x],y = rs[y];
			u = rs[u],v = rs[v];
			l = mid+1;
		}
	}
	ans = b[l];
	printf("%d",ans);
}
int main()
{
	n = read();m = read();
	for(int i = 1;i<= n;i++){a[i] = read();b[i] = a[i];}
	sort(b+1,b+n+1);
	for(int i = 1;i<= n;i++)
		a[i] = lower_bound(b+1,b+n+1,a[i])-b;
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		x = read();y = read();
		add(x,y),add(y,x);
	}
	build(root[0],1,n);
	dfs(1);
	init();
	for(int i = 1;i<= m;i++)
	{
		x = read();y = read();z = read();
		x = x^ans;
		//if(x==y){ans = val[x];printf("%d",ans);}
		solve(x,y,z);
		if(i!=m)printf("\n");
	}
	return 0;
}
Problem2595

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 11;
const int S = 1<<10;
const int INF = 0x3f3f3f3f;
#define f(i,j,s1,s2) f[i][j][s1]+f[i][j][s2]
int f[N][N][S],a[N][N],n,m,K;;
struct Pair{int x,y;};
struct Tele{int x,y,s;};
int dx[4] = {0,0,1,-1};
int dy[4] = {1,-1,0,0};
Tele pre[N][N][S];
queue <Pair>Q;
bool v[N][N];
void spfa(int sta)
{
	while(!Q.empty())
	{
		Pair t = Q.front();
		Q.pop();
		v[t.x][t.y] = false;
		for(int i = 0;i<4;i++)
		{
			int xx = t.x+dx[i],yy = t.y+dy[i];
			if(xx<0||yy<0||xx>n||yy>m)continue;
			if(f[xx][yy][sta]>f[t.x][t.y][sta]+a[xx][yy])
			{
				f[xx][yy][sta] = f[t.x][t.y][sta]+a[xx][yy];
				pre[xx][yy][sta] = (Tele){t.x,t.y,sta};
				if(!v[xx][yy])
				{
					Q.push((Pair){xx,yy});
					v[xx][yy] = true;
				}	
			}
		}
	}
}
bool used[N][N];
void dfs(int x,int y,int sta)
{
	if(x>=INF||pre[x][y][sta].s==0)return ;
	used[x][y] = true;
	Tele t = pre[x][y][sta];
	dfs(t.x,t.y,t.s);
	if(t.x==x&&t.y==y)dfs(x,y,sta-t.s);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&a[i][j]);
			if(!a[i][j])K++;
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			for(int s = 0;s<1<<K;s++)
				f[i][j][s] = pre[i][j][s].x = INF;
	K = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(!a[i][j])
				{f[i][j][1<<K] = 0;K++;}
	for(int sta = 0;sta<1<<K;sta++)
	{
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= m;j++)
			{
				for(int s = sta&(sta-1);s;s = sta&(s-1))
					if(f(i,j,s,sta-s)-a[i][j]<f[i][j][sta])
					{
						f[i][j][sta] = f(i,j,s,sta-s)-a[i][j];
						pre[i][j][sta] = (Tele){i,j,s};
					}
				if(f[i][j][sta]<INF)
					{Q.push((Pair){i,j});v[i][j] = true;}
			}
		spfa(sta);
	}
	int x,y;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(!a[i][j])
				{x = i,y = j;break;}
	dfs(x,y,(1<<K)-1);
	printf("%d\n",f[x][y][(1<<K)-1]);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= m;j++)
		{
			if(!a[i][j])printf("x");
			else if(used[i][j])printf("o");
			else printf("_");
		}
		printf("\n");
	}
	return 0;
}
Problem2599

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int K = 1e6+5;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,t[K];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
bool used[N];
int sum,root,size[N],f[N],n,k;
void get_root(int x,int fa)
{
	size[x] = 1;f[x] = 0;
	for(int i = head[x];i;i =e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int dis[N],dep[N];
int ans = INF;
void get_ans(int x,int fa)
{
	if(dis[x]<=k)ans = min(ans,dep[x]+t[k-dis[x]]);
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		dep[e[i].to] = dep[x]+1;
		dis[e[i].to] = dis[x]+e[i].val;
		get_ans(e[i].to,x);
	}
}
void init(int x,int fa,int opt)
{
	if(dis[x]<=k)
	{
		if(opt)t[dis[x]] = min(t[dis[x]],dep[x]);
		else t[dis[x]] = INF;
	}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			init(e[i].to,x,opt);
}
void work(int x)
{
	used[x] = true,t[0] = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			dep[e[i].to] = 1,dis[e[i].to] = e[i].val;
			get_ans(e[i].to,0);
			init(e[i].to,0,1);
		}
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
			init(e[i].to,0,0);
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			root = 0,sum = size[e[i].to];
			get_root(e[i].to,0);
			work(root);
		}
}
int main()
{
	int x,y,z;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= k;i++)t[i]=n;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		x++,y++;
		add(x,y,z);
	}
	ans = sum = f[0] = n;
	get_root(1,0);
	work(root);
	if(ans<n)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem2600

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
int n,x;
LL p;
LL pos[N];
bool check(int len)
{
	int i,l,r,mid;
	LL now=0;
	l=1,r=len,mid=(l+r)>>1;
	for(i=l;i<mid;i++)now+=(pos[mid]-pos[i]);
	for(i=mid+1;i<=r;i++)now+=(pos[i]-pos[mid]);
	if(now<=p)return true;
	for(;r<n;)
	{
		now-=(pos[mid]-pos[l++]);
		now+=(pos[++r]-pos[mid]);
		mid=(l+r)>>1;
		now+=(pos[mid]-pos[mid-1])*(mid-l);
		now-=(pos[mid]-pos[mid-1])*(r-mid+1);
		if(now<=p)return true;
	}
	return false;
}
int main()
{
	scanf("%d%d%lld",&n,&x,&p);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&pos[i]);
	int L = 0,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(check(mid))L = mid+1;
		else R = mid;
	}
	L--;
	printf("%d\n",L);
	return 0;
}
Problem2618

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 510;
const double eps = 1e-7;
struct Point
{
	double x,y;
	Point(){}
	Point(double x,double y):x(x),y(y){}
	Point operator+(const Point &a)const
	{
		return Point(x+a.x,y+a.y);
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	double operator*(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
	Point operator*(const double &s)const
	{
		return Point(x*s,y*s);
	}
	void getp()
	{
		scanf("%lf%lf",&x,&y);
	}
}poi[N];
struct Line
{
	Point p,v;
	double alpha;
	Line(){}
	Line(const Point &a,const Point &b):p(a),v(b-a)
	{
		alpha = atan2(v.y,v.x);
	}
	bool operator<(const Line &a)const
	{
		return alpha<a.alpha;
	}
}line[N];
int n,m,tot,r,h;
Line *q[N];
double ans;
bool on_left(const Point &p,const Line &l)
{
	return (l.p-p)*l.v>=0;
}
Point get_its(const Line &l1,const Line &l2)
{
	Point u = l1.p-l2.p;
	double tmp = (l2.v*u)/(l1.v*l2.v);
	return l1.p+l1.v*tmp;
}
void Get_hpits()
{
	for(int i = 1;i<= tot;i++)
	{
		while(r-h>=2&& !on_left(get_its(*q[r],*q[r-1]),line[i]))
			q[r--]=NULL;
		if(r-h>=1&&fabs(line[i].v*q[r]->v)<=0)
			q[r] = on_left(line[i].p,*q[r])?&line[i]:q[r];
		else q[++r]=&line[i];
	}
	while(true)
	{
		if(r-h>=2&& !on_left(get_its(*q[h+1],*q[h+2]),*q[r]))
			q[++h]=NULL;
		else if(r-h>=2&& !on_left(get_its(*q[r],*q[r-1]),*q[h+1]))
			q[r--]=NULL;
		else break;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		Point fir,p1,p2;
		scanf("%d",&m);
		fir.getp();p2 = fir;
		for(int j = 2;j<= m;j++)
		{
			p1 = p2;p2.getp();
			line[++tot]=Line(p1,p2);
		}
		line[++tot] = Line(p2,fir);
	}
	sort(line+1,line+tot+1);
	Get_hpits();
	if(r-h<=2)
		return printf("0.000\n"),0;
	tot = 0;
	for(int i = h+2;i<= r;i++)
		poi[++tot] = get_its(*q[i],*q[i-1]);
	poi[++tot]=get_its(*q[r],*q[h+1]);
	for(int i = 2;i<= tot;i++)
		ans+=poi[i-1]*poi[i];
	ans+=poi[tot]*poi[1];
	printf("%.3lf\n",ans/2.0);
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
const int mod = 51061;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,sum,add,size,times;
	bool rev;
	Splay(int x);
	void push_up();
	void push_down();
	void reverse();
	void Add(int x);
	void Times(int x);
}*null = new Splay(0),*tree[N];
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	val = sum = x;
	if(x)size = 1;else size = 0;
	add = 0;rev = false;times = 1;
}
void Splay :: reverse()
{
	if(this==null)return ;
	swap(ls,rs);
	rev ^= 1;
}
void Splay :: Add(int x)
{
	if(this==null)return ;
	(val+=x)%=mod;
	(sum+=(LL)x*size%mod)%=mod;
	(add+=x)%=mod;
}
void Splay :: Times(int x)
{
	if(this==null)return ;
	times=(LL)times*x%mod;
    val=(LL)val*x%mod;
    add=(LL)add*x%mod;
    sum=(LL)sum*x%mod;
}
void Splay :: push_up()
{
	if(this==null)return ;
	size = ls->size+rs->size+1;
	sum = (ls->sum+rs->sum+val)%mod;
}
void Splay :: push_down()
{
	if(this==null)return ;
	if(this==fa->ls||fa->rs==this)
		fa->push_down();
	if(times^1)
	{
		ls->Times(times);
		rs->Times(times);
		times = 1;
	}
	if(add)
	{
		ls->Add(add);
		rs->Add(add);
		add = 0;
	}if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = false;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	//y->push_down();
	//x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	//y->push_down();
	//x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	if(x==null)return ;
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
void link(Splay *x,Splay *y)
{
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	x->fa = null;
	y->ls = null;
	y->push_up();
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
queue<int>Q;
int fa[N];
void bfs(int x)
{
	Q.push(x);
	while(!Q.empty())
	{
		int t = Q.front();
		Q.pop();
		tree[t] = new Splay(1);
		if(fa[t])
			tree[t]->fa=tree[fa[t]];
		for(int i = head[t];i;i = e[i].next)
		{
			if(e[i].to==fa[t])continue;
			Q.push(e[i].to);
			fa[e[i].to] = t;
		}
	}
}
int main()
{
	int n,q,x,y,a,b,c;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	bfs(1);
	char opt[3];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='+')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			tree[y]->Add(c);
		}else if(opt[0]=='-')
		{
			scanf("%d%d%d%d",&x,&y,&a,&b);
			cut(tree[x],tree[y]);
			link(tree[a],tree[b]);
		}else if(opt[0]=='*')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			tree[y]->Times(c);
		}else
		{
			scanf("%d%d",&x,&y);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			printf("%d\n",tree[y]->sum);
		}
	}
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 51061;
int son[N][2],fa[N],val[N],add[N],mul[N],size[N],sum[N];
bool rev[N];
bool is_root(int p)
{
	return son[fa[p]][0]!=p&&son[fa[p]][1]!=p;
}
void init(int p,int v = 0)
{
	son[p][0]=son[p][1]=fa[p]=0;
	val[p] = sum[p] = v;
	add[p] = 0,mul[p] = 1;
}
void Add(int p,int a)
{
	if(!p)return ;
	sum[p] = (sum[p]+(ll)size[p]*a%mod)%mod;
	add[p] = (add[p]+a)%mod;
	val[p] = (val[p]+a)%mod;
}
void reverse(int p)
{
	rev[p]^=1;
	swap(son[p][0],son[p][1]);	
}
void Multi(int p,int m)
{
	if(!p)return ;
	sum[p] = (ll)sum[p]*m%mod;
	val[p] = (ll)val[p]*m%mod;
	add[p] = (ll)add[p]*m%mod;
	mul[p] = (ll)mul[p]*m%mod;
}
void Push_up(int p)
{
	if(!p)return ;
	size[p] = size[son[p][0]]+size[son[p][1]]+1;
	sum[p] = (sum[son[p][0]]+sum[son[p][1]]+val[p])%mod;
}
void Push_down(int p)
{
	if(!is_root(p))
		Push_down(fa[p]);
	if(mul[p]^1)
	{
		Multi(son[p][0],mul[p]);
		Multi(son[p][1],mul[p]);
		mul[p] = 1;
	}
	if(add[p])
	{
		Add(son[p][0],add[p]);
		Add(son[p][1],add[p]);
		add[p] = 0;
	}
	if(rev[p])
	{
		reverse(son[p][0]),reverse(son[p][1]);
		rev[p] = false;
	}
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(son[z][0]==y)son[z][0] = x;
		else son[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[son[x][d^1]] = y;
	son[y][d] = son[x][d^1],son[x][d^1] = y;
	Push_up(y);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)^(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		son[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;
	son[y][0] = 0;
	Push_up(y);
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void adde(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
queue<int>Q;
int father[N];
void bfs(int rt)
{
	Q.push(rt);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		fa[x] = father[x];
		for(int i = head[x];i;i=e[i].next)
			if(father[x]!=e[i].to)
			{
				Q.push(e[i].to);
				father[e[i].to] = x;
			}
	}
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	int u,v;
	for(int i = 1;i<= n;i++)init(i,1);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		adde(u,v);
	}
	bfs(1);
	char opt[3];
	int x,y,a,b,c;
	while(q--)
	{
		scanf("%s",opt);
		if(opt[0]=='+')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(x);
			access(y);splay(y);
			Add(y,c);
		}else if(opt[0]=='-')
		{
			scanf("%d%d%d%d",&x,&y,&a,&b);
			cut(x,y);
			link(a,b);
		}else if(opt[0]=='*')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(x);
			access(y),splay(y);
			Multi(y,c);
		}else
		{
			scanf("%d%d",&x,&y);
			move_to_root(x);
			access(y),splay(y);
			printf("%d\n",sum[y]);
		}
	}
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 51061;
int ch[N][2],add[N],mul[N],size[N],fa[N],val[N],sum[N];
bool rev[N];
bool is_root(int p)
{
	return ch[fa[p]][0]!=p&&ch[fa[p]][1]!=p;
}
void init(int p,int v)
{
	ch[p][0]=ch[p][1]=fa[p]=0;
	size[p]=1;
	mul[p] = 1,add[p]=0,rev[p]=false;
	sum[p]=val[p]=v;
}
void Multiply(int p,int c)
{
	if(!p)return ;
	mul[p] = (ll)mul[p]*c%mod;
	sum[p] = (ll)sum[p]*c%mod;
	val[p] = (ll)val[p]*c%mod;
	add[p] = (ll)add[p]*c%mod;
}
void Add(int p,int c)
{
	if(!p)return ;
	(add[p]+=c)%=mod;
	(val[p]+=c)%=mod;
	(sum[p]+=(ll)size[p]*c%mod)%=mod;
}
void Reverse(int p)
{
	rev[p]^=1;
	swap(ch[p][0],ch[p][1]);
}
void Push_down(int p)
{
	if(!is_root(p))Push_down(fa[p]);
	if(mul[p]!=1)
	{
		Multiply(ch[p][0],mul[p]);
		Multiply(ch[p][1],mul[p]);
		mul[p] = 1;
	}
	if(add[p])
	{
		Add(ch[p][0],add[p]);
		Add(ch[p][1],add[p]);
		add[p] = 0;
	}
	if(rev[p])
	{
		Reverse(ch[p][0]);
		Reverse(ch[p][1]);
		rev[p] = false;
	}
}
void Push_up(int p)
{
	if(!p)return ;
	size[p] = size[ch[p][0]]+1+size[ch[p][1]];
	sum[p] = (sum[ch[p][0]]+val[p]+sum[ch[p][1]])%mod;
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		if(ch[z][1]==y)ch[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y),Push_up(x);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[y][0]==x)^(ch[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	Reverse(x);
}
void Link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void Cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;ch[y][0] = 0;
	Push_up(y);
}
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void adde(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
queue<int>Q;
void bfs()
{
	Q.push(1);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				Q.push(e[i].to);
			}
	}
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)init(i,1);
	int u,v;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		adde(u,v);
	}
	bfs();
	char opt[3];
    int x,y,a,b,c;
    while(q--)
    {
        scanf("%s",opt);
        if(opt[0]=='+')
        {
            scanf("%d%d%d",&x,&y,&c);
            move_to_root(x);
            access(y);splay(y);
            Add(y,c);
        }else if(opt[0]=='-')
        {
            scanf("%d%d%d%d",&x,&y,&a,&b);
            Cut(x,y);
            Link(a,b);
        }else if(opt[0]=='*')
        {
            scanf("%d%d%d",&x,&y,&c);
            move_to_root(x);
            access(y),splay(y);
            Multiply(y,c);
        }else
        {
            scanf("%d%d",&x,&y);
            move_to_root(x);
            access(y),splay(y);
            printf("%d\n",sum[y]);
        }
    }
	return 0;
}
Problem2654

#include<iostream>
#include<set>
#include<map>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<vector>
#include<queue>
#include<algorithm>
#include<cmath>
#define inf 1000000000
#define pa pair<int,int>
#define ll long long 
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,cnt,tot,ned;
int sumv;
int u[100005],v[100005],w[100005],c[100005];
int fa[100005];
struct edge{
	int u,v,w,c;
}e[100005];
bool operator<(edge a,edge b)
{
	return a.w==b.w?a.c<b.c:a.w<b.w;
}
int find(int x)
{
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
bool check(int x)
{
	tot=cnt=0;
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		e[i].u=u[i],e[i].v=v[i],e[i].w=w[i];e[i].c=c[i];
		if(!c[i])e[i].w+=x;
	}
	sort(e+1,e+m+1);
	for(int i=1;i<=m;i++)
	{
		int p=find(e[i].u),q=find(e[i].v);
		if(p!=q)
		{
			fa[p]=q;
			tot+=e[i].w;
			if(!e[i].c)cnt++;
		}
	}
	return cnt>=ned;
}
int main()
{
	n=read();m=read();ned=read();
	for(int i=1;i<=m;i++)
	{
		u[i]=read(),v[i]=read(),w[i]=read(),c[i]=read();
		u[i]++;v[i]++;
	}
	int l=-105,r=105;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))l=mid+1,sumv=tot-ned*mid;
		else r=mid-1;
	}
	printf("%d",sumv);
	return 0;
}
Problem2657

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
int cnt;
struct E
{int x,y,id;}edge[N<<2];
void insert(int a,int b,int i)
{
	edge[++cnt].x = a;
	edge[cnt].y = b;
	edge[cnt].id = i; 
}
bool cmp(E a,E b)
{
	if(a.x!=b.x)
		return a.x<b.x;
	return a.y<b.y;
}
struct Edge
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int max_dep,end;
void dfs(int x,int fa,int dep)
{
	if(dep>max_dep)
	{
		max_dep = dep;
		end = x;
	}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,dep+1);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n-2;i++)
	{
		int a[4];
		scanf("%d%d%d",&a[1],&a[2],&a[3]);
		sort(a+1,a+4);
		insert(a[1],a[2],i);insert(a[1],a[3],i);insert(a[2],a[3],i);
	}
	sort(edge+1,edge+cnt+1,cmp);
	for(int i = 2;i<= cnt;i++)
		if(edge[i].x==edge[i-1].x&&edge[i].y==edge[i-1].y)add(edge[i].id,edge[i-1].id);
	dfs(1,0,1);
	dfs(end,0,1);
	printf("%d\n",max_dep);
	return 0;
}
Problem2671

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int mu[N],prime[N],cnt;
bool v[N];
ll n,stack[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
		{
			mu[i] = -1;
			prime[++cnt] = i;
		}
		for(int j=1;j<= cnt&&i*prime[j]<N;j++)
		{
			v[prime[j]*i]=true;
			if(i%prime[j])mu[i*prime[j]]=-mu[i];
			else 
			{
				mu[i*prime[j]]=0;
				break;
			}
		}
	}
}
void get_fac(ll x)
{
	stack[0]=0;
	for(ll i = 1;i*i<=x;i++)
		if(x%i==0)
		{
			stack[++stack[0]] = i;
			if(i*i!=x)stack[++stack[0]]=x/i;
		}
	sort(stack+1,stack+stack[0]+1);
}
ll calc()
{
	ll a,b,k,last,ans=0;
	for(b=1;b*(b+1)<=n;b++)
	{
		get_fac(b);
		for(a=1;a<b&&b*(a+b)<=n;a=last+1)
		{
			last=min(n/(n/b/(a+b))/b-b,b-1);
			ll cnt = 0;
			for(k=1;stack[k]<=last;k++)
				cnt+=(ll)mu[stack[k]]*(last/stack[k]-(a-1)/stack[k]);
			ans+=n/b/(a+b)*cnt;
		}
	}
	return ans;
}
int main()
{
	scanf("%lld",&n);
	quick_mu();
	printf("%lld\n",calc());
	return 0;
}
Problem2683

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 500005;
struct P
{int x,y,num,opt,no;}p[N<<2],np[N<<2];
int ans[N];
bool cmp(const P &a,const P &b)
{
	if(a.x==b.x)
	{
		if(a.y==b.y)return a.no<b.no;
		return a.y<b.y;
	}
	return a.x<b.x;
}
int c[M];
void update(int x,int y)
{
	for(int i = x;i<M;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void clear(int x)
{
	for(int i = x;i<M;i+=i&(-i))
		c[i] = 0;
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)return ;
	for(int i = l;i<= r;i++)
	{
		if(p[i].no<=mid&&p[i].opt==0)
			update(p[i].y,p[i].num);
		else if(p[i].no>mid&&p[i].opt!=0)
		{
			ans[p[i].num]+=p[i].opt*getans(p[i].y);
		}
	}
	for(int i = l;i<=r;i++)
		if(p[i].no<=mid&&p[i].opt==0)
			update(p[i].y,-p[i].num);
	int t1 = l,t2 = mid+1;
	for(int i = l;i<= r;i++)
		if(p[i].no<=mid)np[t1++] = p[i];
		else np[t2++] = p[i];
	for(int i = l;i<= r;i++)
		p[i]=np[i];
	CDQ(l,mid);CDQ(mid+1,r);
}
int main()
{
	int n,opt,x,y,a,b,cnt = 0,ask = 0;
	scanf("%d",&n);
	while(scanf("%d",&opt))
	{
		if(opt==3)break;
		else if(opt==1)
		{
			scanf("%d%d%d",&x,&y,&a);
			++cnt;p[cnt] = (P){x,y,a,0,cnt};
		}else
		{
			ask++;
			scanf("%d%d%d%d",&x,&y,&a,&b);
			++cnt;p[cnt] = (P){a,b,ask,1,cnt};
			if(y!=1){++cnt;p[cnt] = (P){a,y-1,ask,-1,cnt};}
			if(x!=1){++cnt;p[cnt] = (P){x-1,b,ask,-1,cnt};}
			if(x!=1&&y!=1){++cnt;p[cnt] = (P){x-1,y-1,ask,1,cnt};}
		}
	}
	sort(p+1,p+cnt+1,cmp);
	CDQ(1,cnt);
	for(int i=1;i<= ask;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem2687

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int N = 1e6+5;
typedef long long ll;
using namespace std;
struct aa{int l, r;}a[N], b[N];
int n, now, mxp, l, flag[N];
ll ans;
bool cmp(aa a, aa b)
{
    if(a.l!=b.l)return a.l<b.l;
    return a.r>b.r;
}
ll get(int i, int j)
{
    if(b[i].r<b[j].l)return 0;
    return (ll)(b[i].r-b[j].l+1)*(b[j].r-b[i].l+1);
}
int main()
{
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
    {
    	scanf("%d%d",&a[i].l,&a[i].r);
    	a[i].r--;
    }
    sort(a+1, a+1+n, cmp);
    now=mxp=ans=0;
    for(int i=1; i<=n; i++)
    {
        if(a[i].r<=now)
        {
            flag[i]=mxp;
            ans=max(ans, (ll)(a[i].r-a[i].l+1)*(a[mxp].r-a[mxp].l+1));
        }
        else flag[i]=0;
        if(now<a[i].r){now=a[i].r; mxp=i;}
    }
    l=0;
    for(int i=1; i<=n; i++)if(!flag[i])b[++l]=a[i];
    now=2;
    for(int i=1; i<=l-1; i++)
    {
        if(now==i)now++;
        while(now<=l-1&&get(i, now)<get(i, now+1))now++;
        ans=max(ans, get(i, now));
    }
    printf("%lld", ans);
    return 0;
}
Problem2705

#include<stdio.h>
#include<math.h>
typedef long long LL;
int main()
{
	 LL n;
	 while(scanf("%lld",&n)!=EOF)
	 {
	 	LL ans = n,tmp,q,cnt;
	 	tmp = (int)sqrt(n);
	 	for(int i = 2;i<= tmp;i++)
	 	{
	 		if(n%i==0)
	 		{
	 			cnt = 0;
	 			q = i;
	 			while(n%q==0)
	 			{
	 				cnt++;
	 				n = n/q;
	 			}
	 			ans = ans+ans*cnt*(q-1)/q;
	 		}
	 	}
	 	if(n!=1) ans = ans+ans*(n-1)/n;
	 	printf("%lld\n",ans);
	 }
	 return 0;
}
Problem2708

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
int a[55],f[55];
int calc(int x,int y)
{
	for(int k = 1;k<= y-x+1;k++)
	{
		for(int j = x;j<= y-k;j++)
			if(abs(a[j]-a[j+k])>1)return k-1;
		if(abs(a[x+k-1]-a[y-k+1])<=1)return k-1;
	}
	return y-x+1;
}
int main()
{
	int n;
	while(scanf("%d",&n)!=EOF)
	{
		for(int i = 1;i<= n;i++)
			scanf("%d",&a[i]);
		sort(a+1,a+n+1);
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
			for(int j = 0;j<i;j++)
				f[i] = max(f[i],f[j]+calc(j+1,i));
		printf("%d\n",f[n]);
	}
	return 0;
}
Problem2716

#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll long long
#define inf 1000000000 
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,root,D;
struct P{
	int d[2],mn[2],mx[2],l,r;
	int& operator[](int x){return d[x];}
	P(int x=0,int y=0)
		{l=0,r=0;d[0]=x,d[1]=y;}  
}p[500005];
bool operator<(P a,P b)
{
	return a[D]<b[D];
}
inline int dis(P a,P b)
{
	return abs(a[0]-b[0])+abs(a[1]-b[1]);
}
struct kdtree{
	int ans;
	P t[1000005],T;
	void update(int k){
		P l=t[t[k].l],r=t[t[k].r];
		for(int i=0;i<2;i++)
		{
			if(t[k].l)t[k].mn[i]=min(t[k].mn[i],l.mn[i]),t[k].mx[i]=max(t[k].mx[i],l.mx[i]);
			if(t[k].r)t[k].mn[i]=min(t[k].mn[i],r.mn[i]),t[k].mx[i]=max(t[k].mx[i],r.mx[i]);
		}
	}
	int build(int l,int r,int now){
		D=now;
		int mid=(l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid]=p[mid];
		for(int i=0;i<2;i++)
			t[mid].mn[i]=t[mid].mx[i]=t[mid][i];
		if(l<mid)t[mid].l=build(l,mid-1,now^1);
		if(r>mid)t[mid].r=build(mid+1,r,now^1);
		update(mid);
		return mid;
	}
	int get(int k,P p){
		int tmp=0;
		for(int i=0;i<2;i++)
			tmp+=max(0,t[k].mn[i]-p[i]);
		for(int i=0;i<2;i++)
			tmp+=max(0,p[i]-t[k].mx[i]);
		return tmp;
	}
	void insert(int k,int now){
		if(T[now]>=t[k][now])
		{
			if(t[k].r)insert(t[k].r,now^1);
			else 
			{
				t[k].r=++n;t[n]=T;
				for(int i=0;i<2;i++)
					t[n].mn[i]=t[n].mx[i]=t[n][i];
			}
		}
		else 
		{
			if(t[k].l)insert(t[k].l,now^1);
			else 
			{
				t[k].l=++n;t[n]=T;
				for(int i=0;i<2;i++)
					t[n].mn[i]=t[n].mx[i]=t[n][i];
			}
		}
		update(k);
	}
	void query(int k,int now){
		int d,dl=inf,dr=inf;
		d=dis(t[k],T);
		ans=min(ans,d);
		if(t[k].l)dl=get(t[k].l,T);
		if(t[k].r)dr=get(t[k].r,T);
		if(dl<dr)
		{
			if(dl<ans)query(t[k].l,now^1);
			if(dr<ans)query(t[k].r,now^1);
		}
		else
		{
			if(dr<ans)query(t[k].r,now^1);
			if(dl<ans)query(t[k].l,now^1);
		}
	}
	int query(P p){
		ans=inf;T=p;query(root,0);
		return ans;
	}
	void insert(P p){
		T=p;insert(root,0);
	}
}kd;
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)p[i][0]=read(),p[i][1]=read();
	root=kd.build(1,n,0);
	while(m--)
	{
		int opt=read(),x=read(),y=read();
		if(opt==1)kd.insert(P(x,y));
		else printf("%d\n",kd.query(P(x,y)));
	}
	return 0;
}
Problem2721

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int mod = 1e9+7;
int prime[N],cnt;
bool v[N];
void quick_prime(int n)
{
	for(int i = 2;i<= n;i++)
	{
		if(!v[i])
			prime[++cnt]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	int n;
	long long ans = 1;
	scanf("%d",&n);
	quick_prime(n);
	for(int i = 1;i<= cnt;i++)
	{
		int tmp = n;
		long long cnt = 0;
		while(tmp)
		{
			cnt+=tmp/prime[i];
			tmp/=prime[i];
		}
		cnt = (cnt<<1|1)%mod;
		ans = ans*cnt%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2730

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1005;
struct E
{int next,to;}e[M];
int head[N],tot = 1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int stack[N],low[N],dfn[N],dcc,cnt,top,m,n;
bool ins[N],v[N];
int bel[N];
int ans1;
long long ans2;
void init()
{
	memset(v,0,sizeof(v));
	memset(head,0,sizeof(head));
	tot = 1,cnt = 0,dcc = 0,top = 0,n = 0;
	ans1 = 0;ans2 = 1;
	memset(bel,0,sizeof(bel));
}
void tarjan(int x,int l)
{
	dfn[x] = low[x] = ++cnt;
	//stack[++top] = x;
	v[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(v[e[i].to])low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			if(low[e[i].to]>=dfn[x])
				bel[x]++;
		}
	}
}
void tarjan1(int x,int l)
{
	dfn[x] = low[x] = ++cnt;
	stack[++top] = x;
	ins[x] = v[x] = true;
	int temp,size;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(v[e[i].to])low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan1(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			if(low[e[i].to]>=dfn[x])
			{
				temp = size = 0;
				int tmp;
				do
				{
					tmp = stack[top--];
					ins[tmp] = false;
					if(bel[tmp]>=2)
						temp++;
					size++;
				}while(tmp!=e[i].to);
				tmp = x;
				if(bel[tmp]>=2)
					temp++;
				size++;
				if(!temp)
					ans1+=2,ans2*=size*(size-1)/2;
				else if(temp==1) 
					ans1++,ans2*=size-1;
			}
		}
	}
}
int main()
{
	int x,y,T = 0;
	while(scanf("%d",&m)&&m!=0)
	{
		T++;
		init();
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
			n = max(n,max(x,y));
		}
		for(int i = 1;i<= n;i++)
			if(!v[i])
				tarjan(i,-1);
			else bel[i]++;
		memset(v,0,sizeof(v));
		cnt = 0;
		for(int i = 1;i<= n;i++)
			if(!v[i])
				tarjan1(i,-1);
		printf("Case %d: %d %lld\n",T,ans1,ans2);
	}
	return 0;
}
Problem2733

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Q = 300005;
const int N = 100005;
int root[N],ls[N*20],rs[N*20],sum[N*20],num[N],seg;
void update(int &p,int l,int r,int x)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		sum[p] = 1;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(ls[p],l,mid,x);
	else update(rs[p],mid+1,r,x);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int p,int l,int r,int x,int s)
{
	if(!p)return -1;
	if(l==r)
		return l;
	int mid = (l+r)>>1;
	if(sum[ls[p]]+s<x)
		return getans(rs[p],mid+1,r,x,sum[ls[p]]+s);
	else return getans(ls[p],l,mid,x,s);
}
int merge(int x,int y)
{
	if(!x)return y;
	if(!y)return x;
	ls[x] = merge(ls[x],ls[y]);
	rs[x] = merge(rs[x],rs[y]);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
int fa[N],rnk[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else
	{ 
		int tmp = getfa(fa[x]);
		//root[x] = merge(root[tmp],root[x]);
		return fa[x] = tmp;
	}
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx==fy)return ;
	if(rnk[fx]>rnk[fy])
	{
		fa[fy] = fx;
		root[fx] = merge(root[fx],root[fy]);
	}
	else
	{
		fa[fx] = fy,rnk[fy]+=rnk[fx]==rnk[fy];
		root[fy] = merge(root[fy],root[fx]);
	}
}
int imc[N],bri[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&imc[i]);
		bri[imc[i]] = i;
		update(root[i],1,n,imc[i]);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		uni(x,y);
	}
	int q;
	scanf("%d",&q);
	char ju[3];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",ju);
		scanf("%d%d",&x,&y);
		if(ju[0]=='B')uni(x,y);
		else
		{
			int fx = getfa(x);
			int tmp = getans(root[fx],1,n,y,0);
			if(tmp==-1)printf("-1\n");
			else printf("%d\n",bri[tmp]);
		}
	}
	return 0;
}
Problem2734

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int M = 1<<12;
const int INF = 1e8;
const LL mod = 1000000001;
bool v[N];
int a[20][13],b[20],p2[20],n;
int f[20][M];
LL calc(int x)
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	a[1][1] = x;
	for(int i = 2;i<= 18;i++)
	{
		if((a[i-1][1]<<1)<=n)
			a[i][1] = a[i-1][1]<<1;
		else a[i][1] = INF;
	}
	for(int i = 1;i<= 18;i++)
		for(int j = 2;j<= 12;j++)
		{
			if(a[i][j-1]*3<=n)
				a[i][j] = a[i][j-1]*3;
			else a[i][j] = INF;
		}
	for(int i = 1;i<= 18;i++)
		for(int j = 1;j<= 12;j++)
			if(a[i][j]<=n)
			{
				v[a[i][j]] = true;
				b[i]+=p2[j-1];
			}
	memset(f,0,sizeof(f));
	f[0][0] = 1;
	for(int i = 1;i<= 18;i++)
		for(int j = 0;j<=b[i-1];j++)
		{
			if(((j<<1)&j)||((j>>1)&j))continue;
			for(int k = 0;k<= b[i];k++)
			{
				if(((k<<1)&k)||((k>>1)&k)||(j&k))continue;
				f[i][k]=(f[i][k]+f[i-1][j])%mod;
			}
		}
	long long ans = 0;
	for(int i = 0;i<=b[18];i++)
		ans = (ans+f[18][i])%mod;
	return ans;
}
int main()
{
	for(int i = 0;i<=18;i++)
		p2[i] = 1<<i;
	scanf("%d",&n);
	LL ans = 1;
	for(int i = 1;i<= n;i++)
		if(!v[i])ans = ans*calc(i)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem2744

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
struct E
{int next,to;}e[N*N>>2];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to =y;
	e[tot].next =head[x];
	head[x]=tot;
}
int res[N],sta[N],ban[N],dfn[N];
int a[N],b[N],A,B,m,n,ans,T1,T2;
bool map[N][N];
int cnt(int x)
{
	int ans = 0;
	while(x)
		x-=x&(-x),ans++;
	return ans;
}
bool get_partner(int x)
{
	if(ban[x]==T1)return false;
	for(int i = head[x];i;i=e[i].next)
		if(ban[e[i].to]!=T1&&sta[e[i].to]!=T2)
		{
			sta[e[i].to]=T2;
			if(!res[e[i].to]||dfn[e[i].to]!=T1||get_partner(res[e[i].to]))
			{
				dfn[e[i].to]=T1;
				res[e[i].to]=x;
				return true;
			}
		}
	return false;
}
int getans(int x=0,int y=0)
{
	T1++;
	int ans = 0;
	for(int i = 1;i<= B;i++)
		if(map[x][i]||map[y][i])
			ban[i]=T1,ans++;
	for(int i = 1;i<= B;i++)
		if(b[i]&1)
		{
			++T2;
			if(get_partner(i))
				ans++;
		}
	return B-ans;
}
int main()
{
	scanf("%d%d%d",&A,&B,&m);
	for(int i = 1;i<= A;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= B;i++)scanf("%d",&b[i]);
	memset(map,true,sizeof(map));
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y]=false;
	}
	for(int i = 1;i<= B;i++)
		if(b[i]&1)
			for(int j = 1;j<= B;j++)
				if(~b[j]&1)
					if(~cnt(b[i]|b[j])&1)
						add(i,j);
	int ans;
	for(int i = 1;i<=B;i++)map[0][i]=0;
	ans=getans();
	for(int i = 1;i<=A;i++)
		ans=max(ans,getans(i)+1);
	for(int i = 1;i<= A;i++)
		if(a[i]&1)
			for(int j = 1;j<= A;j++)
				if(~a[j]&1)
					ans = max(ans,getans(i,j)+2);
	printf("%d\n",ans);
	return 0;
}
Problem2754

#include <stdio.h>
#include <map>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int s[N];
vector<int>a[20005],st[N],V,M;
bool vis[N],mark[N];
int ans1[N],ans2[N];
struct AC_Machine
{
	map<int,int>ch[N];
	int fail[N];bool end[N];
	int cnt,q[N],h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i=-1;i<=10000;i++)
            ch[0][i]=1;
        fail[1]=0;
	}
	void insert(int len,int id)
	{
		int now = 1;
		for(int i = 1;i<=len;i++)
		{
			if(!ch[now][s[i]])ch[now][s[i]]=++cnt;
			now = ch[now][s[i]];
		}
		st[now].push_back(id);
	}
	void build()
	{
		h = 0,t = -1;
		q[++t]=1,fail[0] =1;
		while(h<=t)
		{
			int x = q[h++];
			map<int,int>::iterator it;
			for(it=ch[x].begin();it!=ch[x].end();it++)
			{
				int i = it->first;
				int to = it->second;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				q[++t]=to;
			}
		}
	}
	void get(int id,int x)
	{
		for(int i = x;i;i=fail[i])
			if(!vis[i])
			{
				vis[i] = true;V.push_back(i);
				for(int j= 0;j<st[i].size();j++)
					if(!mark[st[i][j]])
					{
						mark[st[i][j]]=true;
						M.push_back(st[i][j]);
						ans1[st[i][j]]++;
						ans2[id]++;
					}
			}
			else break;
	}
	void solve(int x)
	{
		int now = 1;
		int sz = a[x].size();
		for(int i = 0;i<sz;i++)
		{
			int t = a[x][i];
			while(!ch[now][t])now = fail[now];
			now = ch[now][t],get(x,now);
		}
		for(int i= 0;i<V.size();i++)vis[V[i]] = false;
		for(int i= 0;i<M.size();i++)mark[M[i]] = false;
		V.clear();M.clear();
	}
}AC;
int main()
{
	int n,m,l;
	scanf("%d%d",&n,&m);
	for(int i= 1;i<= n;i++)
	{
		int x;
		scanf("%d",&l);
		for(int j = 1;j<= l;j++)
		{
			scanf("%d",&x);
			a[i].push_back(x);
		}
		a[i].push_back(-1);
		scanf("%d",&l);
		for(int j = 1;j<= l;j++)
		{
			scanf("%d",&x);
			a[i].push_back(x);
		}
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&l);
		for(int k =1;k<= l;k++)
			scanf("%d",&s[k]);
		AC.insert(l,i);
	}
	AC.build();
	for(int i= 1;i<= n;i++)
		AC.solve(i);
	for(int i = 1;i<= m;i++)printf("%d\n",ans1[i]);
	for(int i = 1;i<= n;i++)
	{
		printf("%d",ans2[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem2759

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
struct data
{
	int k,b;
	data(int _k=1,int _b=0):k(_k%mod),b(_b%mod){}
	data operator +(const data &s)const
	{
		data res;
		res.k = k*s.k%mod;
		res.b = (b*s.k+s.b)%mod;
		return res;
	}
	int cal(int x){x%=mod;return (k*x+b)%mod;}
};
void ex_gcd(int a,int b,int &x,int &y)
{
	if(!b)y=0,x=1;
	else
	{
		ex_gcd(b,a%b,y,x);
		y-=a/b*x;
	}
}
const int N = 6e4+5;
int ch[N][2],fa[N],sp_fa[N],size[N];
data sum[N],val[N];
bool vis[N],ins[N];
void dfs(int x)
{
	ins[x] = vis[x] = true;
	int v = fa[x];
	if(ins[v])
	{
		sp_fa[x] = v;
		fa[x] = 0;
	}
	if(!vis[v])dfs(v);
	ins[x] = false;
}
bool is_root(int x)
{
	return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;
}
void Push_up(int x)
{
	sum[x] = sum[ch[x][0]]+val[x]+sum[ch[x][1]];
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		else ch[z][1] = x;
	}
	fa[y] = x;fa[x] = z;fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y);
}
void splay(int x)
{
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[y][0]==ch[x][0])^(ch[z][0]==ch[y][0]))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
int Find_root(int x)
{
	access(x);
	splay(x);
	int rot = x;
	while(ch[rot][0])rot = ch[rot][0];
	splay(rot);return rot;
}
int Getans(int x)
{
	access(x);
	splay(x);
	data v1 = sum[x];
	int rot = Find_root(x),f = sp_fa[rot];
	access(f);splay(f);
	data v2 = sum[f];
	if(v2.k==1)return v2.b?-1:-2;
	if(v2.k==0)return v1.cal(v2.b);
	int X,Y;
	ex_gcd(v2.k-1,mod,X,Y);
	int tmp = (mod-X)%mod*v2.b%mod;
	return v1.cal(tmp);
}
void Cut(int x)
{
	access(x);
	splay(x);
	fa[ch[x][0]] = 0;
	ch[x][0] = 0;
	Push_up(x);
}
void Link(int x,int y)
{
	access(x);splay(x);
	fa[x] = y;
}
bool in_circle(int x,int rot)
{
	int f = sp_fa[rot];
	if(x==f)return true;
	access(f);
	splay(f);splay(x);
	return !is_root(f);
}
void update(int u,int f,int k,int b)
{
    access(u);
    splay(u);
    val[u]=data(k,b);
    Push_up(u);
    int ro=Find_root(u);
    if(u==ro)
    {
        int rf=Find_root(f);
        if(rf==ro)sp_fa[u]=f;
        else
        {
            sp_fa[u]=0;
            Link(u,f);
        }
    }else
    {
        if(in_circle(u,ro))
        {
            Cut(u);
            Link(ro,sp_fa[ro]);
            sp_fa[ro]=0;
            int rf=Find_root(f);
            if(rf==u)sp_fa[u]=f;
            else Link(u,f);
        }else
        {
            Cut(u);
            int rf=Find_root(f);
            if(rf==u)sp_fa[u]=f;
            else Link(u,f);
        }   
    }
}
int main()
{
	int n,k,b;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&k,&fa[i],&b);
		val[i] = sum[i] = data(k,b);
	}
	for(int i = 1;i<= n;i++)if(!vis[i])dfs(i);
	int q,x,f;
	char opt[3];
	scanf("%d",&q);
	while(q--)
	{
		scanf("%s%d",opt,&x);
		if(opt[0]=='A')printf("%d\n",Getans(x));
		else
		{
			scanf("%d%d%d",&k,&f,&b);
			update(x,f,k,b);
		}
	}
	return 0;
}
Problem2780

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int id[N],Dfn,in[N],out[N];
int c[N];
struct E
{int next,to;};
struct Gragh
{
	E e[N];
	int head[N],tot;
	void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
	void dfs(int x)
	{
		id[++Dfn] = x;
		in[x] = Dfn;
		for(int i = head[x];i;i=e[i].next)
			dfs(e[i].to);
		out[x] = Dfn;
	}
}g1,g2;
int trs[N][26],len[N],fa[N],lastins[N],ans[N];
int cnt,last;
int insert(int x)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	return last;
}
void init(){last=cnt=1;}
void build()
{
	for(int i = 1;i<= cnt;i++)
		g1.add(fa[i],i);
	g1.dfs(1);
}
struct Ask
{
	int l,r,no;
	bool operator<(const Ask &S)const
	{
		return r<S.r;
	}
}ask[N];
void update(int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
char s[360005];
int main()
{
	int n,q;
	init();
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1);
		last = 1;
		for(int j = 1;j<= l;j++)
		{
			int tmp = insert(s[j]-'a');
			g2.add(tmp,i);
		}
	}
	build();
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1),p=1;
		bool find = true;
		for(int j=1;j<=l;j++)
			if(!trs[p][s[j]-'a']){find = false;break;}
			else p = trs[p][s[j]-'a'];
		if(find)
			ask[i] = (Ask){in[p],out[p],i};
		else ask[i] = (Ask){-1,-1,i};
	}
	sort(ask+1,ask+q+1);
	int noww;
	int k=1;
	while(k<=q&&ask[k].l==-1)
		k++;
	for(int i=1;i<=cnt;i++)
	{
		for(int j=g2.head[id[i]];j;j=g2.e[j].next)
		{
			noww=g2.e[j].to;
			update(i,1);
			if(lastins[noww])
				update(lastins[noww],-1);
			lastins[noww]=i;
		}
		for(;ask[k].r==i;k++)
			ans[ask[k].no]=getans(ask[k].r)-getans(ask[k].l-1);
	}
	for(int i = 1;i<= q;i++)printf("%d\n",ans[i]);
	return 0;
}
Problem2783

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,a[N],sum[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int line[N],h,t,cnt,n,s;
multiset<int>Q;
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		sum[e[i].to] = sum[x]+a[e[i].to];
		if(Q.find(sum[e[i].to]-s)!=Q.end())cnt++;
		Q.insert(sum[e[i].to]);
		dfs(e[i].to);
		Q.erase(Q.find(sum[e[i].to]));
	}
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	Q.insert(0);
	sum[1] = a[1];
	Q.insert(sum[1]);
	dfs(1);
	printf("%d\n",cnt);
	return 0;
}
Problem2788

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 605;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool ins[N],v[N];
int dep[N],low[N],stack[N],dfn,top,bel[N],scc;
int map[N][N];
void tarjan(int x)
{
	v[x] = ins[x] = true;
	stack[++top] = x;
	dep[x] = low[x] = ++dfn;
	for(int i = head[x];i;i = e[i].next)
	{
		if(!v[e[i].to])
			{tarjan(e[i].to);low[x] = min(low[e[i].to],low[x]);}
		else if(ins[e[i].to])
			{low[x] = min(low[x],dep[e[i].to]);}
	}
	if(dep[x]==low[x])
	{
		scc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] =false;
			bel[tmp] = scc;
		}while(tmp!=x);
	}
}
int main()
{
	int n,m1,m2;
	scanf("%d%d%d",&n,&m1,&m2);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			map[i][j] = -INF;
	for(int i = 1;i<= n;i++)map[i][i] = 0;
	int x,y;
	for(int i = 1;i<= m1;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,1),add(y,x,-1);
		map[x][y] = max(map[x][y],1);
		map[y][x] = max(map[y][x],-1);
	}
	for(int i = 1;i<= m2;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,0);
		map[x][y] = max(map[x][y],0);
	}
	for(int i = 1;i<= n;i++)
		if(!v[i])
			tarjan(i);
	int t_ans = 0;
	for(int t = 1;t<= scc;t++)
	{
		for(int k = 1;k<= n;k++)
		{
			if(bel[k]!=t)continue;
			for(int i = 1;i<= n;i++)
			{
				if(bel[i]!=t||map[i][k]==-INF)continue;
				for(int j = 1;j<= n;j++)
				{
					if(bel[j]!=t||map[k][j]==-INF)continue;
					map[i][j] = max(map[i][j],map[i][k]+map[k][j]);
				}
			}
		}
		int ans = 0;
		for(int i = 1;i<= n;i++)
			if(bel[i]==t)
				for(int j = 1;j<= n;j++)
					if(bel[j]==t)
						ans = max(ans,abs(map[i][j]));
		t_ans += ans+1;
	}
	for(int i = 1;i<= n;i++)
		if(map[i][i])
		{
			printf("NIE\n");
			return 0;
		}
	printf("%d\n",t_ans);
	return 0;
}
Problem2789

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int last[30],next[N],val[N],c[N];
char s1[N],s2[N];
queue <int>Q[30];
void update(int x,int t)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=t;
}
int getans(int x)
{
	int sum = 0;
	for(int i = x;i>0;i-=i&(-i))
		sum+=c[i];
	return sum;
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s1+1);
	scanf("%s",s2+1);
	for(int i = 1;i<= n;i++)
		Q[s1[i]-'A'].push(i);
	for(int i = 1;i<= n;i++)
	{
		val[i] = Q[s2[i]-'A'].front();
		Q[s2[i]-'A'].pop();
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans+=getans(n)-getans(val[i]);
		update(val[i],1);
	}
	printf("%lld",ans);
	return 0;
}
Problem2790

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
int f[M],a[N],pre[M],sec[M];
int prime[N],cnt,v[M];
void init(int x)
{
	for(int i = 2;i<= x;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			f[i] = 1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<= x;j++)
		{
			v[prime[j]*i]= true;
			f[i*prime[j]] = f[i]+1;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	//freopen("odl.in","r",stdin);
	//freopen("odl.out","w",stdout);
	f[0] = INF;
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	init(1000000);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j*j<= a[i];j++)
		{
			if(a[i]%j==0)
			{
				if(f[a[i]]<f[a[pre[j]]])sec[j] = pre[j],pre[j] = i;
				else if(f[a[i]]<f[a[sec[j]]])sec[j] = i;
				if(f[a[i]]<f[a[pre[a[i]/j]]])sec[a[i]/j] = pre[a[i]/j],pre[a[i]/j] = i;
				else if(f[a[i]]<f[a[sec[a[i]/j]]]&&pre[a[i]/j]!=i)sec[a[i]/j] = i;
			}
		}
	}
	
	for(int i = 1;i<= n;i++)
	{
		int ans1 = 0x3f3f3f3f,ans2 = 0;
		for(int j = 1;j*j<= a[i];j++)
		{
			if(a[i]%j==0)
			{
				if(pre[j]&&sec[j]&&f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]]<ans1)
				{
					ans1 = f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]];
					ans2 = pre[j]==i?sec[j]:pre[j];
				}else if(f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]]==ans1)
					ans2 = min(ans2,pre[j]==i?sec[j]:pre[j]);
				if(pre[a[i]/j]&&sec[a[i]/j]&&f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]]<ans1)
				{
					ans1 = f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]];
					ans2 = pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j];
				}else if(f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]]==ans1)
					ans2 = min(ans2,pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]);
			}
		}
		printf("%d\n",ans2);
	}
	return 0;
}
Problem2791

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int fa[N][20];
int a[N],on_ring[N],v[N],pos[N],size[N],root[N],dep[N],n;
void dfs(int x,int id)
{
	v[x] = id;
	if(v[a[x]]==v[x])
	{
		int tmp = 1;
		for(int i = x;i!=x||tmp==1;i = a[i],tmp++)
			on_ring[i] = id,pos[i] = tmp,root[i] = i;
		size[id] = --tmp;
		return ;
	}
	if(!v[a[x]])
		dfs(a[x],id);
	if(!on_ring[x])
	{
		fa[x][0] = a[x];
		dep[x] = dep[a[x]]+1;
		root[x] = root[a[x]];
	}
}
void init()
{
	for(int j = 1;j<= 19;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 19;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 19;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int dist(int x,int y,int p)
{
	return (y-x+p)%p;
}
void solve(int x,int y)
{
	if(on_ring[root[x]]!=on_ring[root[y]])
	{
		printf("-1 -1\n");
		return ;
	}
	if(root[x]==root[y])
	{
		int lca = getlca(x,y);
		printf("%d %d\n",dep[x]-dep[lca],dep[y]-dep[lca]);
		return ;
	}
	int fx = root[x],fy = root[y];
	int x1=dep[x]+dist(pos[fx],pos[fy],size[on_ring[fx]]),y1=dep[y];
	int x2=dep[x],y2=dep[y]+dist(pos[fy],pos[fx],size[on_ring[fy]]);
	if(max(x1,y1)!=max(x2,y2))
	{
		if(max(x1,y1)<max(x2,y2))printf("%d %d\n",x1,y1);
		else printf("%d %d\n",x2,y2);
		return ;
	}
	if(min(x1,y1)!=min(x2,y2))
	{
		if(min(x1,y1)<min(x2,y2))printf("%d %d\n",x1,y1);
		else printf("%d %d\n",x2,y2);
		return ;
	}
	printf("%d %d\n",max(x1,y1),min(x1,y1));
}
int main()
{
	int q,x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int rings = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i])
		{
			rings++;
			dfs(i,rings);
		}
	init();
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&x,&y);
		solve(x,y);
	}
	return 0;
}
Problem2792

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 1e6+5;
int x[M];
int c[M];
long long l[M],r[M];
int n;
LL m;
int check(int p)
{
	memcpy(c,x,sizeof(x));
	memset(l,0,sizeof(l));
	memset(r,0,sizeof(r));
	LL tot = 0;
	for(int i = 1;i<= n-1;i++)
		if(c[i+1]-c[i]>=p)
		{
			tot+=c[i+1]-c[i]-p;
			c[i+1] = c[i]+p;
		}
	//if(c[1]>c[2]+p){tot+=c[1]-c[2]-p;c[1] = c[2]+p;}
	if(tot>m)return -1;
	for(int i = n;i>= 2;i--)
		if(c[i-1]-c[i]>=p)
		{
			tot+=c[i-1]-c[i]-p;
			c[i-1] = c[i]+p;
		}
	//if(c[n]>c[n-1]+p){tot+=c[n]-c[n-1]-p;c[n] = c[n-1]+p;}
	if(tot>m)return -1;
	LL sum =0;
	int j = 1;
	for(int i = 1;i<= n;i++)
	{
		while((i-j)*p>c[j]&&j<i)
			{sum-=c[j];j++;}
		l[i]=sum-(LL)(i-j)*(i-j+1)/2*p;
		sum+=c[i];
	}
	sum =0,j = n;
	for(int i = n;i>= 1;i--)
	{
		while((j-i)*p>c[j]&&j>i)
			{sum-=c[j];j--;}
		r[i]=sum-(LL)(j-i)*(j-i+1)/2*p;
		sum+=c[i];
	}
	for(int i = 1;i<= n;i++)
		if(tot+l[i]+r[i]+c[i]<=m)
			return i;
	return -1;
}
int main()
{
	//freopen("stu.in","r",stdin);
	//freopen("stu.out","w",stdout);
	int maxn = 0;
	scanf("%d%lld",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x[i]);
		maxn = max(maxn,x[i]);
	}
	int L = 0,R = maxn+1;
	int ans = 1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		int tmp = check(mid);
		if(tmp==-1)L = mid+1;
		else {ans = tmp;R = mid;}
	}
	printf("%d %d\n",ans,L);
	return 0;
}
Problem2793

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 1e6;
bool is_luck[N],v[N];
int mn[N],cnt;
long long ans[N];
int main()
{
	int m,x;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&x);
		is_luck[x] = true;
	}
	int n;
	long long tot = 0;
	scanf("%d",&n);
	v[0] = true;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		for(int j = 1;j<= x;j++)
		{
			while(mn[x]*x<=INF&&v[mn[x]*x])mn[x]++;
			if(mn[x]*x>INF)break;
			v[mn[x]*x] = true;
			if(is_luck[mn[x]*x])ans[++cnt] = tot+j;
		}
		tot+=x;
	}
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem2794

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int Q = 1e6+5;
const int M = 1e5+5;
struct A
{int l,r,v,id;}w[N],ask[Q];
bool cmp(A a,A b)
{
	return a.l<b.l;
}
int f[M],ans[Q];
int main()
{
	int n,q;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&w[i].v,&w[i].l,&w[i].r);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].l,&ask[i].v,&ask[i].r);
		ask[i].r+=ask[i].l;
		ask[i].id = i;
	}
	sort(w+1,w+n+1,cmp);
	sort(ask+1,ask+1+q,cmp);
	f[0] = 1e9;
	int j = 1;
	for(int i = 1;i<= q;i++)
	{
		while(w[j].l<=ask[i].l&&j<=n)
		{
			for(int k = M-5;k>= w[j].v;k--)
				f[k] = max(f[k],min(f[k-w[j].v],w[j].r));
			j++;
		}
		if(f[ask[i].v]>ask[i].r)
			ans[ask[i].id] = 1;
	}
	for(int i = 1;i<= q;i++)
	{
		if(ans[i])printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem2795

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int MOD = 23333333;
const int SED = 37;
const int N = 500005;
int nxt[N],pow[N],n;
int sum[N][26];
void init()
{
	pow[0] = 1;
	for(int i = 1;i<= n;i++)
		pow[i] = (LL)pow[i-1]*SED%MOD;
}
char s[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
int gethash(int a,int b)
{
	int lth = b-a+1;
	return (LL)(nxt[a]-(LL)nxt[b+1]*pow[lth]%MOD+MOD)%MOD;
}
int main()
{
	int a,b;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<26;j++)
			sum[i][j] = sum[i-1][j]+(s[i]==j+'a');
	for(int i = n;i>=1;i--)
		nxt[i] = ((LL)nxt[i+1]*SED+s[i]-'a')%MOD;
	init();
	int q;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&a,&b);
		int tmp = b-a+1;
		int lth = tmp;
		for(int j = 0;j<26;j++)
			tmp = gcd(tmp,sum[b][j]-sum[a-1][j]);
		int ans = lth;
		for(int j = 1;j*j<= tmp;j++)
		{
			if(tmp%j==0)
			{
				if(gethash(a,b-lth/j)==gethash(a+lth/j,b))
					ans = min(ans,lth/j);
				if(gethash(a,b-lth/(tmp/j))==gethash(a+lth/(tmp/j),b))
					ans = min(ans,lth/(tmp/j));
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem2796

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL f[100];
int solve(LL x)
{
	if(!x)return 0;
	int i = 1;
	while(f[i]<x)i++;
	if(f[i]==x)return 1;
	return solve(min(f[i]-x,x-f[i-1]))+1;
}
int main()
{
	f[1] = f[2] = 1;
	for(int i = 3;i<= 95;i++)f[i] = f[i-1]+f[i-2];
	int T;
	scanf("%d",&T);
	while(T--)
	{
		LL n;
		scanf("%lld",&n);
		printf("%d\n",solve(n));
	}
	return 0;
}
Problem2797

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
multiset<int>m;
int ans[305][305];
int t_ans[305];
int sum[90005],n,tot,cnt;
void getans(int sum3)
{
	m.clear();
	for(int i = 3;i<= tot;i++)
		m.insert(sum[i]);
	if((sum[1]+sum[2]+sum3)&1)return ;
	t_ans[1] = (sum[1]+sum[2]-sum3)>>1;
	t_ans[2] = (sum[1]+sum3-sum[2])>>1;
	t_ans[3] = (sum[2]+sum3-sum[1])>>1;
	if(t_ans[1]<=0||t_ans[2]<=0||t_ans[3]<=0)return ;
	m.erase(m.find(sum3));
	for(int i = 4;i<= n;i++)
	{
		t_ans[i] = *m.begin()-t_ans[1];
		if(t_ans[i]<=0)return ;
		for(int j = 1;j<i;j++)
		{
			int tmp = t_ans[j]+t_ans[i];
			if(m.find(tmp)==m.end())return ;
			m.erase(m.find(tmp));
		}
	}
	for(int i = 2;i<= n;i++)
		if(t_ans[i-1]>=t_ans[i])return ;
	cnt++;
	for(int i = 1;i<= n;i++)
		ans[cnt][i] = t_ans[i];
}
int main()
{
	scanf("%d",&n);
	tot = n*(n-1)/2;
	for(int i = 1;i<=tot;i++)
		scanf("%d",&sum[i]);
	sort(sum+1,sum+tot+1);
	for(int i = 3;i<= n;i++)
		if(i==3||sum[i]!=sum[i-1])
			getans(sum[i]);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = 1;j<=n;j++)
			printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
Problem2799

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int p[N],z[N],mn[N],fa[N],num[N],id[N],sum[N],cnt;
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void dfs(int x)
{
	if(mn[x])return ;
	dfs(p[x]);
	mn[x] = getfa(mn[p[x]]-1);
	if(++num[mn[x]]==1)
		id[mn[x]] = x;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)fa[i] = i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&p[i],&z[i]);
		if(p[i]==i)z[i] = n;
		if(z[i])
		{
			fa[z[i]] = z[i]-1;
			mn[i] = z[i];
		}
	}
	for(int i = 1;i<= n;i++)
		if(!mn[i])dfs(i);
	for(int i = 1;i<= n;i++)
		sum[i] = sum[i-1]+(fa[i]==i);
	for(int i = 1;i<= n;i++)
		if(num[i])
		{
			if(num[i]==1&&sum[i]==cnt+1)
				z[id[i]] = i,cnt++;
			else if(num[i]+cnt==sum[i])
				cnt = sum[i]; 
			else num[i+1]+=num[i];
		}
	for(int i = 1;i<= n;i++)
		printf("%d\n",z[i]);
	return 0;
}
Problem2801

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 500005;
const int M = 3000005;
char BB[1<<15],*K=BB,*T=BB;
#define getc() (K==T&&(T=(K=BB)+fread(BB,1,1<<15,stdin),K==T)?0:*K++)
inline long long read()
{
    long long x=0;char ch=getc();
    while(ch<'0'||ch>'9')ch=getc();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getc();
    return x;
}
struct F
{
	LL k,c;
	F()
	{k = c = 0;}
	void operator -=(const F &S)
	{k-=S.k;c-=S.c;}
}f[N];
struct E
{int next,to,val;}e[M<<1];
int head[N],tot;
LL p[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
bool v[N];
LL l,r;
LL O,V,X;
int line[N],h,t;
int dfs(int s)
{
	O = V= 0;
	h = 0,t = -1;
	l = 0,r = p[s];
	line[++t] = s;
	v[s] = true;
	f[s].k = 1,f[s].c = 0;
	while(h<=t)
	{
		int x = line[h++];
		O-=f[x].k,V+=p[x]-f[x].c;
		for(int i = head[x];i;i = e[i].next)
		{
			int j = e[i].to;
			if(!v[j])
			{
				line[++t] = j;
				v[j] = true;
				f[j].k = -f[x].k;
				f[j].c = e[i].val-f[x].c;
				if(f[e[i].to].k==1)
				{
					r=min(r,p[j]-f[j].c);
					l=max(l,-f[j].c);
				}
				else
				{
					r=min(r,f[j].c);
					l=max(l,f[j].c-p[j]);
				}
				if(r<l)return -1;
			}else
			{
				if(f[j].k==f[x].k)
				{
					X = f[j].c+f[x].c-e[i].val;
					if(X%2!=0)return -1;
					r = min(r,(e[i].val-f[x].c-f[e[i].to].c)/2/f[x].k);
					l = max(l,(e[i].val-f[x].c-f[e[i].to].c)/2/f[x].k);
					if(r<l)return -1;
				}else
				{
					if(e[i].val!=f[x].c+f[j].c)
						return -1;
				}
			}
		}
	}
	return 0;
}
int main()
{
	//freopen("bez.in","r",stdin);
	//freopen("bez.out","w",stdout);
	long long n,m,x,y,z;
	n = read(),m = read();
	for(int i = 1;i<= n;i++)
		p[i] = read();
	for(int i = 1;i<= m;i++)
	{
		x = read(),y = read(),z = read();
		add(x,y,z),add(y,x,z);
	}
	LL minn = 0,maxn = 0;
	for(int i = 1;i<= n;i++)
	{
		if(!v[i])
		{
			int tmp = dfs(i);
			if(tmp==-1){printf("NIE\n");return 0;}
			else if(O>0)
				minn+=l*O+V,maxn+=r*O+V;
			else minn+=r*O+V,maxn+=l*O+V;
		}
	}
	printf("%lld %lld\n",minn,maxn);
	return 0;
}
Problem2802

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250005;
typedef long long LL;
struct H
{int no,val;}heap[N];
LL a[N];
int ans[N],cnt;
bool cmp(H a,H b)
{
	return a.val<b.val;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		int b;
		scanf("%d",&b);
		a[i]+=a[i-1];
		if(b<=a[i])
		{
			a[i]-=b;
			heap[++cnt].val = b;
			heap[cnt].no = ++ans[0];
			ans[ans[0]] = i;
			push_heap(heap+1,heap+cnt+1,cmp);
		}else if(cnt)
		{
			int tmp = heap[1].val,pos = heap[1].no;
			if(a[i]+tmp-b>=0&&tmp>b)
			{
				pop_heap(heap+1,heap+cnt+1,cmp);
				cnt--;
				a[i] = a[i]+tmp-b;
				ans[pos] = i;
				heap[++cnt].val = b;
				heap[cnt].no = pos;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
	}
	printf("%d\n",ans[0]);
	for(int i = 1;i< ans[0];i++)
		printf("%d ",ans[i]);
	if(ans[0])printf("%d\n",ans[ans[0]]);
	return 0;
}
Problem2803

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
const int SED = 37;
int MOD[2] = {23333333,99824435};
int pre[2][N],pow[2][N],n;
char s[N];
void init()
{
	for(int i = 1;i<= n;i++)
	{
		pre[0][i] = ((LL)pre[0][i-1]*SED+s[i]-'a')%MOD[0];
		pre[1][i] = ((LL)pre[1][i-1]*SED+s[i]-'a')%MOD[1];
	}
	pow[0][0] = pow[1][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		pow[0][i] = ((LL)pow[0][i-1]*SED)%MOD[0];
		pow[1][i] = ((LL)pow[1][i-1]*SED)%MOD[1];	
	}
}
int gethash(int l,int r,int no)
{
	int lth = r-l+1;
	return (pre[no][r]-(LL)pre[no][l-1]*pow[no][lth]%MOD[no]+MOD[no])%MOD[no];
}
bool check(int l1,int r1,int l2,int r2)
{
	return gethash(l1,r1,0)==gethash(l2,r2,0)&&gethash(l1,r1,1)==gethash(l2,r2,1);
}
int main()
{
	scanf("%d",&n);
	scanf("%s",s+1);
	init();
	int ans = 0;
	for(int i = n>>1,j = 0;i>0;i--,j = min(j+2,n/2-i))
		if(check(1,i,n-i+1,n))
			for(;~j;j--)
				if(check(i+1,i+j,n-i-j+1,n-i))
				{
					ans = max(ans,i+j);
					break;
				}
	printf("%d\n",ans);
	return 0;
}
Problem2806

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2300000+5;
char s[N];
int trs[N][2],len[N],fa[N];
int cnt,last,maxlen;
void insert(int x)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
}
int mtc[N];
void match(int n)
{
	int tmp = 0,p = 1;
	for(int i = 1;i<= n;i++)
	{
		int x = s[i]-'0';
		if(trs[p][x])p=trs[p][x],tmp++;
		else
		{
			while(p&&!trs[p][x])p=fa[p];
			if(!p)tmp = 0,p=1;
			else tmp = len[p]+1,p = trs[p][x];
		}
		mtc[i] = tmp;
	}
}
int Q[N],H,T,f[N],tmp[N];
bool check(int x,int n)
{
	f[0] = 0;
	H = 0,T = -1;
	//for(int i=1;i<=n;i++)tmp[i]=i-mtc[i];
	for(int i = 1;i<= n;i++)
	{
		f[i] = f[i-1];
		int p = i-x;  
        while(p>=0&&H<=T&&f[p]-p>f[Q[H]]-Q[H])
        	H++;
		if(p>=0)Q[++T] = p;
        while(H<=T&&i-mtc[i]>Q[H])H++;  
        if(H<=T)f[i] = max(f[i], f[Q[H]]+i-Q[H]);
	}
	return f[n]*10>=n*9;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	cnt = 1;
	for(int i = 1;i<= m;i++)
	{
		last = 1;
		scanf("%s",s+1);int lth = strlen(s+1);
		maxlen = max(maxlen,lth);
		for(int j = 1;j<= lth;j++)
			insert(s[j]-'0');
	}
	while(n--)
	{
		scanf("%s",s+1);
		int lth = strlen(s+1);
		match(lth);
		int l = 0,r = lth,ans=0;
		while(l<=r)
		{
			int mid = (l+r)>>1;
			if(check(mid,lth))l=mid+1,ans = mid;
			else r=mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem2809

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
int n,tot_root,b;
long long m;
struct Heap{
	Heap *ls,*rs;
	int key;
	Heap(int f)
	{
		ls = rs = NULL;
		key = f;
	}
};
Heap* Merge(Heap *x,Heap *y)
{
	if(!x)return y;
	if(!y)return x;
	if(y->key>x->key)
		swap(x,y);
	if(rand()%2==1)
		x->ls = Merge(x->ls,y);
	else 
		x->rs = Merge(x->rs,y);
	return x;
}
struct e
{int next,to;}edge[100005];
int head[100005],tot;
long long c[100005],l[100005],tc[100005],tp[100005];
Heap *h[100005];
void add(int x,int y)
{
	edge[++tot].to = y;
	edge[tot].next = head[x];
	head[x] = tot;
}
long long ans = 0;
void dfs(int x)
{
	Heap *root = new Heap(c[x]);
	tc[x]+=c[x];tp[x]++;
	for(int i = head[x];i;i = edge[i].next)
	{
		dfs(edge[i].to);
		root = Merge(root,h[edge[i].to]);
		tc[x]+=tc[edge[i].to];
		tp[x]+=tp[edge[i].to];
	}
	while(tc[x]>m)
	{
		tc[x]-=root->key;
		root = Merge(root->ls,root->rs);
		tp[x]--;
	}
	ans = max(ans,(long long)tp[x]*l[x]);
	h[x] = root;
}
int main()
{
	scanf("%d%lld",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%lld%lld",&b,&c[i],&l[i]);
		if(b==0)tot_root = i;
		else add(b,i);
	}
	dfs(tot_root);
	printf("%lld",ans);
	return 0;
}
Problem2813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e7+5;
const int mod = 1e9+7;
bool v[N];
int f[N],g[N],prime[N],e[N],d[N],cnt;
int main()
{
	int q1,a,b,c;
	int q;
	scanf("%d%d%d%d%d",&q,&q1,&a,&b,&c);
	f[1] = g[1] = 1;
	for(int i = 2;i<= c;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			e[i] = d[i] = 1;
			g[i] = 2;
			f[i]=((LL)i*i+1)%mod;
		}
		int k;
		for(int j = 1;j<= cnt&&(k=i*prime[j])<=c;j++)
		{
			v[k] = true;
			if(i%prime[j]==0)
			{
				e[k] = e[i]+1;
				g[k] = (g[i]/e[k])*(e[k]+1);
				d[k] = d[i];
				f[k] = ((LL)f[i]*prime[j]%mod*prime[j]%mod+f[d[i]])%mod;
			}else
			{
				e[k] = 1;
				d[k] = i;
				g[k] = g[i]*2;
				f[k] = (LL)f[i]*((LL)prime[j]*prime[j]%mod+1)%mod;
			}
		}
	}
	int ans1 = 0,ans2 = 0;
	for(int i = 1;i<= q;i++)
	{
		(ans1+=g[q1]+(q1&1))%=mod;
		(ans2+=f[q1]+4*(q1&1))%=mod;
		q1 = ((LL)q1*a+b)%c+1;
	}
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e7+5;
const int mod = 1e9+7;
bool v[N];
int f[N],g[N],prime[N],e[N],d[N],cnt;
int main()
{
	int q1,a,b,c;
	int q;
	scanf("%d%d%d%d%d",&q,&q1,&a,&b,&c);
	f[1] = g[1] = 1;
	for(int i = 2;i<= c;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			e[i] = d[i] = 1;
			g[i] = 2;
			f[i]=((LL)i*i+1)%mod;
		}
		int k;
		for(int j = 1;j<= cnt&&(k=i*prime[j])<=c;j++)
		{
			v[k] = true;
			if(i%prime[j]==0)
			{
				e[k] = e[i]+1;
				g[k] = (g[i]/e[k])*(e[k]+1);
				d[k] = d[i];
				f[k] = ((LL)f[i]*prime[j]%mod*prime[j]%mod+f[d[i]])%mod;
				break;
			}else
			{
				e[k] = 1;
				d[k] = i;
				g[k] = g[i]*2;
				f[k] = (LL)f[i]*((LL)prime[j]*prime[j]%mod+1)%mod;
			}
		}
	}
	int ans1 = 0,ans2 = 0;
	for(int i = 1;i<= q;i++)
	{
		(ans1+=g[q1]+(q1&1))%=mod;
		(ans2+=f[q1]+4*(q1&1))%=mod;
		q1 = ((LL)q1*a+b)%c+1;
	}
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2815

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 65534+5;
struct E
{int next,to;}e1[N<<4],e2[N<<1],ef[N<<4];
int he[N],ht[N],hf[N],tote,tott,fa[N][17],ind[N],dep[N];
void adde(int x,int y)
{
	ind[y]++;
	e1[++tote].to = y;
	e1[tote].next = he[x];
	he[x] = tote;
	ef[tote].to = x;
	ef[tote].next = hf[y];
	hf[y] = tote;
}
void addt(int x,int y)
{
	e2[++tott].to = y;
	e2[tott].next = ht[x];
	ht[x] = tott;
	e2[++tott].to = x;
	e2[tott].next = ht[y];
	ht[y] = tott;
}
queue <int>Q;
int line[N],cnt,n;
void addleaf(int x,int y)
{
	dep[x] = dep[y]+1;fa[x][0] = y;
	for(int i = 1;i<17;i++)
		fa[x][i] = fa[fa[x][i-1]][i-1];
}
int getlca(int x,int y)
{
	if(x<0)return y;
	if(dep[x]<dep[y])swap(x,y);
	for(int j = 16;j>=0;j--)
		if(dep[fa[x][j]]>=dep[y])
			x = fa[x][j];
	if(x==y)return x;
	int re;
	for(int j = 16;j>=0;j--)
	{
		if(fa[x][j]!=fa[y][j])
		{
			x = fa[x][j];
			y = fa[y][j];
		}else re = fa[x][j];
	}
	return re;
}
void topo()
{
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i),addt(0,i),dep[i] = 1;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = he[x];i;i = e1[i].next)
		{
			--ind[e1[i].to];
			if(!ind[e1[i].to])
			{
				Q.push(e1[i].to);
				line[++cnt] = e1[i].to;
			}
		}
	}
}
void build(int x)
{
	int tmp = -1;
	for(int i = hf[x];i;i = ef[i].next)
		tmp = getlca(tmp,ef[i].to);
	addt(tmp,x);
	addleaf(x,tmp);
}
int size[N];
void dfs(int x,int fa)
{
	size[x]++;
	for(int i = ht[x];i;i = e2[i].next)
		if(e2[i].to!=fa)
		{
			dfs(e2[i].to,x);
			size[x]+=size[e2[i].to];
		}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		int x;
		while(scanf("%d",&x))
		{
			if(x==0)break;
			adde(x,i);
		}
	}
	topo();
	for(int i = 1;i<= cnt;i++)
		build(line[i]);
	dfs(0,-1);
	for(int i = 1;i<= n;i++)
		printf("%d\n",size[i]-1);
	return 0;
}
Problem2818

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long sum_oula[10000005];
long long oula[10000005];
int prime[1000005],t_p,n;
bool v[10000005];
void quick_oula()
{
	oula[1] = 1;
	for(int i = 2;i<= n;i++)
	{
		if(!v[i])
		{
			t_p++;
			prime[t_p] = i;
			oula[i] = i - 1;
		}
		for(int j = 1;j<= t_p&&i*prime[j]<=n;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j]==0)
			{
				oula[i*prime[j]] = oula[i]*prime[j];
				break;
			}
			else 
				oula[i*prime[j]] = oula[i]*(prime[j]-1);
		}
	}
	for(int i = 1;i<= n;i++)
		sum_oula[i] = sum_oula[i-1]+oula[i];
}
int main()
{
	memset(prime,0x3f,sizeof(prime));
	scanf("%d",&n);
	quick_oula();
	int j = 1;long long ans = 0;
	while(prime[j]<=n)
	{
		ans +=sum_oula[n/prime[j]];
		j++;
	}
	ans = ans*2-j+1;
	printf("%lld",ans);
	return 0;
}
Problem2820

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int prime[N/10],mu[N],sum[N],g[N],cnt;
bool vis[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<=cnt;i++)
		for(int j = 1;j*prime[i]<N;j++)
			g[j*prime[i]]+=mu[j];
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+g[i];
}
void solve(int n,int m)
{
	ll ans = 0;
	int last;
	for(int i = 1;i<=n&&i<=m;i = last+1)
	{
		last = min(m/(m/i),n/(n/i));
		ans+=(ll)(n/i)*(m/i)*(sum[last]-sum[i-1]);
	}
	printf("%lld\n",ans);
}
int main()
{
	int t;
	scanf("%d",&t);
	quick_mu();
	while(t--)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		solve(x,y);
	}
	return 0;
}
Problem2879

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 3e6+5;
const int INF = 0x3f3f3f3f;
int p[45],P,m,n,from[N];
int t[45][105];
struct E
{int next,to,c,f,from;}e[M];
int head[N],tot=1,st,end;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f;e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0;e[tot].c=-c;
	e[tot-1].from=x;e[tot].from=y;
}
int dis[N];bool v[N];
queue<int>Q;
bool spfa()
{
	memset(dis,0x3f,sizeof(dis));
	Q.push(st);
	dis[st]=0,v[st]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].c&&e[i].f)
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[end]!=INF;
}
int ans;
void mcf()
{
	int x = INF,a,b,y;
	for(int i = from[end];i;i=from[e[i].from])
	{
		x = min(x,e[i].f);
		if(e[i].from==0)
		{
			y = e[i].to;
			a = (y-1)/P+1;b = y%P+1;
		}
	}
	for(int i = from[end];i;i=from[e[i].from])
	{
		e[i].f-=x;e[i^1].f+=x;ans+=e[i].c*x;
	}
	for(int i = 1;i<= m;i++)
		add((a-1)*P+b,n*P+i,1,b*t[i][a]);
}
int main()
{
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&p[i]);
		P+=p[i];
	}
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			scanf("%d",&t[i][j]);
	st = 0,end = n*P+m+1;
	for(int i = 1;i<= n*P;i++)
		add(st,i,1,0);
	for(int i = 1;i<= m;i++)
		add(n*P+i,end,p[i],0);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			add((i-1)*P+1,n*P+j,1,t[j][i]);
	while(spfa())mcf();
	printf("%d\n",ans);
	return 0;
}
Problem2888

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 40005;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,ans,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int son[N][2],sum[N],fa[N],size[N],lazy[N],val[N],s[N],d[N];
bool rev[N];
inline bool is_root(int x)
{
	return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;
}
inline void reverse(int x)
{
	rev[x]^=1;
	swap(son[x][0],son[x][1]);
}
inline void init(int x,int f)
{
	fa[x] = f;
	son[x][0] = son[x][1] = val[x] = lazy[x] = 0;
	sum[x] = s[x] = d[x] = 0;size[x] = 1;
}
inline void Push_up(int x)
{
	if(!x)return ;
	size[x] =size[son[x][0]]+1+size[son[x][1]];
}
inline void Add(int x,int y)
{
	if(!x)return ;
	val[x]+=y;
	lazy[x]+=y;
}
inline void update(int x,int S,int D)
{
	if(!x)return ;
	sum[x]+=S+size[son[x][1]]*D;
	s[x]+=S,d[x]+=D;
}
inline void Push_down(int x)
{
	int ls = son[x][0],rs = son[x][1];
	if(rev[x])
	{
		reverse(ls);
		reverse(rs);
		rev[x] = 0;
	}
	if(lazy[x])
	{
		Add(ls,lazy[x]),Add(rs,lazy[x]);
		lazy[x] = 0;
	}
	if(d[x])
	{
		update(ls,s[x]+(size[rs]+1)*d[x],d[x]);
		update(rs,s[x],d[x]);
		s[x] = d[x] = 0;
	}
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(y==son[z][0])son[z][0] = x;
		else son[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[son[x][d^1]] = y;
	son[y][d] = son[x][d^1],son[x][d^1] = y;
	Push_up(x),Push_up(y);
}
int stack[N],top;
void splay(int x)
{
	top = 0;
	stack[++top] = x;
	for(int i = x;!is_root(i);i = fa[i])stack[++top] = fa[i];
	while(top)Push_down(stack[top--]);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)!=(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		son[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
int find(int x)
{
	access(x);
	splay(x);
	while(son[x][0])
		x = son[x][0];
	return x;
}
void insert(int f,int x)
{
	init(x,f);
	f = find(f);access(x);splay(f);
	Add(f,1);
	update(f,0,1);
	x = son[f][1];
	while(son[x][0])
		x = son[x][0];
	splay(x);
	int v1 = val[f],v2= val[x];
	if(v2*2>v1)
	{
		val[x] = v1,val[f]-=v2;
		sum[f]-=sum[x]+v2;sum[x]+=sum[f]+v1-v2;
		access(x);splay(f);
		son[f][0] = x;son[f][1] = 0;
	}
}
void dfs(int x,int f)
{
	insert(f,x);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=f)dfs(e[i].to,x);
}
void Link(int x,int y)
{
	add(x,y),add(y,x);
	int p = find(x),q = find(y);
	ans-=sum[p]+sum[q];
	if(val[p]<val[q])swap(x,y);
	dfs(y,x);
	ans+=sum[find(x)];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)val[i]=size[i]=1;
	char opt[3];
	int a,b;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='A'){scanf("%d%d",&a,&b);Link(a,b);}
		else printf("%d\n",ans);
	}
	return 0;
}
Problem2929

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int M = 8e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].flow = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].flow = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow&&d[e[i].to]==d[s]-1)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF))!=0)
			ans+=nowflow;
	return ans;
}
int main()
{
	int n,m,x;
	scanf("%d",&n);
	int st = 1,end = n;
	for(int i = 1;i< n;i++)
	{
		scanf("%d",&m);
		if(i==1)
			while(m--)
			{
				scanf("%d",&x);
				add(1,x,1);
			}
		else
			while(m--)
			{
				scanf("%d",&x);
				if(x!=n)add(i,x,INF);
				else add(i,n,1);
			}
	}
	printf("%d\n",dinic(st,end));
	return 0;
}
Problem2938

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int s[N];char str[N];
bool ins[N],vis[N];
struct AC_Machine
{
	int ch[N][2],fail[N];bool end[N];
	int cnt,q[N],h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<2;i++)
			ch[0][i] = 1;
	}
	void insert(int len)
	{
		int now = 1;
		for(int i = 1;i<=len;i++)
		{
			if(!ch[now][s[i]])ch[now][s[i]]=++cnt;
			now = ch[now][s[i]];
		}
		end[now] = true;
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1,fail[0] = 1;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<2;i++)
			{
				int j = ch[x][i];
				if(!j)
				{
					ch[x][i]=ch[fail[x]][i];
					continue;
				}
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[j] = ch[k][i];
				end[j]|=end[fail[j]];
				q[++t]=j;
			}
		}
	}
	bool dfs(int x)
	{
		ins[x] = true;
		for(int i = 0;i<2;i++)
		{
			int v = ch[x][i];
			if(ins[v])return true;
			if(vis[v]||end[v])continue;
			vis[v] = true;
			if(dfs(v))return true;
		}
		ins[x] = false;
		return false;
	}
}AC;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",str+1);
		int len = strlen(str+1);
		for(int j = 1;j<= len;j++)
			s[j] = str[j]-'0';
		AC.insert(len);
	}
	AC.build();
	if(AC.dfs(1))printf("TAK\n");
	else printf("NIE\n");
	return 0;
}
Problem2960

#include <stdio.h>
#include <set>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e4+5;
struct Point 
{
	int x,y;
	Point(int _x=0,int _y=0):x(_x),y(_y){}
	void read(){scanf("%d%d",&x,&y);}
	int operator *(const Point &s)const
	{
		return x*s.y-y*s.x;
	}
}p[N];
struct E
{
	int x,y;
	double alp;
	E(int _x=0,int _y=0):x(_x),y(_y)
	{
		alp = atan2(p[_y].x-p[_x].x,p[_y].y-p[_x].y);
	}
}e[N];
struct Edge
{
	int x,y,v;
	Edge(int _x=0,int _y=0,int _v=0):x(_x),y(_y),v(_v){}
}ed[N];
int bel[N],cnt,tp=1;
int w[N];
struct Pic_to_Gra
{
	struct cmp
	{
		bool operator()(const int &a,const int &b)
			{return e[a].alp<e[b].alp;}
	};
	set<int,cmp>g[N];
	set<int>::iterator it;
	bool del[N];
	int q[N];
	void Insert(int x,int y){g[x].insert(y);}
	void work()
	{
		int t,j;
		for(int i = 2;i<=tp;i++)
			if(!del[i])
			{
				t = 1;
				q[t] = j = i;
				while(true)
				{
					it = g[e[j].y].find(j^1);
					it++;
					if(it==g[e[j].y].end())it = g[e[j].y].begin();
					if(*it==i)break;
					q[++t] = j = *it;
				}
				int s= 0;
				for(j=1;j<=t;j++)s+=p[e[q[j]].x]*p[e[q[j]].y];
				++cnt;
				for(j=1;j<=t;j++)del[q[j]]=true,bel[q[j]]=cnt;
			}
	}
}p2g;
struct Minimum_Tree_Gragh
{
	int pre[N],id[N],in[N],vis[N];
	int work(int root,int n,int m)
	{
		int tn,tm,ans = 0;
		while(true)
		{
			for(int i = 1;i<= n;i++)in[i]=INF,pre[i]=0;
			for(int i = 1;i<= m;i++)
				if(ed[i].v<in[ed[i].y])
				{
					in[ed[i].y] = ed[i].v;
					pre[ed[i].y] = ed[i].x;
				}
			tn = tm = in[root] = 0;
			for(int i = 1;i<= n;i++)id[i]=vis[i] = 0;
			for(int v,i = 1;i<= n;i++)
			{
				ans+=in[v=i];
				while(vis[v]!=i&&!id[v]&&v!=root)vis[v]=i,v=pre[v];
				if(v!=root&&!id[v])
				{
					id[v] = ++tn;
					for(int u = pre[v];u!=v;u=pre[u])id[u]=tn;
				}
			}
			if(!tn)break;
			for(int i = 1;i<= n;i++)if(!id[i])id[i]=++tn;
			for(int i = 1;i<= m;i++)
				if(id[ed[i].x]!=id[ed[i].y])
					ed[++tm] = Edge(id[ed[i].x],id[ed[i].y],ed[i].v-in[ed[i].y]);
			n = tn,m = tm,root = id[root];
		}
		return ans;
	}
	void solve()
	{
		int n = cnt+1,root = cnt+1,m=0,sum = 0;
		for(int i = 2;i<= tp;i++)
			if(bel[i]&&bel[i^1]&&w[i])
			{
				ed[++m] = Edge(bel[i],bel[i^1],w[i]);
				sum+=w[i];
			}
		for(int i = 1;i<= cnt;i++)ed[++m] = Edge(root,i,sum);
		printf("%d\n",work(root,n,m)-sum);
	}
}mtg;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)p[i].read();
	for(int i = 1;i<= m;i++)
	{
		int u,v;
		scanf("%d%d%d%d",&u,&v,&w[i*2],&w[i*2+1]);
		e[++tp] = E(u,v),p2g.Insert(u,tp);
		e[++tp] = E(v,u),p2g.Insert(v,tp);
	}
	p2g.work();
	mtg.solve();
	return 0;
}
Problem2961

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const double INF = 1e11;
const int N = 5e5+500;
struct Point
{
	double x,y;
	Point(){}
	Point(double _x,double _y):x(_x),y(_y){}
};
struct Qurey
{
	int type,id;
	Point a;
	double k;
	Qurey(){}
	Qurey(int _type,double _x,double _y,int _id):type(_type),id(_id)
	{
		a.x = _x,a.y = _y;
		if(fabs(a.y)<eps)
			k = INF;
		else 
			k = -a.x/a.y;
	}
	bool operator <(const Qurey &s)const
	{
		return k<s.k;
	}
}q[N],nq[N];
double Distance(const Point &a,const Point &b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
double Slope(const Point &a,const Point &b)
{
	if(fabs(a.x-b.x)<eps)
		return INF;
	return (b.y-a.y)/(b.x-a.x);
}
int n,cnt,stk1[N],stk2[N];
bool ap[N];
void solve(int l,int r)
{
	if(l==r)return ;
	int mid = (l+r)>>1;
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
	{
		if(q[i].id<=mid)
			nq[l1++]=q[i];
		else 
			nq[l2++]=q[i];
	}
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	solve(l,mid);
	int top1 = 0,top2 = 0;
	for(int i = l;i<= mid;i++)
	{
		if(q[i].type==1)continue;
		while(top1>1 && Slope(q[stk1[top1-1]].a,q[i].a)+eps>Slope(q[stk1[top1-1]].a,q[stk1[top1]].a))
			top1--;
		stk1[++top1] = i;
		while(top2>1 && Slope(q[stk2[top2-1]].a,q[i].a)<Slope(q[stk2[top2-1]].a,q[stk2[top2]].a)+eps)
			top2--;
		stk2[++top2] = i;
	}
	int j = 1;
	for(int i = mid+1;i<= r;i++)
	{
		if(q[i].type==0)continue;
		if(q[i].a.y<eps)
		{
			while(top1>1&&Slope(q[stk1[top1-1]].a,q[stk1[top1]].a)<q[i].k)
				top1--;
			if(top1>0&&Distance(q[stk1[top1]].a,q[0].a)<Distance(q[stk1[top1]].a,q[i].a))
				ap[q[i].id]=false;
		}else
		{
			while (j<top2 && Slope(q[stk2[j]].a,q[stk2[j+1]].a)<q[i].k)
				j++;
            if (j<=top2 && Distance(q[stk2[j]].a,q[0].a)<Distance(q[stk2[j]].a,q[i].a)) 
            	ap[q[i].id]=false;
		}
	}
	solve(mid+1,r);
	l1 = l,l2 = mid+1;
	for (int i = l;i<= r;i++)
        if (l1<=mid && q[l1].a.x<q[l2].a.x || l2>r)
        	nq[i]=q[l1++]; 
        else nq[i]=q[l2++];
    for (int i=l; i<=r; i++) q[i]=nq[i];
}
bool cmp(const Qurey &a,const Qurey &b)
{
	return a.id<b.id;
}
int main()
{
	int type;
	double x,y;
	scanf("%d",&n);
	bool flag = false;
	q[0].a = Point(0,0);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%lf%lf",&type,&x,&y);
		q[i] = Qurey(type,x,y,i);
		if(!q[i].type)flag = true;
		ap[i]=flag;
	}
	sort(q+1,q+n+1);
	solve(1,n);
	sort(q+1,q+n+1,cmp);
	for(int i = 1;i<= n;i++)
		if(q[i].type)
			puts(ap[i]?"Yes":"No");
	return 0;
}
Problem2962

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int mod = 19940417;
const int nmd = 17091780;
const int N = 50050;
const int INF = 1e9+5;
int fac[N],env[N];
int calc[N][25];
void init()
{
	calc[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		calc[i][0] = 1;
		for(int j = 1;j<= 20;j++)
			calc[i][j] = (calc[i-1][j-1]+calc[i-1][j])%mod;
	}
	return ;
}
int f[N<<2][21],la[N<<2],lf[N<<2];
void push_up(int p,int l,int r)
{
	int len = (r-l+1);
	int end = min(len,20);
	for(int i = 1;i<= end;i++)
	{
		f[p][i] = 0;
		for(int j = 0;j<=i;j++)
			(f[p][i]+=((LL)f[p<<1][j]*f[p<<1|1][i-j])%mod+mod)%=mod;
	}
}
int powx[21];
void push_down(int p,int l,int r)
{
	if(l==r||(lf[p]==0&&la[p]==0))return ;
	int mid = (l+r)>>1;
	if(lf[p])
	{
		for(int i = 1;i<=19;i+=2)
		{
			f[p<<1][i] = (mod-f[p<<1][i])%mod;
			f[p<<1|1][i] = (mod-f[p<<1|1][i])%mod;
		}
		lf[p<<1] = lf[p<<1]^lf[p],lf[p<<1|1] = lf[p<<1|1]^lf[p];
		la[p<<1] = (mod-la[p<<1])%mod,la[p<<1|1] = (mod-la[p<<1|1])%mod;
	}
	if(la[p])
	{
		powx[0] = 1;
		for(int i = 1;i<= 20;i++)
			powx[i] = (LL)powx[i-1]*la[p]%mod;
		for(int i = 20;i>= 1;i--)
			for(int j = 1;j<= i;j++)
			{
				(f[p<<1][i] += (LL)f[p<<1][i-j]*powx[j]%mod*calc[mid-l+1-i+j][j]%mod+mod)%=mod;
				(f[p<<1|1][i] += (LL)f[p<<1|1][i-j]*powx[j]%mod*calc[r-mid-i+j][j]%mod+mod)%=mod;
			}
		la[p<<1] += la[p],la[p<<1|1]+=la[p];
	}
	
	lf[p] = la[p] = 0;
	return ;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		if(c==INF)
		{
			for(int i = 1;i<=19;i+=2)
				f[p][i] = mod-f[p][i];
			lf[p] = lf[p]^1;
		}else
		{
			int end = min(20,(r-l+1));
			powx[0] = 1;
			for(int i = 1;i<= end;i++)
				powx[i] = (LL)powx[i-1]*c%mod;
			for(int i = end;i>= 1;i--)
				for(int j = 1;j<= i;j++)
					(f[p][i] += (LL)f[p][i-j]*powx[j]%mod*calc[r-l+1-i+j][j]%mod+mod)%=mod;
			la[p]+=c;
		}
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,c);
	push_up(p,l,r);
}
struct E
{int t[21];};
E getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		E a;
		a.t[0] =1;
		for(int i = 1;i<= 20;i++)
			a.t[i] = f[p][i];
		return a;
	}
	int mid=(l+r)>>1;
	if(b<=mid)
		return getans(p<<1,l,mid,a,b);
	else if(a>mid)
		return getans(p<<1|1,mid+1,r,a,b);
	else
	{
		E A = getans(p<<1,l,mid,a,mid);
		E B = getans(p<<1|1,mid+1,r,mid+1,b);
		E C;
		int len = (b-a+1);
		int end = min(len,20);
		C.t[0] = 1;
		for(int i = 1;i<= end;i++)
		{
			C.t[i] = 0;
			for(int j = 0;j<=i;j++)
				if(j<=mid-a+1&&i-j<=b-mid)(C.t[i]+=((LL)A.t[j]*B.t[i-j])%mod+mod)%=mod;
		}
		return C;
	}
}
void build(int p,int l,int r)
{
	la[p] = lf[p] = 0;
	f[p][0] =1;
	if(l==r)
	{
		scanf("%d",&f[p][1]);
		f[p][1] = (f[p][1]%mod+mod)%mod;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p,l,r);
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	init();
	build(1,1,n);
	char opt[3];
	int a,b,c;
	for(int i =1;i<= q;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d%d%d",&a,&b,&c);
			update(1,1,n,a,b,c);
		}else if(opt[0]=='R')
		{
			scanf("%d%d",&a,&b);
			update(1,1,n,a,b,INF);
		}else
		{
			scanf("%d%d%d",&a,&b,&c);
			E t = getans(1,1,n,a,b);
			printf("%d\n",t.t[c]%mod);
		}
	}
	return 0;
}
Problem3004

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1200005;
int fa[N],size[N],f[N],ind[N];
int Div[2200],cnt;
void getdiv(int x)
{
	for(int i = 1;i*i<= x;i++)
	{
		if(i*i==x)
			Div[++cnt] = i;
		else if(x%i==0)
			Div[++cnt] = i,Div[++cnt] = x/i;
	}
	return ;
}
queue<int>Q;
int main()
{
	int n;
	scanf("%d",&n);
	getdiv(n);
	sort(Div+1,Div+cnt+1);
	for(int id = 1;id<= 10;id++)
	{
		memset(ind,0,sizeof(ind));
		if(id==1)
			for(int i = 2;i<= n;i++)
			{
				if(i==n)scanf("%d",&fa[i]);
				else scanf("%d,",&fa[i]);
				ind[fa[i]]++;
			}
		else
			for(int i = 2;i<= n;i++)
				{fa[i] = (fa[i]+19940105)%(i-1)+1;ind[fa[i]]++;}
		memset(size,0,sizeof(size));
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
			if(!ind[i])
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			size[x]++;
			ind[fa[x]]--;
			size[fa[x]]+=size[x];
			if(!ind[fa[x]])
				Q.push(fa[x]);
		}
		for(int i = 1;i<= n;i++)
			f[size[i]]++;
		printf("Case #%d:\n",id);
		for(int i = 1;i<= cnt;i++)
		{
			int num = 0;
			for(int j = Div[i];j<=n;j+=Div[i])
				num+=f[j];
			if(num==n/Div[i])
				printf("%d\n",Div[i]);
		}
	}
	return 0;
}
Problem3028

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
char s[1005];
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{	
	int d,n=0;
	scanf("%s",s+1);
	for(int i = 1;s[i];i++)
		n = (n*10+s[i]-'0')%mod;
	int ans = n*(n+1)%mod*(n+2)%mod;
	ans = ans*quick_pow(6,mod-2)%mod;
	printf("%d\n",ans);
	return 0;
}
Problem3029

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 201;
double f[2][N][N<<1];
int w[N];
double p[N];
int main()
{
	int n,l,K;
	scanf("%d%d%d",&n,&l,&K);
	if(K>n)K = n;
	f[0][0][K+200] = 1;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf",&p[i]);
		p[i]/=100.0;
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&w[i]);
	for(int i = 0;i< n;i++)
	{
		int next = (i+1)&1,now = i&1;
		for(int j = 0;j<=i;j++)
			for(int k = -i;k<= n;k++)
			{
				f[next][j][k+200] += (1.0-p[i+1])*f[now][j][k+200];
				int tmp = k+w[i+1];
				if(tmp>n)tmp = n;
				f[next][j+1][tmp+200] += p[i+1]*f[now][j][k+200];
			}
		memset(f[now],0,sizeof(f[now]));
	}
	double ans = 0;
	for (int i=0;i<=n;i++) 
	  for (int j=l;j<=n;j++) 
	    ans+=f[n&1][j][i+200];
	printf("%.6f\n",ans);
	return 0;
}
Problem3037

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,a[N],edge;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool v[N];
int p;
void dfs(int x)
{
	v[x] = true;
	if(v[a[x]]){p = x;return ;}
	dfs(a[x]);
}
int g[N],f[N];
void dp(int x,int fa)
{
	f[x] = 1,g[x] = INF,v[x] = true;
	if(x==edge)g[x]= 0;
	for(int i = head[x];i;i= e[i].next)
	{
		if(e[i].to!=fa&&e[i].to!=p)
		{
			dp(e[i].to,x);
			g[x] += min(g[e[i].to],f[e[i].to]);
			g[x] = min(g[x],f[x]+f[e[i].to]-1);
			f[x] += min(g[e[i].to],f[e[i].to]); 
		}
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		add(a[i],i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
	{
		if(v[i])continue;
		dfs(i);
		edge = a[p];
		dp(p,0);int tmp = f[p];
		edge = 0;
		dp(p,0);
		ans+=min(tmp,g[p]);
	}
	printf("%d\n",n-ans);
	return 0;
}
Problem3038

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long LL;
LL sum[N<<2];
LL a[N];
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void update(int p,int l,int r,int x,LL c)
{
	if(l==r)
		{sum[p] = c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,c);
	else update(p<<1|1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
LL getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans = ans+getans(p<<1,l,mid,a,b);
	if(b>mid)ans = ans+getans(p<<1|1,mid+1,r,a,b);
	return ans;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = a[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	build(1,1,n);
	for(int i = 1;i<= n;i++)
	{
		if(a[i]>1)fa[i] = i;
		else fa[i] = i+1;
	}
	fa[n+1] = n+1;
	int x,y,opt;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt,&x,&y);
		if(x>y)swap(x,y);
		if(opt==0)
		{
			for(int t = getfa(x);t<= y;t= getfa(t))
			{
				a[t] = sqrt(a[t]);
				update(1,1,n,t,a[t]);
				if(a[t]<=1)
					fa[t] = t+1;
				t = t+1;
			}
		}else
			printf("%lld\n",getans(1,1,n,x,y));
	}
	return 0;
}
Problem3039

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
bool map[N][N];
int l[N][N],r[N][N],h[N][N];
char s[3];
int ans = 0,n,m;
void work()
{
	for(int i = 1;i<= n;i++)
	{
		int t = 1;
		for(int j = 1;j<= m;j++)
			if(map[i][j])l[i][j] = t;
			else l[i][j] = 1,t = j+1;
		t = m;
		for(int j = m;j>=1;j--)
			if(map[i][j])r[i][j] = t;
			else r[i][j] = m,t = j-1;
	}
	for(int j = 1;j<= m;j++)l[0][j] = 1,r[0][j] = m;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(map[i][j])
			{
				h[i][j] = h[i-1][j]+1;
				l[i][j] = max(l[i-1][j],l[i][j]);
				r[i][j] = min(r[i-1][j],r[i][j]);
				ans = max(ans,(r[i][j]-l[i][j]+1)*h[i][j]);
			}
	printf("%d\n",ans*3);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<=m;j++)
		{
			scanf("%s",s);
			map[i][j] = s[0]=='F';
		}
	}
	work();
	return 0;
}
Problem3053

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int INF = 1e9+1;
typedef double db;
int n,k,t,m,root;
struct P
{
	int mx[6],mn[6],d[6],l,r;
	int& operator[](int x){return d[x];}
	void clear()
	{
		for(int i = 0;i<6;i++)
			mx[i] = mn[i] = d[i] = 0;
	}
}p[N];
struct data
{int no,dis;}ans[15];
int top;
bool cmp(const data &a,const data &b)
{
	return a.dis<b.dis;
}
int D;
bool operator<(P a,P b)
{
	return a[D]<b[D];
}
inline int getdis(P a,P b)
{
	int ans = 0;
	for(int i = 0;i< k;i++)
		ans+=(a[i]-b[i])*(a[i]-b[i]);
	return ans;
}
struct KD_tree
{
	P t[N],T;
	int cnt;
	void clear()
	{
		for(int i = 0;i<N;i++)
			t[i].clear();
		T.clear();
		cnt = 0;
	}
	void update(int o)
	{
		P l = t[t[o].l],r = t[t[o].r];
		for(int i = 0;i< k;i++)
		{
			if(t[o].l)t[o].mn[i] = min(t[o].mn[i],l.mn[i]),t[o].mx[i] = max(t[o].mx[i],l.mx[i]);
			if(t[o].r)t[o].mn[i] = min(t[o].mn[i],r.mn[i]),t[o].mx[i] = max(t[o].mx[i],r.mx[i]);
		}
		return ;
	}
	int build(int l,int r,int now)
	{
		D = now;
		int mid = (l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid] = p[mid];
		for(int i = 0;i<k;i++)
			t[mid].mn[i]=t[mid].mx[i] = t[mid][i];
		if(l<mid)t[mid].l = build(l,mid-1,(now+1)%k);
		if(r>mid)t[mid].r = build(mid+1,r,(now+1)%k);
		update(mid);
		return mid;
	}
	int getmindis(int o,P p)
	{
		int ans = 0;
		for(int i = 0;i<k;i++)
		{
			if(p[i]<t[o].mn[i])
				ans+=(t[o].mn[i]-p[i])*(t[o].mn[i]-p[i]);
			if(p[i]>t[o].mx[i])
				ans+=(p[i]-t[o].mx[i])*(p[i]-t[o].mx[i]);
		}
		return ans;
	}
	void query(int o,int now)
	{
		int d,dl = INF,dr = INF;
		d = getdis(t[o],T);
		if(d<ans[1].dis)
		{
			pop_heap(ans+1,ans+top+1,cmp);
			ans[top] = (data){o,d};
			push_heap(ans+1,ans+top+1,cmp);
		}
		if(t[o].l)dl = getmindis(t[o].l,T);
		if(t[o].r)dr = getmindis(t[o].r,T);
		if(dl<dr)
		{
			if(dl<ans[1].dis)query(t[o].l,(now+1)%k);
			if(dr<ans[1].dis)query(t[o].r,(now+1)%k);
		}else
		{
			if(dr<ans[1].dis)query(t[o].r,(now+1)%k);
			if(dl<ans[1].dis)query(t[o].l,(now+1)%k);
		}
	}
	void getans(P p,int num)
	{
		for(int i = 1;i<= num;i++)
			ans[i] = (data){0,INF};
		top = num;
		T = p;
		query(root,0);
	}
}KD;
void init()
{
	KD.clear();
	top = t = 0;
	memset(ans,0,sizeof(ans));
}
void work()
{
	int x;
	init();
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<k;j++)
		{
			scanf("%d",&x);
			p[i][j] = x;
		}
	root = KD.build(1,n,0);
	P tmp;
	scanf("%d",&t);
	for(int i =1;i<= t;i++)
	{
		for(int j = 0;j<k;j++)
		{
			scanf("%d",&x);
			tmp[j] = x;
		}
		scanf("%d",&m);
		KD.getans(tmp,m);
		printf("the closest %d points are:\n",m);
		sort(ans+1,ans+m+1,cmp);
		for(int j = 1;j<=m;j++)
		{
			for(int tt = 0;tt<k-1;tt++)
				printf("%d ",p[ans[j].no][tt]);
			printf("%d\n",p[ans[j].no][k-1]);
			//printf("%d ",ans[1].no);
			//pop_heap(ans+1,ans+top+1,cmp);
			//top--;
		}
	}
}
int main()
{
	while(scanf("%d%d",&n,&k)!=EOF)
		work();
	return 0;
}
Problem3053

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e9+1;
int n,k,D,root;
struct Point
{
	int mx[6],mn[6],d[6],l,r;
	int& operator[](int x){return d[x];}
	void clear()
	{
		for(int i = 0;i<6;i++)
			mx[i]=mn[i]=d[i]=0;
	}
}p[N];
bool operator <(Point a,Point b)
{
	return a[D]<b[D];
}
int getdis(Point a,Point b)
{
	int ans = 0;
	for(int i = 0;i<k;i++)
		ans = ans+(a[i]-b[i])*(a[i]-b[i]);
	return ans;
}
int top;
struct Heap
{
	int o,dis;
	Heap(int _o=0,int _dis=INF):o(_o),dis(_dis){}
	bool operator <(const Heap &s)const
	{
		return dis<s.dis;
	}
}ans[15];
struct KD_tree
{
	Point t[N],target;
	int cnt;
	void clear()
	{
		for(int i = 0;i<N;i++)
			t[i].clear();
		target.clear();
		cnt = 0;
	}
	void Push_up(int p)
	{
		Point l = t[t[p].l],r = t[t[p].r];
		for(int i = 0;i<k;i++)
		{
			if(t[p].l)t[p].mx[i]=max(t[p].mx[i],l.mx[i]),t[p].mn[i]=min(t[p].mn[i],l.mn[i]);
			if(t[p].r)t[p].mx[i]=max(t[p].mx[i],r.mx[i]),t[p].mn[i]=min(t[p].mn[i],r.mn[i]);
		}
	}
	int getmindis(int x,Point p)
	{
		int ans = 0;
		for(int i = 0;i<k;i++)
		{
			if(p[i]>t[x].mx[i])
				ans = ans+(p[i]-t[x].mx[i])*(p[i]-t[x].mx[i]);
			if(p[i]<t[x].mn[i])
				ans = ans+(t[x].mn[i]-p[i])*(t[x].mn[i]-p[i]);
		}
		return ans;
	}
	int build(int l,int r,int now)
	{
		D = now;
		int mid = (l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid] = p[mid];
		for(int i = 0;i<k;i++)
			t[mid].mx[i]=t[mid].mn[i]=t[mid][i];
		if(l<mid)t[mid].l = build(l,mid-1,(now+1)%k);
		if(r>mid)t[mid].r = build(mid+1,r,(now+1)%k);
		Push_up(mid);
		return mid;
	}
	void getans(int o)
	{
		int d,dl = INF,dr = INF;
		d = getdis(target,t[o]);
		if(d<ans[1].dis)
		{
			pop_heap(ans+1,ans+top+1);
			ans[top] = Heap(o,d);
			push_heap(ans+1,ans+top+1);
		}
		if(t[o].l)dl = getmindis(t[o].l,target);
		if(t[o].r)dr = getmindis(t[o].r,target);
		if(dl<dr)
		{
			if(dl<ans[1].dis)getans(t[o].l);
			if(dr<ans[1].dis)getans(t[o].r);
		}else
		{
			if(dr<ans[1].dis)getans(t[o].r);
			if(dl<ans[1].dis)getans(t[o].l);
		}
	}
	void Getans(const Point &o,int num)
	{
		for(int i = 1;i<=num;i++)
			ans[i] = Heap(0,INF);
		top = num;
		target = o;
		getans(root);
	}
}kd;
void init()
{
	kd.clear();
	top = 0;
	for(int i = 0;i<15;i++)
		ans[i]=Heap(0,INF);
}
void work()
{
	init();
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<k;j++)
			scanf("%d",&p[i].d[j]);
	root = kd.build(1,n,0);
	int m,num;Point t;
	scanf("%d",&m);
	while(m--)
	{
		for(int i = 0;i<k;i++)
			scanf("%d",&t.d[i]);
		scanf("%d",&num);
		kd.Getans(t,num);
		printf("the closest %d points are:\n",num);
		sort(ans+1,ans+num+1);
		for(int j = 1;j<=num;j++)
		{
			for(int tt = 0;tt<k-1;tt++)
				printf("%d ",p[ans[j].o][tt]);
			printf("%d\n",p[ans[j].o][k-1]);
		}
	}
}
int main()
{
	while(scanf("%d%d",&n,&k)!=EOF)
		work();
	return 0;
}
Problem3060

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2e6+5;
const int N = 1e6+5;
int fa[N],rnk[N];
int a[M],b[M];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(rnk[x]>rnk[y])
		fa[y] = x;
	else
	{
		fa[x] = y;
		rnk[y]+=rnk[x]==rnk[y];
	}
}
int main()
{
	int n,m,k,x,y,cnt = 0;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		if(x<=k||y<=k)
		{
			a[++cnt] = x;
			b[cnt] = y;
		}else uni(x,y);
	}
	int ans = 0;
	for(int i = 1;i<= cnt;i++)
	{
		int fx = getfa(a[i]),fy = getfa(b[i]);
		if(fx==fy)ans++;
		else uni(a[i],b[i]);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3065

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double beta = 0.75;
const int N = 7e4;
const int M = 1e7+5;
struct seg
{int l,r,sum;}a[M];
vector<int>rec,T,P;
int root[140005],ls[140005],rs[140005],v[140005],dfn[140005];
int n,m,size,lastans,tmp,Root;
int newnode()
{
	if(!rec.size())return ++size;
	else
	{
		int k = rec.back();rec.pop_back();
		return k;
	}
}
void Free(int &x)
{
	if(!x)return ;
	rec.push_back(x);
	Free(a[x].l),Free(a[x].r);
	a[x].sum =0;x = 0;
}
void Insert(int &p,int l,int r,int pos,int num)
{
	if(!p)p = newnode();
	if(l==r){a[p].sum+=num;return ;}
	int mid=(l+r)>>1;
	if(pos<=mid)Insert(a[p].l,l,mid,pos,num);
	else Insert(a[p].r,mid+1,r,pos,num);
	a[p].sum = a[a[p].l].sum+a[a[p].r].sum;
	if(!a[p].sum)Free(p);
}
void build(int &p,int l,int r)
{
	if(l>r)return ;
	if(l==r)
	{
		p = dfn[l];
		Insert(root[p],0,N,v[p],1);
		return ;
	}
	int mid=(l+r)>>1;
	p = dfn[mid];
	build(ls[p],l,mid-1);build(rs[p],mid+1,r);
	for(int i = l;i<=r;i++)
		Insert(root[p],0,N,v[dfn[i]],1);
}
void del(int &x)
{
	if(!x)return ;
	Free(root[x]);
	del(ls[x]);P.push_back(x);del(rs[x]);
	x = 0;
}
void rebuild(int &x)
{
	del(x);
	int s1 = P.size();
	for(int i = 1;i<= s1;i++)dfn[i] = P[i-1];
	build(x,1,s1);
	P.clear();
}
int update(int p,int x,int val)
{
	Insert(root[p],0,N,val,1);
	int t,lsize = a[root[ls[p]]].sum;
	if(x==lsize+1){t=v[p];v[p] = val;}
	else if(lsize>=x)t=update(ls[p],x,val);
	else t=update(rs[p],x-lsize-1,val);
	Insert(root[p],0,N,t,-1);
	return t;
}
void getans(int p,int l,int r)
{
	int L = a[root[ls[p]]].sum,R = a[root[p]].sum;
	if(l==1&&R==r){T.push_back(root[p]);return ;}
	if(l<=L+1&&r>=L+1)P.push_back(v[p]);
	if(r<=L)getans(ls[p],l,r);
	else if(l>L+1)getans(rs[p],l-L-1,r-L-1);
	else
	{
		if(l<=L)getans(ls[p],l,L);
        if(R>L+1)getans(rs[p],1,r-L-1);
	}
}
int Getans(int L,int R,int K)
{
	getans(Root,L,R);
	K--;
	int l = 0,r = N;
	int s1=T.size(),s2 = P.size();
	while(l<r)
	{
		int mid = (l+r)>>1,sum=0;
		for(int i = 0;i<s1;i++)sum+=a[a[T[i]].l].sum;
		for(int i = 0;i<s2;i++)
			if(P[i]>=l&&P[i]<=mid)
				sum++;
		if(K<sum)
		{
			for(int i = 0;i<s1;i++)T[i]=a[T[i]].l;
			r=mid;
		}else
		{
			for(int i = 0;i<s1;i++)T[i]=a[T[i]].r;
			l = mid+1;K-=sum;
		}
	}
	T.clear();P.clear();
	return l;
}
void Insert(int &p,int x,int val)
{
	if(!p)
	{
		p=++n;
		Insert(root[p],0,N,val,1);
		v[p] =val;
		return ;
	}
	Insert(root[p],0,N,val,1);
	int lsize = a[root[ls[p]]].sum;
	if(x<=lsize)Insert(ls[p],x,val);
	else Insert(rs[p],x-lsize-1,val);
	if(a[root[p]].sum*beta>max(a[root[ls[p]]].sum,a[root[rs[p]]].sum))
	{
		if(tmp)
		{
			if(ls[p]==tmp)rebuild(ls[p]);
			else rebuild(rs[p]);
			tmp = 0;
		}
	}else tmp = p;  
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&v[i]);
	for(int i = 1;i<= n;i++)dfn[i] = i;
	build(Root,1,n);
	scanf("%d",&m);
	int x,y,K;char opt[3];
	while(m--)
	{
		scanf("%s%d%d",opt,&x,&y);
		x = x^lastans,y = y^lastans;
		switch(opt[0])
		{
			case 'Q':scanf("%d",&K);K = K^lastans;lastans = Getans(x,y,K);printf("%d\n",lastans);break;
			case 'M':update(Root,x,y);break;
			case 'I':tmp = 0;Insert(Root,x-1,y);if(tmp){tmp = 0;rebuild(Root);}break;
		}
		//printf("%d %d ",x,y);
		//if(opt[0]=='Q')printf("%d\n",K);
		//else printf("\n");
	}
	return 0;
}
Problem3083

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E{int next,to;}e[N<<1];
int head[N],tot,n,m,logx[N],root;
long long f[N<<2];
long long minn[N<<2];
long long INF;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int deep[N],top[N],fa[N],son[N],w[N],size[N],end[N],cnt;
int anc[18][N];
bool v[N];
void init()
{
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<=n;i++)
			anc[j][i] = anc[j-1][anc[j-1][i]];
}
void dfs1(int x,int dep)
{
	deep[x] = dep;
	v[x] = true;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	end[x] = cnt;
}
void push_down(int p)
{
	f[p<<1] = f[p];
	f[(p<<1)+1] = f[p];
	minn[p<<1] = f[p];
	minn[(p<<1)+1] = f[p];
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b,long long c)
{
	if(l>=a&&r<=b)
		{f[p] = c;minn[p] = c;return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update((p<<1)+1,mid+1,r,a,b,c);
	minn[p] = min(minn[p<<1],minn[(p<<1)+1]);
	return ;
}
long long getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return minn[p];
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	long long ans = INF;
	if(a<=mid)
		ans = min(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)
		ans = min(ans,getans((p<<1)+1,mid+1,r,a,b));
	return ans;
}
void get_update(int x,int y,long long c)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		update(1,1,n,w[top[x]],w[x],c);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	update(1,1,n,w[y],w[x],c);
}
long long Ask(int x)
{
	if(w[root]<w[x]||w[root]>end[x])
		return getans(1,1,n,w[x],end[x]);
	else if(root==x)
		return minn[1];
	else
	{
		int tmp = root;
		for(int j = 17;j>=0;j--)
			if(deep[fa[anc[j][tmp]]]>=deep[x])
				tmp = anc[j][tmp];
		long long ans = INF;
		ans = min(ans,getans(1,1,n,1,w[tmp]-1));
		ans = min(ans,getans(1,1,n,end[tmp]+1,n));
		return ans;
	}
}
int main()
{
	memset(minn,0x3f,sizeof(minn));
	INF = minn[0];
	int x,y;long long z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	long long tmp;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&tmp);
		update(1,1,n,w[i],w[i],tmp);
		anc[0][i]= fa[i];
	}
	init();
	scanf("%d",&root);
	int opt;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1){scanf("%d",&x);root = x;}
		else if(opt==2){scanf("%d%d%lld",&x,&y,&z);get_update(x,y,z);}
		else {scanf("%d",&x);printf("%lld\n",Ask(x));}
	}
	return 0;
}
Problem3100

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+2;
ll a[N];
int last[N];
int i,n,ans,mx,wz;
void calc()
{
	int j,l;
	ans = max(ans,1);
	mx = 1;
	l = last[a[i]-a[i-1]];
	last[a[i]-a[i-1]] = i;
	wz = l+1;
	for(j = i+1;j<= n+1;j++)
	{
		if(j>n||a[j]-a[j-1]==1)break;
		l = last[a[j]-a[j-1]];
		last[a[j]-a[j-1]] = j;
		wz = max(wz,l);
		mx = max(mx,int(a[j]-a[j-1]));
		if(wz<=j-mx+1)
			if(a[j]-a[j-mx]==(ll)mx*(mx+1)/2)
				ans = max(ans,mx);
	}
	i = j;
}
int main()
{
	scanf("%d",&n);
	for(i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	for(i = 1;i<= n;i++)a[i]+=a[i-1];
	for(i = 1;i<= n;i++)
	{
		if(a[i]-a[i-1]==1)break;
		last[a[i]-a[i-1]]=i;
	}
	while(i<=n)calc();
	for(i = n;i>= 1;i--)a[i]-=a[i-1];
	for(i = 1;i<= n/2;i++)swap(a[i],a[n-i+1]);
	for(i = 1;i<= n;i++)a[i]+=a[i-1];
	for(i = 1;i<= n;i++)last[i]=0;
	for(i = 1;i<= n;i++)
	{
		if(a[i]-a[i-1]==1)break;
		last[a[i]-a[i-1]]=i;
	}
	while(i<=n)calc();
	printf("%d\n",ans);	
	return 0;
}
Problem3110

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
typedef long long ll;
using namespace std;
const int N = 5e4+5;
const int M = 2e7+5;
int root[N<<2];
int ls[M],rs[M],lazy[M];
ll sum[M];
int tot,n,m;
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	if(!ls[p])ls[p] = ++tot;
	if(!rs[p])rs[p] = ++tot;
	lazy[ls[p]]+=lazy[p];
	lazy[rs[p]]+=lazy[p];
	int mid = (l+r)>>1;
	sum[ls[p]]+=(mid-l+1)*lazy[p];
	sum[rs[p]]+=(r-mid)*lazy[p];
	lazy[p] = 0;
}
void update(int &p,int l,int r,int a,int b)
{
	if(!p)p = ++tot;
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sum[p]+=r-l+1;
		lazy[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(ls[p],l,mid,a,b);
	if(b >mid)update(rs[p],mid+1,r,a,b);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
ll getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	push_down(p,l,r);
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1;ll ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
void insert(int a,int b,int c)
{
	int l = 1,r = n,p = 1;
	while(l!=r)
	{
		int mid=(l+r)>>1;
		update(root[p],1,n,a,b);
		if(c<=mid)r = mid,p = p<<1;
		else l = mid+1,p = p<<1|1;
	}
	update(root[p],1,n,a,b);
}
int solve(int a,int b,ll c)
{
	int l = 1,r = n,p = 1;
	while(l!=r)
	{
		int mid = (l+r)>>1;
		ll tmp = getans(root[p<<1],1,n,a,b);
		if(tmp>=c)r = mid,p = p<<1;
		else l = mid+1,p = p<<1|1,c-=tmp;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	int opt,a,b,c;
	for(int i= 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&opt,&a,&b,&c);
		if(opt==1)
			insert(a,b,n-c+1);
		else
			printf("%d\n",n-solve(a,b,c)+1);
	}
	return 0;
}
Problem3122

#include <stdio.h>
#include <map>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll x,y;
ll ex_gcd(ll a,ll b)
{
	if(b==0)
	{
		x = 1,y = 0;
		return a;
	}
	ll ans = ex_gcd(b,a%b);
	ll c = x;
	x = y;
	y = c-a/b*y;
	return ans;
}
ll getenv(ll X,ll c)
{
	ex_gcd(X,c);
	ll tmp = x;
	tmp = (tmp%c+c)%c;
	return tmp;
}
map<int,int>Pow;
int powA[100005];
ll A,B,C;
ll work()
{
	Pow.clear();
	//scanf("%lld%lld%lld",&A,&C,&B);
	if(A%C==0&&B!=0)return -1;
	ll D = 1;
	ll tmp = 1;
	for(int i = 0;i<=50;i++)
	{
		if((tmp%=C)==B)return i;
		tmp = tmp*A%C;
	}
	ll k = 0,gcd = ex_gcd(A,C);
	while(gcd!=1)
	{
		k++;
		if(B%gcd!=0)return -1;
		B/=gcd,C/=gcd,D*=A/gcd;
		D%=C;
		gcd = ex_gcd(A,C);
	}
	B*=getenv(D,C),B%=C;
	int m = ceil(sqrt(C)+1e-5);
	powA[0] = 1;Pow[1] = 0;
	for(int i = 1;i<= m;i++)
	{
		powA[i] = powA[i-1]*A%C;
		if(powA[i]==B)return i+k;
		Pow[powA[i]] = i;
	}
	D = 1;
	for(int i = 0;i<= m;i++)
	{
		ex_gcd(D,C);
		x = (x*B%C+C)%C;
		if(Pow.find(x)!=Pow.end())
			return (ll)i*m+k+Pow[x];
		D=D*powA[m]%C;
	}
	return -1;
}
ll solve()
{
	ll p,a,b,x1,t,tmp;
	scanf("%lld%lld%lld%lld%lld",&p,&a,&b,&x1,&t);
	if(x1==t)return 1;
	if(!a)return b==t?2:-1;
	if(a==1)
	{
		t+=p-x1,t%=p;
		tmp = ex_gcd(b,p);
		if(t%tmp)return -1;
		b/=tmp,p/=tmp,t/=tmp;
		ex_gcd(b,p);
		tmp = (x*t%p+p)%p;
		return tmp+1;
	}
	ll Y = (a*x1-x1+b)%p;
	ll Z = (a*t-t+b)%p;
	tmp = ex_gcd(Y,p);
	if(Z%tmp)return -1;
	Z/=tmp,Y/=tmp,p/=tmp;
	C = p;
	B = Z*getenv(Y,C)%p;
	A = a;
	tmp = work();
	if(tmp==-1)return -1;
	else return tmp+1;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		printf("%lld\n",solve());
	return 0;
}
Problem3123

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
const int M = 32*17*N;
struct E
{int next,to;}e[N<<2];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int fa[N][18];
int sz[M],ls[M],rs[M],root[N];
int q[N],a[N],T[N],F[N],dep[N],size[N];
int cnt;
void update(int &p,int pre,int l,int r,int x)
{
	p = ++cnt;
	ls[p] = ls[pre],rs[p] = rs[pre];
	sz[p] = sz[pre]+1;
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(x<=mid)
		update(ls[p],ls[pre],l,mid,x);
	else update(rs[p],rs[pre],mid+1,r,x);
}
int getans(int l,int r,int k,int x,int y,int u,int v)
{
	if(l==r)return T[l];
	int mid = (l+r)>>1;
	if(sz[ls[x]]+sz[ls[y]]-sz[ls[u]]-sz[ls[v]]>=k)
		return getans(l,mid,k,ls[x],ls[y],ls[u],ls[v]);
	else return getans(mid+1,r,k-(sz[ls[x]]+sz[ls[y]]-sz[ls[u]]-sz[ls[v]]),rs[x],rs[y],rs[u],rs[v]);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void init(int x)
{
	for(int j = 1;j<= 17;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
}
int top;
void DFS(int x)
{
    int l = 1, r = 0;
    q[++r] = x;
    while(l<=r)
    {
        int tt = q[l++]; 
        init(tt);
        update(root[tt],root[fa[tt][0]],1,top,a[tt]);
        for(int i=head[tt];i;i=e[i].next)
            if(e[i].to!=fa[tt][0])
            {
                fa[e[i].to][0] = tt;
                dep[e[i].to] = dep[tt]  + 1;
                q[++r] = e[i].to;
            }
    }
}
int find(int x)
{
	if(F[x]==x||!F[x])return F[x] = x;
	else return F[x] = find(F[x]);
}
int main()
{
	int p;
	scanf("%d",&p);
	int n,m,t;
	scanf("%d%d%d",&n,&m,&t);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		T[i] = a[i];
	}
	sort(T+1,T+n+1);
	for(int i = 1;i<= n;i++)
		if(T[i]!=T[i-1])
			T[++top] = T[i];
	for(int i = 1;i<= n;i++)
		a[i] = lower_bound(T+1,T+top+1,a[i])-T;
	for(int i = 1;i<= n;i++)size[i] = 1;
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		int fx = find(x),fy = find(y);
		if(fx==fy)continue;
		if(size[fx]<size[fy])swap(fx,fy);
		size[fx]+=size[fy];
		F[fy] = fx;
	}
	for(int i = 1;i<= n;i++)
		if(!root[i])
		{
			dep[i] = 1;
			DFS(i);
		}
	char opt[3];
	int ans=0;
	for(int i = 1;i<= t;i++)
	{
		scanf("%s%d%d",opt,&x,&y);
		x = x^ans,y = y^ans;
		if(opt[0]=='L')
		{
			add(x,y);
			int fx = find(x),fy = find(y);
			if(size[fx]<size[fy])
				swap(fx,fy),swap(x,y);
			F[fy] = fx;size[fx]+=size[fy];
			fa[y][0] = x;dep[y] = dep[x]+1;
			DFS(y);
		}else
		{
			scanf("%d",&z);z = z^ans;
			int u = getlca(x,y);int v = fa[u][0];
			printf("%d\n",ans = getans(1,top,z,root[x],root[y],root[u],root[v]));
		}
	}
	return 0;
}
Problem3132

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2049;
struct T
{
	int a[N][N];
	T()
	{memset(a,0,sizeof(a));}
	void update(int x,int y,int c)
	{
		for(int i = x;i<N;i+=i&(-i))
			for(int j = y;j<N;j+=j&(-j))
				a[i][j]+=c;
	}
	int getans(int x,int y)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			for(int j = y;j>0;j-=j&(-j))
				ans+=a[i][j];
		return ans;
	}
}A,B,C,D;
void update(int x1,int x2,int y1,int y2,int d)
{
	A.update(x1,y1,d),A.update(x2+1,y1,-d);
	A.update(x1,y2+1,-d),A.update(x2+1,y2+1,d);

	B.update(x1,y1,d*x1),B.update(x2+1,y1,-d*(x2+1));
	B.update(x1,y2+1,-d*x1),B.update(x2+1,y2+1,d*(x2+1));

	C.update(x1,y1,d*y1),C.update(x2+1,y1,-d*y1);
	C.update(x1,y2+1,-d*(y2+1)),C.update(x2+1,y2+1,d*(y2+1));

	D.update(x1,y1,d*x1*y1),D.update(x2+1,y1,-d*(x2+1)*y1);
	D.update(x1,y2+1,-d*x1*(y2+1)),D.update(x2+1,y2+1,d*(x2+1)*(y2+1));
}
int getb(int x,int y)
{
	return (x+1)*(y+1)*A.getans(x,y)-(x+1)*C.getans(x,y)-(y+1)*B.getans(x,y)+D.getans(x,y);
}
int main()
{
	int n,m,a,b,c,d,z;
	char ju[3];
	scanf("%s",ju);
	scanf("%d%d",&n,&m);
	while(scanf("%s",ju)!=EOF)
	{
		if(ju[0]=='k')
		{
			scanf("%d%d%d%d",&a,&b,&c,&d);
			int ans = 0;
			ans += getb(c,d)-getb(a-1,d)-getb(c,b-1)+getb(a-1,b-1);
			printf("%d\n",ans);
		}
		else
		{
			scanf("%d%d%d%d%d",&a,&b,&c,&d,&z);
			update(a,c,b,d,z);
		}
	}
	return 0;
}
Problem3143

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 505;
const double eps = 1e-8;
struct E
{int next,to;}e[N*N];
int head[N],tot,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double f[N][N],cnt[N];
double Ans[N*N],ans[N];
void work()
{
	for(int i = 1;i< n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(xn,i);
		for(int line = i+1;line<= n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = 1;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n-1;i>= 1;i--)
	{
		for(int j = i+1;j<= n;j++)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
		cnt[u]+=1.0;cnt[v]+=1.0;
	}
	for(int i = 1;i< n;i++)
	{
		for(int j = head[i];j;j = e[j].next)
			f[i][e[j].to] += 1.0/cnt[e[j].to];
		f[i][i]-=1.0;
	}
	f[1][n+1]-=1.0;
	work();
	int tmp = 0;
	for(int i = 1;i< n;i++)
	{
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to>i)
				Ans[++tmp] = ans[i]/cnt[i]+ans[e[j].to]/cnt[e[j].to];
	}
	sort(Ans+1,Ans+tmp+1);
	double t_ans = 0;
	for(int i = 1;i<= tmp;i++)
		t_ans+=Ans[i]*(m-i+1);
	printf("%.3f\n",t_ans);
	return 0;
}
Problem3155

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long LL;
LL sum[N<<2],lazy[N<<2];
LL pre[N],a[N];
void build(int p,int l,int r)
{
	if(l==r){sum[p] = pre[l];return ;}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
void push_down(int p,int l,int r)
{
	if(l==r){lazy[p] = 0;return ;}
	int mid = (l+r)>>1;
	lazy[p<<1] += lazy[p];
	lazy[p<<1|1] +=lazy[p];
	sum[p<<1] += lazy[p]*(mid+1-l);
	sum[p<<1|1]+=lazy[p]*(r-mid);
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,LL dec)
{
	if(lazy[p])push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=dec;
		sum[p] = sum[p]+dec*(r-l+1);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,dec);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,dec);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
LL get_ans(int p,int l,int r,int a,int b)
{
	if(lazy[p])push_down(p,l,r);
	if(l>=a&&r<=b)
		return sum[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans+=get_ans(p<<1,l,mid,a,b);
	if(b>mid)ans+=get_ans(p<<1|1,mid+1,r,a,b);
	//sum[p] = sum[p<<1]+sum[p<<1|1];
	return ans;
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&a[i]);
		pre[i] = pre[i-1]+a[i];
	}
	build(1,1,n);
	char ju[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",ju);
		if(ju[0]=='M')
		{
			scanf("%d%d",&x,&y);
			LL dec = y-a[x];
			update(1,1,n,x,n,dec);
			a[x] = y;
		}else
		{
			scanf("%d",&x);
			printf("%lld\n",get_ans(1,1,n,1,x));
		}
	}
	return 0;
}
Problem3156

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
int a[N],line[N],l,r;
LL f[N];
double calc(int j,int k)
{
	return ((double)(f[j]-f[k])*2+(double)j*(j+1)-(double)k*(k+1))/(double)(j-k);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		while(l<r&&calc(line[l+1],line[l])<2*i)l++;
		if(l<=r)f[i] = f[line[l]]+(LL)(i-line[l]-1)*(i-line[l])/2+a[i];
		while(l<r&&calc(line[r],line[r-1])>calc(i,line[r]))r--;
		line[++r] = i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem3160

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 8e5+5;
typedef double db;
typedef long long ll;
const int mod = 1e9+7;
const db PI = 3.14159265358979323;
char s[N];
struct cp
{
	db x,y;
	friend cp operator+(const cp &a,const cp &b)
	{
		return (cp){a.x+b.x,a.y+b.y};
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return (cp){a.x-b.x,a.y-b.y};
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return (cp){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};
	}
}a[M],b[M],c[M];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i= 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn = (cp){cos(2*PI*type/i),sin(2*PI*type/i)};
		for(int j = 0;j<len;j+=i)
		{
			cp w = (cp){1,0},tmp;
			for(int k = 0;k<(i>>1);k++,w = w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[M];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i] = a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)
		ans[i] += (int)(c[i].x+0.1);
}
int pow2[N<<1];
void init()
{
	pow2[0] = 1;
	for(int i = 1;i<N*2;i++)
		pow2[i] = pow2[i-1]*2%mod;
}
char tt[N<<1];int p[N<<1],no[N<<1];
ll tot,Ans;
void manacher(int n)
{
	int lth = 0;
	int maxp = 1,id = 1;
	for(int i = 0;i<n;i++)
	{
		tt[++lth] = s[i];
		no[lth] = i+1;
		if(i!=n-1)tt[++lth]='^';
	}
	for(int i = 1;i<= lth;i++)
	{
		if(maxp>i)p[i] = min(p[id*2-i],maxp-i);
		else p[i] = 0;
		while(i+p[i]<=lth&&i-p[i]>=1&&tt[i+p[i]]==tt[i-p[i]])p[i]++;
		p[i]--;
		if(i+p[i]>maxp)maxp = i+p[i],id = i;
		tot+=(no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1])-(no[i]?no[i]:no[i+1])+1;
	}
}
int main()
{
	init();
	scanf("%s",s);
	int n = strlen(s);
	for(int i = 0;i<n;i++)
	{
		a[i].x = (s[i]=='b')?0:1;
		b[i].x = a[i].x;
		a[i].y = b[i].y = 0;
	}
	int len = 1,m= 2*n;
	while(len<=m)len = len<<1;
	len = len<<1;
	conv(a,b,c,len);
	//for(int i = 0;i<len;i++)
	//	printf("%d ",ans[i]);
	//printf("\n");
	for(int i = 0;i<len;i++)
	{
		if(i<n)a[i].x = (s[i]=='a')?0:1;
		else a[i].x = 0;
		b[i].x = a[i].x;
		a[i].y = b[i].y = c[i].x = c[i].y = 0;
	}
	conv(a,b,c,len);
	//for(int i = 0;i<m-1;i++)
	//	printf("%d ",ans[i]);
	for(int i = 0;i<m;i++)
	{
		int tmp = (ans[i]+1)>>1;
		(Ans+=pow2[tmp]-1)%=mod;
	}
	manacher(n);
	Ans = ((Ans-tot)%mod+mod)%mod;
	printf("%lld\n",Ans);
	return 0;
}
Problem3162

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int mod = 1e9+7;
const int sed = 377;
const int N = 5e5+5;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot=1,n,rot,cgs[2];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	//e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],stack[N];
ull hash[N];
ll f[N][2],inv[N];
void Init()
{
	inv[1] = 1;
	for(int i = 2;i<= n;i++)
		inv[i] = (ll)(mod-mod/i)*inv[mod%i]%mod;
}
ll C(ll n,ll m)
{
	ll res = 1;
	n%=mod;
	for(int i = 1;i<= m;i++)
		(res*=(ll)(n-i+1)*inv[i]%mod)%=mod;
	return res;
}
bool cmp(int x,int y)
{
	return hash[x]<hash[y];
}
void dfs(int x,int fa)
{
	bool flag = true;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa)
	{
		dfs(e[i].to,x);
		size[x]+=size[e[i].to];
		if(size[e[i].to]<<1>n)
			flag = false;
	}
	if((n-size[x])<<1>n)
		flag = false;
	if(flag)
		(cgs[0]?cgs[1]:cgs[0])=x;
}
void DP(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			DP(e[i].to,x);
	int top = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			stack[++top] = e[i].to;
	sort(stack+1,stack+top+1,cmp);
	hash[x] = sed;
	f[x][0]=f[x][1]=1;
	int j;
	for(int i = 1;i<= top;i=j)
	{
		for(j = i+1;j<=top&&hash[stack[i]]==hash[stack[j]];j++);
		(f[x][0]*=C(j-i+f[stack[i]][0]+f[stack[i]][1]-1,j-i))%=mod,
		(f[x][1]*=C(j-i+f[stack[i]][0]-1,j-i))%=mod;
	}
	for(int i = 1;i<= top;i++)
	{
		hash[x] = hash[x]*sed+hash[stack[i]];
		hash[x] = (hash[x]^hash[stack[i]])+hash[stack[i]];
	}
}
int main()
{
	scanf("%d",&n);
	Init();
	int x,y;
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs(1,0);
	if(cgs[1])
	{
		for(int i = head[cgs[0]];i;i=e[i].next)
			if(e[i].to==cgs[1])
			{
				e[i].to = e[i^1].to = rot = n+1;
				break;
			}
		add(n+1,cgs[0]);
		add(n+1,cgs[1]);
	}else rot = cgs[0];
	DP(rot,0);
	ll ans = 0;
	if(!cgs[1])
		ans = (f[rot][0]+f[rot][1])%mod;
	else
	{
		x=cgs[0];y=cgs[1];
        if(hash[x]!=hash[y])
            ans=(f[x][0]*f[y][0]%mod+f[x][1]*f[y][0]%mod+f[x][0]*f[y][1]%mod)%mod;
        else
            ans=(f[x][0]*f[y][1]+C(f[x][0]+1,2) )%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3166

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int M = 35*N;
const int INF = 1e9+1;
int root[N];
set<int>q;
struct Data{int pos,val;}a[N];
bool operator<(Data a,Data b)
{
	return a.val>b.val;
}
struct Trie
{
	int ch[M][2],cnt,sum[M];
	int insert(int x,int num)
	{
		int tmp,y;
		tmp=y=++cnt;
		for(int i=30;i>=0;i--)
		{
			int t = num&(1<<i);t=t>>i;
			ch[y][0] = ch[x][0];
			ch[y][1] = ch[x][1];
			x = ch[x][t];
			y = ch[y][t] = ++cnt;
			sum[y]=sum[x]+1;
		}
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 30;i>= 0;i--)
		{
			int t = val&(1<<i);t=t>>i;
			if(sum[ch[r][t^1]]-sum[ch[l][t^1]]>0)
				l=ch[l][t^1],r = ch[r][t^1],ans+=(1<<i);
			else l = ch[l][t],r = ch[r][t];
		}
		return ans;
	}
}trie;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d",&a[i].val);
		a[i].pos = i;
	}
	for(int i = 1;i<= n;i++)
		root[i] = trie.insert(root[i-1],a[i].val);
	q.insert(-2),q.insert(-1),q.insert(INF),q.insert(INF+1);
	sort(a+1,a+n+1);
	q.insert(a[1].pos);
	int ans = 0;
	for(int i = 2;i<= n;i++)
	{
		int l = a[i].pos,r = a[i].pos,x = a[i].pos;
		set<int>::iterator t,p;
		p=q.lower_bound(x);
		t = p;
		r = *t;t++;r = *t-1;
		l = *--p;p--;l=*p+1;
		l = max(1,l),r = min(r,n);
		if(l!=r)ans = max(ans,trie.getans(root[l-1],root[r],a[i].val));
		q.insert(x);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3170

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct P
{
	ll x,y;
	P(){}
	P(ll x,ll y):x(x+y),y(x-y){}

}p[N];
int n;
ll X[N],Y[N],ans = 1e18;
ll sumx[N],sumy[N];
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		p[i]=P(x,y);
		X[i] = p[i].x,Y[i] = p[i].y;
	}
	sort(X+1,X+n+1);
	sort(Y+1,Y+n+1);
	for(int i = 1;i<= n;i++)
	{
		sumx[i] = sumx[i-1]+X[i];
		sumy[i] = sumy[i-1]+Y[i];
	}
	ll tmp=0;
	int pos;
	for(int i = 1;i<= n;i++)
	{
		tmp = 0;
		pos = lower_bound(X+1,X+n+1,p[i].x)-X;
		tmp+=(p[i].x*pos-sumx[pos])+((sumx[n]-sumx[pos])-p[i].x*(n-pos));
		pos = lower_bound(Y+1,Y+n+1,p[i].y)-Y;
		tmp+=(p[i].y*pos-sumy[pos])+((sumy[n]-sumy[pos])-p[i].y*(n-pos));
		ans = min(ans,tmp);
	}
	printf("%lld\n",ans>>1);
	return 0;
}
Problem3171

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int nxt,to,fr,f,c;}e[M];
int head[N],tot=1;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].nxt=head[x];head[x]=tot;
	e[tot].f=f,e[tot].c=c;e[tot].fr=x;
	e[++tot].to=x;e[tot].nxt=head[y];head[y]=tot;
	e[tot].f=0,e[tot].c=-c;e[tot].fr=y;
}
int from[N],dis[N],S,T;
bool v[N];
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	dis[S] = 0,v[S] = true;
	Q.push(S);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].nxt)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans,mxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	mxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int id[20][20][2];
int map[20][20];
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
int main()
{
	int cnt = 0;
	int l,r;
	char s[20];
	scanf("%d%d",&l,&r);
	for(int i = 1;i<= l;i++)
	{
		scanf("%s",s+1);
		for(int j=1;j<= r;j++)
		{
			if(s[j]=='U')map[i][j]=0;
			else if(s[j]=='D')map[i][j]=1;
			else if(s[j]=='L')map[i][j]=2;
			else map[i][j]=3;
		}
	}
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			for(int k = 0;k<2;k++)
				id[i][j][k]=++cnt;
	S = 0,T =cnt+1;
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			for(int d = 0;d<4;d++)
			{
				int nx = i+dx[d],ny = j+dy[d];
				if(nx<1)nx=l;if(ny<1)ny=r;
				if(nx>l)nx=1;if(ny>r)ny=1;
				if(map[i][j]==d)add(id[i][j][0],id[nx][ny][1],1,0);
				else add(id[i][j][0],id[nx][ny][1],1,1);
			}
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			add(S,id[i][j][0],1,0),add(id[i][j][1],T,1,0);
	while(spfa())mcf();
	printf("%d\n",ans);
	return 0;
}
Problem3172

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int LEN = 1e6+5;
const int N = 205;
int pos[N];
char s[LEN];
#define s(i) (s[i]-'a')
struct AC_Machine
{
	int ch[LEN][26],sum[LEN],fail[LEN],q[LEN];
	int cnt,h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i]=1;
	}
	void insert(int &pos)
	{
		int i = 0,now = 1;
		while(s[i])
		{
			if(!ch[now][s(i)])
				ch[now][s(i)] = ++cnt;
			now = ch[now][s(i)];
			sum[now]++;
			i++;
		}
		pos = now;
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1;fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k=fail[k];
				fail[to]=ch[k][i];
				q[++t] = to;
			}
		}
		for(int i = t;i>=0;i--)
			sum[fail[q[i]]]+=sum[q[i]];
	}
}AC;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		AC.insert(pos[i]);
	}
	AC.build();
	for(int i = 1;i<= n;i++)
		printf("%d\n",AC.sum[pos[i]]);
	return 0; 
}
Problem3172

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+500;
char s[N];
int size[N<<1],pos[205];
queue<int>q;
struct SAM
{
	int trs[N<<1][27],fa[N<<1],len[N<<1],ind[N<<1],size[N<<1];
	int cnt,last;
	int end[N<<1];
	void init(){cnt=last=1;}
	int insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np]=len[p]+1;
		size[np]++;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
		return np;
	}
	void build()
	{
		for(int i=1;i<=cnt;i++)ind[fa[i]]++;
		for(int i=1;i<=cnt;i++)
			if(!ind[i])q.push(i);
		while(!q.empty())
		{
			int t=q.front();q.pop();
			if((--ind[fa[t]])==0)q.push(fa[t]);
			size[fa[t]]+=size[t];
		}
	}
}sam;
int beg[205],lth[205];
int main()
{
	int n,ll=0;
	sam.init();
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+ll+1);
		beg[i] = ll+1;
		ll+=(lth[i]=strlen(s+ll+1));
		s[++ll]='a'-1;
	}
	for(int i=1;i<=ll;i++)
        sam.insert(s[i]-'a'+1);
    sam.build();
	for(int i=1;i<=n;i++)
    {
        int now=1;
        for(int j=beg[i];j<=beg[i]+lth[i]-1;j++)
            now=sam.trs[now][s[j]-'a'+1];
        printf("%d\n",sam.size[now]);
    }
	return 0;
}
Problem3191

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int n,m;
double f[55][55];
int a[55];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i= 1;i<= m;i++)scanf("%d",&a[i]);
	f[1][1] = 1;
	for(int i = 2;i<= n;i++)
	{
		for(int j = 1;j<= i;j++)
		{
			for(int k = 1;k<= m;k++)
			{
				int tmp = a[k]%i;
				if(tmp==0)tmp = i;
				if(tmp==j)continue;
				if(tmp>j)tmp = i-tmp+j;
				else tmp = j-tmp;
				f[i][j] += f[i-1][tmp]/(double)m;
			}
		}
	}
	for(int i = 1;i< n;i++)
		printf("%.2lf%c ",f[n][i]*100.0,'%');
	printf("%.2lf%c",f[n][n]*100.0,'%');
	return 0;
}
Problem3192

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct P
{
    int tt,no,ss;
}num[100005];
int pos[100005],c[100005],lim;
bool cmp1(P a,P b){return a.tt<b.tt;}
bool cmp2(P a,P b){return a.no<b.no;}
void update(int x)
{
    for(int i = x;i<=lim;i+=(i&(-i)))
        c[i]--;
}
int check(int x)
{
    int ans = 0;
    for(int i = x;i>0;i-=(i&(-i)))
        ans+=c[i];
    return ans;
}
int main()
{
    //freopen("all.in", "r", stdin);
    //freopen("all.out", "w", stdout);
    int n,m,x;
    scanf("%d%d",&n,&m);
    lim = n+m;
    int cnt = 0;
    for(int i = 1;i<=n;i++)
    {
        scanf("%d",&x);
        cnt++;num[cnt].tt = x;num[cnt].no = n-i;
    }
    for(int i = 1;i<= m;i++)
    {
        scanf("%d",&x);
        cnt++;num[cnt].tt = x;num[cnt].no = n+i;
    }
    sort(num+1,num+cnt+1,cmp1);
    for(int i = 1;i<= cnt;i++)
        num[i].ss = i;
    sort(num+1,num+cnt+1,cmp2);
    for(int i = 1;i<= cnt;i++)
        pos[num[i].ss] = i;
    //p_n为n与n+1之间的
    for(int i = 1;i<= lim;i++)
        c[i] = i&(-i);
    int p = n;int now = n+m;long long ans = 0;
    while(now>0)
    {
        int tmp = check(p);
        if(pos[now]>p)
        {
            ans += check(pos[now]-1)-tmp;
            p = pos[now]-1;
            update(pos[now]);
        }else
        {
            ans += tmp-check(pos[now]);
            p = pos[now];
            update(pos[now]);
        }
        now--;
    }
    printf("%lld",ans);
    return 0;
}
Problem3195

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<9;
const int M = 31;
const int mod = 1000000007;
int f[M+1][M][N][10];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int end = (1<<(k+1))-1;
	f[2][0][0][0] = 1;
	for(int i = 2;i<= n;i++)
	{
		for(int j = 0;j<= m;j++)
		{
			for(int sta = 0;sta<=end;sta++)
			{
				for(int l = 0;l<k;l++)
				{
					(f[i][j][sta][l+1]+=f[i][j][sta][l])%=mod;
					if(j<m&&i-k+l>0)
						(f[i][j+1][sta^(1<<k)^(1<<l)][l]+=f[i][j][sta][l])%=mod;
				}
				if(!(sta&1))(f[i+1][j][sta>>1][0]+=f[i][j][sta][k])%=mod;
			}
		}
	}
	printf("%d\n",f[n+1][m][0][0]);
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(200037);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:scanf("%d%d%d",&l,&r,&k);tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:scanf("%d%d%d",&l,&r,&k);get_number(l,r,k);break;
			case 3:scanf("%d%d",&l,&k);change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:scanf("%d%d%d",&l,&r,&k);tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:scanf("%d%d%d",&l,&r,&k);tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<3)+(x<<1) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(200037);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i] = read();
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:l=read();r=read();k=read();tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:l=read();r=read();k=read();get_number(l,r,k);break;
			case 3:l=read();k=read();change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:l=read();r=read();k=read();tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:l=read();r=read();k=read();tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<3)+(x<<1) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(237);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i] = read();
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:l=read();r=read();k=read();tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:l=read();r=read();k=read();get_number(l,r,k);break;
			case 3:l=read();k=read();change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:l=read();r=read();k=read();tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:l=read();r=read();k=read();tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int INF = 1e8+1;
int a[N],n,m;
struct Treap
{
	Treap *ls,*rs;
	int val,key,cnt,size;
	Treap();
	Treap(int v);
	void Push_up();
}*root[N<<2];
Treap :: Treap()
{
	ls = rs = NULL;
	val = 0;
	key = rand();
	cnt = size = 0;
}
Treap :: Treap(int v)
{
	ls = rs = NULL;
	val = v;
	key = rand();
	cnt = size = 1;
}
void Treap :: Push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->Push_up();
	x->Push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->Push_up();
	x->Push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x=new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->Push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->Push_up();
}
int rnk;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)rnk+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		rnk+=x->cnt;
		if(x->ls)rnk+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_rank(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,v);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,v);
}
void Insert(int p,int l,int r,int pos,int v)
{
	Insert(root[p],v);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Insert(p<<1,l,mid,pos,v);
	else Insert(p<<1|1,mid+1,r,pos,v);
}
void Delete(int p,int l,int r,int pos,int v)
{
	Delete(root[p],v);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Delete(p<<1,l,mid,pos,v);
	else Delete(p<<1|1,mid+1,r,pos,v);
}
int pre,sub;
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)get_pre(x->ls,y);
	else
	{
		pre = max(pre,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)get_sub(x->rs,y);
	else
	{
		sub = min(sub,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_pre(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,v);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,v);
}
void get_sub(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_sub(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,v);
	if(b >mid)get_sub(p<<1|1,mid+1,r,a,b,v);
}
void Get_rank(int l,int r,int k)
{
	rnk = 1;
	get_rank(1,1,n,l,r,k);
	printf("%d\n",rnk);
}
void Get_sub(int l,int r,int k)
{
	sub = INF;
	get_sub(1,1,n,l,r,k);
	printf("%d\n",sub);
}
void Get_pre(int l,int r,int k)
{
	pre = -INF;
	get_pre(1,1,n,l,r,k);
	printf("%d\n",pre);
}
void Get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		rnk = 1;
		get_rank(1,1,n,x,y,mid);
		if(rnk<=c){l=mid+1,ans=mid;}
		else {r = mid-1;}
	}
	printf("%d\n",ans);
}
void update(int pos,int c)
{
	Delete(1,1,n,pos,a[pos]);
	Insert(1,1,n,pos,c);
	a[pos] = c;
}
int main()
{
	srand(200037);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)Insert(1,1,n,i,a[i]);
	while(m--)
	{
		int opt,l,r,x,pos;
		scanf("%d",&opt);
		if(opt==3){scanf("%d%d",&pos,&x);}
		else {scanf("%d%d%d",&l,&r,&x);}
		if(opt==1)Get_rank(l,r,x);
		else if(opt==2)Get_number(l,r,x);
		else if(opt==3)update(pos,x);
		else if(opt==4)Get_pre(l,r,x);
		else Get_sub(l,r,x);
	}
	return 0;
}
Problem3197

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int sed = 237;
const int mul = 213;
const int N = 705;
const int INF = 0x3f3f3f3f;
int f[N][N],f1[N],f2[N],root,cg[2],n;
ull hash[N];
bool cmp(int x,int y)
{
	return hash[x]<hash[y];
}
namespace Tree
{
	struct E
	{int next,to;}e[N<<1];
	int head[N],tot,size[N],fa[N];
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void Get_G(int x,int father)
	{
		size[x] = 1;int F=0;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=father)
			{
				Get_G(e[i].to,x);
				size[x]+=size[e[i].to];
				F = max(F,size[e[i].to]);
			}
		F = max(F,n-size[x]);
		if(!(F<<1>n))
		{
			if(cg[0])cg[1] = x;
			else cg[0] = x;
		}
	}
	int dep[N];
	void Get_Hash(int x)
	{
		dep[x] = dep[fa[x]]+1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				Get_Hash(e[i].to);
			}
		static int stack[N],top;
		top = 0;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
				stack[++top] = e[i].to;
		sort(stack+1,stack+top+1,cmp);
		hash[x] = sed;
		for(int i = 1;i<= top;i++)
		{
			hash[x] = hash[x]*mul+hash[stack[i]];
			hash[x] = hash[x]^hash[stack[i]];
			hash[x] = hash[x]+hash[stack[i]];
		}
	}
}
namespace Flow
{
	struct E
	{int next,to,f,c,from;}e[N*N<<1];
	int head[N<<1],tot,ans,from[N<<1];
	void add(int x,int y,int f,int c)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].from = x;
		e[tot].f = f;e[tot].c = c;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].from = y;
		e[tot].f = 0;e[tot].c = -c;
	}
	void init()
	{
		memset(head,0,sizeof(head));
		tot = 1;ans = 0;
	}
	int dis[N<<1];bool vis[N<<1];
	queue<int>Q;
	bool spfa(int S,int T)
	{
		for(int i = S;i<= T;i++)dis[i] = INF;
		dis[S] = 0;vis[S] = true;
		Q.push(S);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			vis[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
				{
					dis[e[i].to] = dis[x]+e[i].c;
					from[e[i].to] = i;
					if(!vis[e[i].to])
					{
						Q.push(e[i].to);
						vis[e[i].to] = true;
					}
				}
		}
		return dis[T]!=INF;
	}
	void mcf(int S,int T)
	{
		int x = INF;
		for(int i = from[T];i;i=from[e[i].from])
			x = min(x,e[i].f);
		for(int i = from[T];i;i=from[e[i].from])
			ans+=x*e[i].c,e[i].f-=x,e[i^1].f+=x;
	}
	int getmcf(int S,int T)
	{
		while(spfa(S,T))mcf(S,T);
		return ans;
	}
}
int solve(int x,int y)
{
	static int stack1[N],stack2[N];
	int top1 = 0,top2 = 0;
	for(int i = Tree::head[x];i;i=Tree::e[i].next)
		if(Tree::e[i].to!=Tree::fa[x])
			stack1[++top1]=Tree::e[i].to;
	for(int i = Tree::head[y];i;i=Tree::e[i].next)
		if(Tree::e[i].to!=Tree::fa[y])
			stack2[++top2]=Tree::e[i].to;
	sort(stack1+1,stack1+1+top1,cmp);
	sort(stack2+1,stack2+1+top2,cmp);
	Flow::init();
	int j;
	for(int i = 1;i<= top1;i=j)
	{
		for(j=i+1;j<=top1&&hash[stack1[i]]==hash[stack1[j]];j++);
		for(int k=i;k<j;k++)
			for(int l=i;l<j;l++)
				Flow::add(k,top1+l,1,f[stack1[k]][stack2[l]]);
	}
	int S = 0,T = 2*n+1;
	for(int i = 1;i<= top1;i++)
	{
		Flow::add(S,i,1,0);
		Flow::add(i+top1,T,1,0);
	}
	return Flow::getmcf(S,T)+(f1[x]^f2[y]);
}
pair<pair<int,ull>,int> sorter[N]; 
int main()
{
	int x,y;
	scanf("%d",&n);
	Tree::tot = 1;
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		Tree::add(x,y);
	}
	for(int i = 1;i<= n;i++)scanf("%d",&f1[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&f2[i]);
	Tree::Get_G(1,0);
	if(cg[1])
	{
		root = ++n;
		for(int i = Tree::head[cg[1]];i;i=Tree::e[i].next)
			if(Tree::e[i].to==cg[0])
			{
				Tree::e[i].to = Tree::e[i^1].to = n;
				break;
			}
		Tree::add(root,cg[0]);
		Tree::add(root,cg[1]);
	}else root = cg[0];
	Tree::Get_Hash(root);
	for(int i = 1;i<= n;i++)
		sorter[i] = make_pair(make_pair(-Tree::dep[i],hash[i]),i);
	sort(sorter+1,sorter+n+1);
	int j;
	for(int i = 1;i<= n;i=j)
	{
		for(j=i+1;j<=n&&sorter[i].first==sorter[j].first;j++);  
        for(int x=i;x<j;x++)  
            for(int y=i;y<j;y++)  
                f[sorter[x].second][sorter[y].second]=solve(sorter[x].second,sorter[y].second);  
	}
	printf("%d\n",f[root][root]);
	return 0;
}
Problem3198

#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>

#define md 1234567
#define ll long long
#define inf (int) 1e9
#define eps 1e-8
#define N 1234590
#define cg 23333LL
#define M 500010
using namespace std;
int n;
int a[N][6],c[10][10];
ll ans[7];
bool same(int x,int y,int opt)
{
	for (int i=0;i<=5;i++) if ((opt&(1<<i))&&a[x][i]!=a[y][i]) return 0;
	return 1;
}
	
struct ha
{
	ll a[N];
	int q[N],is[N];
	int sz;
	ll clear()
	{
		ll ans=0;
		for (int i=1;i<=sz;i++)
		{
			int x=q[i];
			ans+=a[x]*(a[x]-1)/2;
			a[x]=is[x]=0;
		}
		sz=0;
		return ans;
	}
	void insert(int k,int x,int opt)
	{
		int pos=k;
		while (a[pos]&&(!same(x,is[pos],opt))) pos=(pos+1)%md; 
		if (!a[pos]) q[++sz]=pos,is[pos]=x;
		a[pos]++;
	}
} hash;

ll solve(int opt)
{
	for (int i=1;i<=n;i++)
	{
		ll ha=0;
		for (int j=0;j<=5;j++)
		{
			ha=ha*cg%md;
			if (opt&(1<<j)) { ha=(ha+a[i][j]+1)%md;}
		}
		hash.insert(ha,i,opt);
	}
	return hash.clear();
}
int cal(int i)
{
	int sum=0;
	for (int j=0;j<=5;j++) sum+=(i>>j)&1;
	return sum;
}
int main()
{
	int k;
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++)
		for(int j=0;j<=5;j++)
			scanf("%d",&a[i][j]);
	for (int i=0;i<=63;i++) ans[cal(i)]+=solve(i);
	c[0][0]=1;
	for (int i=1;i<=6;i++)
		for (int j=0;j<=i;j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j];
	for (int i=6;i>=k;i--)
		for (int j=0;j<i;j++)
			ans[j]-=ans[i]*c[i][j];
	printf("%lld\n",ans[k]);
	return 0;
}
Problem3207

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
const int N = 100005;
const int M = 8e6+5;
int num[N],n,m,k,Num,cnt;
ull a[N],T[N];
int find(ull x)
{
	int l = 1,r = Num+1;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(T[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int root[N],ls[M],rs[M],sum[M];
void init()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&num[i]);
	for(int i=1;i+k-1<=n;i++)
	{
		for(int j = i;j<=i+k-1;j++)
			a[i] = (a[i]<<31)+num[j];
		T[++Num] = a[i];
	}
	sort(T+1,T+Num+1);
}
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)
		update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
void Find(int x,int y,int k)
{
	if(x>y){printf("Yes\n");return ;}
	int l = 1,r = Num;
	x = root[x],y = root[y];
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(k<=mid)
		{
			x = ls[x],y = ls[y];
			r = mid;
		}else
		{
			x = rs[x],y = rs[y];
			l = mid+1;
		}
	}
	if(sum[y]-sum[x]>0)printf("No\n");
	else printf("Yes\n");
}
ull hash()
{
	int tmp[25];
	ull t = 0;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&tmp[i]);
		t = (t<<31)+tmp[i];
	}
	return t;
}
int main()
{
	init();
	for(int i =1;i<= Num;i++)
		update(root[i],root[i-1],1,Num,find(a[i]));
	int x,y;
	while(m--)
	{
		scanf("%d%d",&x,&y);
		ull t = hash();
		int tmp = find(t);
		if(T[tmp]!=t)printf("Yes\n");
		else
			Find(x-1,y-k+1,tmp);
	}
	return 0;
}
Problem3209

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL mod = 10000007;
LL c[55][55];
LL x,y;
LL quick_pow(LL x,LL y)
{
    if(y==0)return 1;
    LL tmp = quick_pow(x,y/2);
    if(y&1)return tmp*tmp%mod*x%mod;
    else return tmp*tmp%mod;
}
int main()
{
    c[1][0] = c[1][1] = 1;
    for(int i = 2;i<= 53;i++)
    {
        c[i][0] = 1;
        for(int j = 1;j<= 53;j++)
            c[i][j] = c[i-1][j-1]+c[i-1][j];
    }
    LL n,ans = 1,cnt = 0;
    scanf("%lld",&n);
    for(int i = 53;i>=1;i--)
    {
        if((n&((LL)1<<(i-1)))!=0)
        {
            ans = ans*(cnt+1)%mod;
            for(int j = i-1;j>=1;j--)
                ans = ans*quick_pow(j+cnt,c[i-1][j])%mod;
            cnt++;
        }
    }
    printf("%lld",ans);
    return 0;
}
Problem3217

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1100005;
const int M = 35000005;
const int mod = 1048576;
double alpha = 0.81;
int stack[305],top,a[N],n,m,n0;
struct Trie
{
	int ch[M][2],num[M],cnt;
	queue<int>Q;
	int Addpoint()
	{
		if(!Q.empty())
		{
			int tmp = Q.front();Q.pop();
			ch[tmp][0] = ch[tmp][1] = 0;
			num[tmp] = 0;
			return tmp;
		}
		return ++cnt;
	}
	void Delete(int x)
	{
		if(!x)return ;
		Q.push(x);
		Delete(ch[x][0]);Delete(ch[x][1]);
	}
	void Insert(int &now,int v,int dep,int top)
	{
		if(!now)now = Addpoint();
		num[now]+=top;
		if(dep<0)return ;
		if(v>>dep&1)Insert(ch[now][1],v,dep-1,top);
		else Insert(ch[now][0],v,dep-1,top);
	}
	int merge(int x,int y)
	{
		if(!x&&!y)return 0;
		int ret = Addpoint();
		ch[ret][0] = merge(ch[x][0],ch[y][0]);
		ch[ret][1] = merge(ch[x][1],ch[y][1]);
		num[ret] = num[x]+num[y];
		return ret;
	}
	int getans(int x,int dep)
	{
		if(dep<0)return 0;
		int tmp = x>>dep&1,sum = 0;
		for(int i = 1;i<= top;i++)
			sum+=num[ch[stack[i]][tmp^1]];
		for(int i = 1;i<= top;i++)
			stack[i] = ch[stack[i]][sum ? tmp^1 : tmp];
		return getans(x,dep-1)+(sum?1<<dep:0);
	}
}trie;
struct Node
{
	int mx,sx;
	Node(){}
	Node(int mx,int sx):mx(mx),sx(sx){}
	void ins(int x)
	{
		if(x>mx)sx = mx,mx = x;
		else if(x>sx)sx = x;
	}
};
Node merge(Node r1,Node r2)
{
	Node ret = r1;
	ret.ins(r2.mx),ret.ins(r2.sx);
	return ret;
}
struct Balanced_Tree
{
	queue<int>Q;
	int ch[N][2],root[N],fa[N],size[N],val[N],sz[N],b[N];
	int cnt,Root,fre,pre,tar;
	Node n1,v[N];
	int Addpoint()
	{
		if(!Q.empty())
		{
			int t = Q.front();Q.pop();
			ch[t][0]=ch[t][1]=root[t]=fa[t]=size[t]=val[t]=b[t]=0;
			v[t] = Node(0,0);
			return t;
		}
		return ++cnt;
	}
	int NewNode(int x)
	{
		int ret = Addpoint();
		b[ret] = 1;
		val[ret] = x;
		size[ret] = sz[ret] = 1;
		v[ret] = Node(x,0);
		trie.Insert(root[ret],x,20,1);
		return ret;
	}
	void Push_up(int x)
	{
		size[x] = size[ch[x][0]]+size[ch[x][1]];
		sz[x] = size[x]+1;
		root[x] = trie.merge(root[ch[x][0]],root[ch[x][1]]);
		v[x] = merge(v[ch[x][0]],v[ch[x][1]]);
		fa[ch[x][0]] = fa[ch[x][1]] = x;
	}
	int Build(int l,int r)
	{
		if(l>r)return 0;
		if(l==r)return NewNode(a[l]);
		int mid = (l+r)>>1,ret = Addpoint();
		ch[ret][0] = Build(l,mid);
		ch[ret][1] = Build(mid+1,r);
		Push_up(ret);
		return ret;
	}
	void dfs(int x)
	{
		if(!x)return ;
		Q.push(x);
		trie.Delete(root[x]);
		if(b[x]){a[++n] = val[x];return ;}
		dfs(ch[x][0]),dfs(ch[x][1]);
	}
	void Rebuild(int x)
	{
		trie.Delete(root[x]);
		n = 0;
		dfs(ch[x][0]),dfs(ch[x][1]);
		int tmp = Build(1,n);
		if(x==Root)Root = tmp;
		fa[tmp] = fa[x];
		ch[fa[x]][ch[fa[x]][1]==x]=tmp;
	}
	void Insert(int &now,int x,int y)
	{
		if(size[now]==1||!now)
		{
			int t = NewNode(y),ret = Addpoint();
			fa[ret] = pre;
			ch[ret][0] = t,ch[ret][1] = now;
			Push_up(ret);
			now = ret;
			return ;
		}
		pre=now;
		if(size[ch[now][0]]>=x)Insert(ch[now][0],x,y);
		else Insert(ch[now][1],x-size[ch[now][0]],y);
		trie.Insert(root[now],y,20,1);
		v[now].ins(y);
		size[now]++;sz[now]+=2;
		fa[ch[now][0]] = fa[ch[now][1]] = now;
		if(max(sz[ch[now][0]],sz[ch[now][1]])>sz[now]*alpha)
			fre = now;
	}
	void Delete(int &now,int x)
	{
		if(b[now])
		{
			Q.push(now);
			tar = val[now];
			now = 0;
			return ;
		}
		if(size[ch[now][0]]>=x)Delete(ch[now][0],x);
		else Delete(ch[now][1],x-size[ch[now][0]]);
		trie.Insert(root[now],tar,20,-1);
		v[now] = merge(v[ch[now][0]],v[ch[now][1]]);
		size[now]--;sz[now]--;
		fa[ch[now][0]] = fa[ch[now][1]] = now;
		if(max(sz[ch[now][0]],sz[ch[now][1]])>sz[now]*alpha)
			fre = now;
	}
	void Insert(int x,int y)
	{
		fre = 0;
		Insert(Root,x,y);
		if(fre)
			Rebuild(fre);
	}
	void Delete(int x)
	{
		fre = 0;
		Delete(Root,x);
		if(fre)
			Rebuild(fre);
	}
	void Find(int now,int pre,int x,int y)
	{
		if(pre+1>=x&&pre+size[now]<=y)
		{
			stack[++top] = root[now];
			n1 = merge(n1,v[now]);
			return ;
		}
		if(pre+size[ch[now][0]]>=x)
			Find(ch[now][0],pre,x,y);
		if(pre+size[ch[now][0]]<y)
			Find(ch[now][1],pre+size[ch[now][0]],x,y);
	}
	Node Find(int x,int y)
	{
		top = 0;
		n1 = Node(0,0);
		Find(Root,0,x,y);
		return n1;
	}
}sheep;
int main()
{
	int lastans = 0;
	scanf("%d%d",&n,&m);n0=n;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	sheep.Root=sheep.Build(1,n);
	int x,y;
	char opt[3];
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%mod;
			n0++;
			sheep.Insert(x,y);
		}else if(opt[0]=='D')
		{
			scanf("%d",&x);
			x = (x+lastans)%n0+1;n0--;
			sheep.Delete(x);
		}else if(opt[0]=='C')
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%mod;
			sheep.Delete(x);
			sheep.Insert(x,y);
		}else
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%n0+1;
			Node tmp = sheep.Find(x,y);
			lastans = trie.getans(tmp.sx,20);
			printf("%d\n",lastans);
		}
		//printf("Ask:%c %d %d\nAns = %d\n",opt[0],x,y,lastans);
	}
	return 0;
}
Problem3219

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N=100005;
int to[N<<1],ne[N<<1],val[N<<1],v[N<<1];
int fi[N],V[N],num[N],mx[N],fa[N],dep[N],f[N],g[N];
int q[N],d[N],n,L,R,tot=0,cur,rt;
bool u[N];
inline int read() 
{
    int x=0,f=1;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f=-1;ch = getchar();}
    while(ch >='0' && ch <='9'){x=(x<<1)+(x<<3)+ch-'0';ch = getchar();}
    return x*f;
}
void add(int x,int y,int z)
{
	to[++tot]=y;val[tot]=z;ne[tot]=fi[x];fi[x]=tot;
}
void findrt(int x)
{
	num[x]=1;mx[x]=0;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]] && to[i]!=fa[x])
	{
		fa[to[i]]=x;
		findrt(to[i]);
		num[x]+=num[to[i]];
		mx[x]=std::max(mx[x],num[to[i]]);
	}
	mx[x]=std::max(mx[x],cur-num[x]);
	if (mx[x]<mx[rt]) rt=x;
}
bool work(int x,int sum)
{
	if (sum<=L) return 0;
	cur=sum;rt=0;
	findrt(x);u[x=rt]=1;
	int maxdep=0;f[0]=0;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]])
	{
		int s=1,t=1,head=1,tail=0;
		for (int j=maxdep;j>=L;j--)
		{
			for (;head<=tail && f[d[tail]]<=f[j];tail--);
			d[++tail]=j;
		}
		fa[q[1]=to[i]]=x;dep[to[i]]=1;g[to[i]]=v[i];
		for (;s<=t;s++)
		{
			for (;head<=tail && d[head]+dep[q[s]]>R;head++);
			if (dep[q[s]]<=L)
			{
				for (;head<=tail && f[d[tail]]<=f[L-dep[q[s]]];tail--);
				d[++tail]=L-dep[q[s]];
			}
			if (head<=tail && f[d[head]]+g[q[s]]>=0) return 1;
			if (dep[q[s]]>=R) continue;
			for (int j=fi[q[s]];j;j=ne[j])
			if (!u[to[j]] && to[j]!=fa[q[s]])
			{
				fa[q[++t]=to[j]]=q[s];
				dep[to[j]]=dep[q[s]]+1;
				g[to[j]]=g[q[s]]+v[j];
			}
		}
		maxdep=std::max(maxdep,dep[q[t]]);
		for (int j=1;j<=t;j++) f[dep[q[j]]]=std::max(f[dep[q[j]]],g[q[j]]);
	}
	for (int i=0;i<=maxdep;i++) f[i]=-n;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]])
	{
		if (num[to[i]]>num[x]) num[to[i]]=sum-num[x];
		if (work(to[i],num[to[i]])) return 1;
	}
	return 0;
}
bool check(int mid)
{
	for (int i=1;i<=tot;i++)
		if (val[i]<mid) v[i]=-1;else v[i]=1;
	for (int i=0;i<=n;i++) u[i]=false,fa[i]=0,f[i]=-n;
	mx[0]=n;
	return work(1,n);
}
int main()
{
	n = read();
	L = read();
	R = read();
	for (int i=1;i<n;i++)
	{
		int x,y,z;
		x = read();y = read();z = read();
		add(x,y,z);add(y,x,z);V[i]=z;
	}
	std::sort(V+1,V+n);
	int m=std::unique(V+1,V+n)-V-1;
	V[0]=-1;
	int l=1,r=m,ans=0,mid;
	for (;l<=r;)
	{
		mid=(l+r)>>1;
		if (check(V[mid])) ans=mid,l=mid+1;
			else r=mid-1;
	}
	printf("%d\n",V[ans]);
}
Problem3223

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct S{
	S *son[2],*fa;
	int val,size,flag;
	S(){}
	void reverse()
	{
		flag ^=1;
		swap(son[0],son[1]);
	}
	void push_down()
	{
		if(flag==1)
		{
			son[0]->reverse();
			son[1]->reverse();
			flag = 0;
		}
	}
	void push_up()
	{
		size = son[0]->size+son[1]->size+1;
	}
	void Combine(S *a,bool dir) 
	{
        son[dir] = a;
        a->fa = this;
    }
    bool Check() {
        return fa->son[1] == this;
    }
}none,*nil = &none,*root = nil;
int n,m;
S* Newnode(S *now,int x)
{
	S *re = new S();
	re->val = x;
	re->son[0] = re->son[1]  = nil;
	re->size = 1; re->flag = 0;
	re->fa = now;
	return re;
}
S* build(int l,int r)
{
	if(l>r)return nil;
	int mid = (l+r)>>1;
	S *re = nil;
	re = Newnode(re,mid);
	re->Combine(build(l,mid - 1),false);
    re->Combine(build(mid + 1,r),true);
	re->push_up();
	return re;
}
void Rotate(S *a,bool dir)
{
    S *f = a->fa;
    f->push_down(),a->push_down();
    f->son[!dir] = a->son[dir];
    f->son[!dir]->fa = f;
    a->son[dir] = f;
    a->fa = f->fa;
    f->fa->son[f->Check()] = a;
    f->fa = a;
    f->push_up();
    if(root == f)   root = a;
}
 
void Splay(S *a,S *aim)
{
    while(a->fa != aim) {
        if(a->fa->fa == aim) 
            Rotate(a,!a->Check());
        else if(!a->fa->Check()) {
            if(!a->Check()) {
                Rotate(a->fa,true);
                Rotate(a,true);
            }
            else {
                Rotate(a,false);
                Rotate(a,true);
            }
        }
        else {
            if(a->Check()) {
                Rotate(a->fa,false);
                Rotate(a,false);
            }
            else {
                Rotate(a,true);
                Rotate(a,false);
            }
        }
    }
    a->push_up();
}
S* find_rank(S *now,int x)
{
	now->push_down();
	if(x<=now->son[0]->size)return find_rank(now->son[0],x);
	x = x-now->son[0]->size;
	if(x==1)return now;
	return find_rank(now->son[1],x-1);
}
void work(int x,int y)
{
	x++;y++;
	Splay(find_rank(root,x-1),nil);
	Splay(find_rank(root,y+1),root);
	root->son[1]->son[0]->reverse();
}
void print(S *now)
{
	if(now==nil)return ;
	now->push_down();
	print(now->son[0]);
	if(now->val&&now->val!=n+1)
		printf("%d ",now->val);
	print(now->son[1]);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	root = build(0,n+1);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		work(x,y);
	}
	print(root);
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <time.h>
using namespace std;
struct Treap
{
	Treap *ls,*rs;
	int val,key,cnt,size;
	Treap(int f)
	{
		ls = rs = NULL;
		val = f;
		key = rand();
		cnt = size = 1;
	}
	void push_up()
	{
		size = cnt;
		if(ls) 
			size+=ls->size;
		if(rs)
			size+=rs->size;
	}
};
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key > x->key)
			go_right(x);
	}else
	{
		insert(x->rs,y);
		if(x->rs->key > x->key)
			go_left(x);
	}
	x->push_up();
}
void dele(Treap *&x,int y)
{
	if(y<x->val)
		dele(x->ls,y);
	else if(y>x->val)
		dele(x->rs,y);
	else
	{
		if(x->cnt>1)
			x->cnt--;
		else if(!x->ls)
			x = x->rs;
		else if(!x->rs)
			x = x->ls;
		else
		{
			go_left(x);
			dele(x->ls,y);
			if(x->ls && x->ls->key > x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int query_rank(Treap *x,int y)
{
    if(!x)return 0;
    int tmp;
    if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(x->val==y)return tmp+1;
	else if(y>x->val)
		return tmp+x->cnt+query_rank(x->rs,y);
	else return query_rank(x->ls,y);
}
int query_num(Treap *x,int y)
{
    if(!x)return 0;
    int tmp;
    if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(y<=tmp)
		return query_num(x->ls,y);
    else if(y>tmp+x->cnt)
		return query_num(x->rs,y-tmp-x->cnt);
    else return x->val;
}
/*int getrank(Treap *x,int y,int tr)
{
	if((y<x->val&&x->ls!=NULL)||(y>x->val&&!x->ls))
		return getrank(x->ls,y,tr);
	else if(y>x->val&&x->rs!=NULL)
		return getrank(x->rs,y,tr+x->ls->size);
	else
	{
		if(!x->ls)return tr+1;
		else return tr+x->ls->size+1;
	}
}
int getnum(Treap *x,int y,int ts)
{
	if(y>=ts&&y<=ts+x->cnt)
		return x->val;
	else if(y < x->size+ts&&x->ls!=NULL)
		return getnum(x->ls,y);
	else
		return getnum(x->rs,y);
}*/
int b,q;
/*void getb(Treap *x,int y)
{
	if(x->val<y)b = max(b,x->val);
	if(y<=x->val&&x->ls!=NULL)
		getb(x->ls,y);
	else if(y>x->val&&x->rs!=NULL)
		getb(x->rs,y);
	else return ;
}
void getq(Treap *x,int y)
{
	if(x->val>y)q = min(q,x->val);
	if(y<x->val&&x->ls!=NULL)
		getb(x->ls,y);
	else if(y>=x->val&&x->rs!=NULL)
		getb(x->rs,y);
	else return ;
}*/
int ans;
void query_pro(Treap *x,int y)
{
    if(!x)return;
    if(x->val<y)
	{
		ans=max(ans,x->val);query_pro(x->rs,y);
	}
    else query_pro(x->ls,y);
}
void query_sub(Treap *x,int y)
{
	if(!x)return;
	if(x->val>y)
	{
		ans=min(ans,x->val);query_sub(x->ls,y);
	}
	else query_sub(x->rs,y);
}
int main()
{
	//srand(time(NULL));
	int n,opt,x;
	scanf("%d",&n);
	Treap *root = NULL;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)insert(root,x);
		else if(opt==2)dele(root,x);
		else if(opt==3)printf("%d\n",query_rank(root,x));
		else if(opt==4)printf("%d\n",query_num(root,x));
		else if(opt==5)
			{ans = 0;query_pro(root,x);printf("%d\n",ans);}
		else {ans = 0x3f3f3f3f;query_sub(root,x);printf("%d\n",ans);}
	}
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct S{
	S *son[2],*fa;
	int val,size,cnt;
	S(){}
	int compare(int x)
	{
		if(x==val)return -1;
		else return x>val;
	}
	void push_up()
	{
		size = cnt;
		size+=son[0]->size;
		size+=son[1]->size;
	}
}none,*nil = &none,*root = nil;
S* newnode(S *now,int x)
{
	S *re = new S();
    re->cnt = re->size = 1;
    re->val = x;
    re->son[0] = re->son[1] = nil;
    re->fa = now;
    return re;
}
void go_right(S *x)
{
	S *y = x->fa;
	y->son[0] = x->son[1];
	x->son[1]->fa = y;
	x->son[1] = y;
	x->fa = y->fa;
	if(y==y->fa->son[0])
		y->fa->son[0] = x;
	else if(y==y->fa->son[1])
		y->fa->son[1] = x;
	y->fa = x;
	y->push_up();
	x->push_up();
	if(root == y)
		root = x;
}
void go_left(S *x)
{
	S *y = x->fa;
	y->son[1] = x->son[0];
	x->son[0]->fa = y;
	x->son[0] = y;
	x->fa = y->fa;
	
	if(y==y->fa->son[0])
		y->fa->son[0] = x;
	else if(y==y->fa->son[1])
		y->fa->son[1] = x;
	y->fa = x;
	y->push_up();
	x->push_up();
	if(root == y)
		root = x;
}
void Update(S* now)
{
    now->push_up();
    if(now != root)
        Update(now->fa);
}
void Splay(S *x,S *target)
{
	while(true)
	{
		S *y = x->fa;
		S *z = y->fa;
		if(y==target)
			break;
		if(z==target)
		{
			if(x==y->son[0])go_right(x);
			else go_left(x);
			break;
		}
		else if(x==y->son[0])
		{
			if(y==z->son[0]){go_right(y);go_right(x);}
			else {go_right(x);go_left(x);}
		}else
		{
			if(y==z->son[1]){go_left(y);go_left(x);}
			else {go_left(x);go_right(x);}
		}
	}
	x->push_up();
}
void Insert(int x)
{
	if(root==nil)
	{
		root = newnode(nil,x);return ;
	}
	S *now = root;
	while(1)
	{
		int dir = now->compare(x);
		if(dir==-1)
		{
			now->cnt++;
			Update(now);
			break ;
		}else if(now->son[dir]!=nil)
			now = now->son[dir];
		else
		{
			now->son[dir] = newnode(now,x);
			Update(now);
			Splay(now->son[dir],nil);break ;
		}
	}
}
void Delete(S *&now,int x)
{
	int dir = now->compare(x);
	if(dir!=-1)
		Delete(now->son[dir],x);
	else 
	{
		if(now->cnt>1)now->cnt--;
		else
		{
			if(now->son[0]==nil){now->son[1]->fa = now->fa;now = now->son[1];}
			else if(now->son[1]==nil){now->son[0]->fa = now->fa;now = now->son[0];}
			else 
			{
				go_right(now->son[0]);
				Delete(now->son[1],x);
			}
		}
	}
	if(now!=nil)now->push_up();
}
int get_rank(S *now,int x)
{
	int re = now->son[0]->size;
	int dir = now->compare(x);
	if(dir==-1)return re+1;
	else if(dir==0)return get_rank(now->son[0],x);
	return re+now->cnt+get_rank(now->son[1],x);
}
int get_num(S *now,int x)
{
	if(x<=now->son[0]->size)return get_num(now->son[0],x);
	x = x-now->son[0]->size;
	if(x<=now->cnt)return now->val;
	x = x-now->cnt;
	return get_num(now->son[1],x);
}
int get_pre(S* now,int x)
{
	if(now==nil)return -0x3f3f3f3f;
	else if(x<=now->val)return get_pre(now->son[0],x);
	else return max(now->val,get_pre(now->son[1],x));
}
int get_suc(S* now,int x)
{
	if(now==nil)return 0x3f3f3f3f;
	else if(x>=now->val)return get_suc(now->son[1],x);
	else return min(now->val,get_suc(now->son[0],x));
}
int main()
{
	int n,x,opt;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&opt,&x);
		switch(opt)
		{
			case 1:Insert(x);break;
			case 2:Delete(root,x);break;
			case 3:printf("%d\n",get_rank(root,x));break;
			case 4:printf("%d\n",get_num(root,x));break;
			case 5:printf("%d\n",get_pre(root,x));break;
			case 6:printf("%d\n",get_suc(root,x));break;
		}
	}
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 1e8+1;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,size,key;
	Treap(int x);
	void push_up();
};
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size =cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(x==NULL)
		x = new Treap(y);
	else if(x->val==y)
		x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(x==NULL)return ;
	else if(x->val==y)
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x= x->rs;
		else if(!x->rs)x= x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}else if(y<x->val)
		Delete(x->ls,y);
	else Delete(x->rs,y);
	if(x)x->push_up();
}
int get_rank(Treap *x,int y)
{
	if(x==NULL)return 0;
	if(x->val==y)
	{
		if(x->ls)return x->ls->size;
		else return 0;
	}else if(y<x->val)
		return get_rank(x->ls,y);
	else
	{
		int tmp = x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_rank(x->rs,y);
	}
}
int get_num(Treap *x,int y)
{
    if(!x)return 0;
    int tmp = 0;
    if(x->ls)tmp+=x->ls->size;
	if(y<=tmp)
		return get_num(x->ls,y);
    else if(y>tmp+x->cnt)
		return get_num(x->rs,y-tmp-x->cnt);
    else return x->val;
}
int pre,sub;
void get_pre(Treap *x,int y)
{
	if(x==NULL)return ;
	else if(y<=x->val)get_pre(x->ls,y);
	else
	{
		pre = max(pre,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(x==NULL)return ;
	else if(y<x->val)
	{
		sub = min(sub,x->val);
		get_sub(x->ls,y);
	}else get_sub(x->rs,y);
}
int main()
{
	int n,opt,x;
	scanf("%d",&n);
	Treap *root = NULL;
	while(n--)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)Insert(root,x);
		else if(opt==2)Delete(root,x);
		else if(opt==3)printf("%d\n",get_rank(root,x)+1);
		else if(opt==4)printf("%d\n",get_num(root,x));
		else if(opt==5)pre = -INF,get_pre(root,x),printf("%d\n",pre);
		else sub = INF,get_sub(root,x),printf("%d\n",sub);
	}
	return 0;
}
Problem3230

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long ll;
char s[N];
int cnt[N],sa[N],v[N],nv[N],q[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim=0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i= 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j=max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
int st[18][N];
int log_2[N];
void build_st(int len)
{
	for(int i = 1;i<len;i++)
		st[0][i]=h[i];
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i+(1<<(j-1))<len;i++)
			st[j][i]=min(st[j-1][i],st[j-1][i+(1<<(j-1))]);
	for(int i = 2;i<N;i++)
		log_2[i]=log_2[i>>1]+1;
}
int getans(int l,int r,int n)
{
	l=rnk[l],r=rnk[r];
	if(l>r)swap(l,r);
	l++;
	if(l>r)return n-sa[r];
	int lth = log_2[r-l+1];
	return min(st[lth][l],st[lth][r-(1<<lth)+1]); 
}
ll sum[N];
struct Ask
{int l,r,p,q,a,b;ll ans;}ask[N];
int find(ll x,int n)
{
	int l = 0,r = n,ans=-1;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(sum[mid]<x)l=mid+1;
		else r = mid-1,ans=mid;
	}
	return ans;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	scanf("%s",s);
	build_sa(n,256);
	build_rank(n);
	build_height(n);
	build_st(n);
	for(int i = 0;i<n;i++)
		sum[i]=n-sa[i]-h[i];
	for(int i = 1;i< n;i++)
		sum[i]+=sum[i-1];
	ll x,y;
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld%lld",&x,&y);
		int l = find(x,n),p=find(y,n);
		if(l==-1||p==-1){ask[i].ans=-1;continue;}
		ask[i].l=sa[l],ask[i].p=sa[p];
		if(l>=1)ask[i].r=x-sum[l-1]+ask[i].l+h[l]-1;
		else ask[i].r=ask[i].l+x-1;
		if(p>=1)ask[i].q=y-sum[p-1]+ask[i].p+h[p]-1;
		else ask[i].q=ask[i].p+y-1;
		ask[i].a=min(min(ask[i].r-ask[i].l+1,ask[i].q-ask[i].p+1),getans(ask[i].l,ask[i].p,n));
	}
	for(int i = 0;i<n/2;i++)swap(s[i],s[n-i-1]);
	build_sa(n,256);
	build_rank(n);
	build_height(n);
	build_st(n);
	for(int i = 1;i<= q;i++)
	if(ask[i].ans!=-1)
	{
		ask[i].b=min(min(ask[i].r-ask[i].l+1,ask[i].q-ask[i].p+1),getans(n-ask[i].r-1,n-ask[i].q-1,n));
		ask[i].ans=(ll)ask[i].a*ask[i].a+(ll)ask[i].b*ask[i].b;
	}
	for(int i = 1;i<= q;i++)
		printf("%lld\n",ask[i].ans);
	return 0;
}
Problem3232

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const int N = 105;
const int S = 8e4+5;
int sl[N][N],sr[N][N];
struct E
{int next,to;double dis,a,b;}e[S];
int head[S],tot;
void add(int x,int y,double a,double b)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].a = a,e[tot].b = b;
}
bool inq[S];
double dis[S];
bool dfs(int x)
{
	inq[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(dis[e[i].to]>dis[x]+e[i].dis)
		{
			dis[e[i].to]=dis[x]+e[i].dis;
			if(inq[e[i].to])return true;
			if(dfs(e[i].to))return true;
		}
	inq[x] = false;
	return false;
}
int cnt,id[N][N];
bool check(double mid)
{
	memset(dis,0,sizeof(dis));
	memset(inq,0,sizeof(inq));
	for(int i = 1;i<= tot;i++)
		e[i].dis = -(e[i].a-mid*e[i].b);
	for(int i = 1;i<= cnt;i++)
		if(dfs(i))return true;
	return false;
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			sl[i][j] = sl[i][j-1]+x;
			sr[i][j] = sr[i-1][j]+x;
		}
	for(int i = 0;i<= n;i++)
		for(int j = 0;j<= m;j++)
			id[i][j] = ++cnt;
	for(int i = 0;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			add(id[i][j-1],id[i][j],sr[i][j],x);
			add(id[i][j],id[i][j-1],-sr[i][j],x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<= m;j++)
		{
			scanf("%d",&x);
			add(id[i-1][j],id[i][j],-sl[i][j],x);
			add(id[i][j],id[i-1][j],sl[i][j],x);
		}
	double l = 0,r = 1e9;
	while(fabs(l-r)>eps)
	{
		double mid = (l+r)/2;
		if(check(mid))l=mid;
		else r = mid;
	}
	printf("%.3lf\n",l/2);
	return 0;
}
Problem3233

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5;
int n,a[55];
int f[N+5],prime[N],cnt;
bool vis[N+5];
void quick_prime()
{
	for(int i = 2;i<= N;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<=N;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	quick_prime();
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	memset(f,0x3f,sizeof(f));
	f[1] = 0;
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= N;i++)
	{
		for(int j = 1;j<= cnt&&i*prime[j]<=N;j++)
		{
			int val = i*prime[j];
			ll tmp = 0;
			for(int k = 1;k<= n;k++)
				tmp+=a[k]%val/i;
			if(tmp<=0x3f3f3f3f)
				f[val] = min(f[val],f[i]+(int)tmp);
		}
		ll tmp = f[i];
		for(int k = 1;k<= n;k++)
			tmp+=a[k]/i;
		if(tmp<=0x3f3f3f3f)
			ans = min(ans,(int)tmp);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3238

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
typedef long long ll;
char s[N];
int val[N],newval[N],sa[N],cnt[N],q[N],rank[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rank[sa[i]] = i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
	if(rank[i])
	{
		int j = 0;
		if(i)j=max(0,h[rank[i-1]]-1);
		while(i+j<len&&sa[rank[i]-1]+j<len&&s[i+j]==s[sa[rank[i]-1]+j])j++;
		h[rank[i]] = j;
	}
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]-'a']++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[val[i]]] = i;
	for(int d=1;;d++)
	{
		int id = 0,hl = 1<<(d-1);
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++]=sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]]=q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)newval[sa[k]] = lim;
		}
		for(i = 0;i<len;i++)val[i]=newval[i];
		if(lim==len)break;
	}
}
struct Data
{
	int val,num;
}stack[N];
int main()
{
	scanf("%s",s);
	int n = strlen(s);
	build_sa(n,26);
	build_rank(n);
	build_height(n);
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=(ll)(i+1+n)*(n-i)/2+(ll)i*(n-i);
	int top = 0;
	ll nowans = 0;int nowcnt = 0;
	for(int i = 1;i<n;i++)
	{
		nowcnt = 1;
		while(top>=1&&h[i]<=stack[top].val)
		{
			nowcnt+=stack[top].num;
			nowans-=(ll)stack[top].num*stack[top].val;
			top--;
		}
		stack[++top]=(Data){h[i],nowcnt};
		nowans+=(ll)h[i]*nowcnt;
		ans-=nowans*2;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3238

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 500005;
struct E{int next,to;};
char s[N];
ll ans;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1],size[N<<1],f[N<<1],ct[N<<1],rnk[N<<1];
	int cnt,last;
	bool end[N<<1];
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np] = len[p]+1;
		end[np] = true;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[q] = fa[np] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	void getans(int n)
	{
		ans=0;
		for(int i = 1;i<= cnt;i++)f[i]=size[i]=end[i];
		for(int i=1;i<=cnt;i++) ct[len[i]]++;
		for(int i=1;i<=n;i++) ct[i]+=ct[i-1];
		for(int i=1;i<=cnt;i++) rnk[ct[len[i]]--]=i;
		for(int i=cnt;i;i--) f[fa[rnk[i]]]+=f[rnk[i]];
		for(int i=1;i<=cnt;i++)
		{
			ans+=(ll)size[fa[i]]*f[i]*len[fa[i]];
			size[fa[i]]+=f[i];
		}
	}
}sam;
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	sam.init();
	for(int i = n;i>0;i--)
		sam.insert(s[i]-'a');
	sam.getans(n);
	ans = -2*ans;
	for(int i = 1;i<= n;i++)ans+=(ll)(n-1)*i;
	printf("%lld\n",ans);
	return 0;
}
Problem3251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N=100005;
long long a[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,q,fa[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int dep[N];
void dfs(int x,int f)
{
	fa[x] = f;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
}
long long stack[100];
int top;
bool getans(int x,int y)
{
	top = 0;
	if(dep[y]>dep[x])swap(x,y);
	while(dep[x]>dep[y])
	{
		stack[++top] = a[x];
		if(top>=55)return true;
		x = fa[x];
	}
	while(x!=y)
	{
		stack[++top] = a[x];
		stack[++top] = a[y];
		if(top>=55)return true;
		x = fa[x],y = fa[y];
	}
	stack[++top] = a[x];
	sort(stack+1,stack+top+1);
	for(int i = 1;i<= top-2;i++)
		if(stack[i]+stack[i+1]>stack[i+2])
			return true;
	return false;
}
int main()
{
	//freopen("tree.in","r",stdin);
	//freopen("tree.out","w",stdout);
	int x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%I64d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	int ju;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ju,&x,&y);
		if(ju==0)
		{
			if(getans(x,y))printf("Y\n");
			else printf("N\n");
		}else
			a[x] = y;
	}
	return 0;
}
Problem3254

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int n,m;
const int N = 10;
const int M = 1e4+5;
const ll INF = 1e18;
int E1[M][N],E2[M][N];
int A[M][N],B[M][N],a[M][N];
ll f[M][1<<5],trs[M][1<<5][1<<5];
ll calc(int line,int sta)
{
	ll res = 0;
	int d[10]={0};
	for(int i = 1;i<= n;i++)
		d[i] = (sta>>(i-1))&1;
	for(int i = 1;i<= n;i++)
		res+=(d[i]^a[line][i])*B[line][i];
	for(int i = 1;i<= n;i++)
		res+=(d[i]^d[i%n+1])*E1[line][i];
	return res;
}
int main()
{
	int maxx=0;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&A[j][i]),maxx = max(maxx,A[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&B[j][i]),maxx = max(maxx,B[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 2;j<=m;j++)
			scanf("%d",&E2[j][i]),maxx = max(maxx,E2[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&E1[j][i]),maxx = max(maxx,E1[j][i]);
	int l = 1,cnt=0;
	while(l<=maxx)l<<=1,cnt++;
	//cnt--;
	ll Ans = 0;
	for(int j = 2;j<= m;j++)
		for(int sta = 0;sta<1<<n;sta++)
		{
			for(int pre = 0;pre<1<<n;pre++)
			{
				ll sum = 0;
				for(int i = 0;i< n;i++)
					if(((sta>>i)&1)^((pre>>i)&1))
						sum+=E2[j][i+1];
				trs[j][sta][pre] = sum;
			}
		}
	for(int s = 0;s<cnt;s++)
	{
		for(int j = 1;j<= m;j++)
			for(int i = 1;i<= n;i++)
				a[j][i]=(A[j][i]>>s)&1;
		for(int sta = 0;sta<1<<n;sta++)
			f[1][sta] = calc(1,sta);
		for(int j = 2;j<= m;j++)
			for(int sta = 0;sta<1<<n;sta++)
			{
				f[j][sta] = INF;
				ll tmp = calc(j,sta);
				for(int pre = 0;pre<1<<n;pre++)
					f[j][sta] = min(f[j][sta],f[j-1][pre]+trs[j][sta][pre]+tmp);
			}
		ll tmp = INF;
		for(int i = 0;i<1<<n;i++)
			tmp = min(tmp,f[m][i]);
		Ans += tmp*(1<<s);
	}
	printf("%lld\n",Ans);
	return 0;
}
Problem3261

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 600005;
const int INF = 0x3f3f3f3f;
struct Trie
{
	int cnt;
	int s[N*24][2],sum[N*24];
	int insert(int x,int val)
	{
		int tmp,y;tmp=y=++cnt;
		for(int i = 23;i>=0;i--)
		{
			s[y][0] = s[x][0];
			s[y][1] = s[x][1];
			sum[y]= sum[x]+1;
			int t = val&(1<<i);t = t>>i;
			x=s[x][t];
			s[y][t] = ++cnt;
			y = s[y][t];
		}
		sum[y]=sum[x]+1;
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 23;i>= 0;i--)
		{
			int t = val&(1<<i);t = t>>i;
			if(sum[s[r][t^1]]-sum[s[l][t^1]])
				ans+=(1<<i),r = s[r][t^1],l = s[l][t^1];
			else r = s[r][t],l = s[l][t];
		}
		return ans;
	}
}trie;
int a[N],b[N],root[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);n++;
	for(int i = 2;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)b[i] = b[i-1]^a[i];
	for(int i = 1;i<= n;i++)
		root[i]=trie.insert(root[i-1],b[i]);
	char opt[3];
	int l,r,x;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='A')
		{
			n++;
			scanf("%d",&a[n]);
			b[n] = b[n-1]^a[n];
			root[n] = trie.insert(root[n-1],b[n]);
		}else
		{
			scanf("%d%d%d",&l,&r,&x);
			printf("%d\n",trie.getans(root[l-1],root[r],b[n]^x));
		}
	}
	return 0;
}
Problem3262

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct Treap
{
	Treap *ls,*rs;
	int cnt,size,val,key;
	Treap(int x);
	void push_up();
}*root[N];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	cnt = size = 1;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y>x->val)
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}else
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	x->push_up();
}
int get_rank(Treap *x,int y)
{
	if(!x)return 0;
	int tmp;
	if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(x->val==y)return tmp+x->cnt;
	else if(y>x->val)return tmp+x->cnt+get_rank(x->rs,y);
	else return get_rank(x->ls,y);
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		Insert(root[i],y);
}
int getans(int x,int y)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=get_rank(root[i],y);
	return ans;
}
struct F
{int s,c,m,no;}flower[N];
bool cmp1(const F &a,const F &b)
{
	return a.s<b.s;
}
int id[N],cnt;
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int ans[N],no[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&flower[i].s,&flower[i].c,&flower[i].m);
		id[i] = flower[i].c;
		flower[i].no = i;
	}
	sort(flower+1,flower+n+1,cmp1);
	cnt = 0;
	sort(id+1,id+n+1);
	for(int i = 1;i<= n;i++)
		if(id[i]!=id[cnt])
			id[++cnt] = id[i];
	int st,end;
	for(int i = 1;i<= n;i=end+1)
	{
		st = i,end = i;
		while(flower[end].s==flower[st].s&&end<=n)end++;
		end--;
		for(int j = st;j<=end;j++)
		{
			int pos = find(flower[j].c);
			update(pos,flower[j].m);
		}
		for(int j = st;j<= end;j++)
		{
			int pos = find(flower[j].c);
			int rank = getans(pos,flower[j].m)-1;
			ans[rank]++;
			no[flower[j].no] = rank;
		}
		/*int pos = find(flower[i].c);
		int rank = getans(pos,flower[i].m);
		ans[rank]++;
		update(pos,flower[i].m);*/
	}
	//for(int i= 1;i<= n;i++)
	//	printf("%d : %d\n",i,no[i]);
	for(int i = 0;i< n;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3270

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 25;
const int M = N*N;
const double eps = 1e-8;
struct E{int next,to;}e[2*M];
int id[N][N],Cnt,tot,head[N],n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double f[M][M],cnt[N],p[N],ans[M];
void work()
{
	for(int i = 1;i<= n*n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(f[xn],f[i]);
		for(int line = i+1;line<= n*n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = i;j<=n*n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n*n;i>= 1;i--)
	{
		for(int j = i+1;j<= n*n;j++)
			f[i][n*n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n*n+1]/f[i][i];
	}
}
int main()
{
	int x,y,a,b;
	scanf("%d%d%d%d",&n,&m,&a,&b);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
		cnt[x]+=1.0,cnt[y]+=1.0;
	}
	for(int i = 1;i<= n;i++)
		scanf("%lf",&p[i]);
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<= n;j++)
			id[i][j] = ++Cnt;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= n;j++)
		{
			if(i!=j)
			{
				f[id[i][j]][id[i][j]] -= p[i]*p[j];
				for(int t = head[i];t;t = e[t].next)
					f[id[i][j]][id[e[t].to][j]] -= p[j]*(1-p[i])/cnt[i];
				for(int t = head[j];t;t = e[t].next)
					f[id[i][j]][id[i][e[t].to]] -= p[i]*(1-p[j])/cnt[j];
				for(int t1 = head[i];t1;t1 = e[t1].next)
					for(int t2 = head[j];t2;t2 = e[t2].next)
						f[id[i][j]][id[e[t1].to][e[t2].to]] -= (1-p[i])*(1-p[j])/cnt[i]/cnt[j];
			}
		}
	}
	for(int i = 1;i<= n*n;i++)
		for(int j=1;j<i;j++)
			swap(f[i][j],f[j][i]);
	for(int i = 1;i<= n*n;i++)
		f[i][i]+=1;
	f[id[a][b]][n*n+1] = 1;
	work();
	for(int i = 1;i<= n;i++)
		printf("%.6f ",ans[id[i][i]]);
	return 0;
}
Problem3275

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans=0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF))!=0)
			ans+=nowflow;
	return ans;
}
int a[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
bool check(int x,int y)
{
	if(gcd(x,y)!=1)return false;
	int tmp = x*x+y*y;
	if(((int)sqrt(tmp))*((int)sqrt(tmp))==tmp)return true;
	return false;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int st = 0,end = n+1;
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		if(a[i]&1)add(st,i,a[i]);
		else add(i,end,a[i]);
		sum+=a[i];
	}
	for(int i = 1;i<= n;i++)
		if(a[i]&1)
			for(int j = 1;j<= n;j++)
				if(!(a[j]&1))
					if(check(a[i],a[j]))
						add(i,j,INF);
	int ans = dinic(st,end);
	printf("%d\n",sum-ans);
	return 0;
}
Problem3280

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 1e7+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,fr,f,c;}e[M];
int head[N],tot = 1,from[N];
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f,e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0,e[tot].c=-c;
	e[tot-1].fr=x,e[tot].fr=y;
}
bool v[N];
int dis[N],S,T;
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	Q.push(S);
	v[S] = true;dis[S] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans =0,maxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	maxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(from,0,sizeof(from));
	tot = 1;
	ans=0,maxf=0;
}
int a[N],l[N],p[N],d[N],q[N];
void work()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int sum = 0;
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),sum+=a[i];
	for(int i = 1;i<= m;i++)
		scanf("%d%d",&l[i],&p[i]);
	for(int i = 1;i<= k;i++)
		scanf("%d%d",&d[i],&q[i]);
	S = 0,T = 2*n+m+1;
	for(int i = 1;i<= m;i++)
		add(S,i,l[i],0);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			add(j,m+n+i,INF,p[j]);
	for(int i = 1;i<= n;i++)
	{
		add(m+n+i,T,a[i],0);
		if(i<n)add(m+n+i,m+n+i+1,INF,0);
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= k;j++)
		{
			int to = i+d[j]+1;
			if(to<=n)add(m+i,m+n+to,INF,q[j]);
		}
	for(int i = 1;i<= n;i++)
		add(S,m+i,a[i],0);
	while(spfa())mcf();
	if(maxf==sum)printf("%d\n",ans);
	else printf("impossible\n");
}
int main()
{
	int cas;
	scanf("%d",&cas);
	for(int i = 1;i<= cas;i++)
	{
		printf("Case %d: ",i);
		init();
		work();
	}
	return 0;
}
Problem3282

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,sum;
	bool rev;
	Splay(int x);
	void reverse();
	void push_up();
	void push_down();
}*null = new Splay(0),*tree[N];
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	val = x;sum = x;
	rev = false;
}
void Splay :: reverse()
{
	swap(ls,rs);
	rev ^=1;
}
void Splay :: push_down()
{
	if(this==fa->ls||this==fa->rs)
		fa->push_down();
	if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = 0;
	}
}
void Splay :: push_up()
{
	sum = ls->sum ^ rs->sum ^ val;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	Splay *y,*z;
	x->push_down();
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
Splay* find_root(Splay *x)
{
	while(x->fa!=null)x = x->fa;
	return x;
}
void link(Splay *x,Splay *y)
{
	if(find_root(x)==find_root(y))return ;
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	if(x==y||find_root(x)!=find_root(y))return ;
	move_to_root(x);
	access(y);
	splay(y);
	if(y->ls!=x)return ;
	x->fa = null;
	y->ls = null;
	y->push_up();
}
void change(Splay *x,int y)
{
	splay(x);
	x->val = y;
	x->push_up();
}
void qurey(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	printf("%d\n",y->sum);
}
int main()
{
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		tree[i] = new Splay(x);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&c,&x,&y);
		switch(c)
		{
			case 0:qurey(tree[x],tree[y]);break;
			case 1:link(tree[x],tree[y]);break;
			case 2:cut(tree[x],tree[y]);break;
			case 3:change(tree[x],y);break;
		}
	}
	return 0;
}
Problem3295

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 50005;
int n,m,cnt[N],a[N],b[N],c[N],tim[N],f[M],tot;
long long ans;
void update(int x,int flag)
{
	for(int i = x;i&&i<N;i+=flag*(i&-i))
	{
		if(tim[i]!=tot)
			c[i] = 0,tim[i] = tot;
		c[i]++;
	}
}
int getans(int x,int flag)
{
	int ans = 0;
	for(int i = x;i&&i<N;i+=flag*(i&-i))
		if(tim[i]==tot)
			ans+=c[i];
	return ans;
}
struct A
{
	int x,y,pos;
	bool operator <(const A &b)const
	{return y<b.y;}
}q[N],nq[N];
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)
	{
		printf("%lld\n",ans);
		ans-=cnt[q[mid].y];
		ans+=f[mid];
		return ;
	}
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if(q[i].pos<=mid)
			nq[l1++]=q[i];
		else 
			nq[l2++]=q[i];
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	CDQ(l,mid);
	tot++;int j = l;
	for(int i = mid+1;i<= r;i++)
	{
		for(;j<=mid&&q[j].y<q[i].y;j++)
			update(q[j].x,-1);
		f[q[i].pos]+=getans(q[i].x,1);
	}
	tot++,j = mid;
	for(int i = r;i>=mid+1;i--)
	{
		for(;j>=l&&q[j].y>q[i].y;j--)
			update(q[j].x,1);
		f[q[i].pos]+=getans(q[i].x,-1);
	}
	CDQ(mid+1,r);
	l1=l;l2=mid+1;
    for(int i=l;i<=r;i++)
        if((q[l1]<q[l2]||l2>r)&&l1<=mid)
            nq[i]=q[l1++];
        else
            nq[i]=q[l2++];
    memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		b[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
	{
		cnt[i] = getans(a[i],1);
		update(a[i],-1);
		ans+=cnt[i];
	}
	tot++;
	for(int i = n;i;i--)
	{
		cnt[i] += getans(a[i],-1);
		update(a[i],1);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&q[i].x);
		q[i].y = b[q[i].x];
		q[i].pos = i;
	}
	sort(q+1,q+m+1);
	CDQ(1,m);
	return 0;
}
Problem3307

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 6000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N][25],dep[N],cnt;
void dfs(int x,int f)
{
	fa[x][0] = f;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i =e[i].next)
		if(e[i].to!=fa[x][0])
			dfs(e[i].to,x);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 22;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 22;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int maxn[M],ls[M],rs[M],seg,maxno[M],root[N],n,m;
void update(int &p,int l,int r,int x,int c)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		maxn[p] += c;
		maxno[p] = l;
		if(!maxn[p])maxno[p] =0;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(ls[p],l,mid,x,c);
	else update(rs[p],mid+1,r,x,c);
	if(maxn[ls[p]]>=maxn[rs[p]])
		maxn[p] = maxn[ls[p]],maxno[p] = maxno[ls[p]];
	else 
		maxn[p] = maxn[rs[p]],maxno[p] = maxno[rs[p]];
	if(!maxn[p])maxno[p] =0;
}
int merge(int x,int y,int l,int r)
{
	if(!x||!y)return x+y;
	if(l==r)
	{
		maxn[x] = maxn[x]+maxn[y];
		maxno[x] = l;
		if(!maxn[x])maxno[x] =0;
		return x;
	}
	int mid = (l+r)>>1;
	ls[x] = merge(ls[x],ls[y],l,mid);
	rs[x] = merge(rs[x],rs[y],mid+1,r);
	if(maxn[ls[x]]>=maxn[rs[x]])
		maxn[x] = maxn[ls[x]],maxno[x] = maxno[ls[x]];
	else 
		maxn[x] = maxn[rs[x]],maxno[x] = maxno[rs[x]];
	if(!maxn[x])maxno[x] =0;
	return x;
}
int kind[N],Cnt,ans[N];
int find(int x)
{
	int l = 1,r = Cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(kind[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
struct O
{int x,y,d;}opt[N];
void solve(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa[x][0])
		{
			solve(e[i].to);
			root[x] = merge(root[x],root[e[i].to],1,Cnt);
		}
	}
	ans[x] = kind[maxno[root[x]]];
}
void init()
{
	for(int j= 1;j<= 19;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	init();
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt[i].x,&opt[i].y,&opt[i].d);
		kind[++Cnt] = opt[i].d;
	}
	sort(kind+1,kind+Cnt+1);
	int tmp = Cnt;Cnt = 0;
	for(int i = 1;i<= tmp;i++)
		if(kind[i]!=kind[Cnt])
			kind[++Cnt] = kind[i];
	for(int i = 1;i<= m;i++)
	{
		int pos = find(opt[i].d);
		int lca = getlca(opt[i].x,opt[i].y);
		update(root[opt[i].x],1,Cnt,pos,1);
		update(root[opt[i].y],1,Cnt,pos,1);
		update(root[lca],1,Cnt,pos,-1);
		update(root[fa[lca][0]],1,Cnt,pos,-1);
	}
	solve(1);
	for(int i = 1;i<= n;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3309

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int g[N],last[N],t[N],prime[N/10],cnt;
bool vis[N];
int sum[N];
void quick_mu()
{
	for(int i =2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			g[i] = last[i] = t[i] = 1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			int x = i*prime[j];
			vis[x] = true;
			if(i%prime[j]==0)
			{
				last[x] = last[i];
				t[x] = t[i]+1;
				if(last[x]==1)g[x] = 1;
				else g[x] = (t[last[x]]==t[x]?-g[last[x]]:0);
				break;
			}
			last[x] = i;t[x] = 1;
			g[x] = (t[i]==1?-g[i]:0);
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+g[i];
}
ll getans(int x,int y)
{
	int last;
	ll ans = 0;
	for(int i = 1;i<=x&&i<= y;i = last+1)
	{
		last = min(x/(x/i),y/(y/i));
		ans+=(ll)(x/i)*(y/i)*(sum[last]-sum[i-1]);
	}
	return ans;
}
int main()
{
	int t,n,m;
	scanf("%d",&t);
	quick_mu();
	while(t--)
	{
		scanf("%d%d",&n,&m);
		printf("%lld\n",getans(n,m));
	}
	return 0;
}
Problem3329

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL mod = 1e9+7;
LL f[65][2],ans;
struct Martix
{
	int h,w;
	LL map[4][4];
	Martix(int x,int y)
	{
		h = x;
		w = y;
		memset(map,0,sizeof(map));
	}
	Martix()
	{
		h = w = 0;
		memset(map,0,sizeof(map));
	}
	Martix operator*(const Martix &S)const
	{
		Martix ans(S.w,h);
        for(int i = 1;i<= ans.h;i++)
            for(int j = 1;j<= ans.w;j++)
                for(int k = 1;k<= S.h;k++)
                    (ans.map[i][j]+=map[i][k]*S.map[k][j])%=mod;
		return ans;
	}
};
Martix quick_pow(LL y,const Martix &S) 
{
	if(y==0)
	{
		Martix one(3,3);
		for(int i = 0;i<= 3;i++)
			one.map[i][i] = 1;
		return one;
	}
	Martix tmp = quick_pow(y/2,S);
	if(y&1)return tmp*tmp*S;
	else return tmp*tmp;	
}
void init()
{
	f[1][1] = 1,f[1][0] = 1;
	for(int j = 2;j<= 63;j++)
	{
		f[j][0] = f[j-1][0]+f[j-1][1];
		f[j][1] = f[j-1][0];
	}
}
void work(LL n)
{
	//LL tmp = n;
	int cnt = 63;
    while(n < ((LL)1<<(cnt-1))) cnt--;
	for(int i = 1;i < cnt;i++)
        ans += f[i][1];
	int cur = n / ((LL)1<<(cnt-1));
    int pre = cur;
    n %= ((LL)1<<(cnt-1));
	for(int j = cnt-1;j>=1;j--)
	{
		cur = n/((LL)1<<(j-1));
		if(cur)
			ans+=f[j][0];
		if(cur&&pre)break;
		pre = cur;
		n%=((LL)1<<(j-1));
	}
}
int main()
{
	init();
	int T;
	scanf("%d",&T);
	LL n;
	while(T--)
	{
		scanf("%lld",&n);
		ans = 0;
		work(n+1);
		Martix sta(1,2);
		sta.map[1][1] = 1;sta.map[1][2] = 1;
		Martix go(2,2);
		go.map[1][1] = go.map[1][2] = go.map[2][1] = 1;
		sta = sta*quick_pow(n,go);
		printf("%lld\n%lld\n",ans,sta.map[1][1]);
	}
	return 0;
}
Problem3339

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
int sg[N<<2],lazy[N<<2],fa[N],a[N],fs[N],next[N],last[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
struct A
{int l,r,no,ans;}ask[N];
bool cmp(A a,A b){return a.l<b.l;}
bool fir(A a,A b){return a.no<b.no;}
void build(int p,int l,int r)
{
	lazy[p] = INF;
	if(l==r)
	{
		sg[p] = fs[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sg[p] = max(sg[p<<1],sg[p<<1|1]);
}
void push_down(int p,int l,int r)
{
	if(lazy[p]==INF||l==r)return ;
	sg[p<<1] = min(sg[p<<1],lazy[p]);
	sg[p<<1|1] = min(sg[p<<1|1],lazy[p]);
	lazy[p<<1] = min(lazy[p<<1],lazy[p]);
	lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
	lazy[p] = INF;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sg[p] = min(sg[p],c);
		lazy[p] = min(lazy[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	sg[p] = max(sg[p<<1],sg[p<<1|1]);
}
int getans(int p,int l,int r,int x)
{
	push_down(p,l,r);
	if(l==r)return sg[p];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int main()
{
	int n,q,maxn = 0;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		maxn = max(maxn,a[i]);
		next[last[a[i]]] = i;
		last[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
		if(!next[i])next[i] = n+1;
	for(int i = 1;i<= maxn;i++)
		fa[i] = i;
	fa[maxn+1] = maxn+1;
	for(int i = 1;i<= n;i++)
	{
		fa[a[i]] = a[i]+1;
		fs[i] = getfa(0);
	}
	build(1,1,n);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].no = i;
	}
	sort(ask+1,ask+q+1,cmp);
	ask[0].l = 1;
	for(int i = 1;i<= q;i++)
	{
		for(int j = ask[i-1].l;j<ask[i].l;j++)
			update(1,1,n,j,next[j]-1,a[j]);
		ask[i].ans = getans(1,1,n,ask[i].r);
	}
	sort(ask+1,ask+q+1,fir);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ask[i].ans);
	return 0;
}
Problem3413

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
char s[N],b[N];
int ch[N][10],len[N],fa[N],n,m,fl,cnt=1,last=1,rt[N],pp;
struct E{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int in[N],out[N],dfn,id[N],to[N];
void dfs(int x)
{
	in[x] = ++dfn;
	if(to[x])id[dfn] = n-len[x];
	else id[dfn] = -1;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	out[x] = dfn;
}
int L[N*20],R[N*20],sz[N*20],ID;
void update(int &x,int y,int l,int r,int k)
{
	sz[x = ++ID] = sz[y]+1;
	L[x]=L[y],R[x]=R[y];
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(k<=mid)update(L[x],L[y],l,mid,k);
	else update(R[x],R[y],mid+1,r,k);
}
int getans(int k,int l,int r,int x)
{
	if(!k)return 0;
	if(r<=x)return sz[k];
	int mid = (l+r)>>1;
	int ans = getans(L[k],l,mid,x);
	if(x>mid)ans+=getans(R[k],mid+1,r,x);
	return ans;
}
int getm(int x,int y)
{
	int l = 0,r = n,mid;
	while(l<r)
	{
		mid = (l+r)>>1;
		if(sz[L[y]]-sz[L[x]])
			x = L[x],y = L[y],r = mid;
		else x = R[x],y=R[y],l=mid+1;
	}
	return l;
}
void insert(int x,int y)
{
	int p = last,np = ++cnt,q,nq;
	last = np;len[np] = len[p]+1;
	for(;p&&!ch[p][x];p=fa[p])ch[p][x] = np;
	if(!p)fa[np] = 1;
	else
	{
		q = ch[p][x];
		if(len[q]==len[p]+1)fa[np] = q;
		else
		{
			fa[nq=++cnt]=fa[q];
			len[nq] = len[p]+1;
			memcpy(ch[nq],ch[q],sizeof(ch[q]));
			fa[np] = fa[q] = nq;
			for(;p&&ch[p][x]==q;p=fa[p])ch[p][x] = nq;
		}
	}
	to[last] = y;
}
bool match(int lenb)
{
	int w = 1,ff = 1,i,j;pp = 1;
	for(fl = 0;w<=lenb&&ff;)
		for(ff = 0,i = head[pp];i;i=e[i].next)
			if(s[e[i].val]==b[w])
			{
				int tt = e[i].to;
				for(fl=j=0;j<min(len[tt]-len[pp],lenb-w+1);fl++,j++)
					if(s[e[i].val+j]!=b[w+j])
						return pp=tt,0;
				w+=len[tt]-len[pp];pp=tt;ff=1;break;
			}
	return ff;
}
int v[N];
int main()
{
	scanf("%d%s",&n,s+1);
	for(int i = n;i>=1;i--)
		insert(s[i]-'0',i);
	int p,i,j;
	for(v[1] = 1,i = 1;i<=cnt;i++)
		if(to[i])
			for(p = n,j = i;!v[j];j=fa[j])
				p-=len[j]-len[fa[j]],v[j]=true,add(fa[j],j,p+1);
	dfs(1);
	for(i = 1;i<= dfn;i++)
		if(id[i]>=0)
			update(rt[i],rt[i-1],0,n,id[i]);
		else rt[i] = rt[i-1];
	scanf("%d",&m);
	int ans,w;
	while(m--)
	{
		scanf("%s",b+1);
		int lenb = strlen(b+1);
		ans = w = match(lenb)?getm(rt[in[pp]-1],rt[out[pp]]):n;
		for(ans+=fl*(getans(rt[out[pp]],0,n,w)-getans(rt[in[pp]-1],0,n,w)),pp=fa[pp];pp;pp=fa[pp])
            ans+=(len[pp]-len[fa[pp]])*(getans(rt[out[pp]],0,n,w)-getans(rt[in[pp]-1],0,n,w));
        printf("%d\n",ans);
	}
	return 0;
}
Problem3414

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
int er[N],la[N],beg[N],lef[N],now[N];
int who[N],when[N],how[N],n,m;
bool check(int e)
{
	memset(er,0x3f,sizeof(er));
	memset(la,0,sizeof(la));
	memset(beg,0,sizeof(beg));
	memset(lef,0,sizeof(lef));
	memset(now,0,sizeof(now));
	int maxn = 0;
	for(int i=1;i<= e;i++)
	{
		er[who[i]] = min(er[who[i]],when[i]);
		la[who[i]] = max(la[who[i]],when[i]);
		maxn = max(maxn,when[i]);
		if(!now[when[i]]||now[when[i]]==how[i]+1)now[when[i]] = how[i]+1;
		else return false;
	}
	for(int i = 1;i<= n;i++)
		if(er[i]!=INF)
			beg[er[i]]++,lef[la[i]]++;
	int tot=0,peop = 0,ended = 0,notbegin = 0;
	for(int i=1;i<=maxn;i++)
	if(now[i])
	{
		peop+=beg[i];
		if(peop>now[i])return false;
		if(beg[i]<=notbegin)notbegin-=beg[i];
		else tot+=beg[i]-notbegin,notbegin = 0;
		if(peop+notbegin+ended<now[i])tot += now[i]-peop-notbegin-ended,notbegin = now[i]-peop-ended;
		else
		{
			if(peop+notbegin>now[i])notbegin=now[i]-peop,ended=0;
			else ended=now[i]-peop-notbegin;
		}
		peop-=lef[i];ended+=lef[i];
	}
	if(tot>n)return false;
	return true;
}
void work()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&when[i],&who[i],&how[i]);
	int l = 1,r = m+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(mid))l = mid+1;
		else r = mid;
	}
	printf("%d\n",l-1);
}	
int main()
{
	int c;
	scanf("%d",&c);
	while(c--)
		work();
	return 0;
}
Problem3416

#include <stdio.h>
#include <vector>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
bool last[N<<1];
char in[N];
int a[N],q[N],t;
vector<int>ans[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	scanf("%s",in+1);
	for(int i = 1;i<= n;i++)
	{
		if(in[i]=='c')a[i] = a[i-1]-k;
		else a[i] = a[i-1]+1;
	}
	int cnt = 0;
	last[n] = true;
	for(int i = 1;i<= n;i++)
	{
		a[i]+=n;
		if(last[a[i]])
		{
			cnt++;
			for(int j = t-k+1;j<= t;j++)
				ans[cnt].push_back(q[j]),last[a[q[j]]] = false;
			ans[cnt].push_back(i);
			t-=k;
		}else
		{
			t++;
			q[t] = i;
			last[a[i]] =true;
		}
	}
	for(int i = cnt;i>=1;i--)
	{
		for(unsigned int j = 0;j<ans[i].size();j++)
			printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
Problem3417

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const int K = 1e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct A
{int s,t,k,no,ans;}ask[K];
bool cmp1(A a,A b){return a.s<b.s;}
bool cmp2(A a,A b){return a.no<b.no;}
queue<int>Q;
int f[N],g[N];
bool v[N];
void spfa(int s)
{
	memset(f,0x3f,sizeof(f));
	memset(g,0x3f,sizeof(g));
	Q.push(s);
	f[s] = 0;
	v[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i = e[i].next)
		{
			if(f[x]+1<g[e[i].to]||g[x]+1<f[e[i].to])
			{
				f[e[i].to] = min(f[e[i].to],g[x]+1);
				g[e[i].to] = min(g[e[i].to],f[x]+1);
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
			else if(e[i].to==s)
			{
				if(f[s]==0)f[s] = g[x]+1,g[s] = f[x]+1;
				else f[s] = min(g[x]+1,f[s]),g[s] = min(f[x]+1,g[s]);
			}
		}
	}
	if(f[s]==0)f[s] = 0x3f3f3f3f;
}
int main()
{
	int n,m,k,x,y;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%d",&ask[i].s,&ask[i].t,&ask[i].k);
		ask[i].no = i;
	}
	sort(ask+1,ask+k+1,cmp1);
	int j = 0;
	for(int i = 1;i<= k;i++)
	{
		if(ask[i].s!=j)
		{
			spfa(ask[i].s);
			j = ask[i].s;
		}
		if(ask[i].k%2==1)
			{if(g[ask[i].t]<=ask[i].k)ask[i].ans = 1;}
		else {if(f[ask[i].t]<=ask[i].k)ask[i].ans = 1;}
	}
	sort(ask+1,ask+k+1,cmp2);
	for(int i = 1;i<= k;i++)
	{
		if(ask[i].ans)printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem3419

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 500005;
LL a[N];
bool cmp(LL a,LL b)
{
	return a>b;
}
int main()
{
	//freopen("tak.in","r",stdin);
	//freopen("tak.out","w",stdout);
	int n;
	LL m,d;
	scanf("%lld%lld%d",&m,&d,&n);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	sort(a+1,a+n+1,cmp);
	if(a[1]>=m+d){printf("1\n");return 0;}
	int sec = 0;
	for(int i = 1;i<= n;i++)
		if(a[i]>=m-d)sec = i;
	if(sec==0){printf("0\n");return 0;}
	int ans = 1;
	LL back = 0;
	for(int i=1;i<=n;i++)
	{
		if(i==sec) continue;
		if(back>=d||m-back+d-back<=a[sec]) break;
		if(a[i]<=d-back) {puts("0");return 0;}
		ans++;
		back+=a[i]-(d-back);
		if(back>=m) {ans--;break;}
	}
	if(m-back+d-back>a[sec]) puts("0");
	else printf("%d\n",ans);
	return 0;
}
Problem3420

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N =300005;
typedef long long LL;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
LL f[N];
bool is_leaf[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int ans;
void dfs(int x,int fa)
{
	is_leaf[x] = true;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			is_leaf[x] = false;
			dfs(e[i].to,x);
			f[x]+=f[e[i].to]+1;
		}
	f[x]-=ans;
	f[x] = max(f[x],(LL)0);
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	int l = 0,r = n-1;
	while(l<r)
	{
		ans = (l+r)>>1;
		memset(f,0,sizeof(f));
		dfs(1,0);
		if(f[1]!=0)l = ans+1;
		else r = ans;
	}
	printf("%d\n",l);
	return 0;
}
Problem3425

#include <stdio.h>
#include <bitset>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 250005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
bitset<N>F;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int size[N],tb[N];
int root,dirr,n;
LL ans;
void dfs(int x,int fa)
{
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(fa!=e[i].to)
		{
			dfs(e[i].to,x);
			size[x]+=size[e[i].to];
			tb[x] = max(tb[x],size[e[i].to]);
		}
	}
	tb[x] = max(tb[x],n-size[x]);
	if(tb[x]<tb[root])
	{
		root = x;
		dirr = fa;
	}
}
int ts[N];
void getpre(int x,int fa,int dep)
{
	ans+=dep;
	ts[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			getpre(e[i].to,x,dep+1);
			ts[x]+=ts[e[i].to];
		}
	}
}
void solve1(int x)
{
	F[0] = 1;
	for(int i = head[x];i;i = e[i].next)
		F |= F<<ts[e[i].to];
	LL tmp = 0;
	for(int i = 1;i<= n;i++)
		if(F[i])
			tmp = max(tmp,(LL)i*(n-i-1));
	ans+=tmp;
}
int heap[N],cnt;
void solve2(int x)
{
	for(int i = head[x];i;i =e[i].next)
	{
		heap[++cnt] = ts[e[i].to];
		push_heap(heap+1,heap+cnt+1);
	}
	while(cnt>=2)
	{
		int t1 = heap[1];
		pop_heap(heap+1,heap+cnt+1);cnt--;
		int t2 = heap[1];
		pop_heap(heap+1,heap+cnt+1);cnt--;
		heap[++cnt] = abs(t1-t2);
		push_heap(heap+1,heap+cnt+1);
	}
	ans+=(LL)((n-1+heap[1])/2)*((n-1-heap[1])/2);
}
int d[N];
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		d[x]++;d[y]++;
	}
	tb[0] = INF;
	dfs(1,0);
	getpre(root,0,0);
	if(d[root]<=800)
		solve1(root);
	else solve2(root);
	printf("%d %lld\n",n-1,ans);
	return 0;
}
Problem3426

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const int M = 1000005;
struct E
{int next,to;}e[M<<1];
int head[N],tot;
bool u1[N],u2[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void cover2(int x)
{
	u1[x] = true;
	for(int i = head[x];i;i = e[i].next)
		u1[e[i].to] = true;
	return ;
}
void cover1(int x)
{
	u1[x] = u2[x] = true;
	for(int i = head[x];i;i =e[i].next)
	{
		if(u2[e[i].to])continue;
		u2[e[i].to] = true;
		cover2(e[i].to);
	}
	return ;
}
int ans[N],cnt;
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(!u1[i])
		{
			ans[++cnt] = i;
			cover1(i);
		}
	printf("%d\n",cnt);
	for(int i = 1;i<cnt;i++)
		printf("%d ",ans[i]);
	printf("%d",ans[cnt]);
	return 0;
}
Problem3427

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int INF = 707185547;
int f[N][3];
int a[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	f[1][0] = f[1][1] = f[1][2] = INF;
	if(a[1]==-1)f[1][0] = 0;
	else if(a[1]==0)f[1][1] = 0;
	else f[1][2] = 0;
	for(int i = 2;i<= n;i++)
	{
		f[i][0] = f[i-1][0]+a[i]+1;
		if(a[i]==-1)
		{
			if(a[i-1]==1)f[i][1] = min(f[i-1][1],f[i-1][0])+1;
			else f[i][1] = INF;
		}else if(a[i]==0)f[i][1] = min(f[i-1][1],f[i-1][0]);
		else
		{
			if(a[i-1]==-1)f[i][1] = min(f[i-1][1],f[i-1][0])+1;
			else f[i][1] = f[i-1][0]+1;
		}
		if(a[i]==-1)
		{
			if(a[i-1]==1)f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+2;
			else f[i][2] = f[i-1][2]+2;
		}else if(a[i]==0)
		{
			if(a[i-1]==1)f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+1;
			else f[i][2] = f[i-1][2]+1;
		}else f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
	}
	int ans = min(f[n][0],min(f[n][1],f[n][2]));
	if(ans>=INF)printf("BRAK\n");
	else printf("%d\n",ans);
	return 0;
}
Problem3438

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e3+5;
const int M = 5e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot = 1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].flow = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].flow = 0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int a[N],b[N],c1[N],c2[N];
int main()
{
	int n;
	scanf("%d",&n);
	int st = 0,end = n+1;
	int id = n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	int m,k,x,ans = 0;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&k,&c1[i],&c2[i]);
		ans+=c1[i]+c2[i];
		add(st,id+1,c1[i]),add(id+2,end,c2[i]);
		for(int j = 1;j<=k;j++)
		{
			scanf("%d",&x);
			add(id+1,x,INF);add(x,id+2,INF);
		}
		id+=2;
	}
	for(int i = 1;i<= n;i++)add(st,i,a[i]),ans+=a[i];
	for(int i = 1;i<= n;i++)add(i,end,b[i]),ans+=b[i];
	ans-=dinic(st,end);
	printf("%d\n",ans);
	return 0;
}
Problem3439

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int ch[N][26],tot=1;
char s[N];
vector<int>end[N];
void insert(int no)
{
	int i = strlen(s+1),p = 1;
	while(i)
	{
		if(!ch[p][s[i]-'a'])ch[p][s[i]-'a'] = ++tot;
		p = ch[p][s[i]-'a'];
		i--;
	}
	end[p].push_back(no);
}
int ls[N*20],rs[N*20],root[N],sum[N*20],cnt;
int a[N],in[N],out[N],Dfn;
void dfs(int x)
{
	int num = Dfn;
	for(int i= 0;i<end[x].size();i++)a[++Dfn] = end[x][i];
	for(int i = 0;i<26;i++)
		if(ch[x][i])
			dfs(ch[x][i]);
	for(int i = 0;i<end[x].size();i++)
		in[end[x][i]] = num,out[end[x][i]] = Dfn;
}
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p] = sum[pre]+1;
		return ;
	}
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int x,int y,int l,int r,int k)
{
	int mid = (l+r)>>1;
	if(l==r)return l;
	if(sum[y]-sum[x]<k)return -1;
	if(sum[ls[y]]-sum[ls[x]]>=k)return getans(ls[x],ls[y],l,mid,k);
	else return getans(rs[x],rs[y],mid+1,r,k-sum[ls[y]]+sum[ls[x]]);
}
int main()
{
	int n,k;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		insert(i);
	}
	dfs(1);
	root[0]=ls[0]=rs[0]=sum[0]=0;
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],1,n,a[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		printf("%d\n",getans(root[in[i]],root[out[i]],1,n,k));
	}
	return 0;
}
Problem3450

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
char m[N];
double l[N],f[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",m+1);
	for(int i = 1;i<= n;i++)
	{
		if(m[i]=='o')
		{
			l[i] = l[i-1]+1;
			f[i] = f[i-1]+2*l[i-1]+1;
		}else if(m[i]=='x')
		{
			l[i] = 0;
			f[i] = f[i-1];
		}else
		{
			l[i] = 0.5*(l[i-1]+1);
			f[i] = 0.5*(f[i-1])+0.5*(f[i-1]+2*l[i-1]+1);
		}
	}
	printf("%.4f\n",f[n]);
	return 0;
}
Problem3456

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<18;
typedef long long ll;
const int mod = 1004535809;
int fac[N],env[N],cnt;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y = y>>1;
	}
	return res;
}
int a[N],b[N],c[N];
void NTT(int *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = (len>>1);(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		int wn = quick_pow(3,(mod-1)/i);
		for(int j = 0;j<len;j+=i)
		{
			int w = 1,tmp;
			for(int k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
			{
				tmp = (ll)a[j+k+(i>>1)]*w%mod;
				a[j+k+(i>>1)]=(a[j+k]-tmp+mod)%mod;
				a[j+k] = (a[j+k]+tmp)%mod;
			}
		}
	}
	if(type==-1)
	{
		for(int i = 1;i<(len>>1);i++)
			swap(a[i],a[len-i]);
		int Inv = quick_pow(len,mod-2);
		for(int i = 0;i<len;i++)
			a[i] = (ll)a[i]*Inv%mod;
	}
	/*printf("#case %d:",++cnt);
	for(int i = 0;i<len;i++)
		printf("%d ",a[i]);
	printf("\n");*/
}
void Get_Inv(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = quick_pow(a[0],mod-2);
		return ;
	}
	Get_Inv(a,b,len>>1);
	static int tmp[N];
	memcpy(tmp,a,sizeof(int)*len);
	memset(tmp+len,0,sizeof(int)*len);
	NTT(tmp,len<<1,1);
	NTT(b,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i]=(ll)b[i]*(2-(ll)b[i]*tmp[i]%mod+mod)%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(int)*len);
}
int C(int n)
{
	return ((ll)n*(n-1)>>1)%(mod-1);
}
int main()
{
	int n,m=1;
	scanf("%d",&n);
	for(m=1;m<=n;m<<=1);
	fac[0]=1,env[0]=1;
	for(int i =1;i<=m;i++)
		fac[i] = (ll)fac[i-1]*i%mod;
	env[m] = quick_pow(fac[m],mod-2);
	for(int i = m-1;i>=1;i--)
		env[i] = (ll)env[i+1]*(i+1)%mod;
	for(int i = 0;i< m;i++)
		b[i] = (ll)quick_pow(2,C(i))*env[i]%mod;
	for(int i = 1;i< m;i++)
		c[i] = (ll)quick_pow(2,C(i))*env[i-1]%mod;
	static int tmp[N];
	memset(tmp,0,sizeof(tmp));
	Get_Inv(b,tmp,m);
	NTT(c,m<<1,1);
	NTT(tmp,m<<1,1);
	for(int i = 0;i<m<<1;i++)a[i]=(ll)c[i]*tmp[i]%mod;
	NTT(a,m<<1,-1);
	printf("%lld\n",(ll)a[n]*fac[n-1]%mod);
	return 0;
}
Problem3460

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,m,key;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int top[N],size[N],son[N],fa[N],dep[N],q[N],rk[N],a[N];
void dfs(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
	}
}
int seq[N],Dfn,in[N],out[N];
void dfs2(int x,int tp)
{
	top[x] = tp;
	in[x] = ++Dfn;seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	out[x] = ++Dfn;seq[Dfn] = x;
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	else return y;
}
struct data
{
	int x,y,k;
	data(int _x=0,int _y=0,int _k=0):x(_x),y(_y),k(_k){}
}b[N];
int cnt;
ll c[N],ans[N],res;
bool vis[N];
void Add(int x,ll y)
{
	for(int i = x;i<=n;i+=i&(-i))
		c[i]+=y;
}
ll Getans(int x)
{
	ll ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void Insert(int x,int y)
{
	int lca = getlca(x,y);
	if(in[x]>in[y])swap(x,y);
	cnt++;
	b[cnt] = data(lca==x?in[x]:out[x],in[y],cnt+1);
}
int per;
void update(int y)
{
	int x = rk[y];
	vis[y]^=1;
	if(vis[y])
	{
		per++;
		Add(x,(ll)a[y]*n+1);
		ll z = Getans(x)-1;
		res+=(ll)a[y]*(per-z%n-1)+z/n;
	}else
	{
		ll z = Getans(x)-1;
		res-=(ll)a[y]*(per-z%n-1)+z/n;
		per--;
		Add(x,-((ll)a[y]*n+1));
	}
}
int bl;
bool cmp1(int x,int y)
{
	return a[x]<a[y];
}
bool cmp2(const data &a,const data &b)
{
	if(a.x/bl==b.x/bl)return a.y<b.y;
	return a.x/bl<b.x/bl;
}
int main()
{
	int root =0;
	scanf("%d%d%d",&n,&m,&key);
	bl = sqrt(2*n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),q[i]=i;
	sort(q+1,q+n+1,cmp1);
	for(int i=1;i<= n;i++)rk[q[i]]=i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&fa[i]);
		if(fa[i])add(fa[i],i);
		else root = i;
	}
	dfs(root);dfs2(root,root);
	int x=1,y;char opt[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s%d",opt,&y);
		if(opt[0]=='C')x=y;
		else
		{
			Insert(x,y%n+1);
			Insert(x,(y+key)%n+1);
		}
	}
	sort(b+1,b+cnt+1,cmp2);
	int l = 1,r = 0;res = 0;
	for(int i = 1;i<= cnt;i++)
	{
		while(l<b[i].x)update(seq[l]),l++;
		while(b[i].x<l)l--,update(seq[l]);
		while(r<b[i].y)r++,update(seq[r]);
		while(b[i].y<r)update(seq[r]),r--;
		x=seq[l]; y=seq[r]; int z=getlca(x,y);
		if (x!=z) update(z); 
		ans[b[i].k]=res; 
		if (x!=z) update(z);
	}
	ll tmp = 0;
	for(int i = 1;i<= cnt>>1;i++)
	{
		tmp = ans[i<<1|(tmp&1)];
		printf("%lld\n",tmp);
	}
	return 0;
}
Problem3473

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
char s[N];
struct E{int next,to;};
int id[N],in[N],out[N],Dfn,num[N],n,k,to[N];
ll ans[N];
int last,cnt;
int trs[N][26],fa[N],len[N];
vector<int>ed[N];
bool v[N];
struct Gragh
{
	E e[N];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}
	void dfs(int x)
	{
		id[++Dfn] = x;
		in[x] = Dfn;
		for(int i = head[x];i;i=e[i].next)
			dfs(e[i].to);
		out[x] = Dfn;
	}
	void getans(int x,ll Ans)
	{
		if(num[x]>=k)Ans+=len[x]-len[fa[x]];
		for(int i = 0;i<ed[x].size();i++)
			ans[ed[x][i]]+=Ans;
		for(int i = head[x];i;i=e[i].next)
			getans(e[i].to,Ans);
	}
}g1,g2;
void init(){last=cnt=1;}
int insert(int x,int y)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq] = len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
			}
		}
	}
	ed[last].push_back(y);
	return last;
}
void build()
{
	for(int i = 1;i<= cnt;i++)
		g1.add(fa[i],i);
	g1.dfs(1);
}
int c[N];
void update(int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int lst[N];
struct Ask
{
	int l,r,no;
	bool operator<(const Ask &s)const
	{
		return r<s.r;
	}
}ask[N];
int pos[N];
int main()
{
	scanf("%d%d",&n,&k);
	init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1);
		last = 1;
		for(int j = 1;j<= l;j++)
		{
			int tmp=insert(s[j]-'a',i);
			g2.add(tmp,i);
		}
	}
	build();
	for(int i = 1;i<=cnt;i++)
		ask[i] = (Ask){in[i],out[i],i};
	sort(ask+1,ask+cnt+1);
	int tt = 1;
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = g2.head[id[i]];j;j=g2.e[j].next)
		{
			int p = g2.e[j].to;
			if(lst[p])update(lst[p],-1);
			update(i,1);
			lst[p] = i;
		}
		for(;ask[tt].r==i;tt++)
			num[ask[tt].no]=getans(ask[tt].r)-getans(ask[tt].l-1);
	}
	g1.getans(1,0);
	for(int i = 1;i<= n;i++)
		printf("%lld ",ans[i]);
	printf("\n");
	return 0;
}
Problem3489

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stack>
#include <algorithm>
#define Maxn 200010
#define l(x) ch[x][0]
#define r(x) ch[x][1]
#define lc(x) c[x][0]
#define rc(x) c[x][1]
using namespace std;
int n,m,tot=0,_tot=0,tree[Maxn]={0};
int a[Maxn],last[Maxn],pos[Maxn],next[Maxn],N,rank[Maxn];
int maxt[40000005],ch[40000010][2];
int c[2000010][2],root[2000010];
stack<int> _mL,mL;
int get()
{
	if(mL.empty()) return ++tot;
	int tp=mL.top();
	mL.pop();
	return tp;
}
int _get()
{
	if(_mL.empty()) return ++_tot;
	int tp=_mL.top();
	_mL.pop();
	return tp;
}
int _change(int o,int l,int r,int qx,int qv)
{
    int x=++_tot; maxt[x]=max(maxt[o],qv);
    l(x)=l(o); r(x)=r(o);
    if(l==r) return x;
    int mid=(l+r)>>1;
    if(qx<=mid) l(x)=_change(l(x),l,mid,qx,qv);
    else r(x)=_change(r(x),mid+1,r,qx,qv);
    return x;
}
int _query(int o,int l,int r,int ql,int qr)
{
	if(!o) return 0;
    if(ql<=l&&r<=qr) return maxt[o];
    int mid=(l+r)>>1,res=0;
    if(ql<=mid) res=max(res,_query(l(o),l,mid,ql,qr));
    if(mid<qr) res=max(res,_query(r(o),mid+1,r,ql,qr));
    return res;
}
int query(int o,int l,int r,int ql,int qr,int qa,int qb)
{
    if(ql<=l&&r<=qr) return _query(root[o],1,n,qa,qb);
    int mid=(l+r)>>1,res=0;
    if(ql<=mid) res=max(res,query(lc(o),l,mid,ql,qr,qa,qb));
    if(mid<qr) res=max(res,query(rc(o),mid+1,r,ql,qr,qa,qb));
    return res;
}
int change(int o,int l,int r,int qx,int qy,int qv)
{
    int x=++tot;
    lc(x)=lc(o); rc(x)=rc(o);
    root[x]=_change(root[o],1,n,qy,qv);
    if(l==r) return x;
    int mid=(l+r)>>1;
    if(qx<=mid) lc(x)=change(lc(o),l,mid,qx,qy,qv);
    else rc(x)=change(rc(o),mid+1,r,qx,qy,qv);
    return x;
}
bool cmp(const int &a,const int &b){return last[a]<last[b];}
int main()
{
    scanf("%d%d",&n,&m);
    memset(last,0,sizeof(last));
    for(int i=1;i<=n;i++) pos[i]=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        last[i]=pos[a[i]],pos[a[i]]=i;
    }
    memset(next,0,sizeof(next));
    for(int i=1;i<=n;i++) pos[i]=n+1;
    for(int i=n;i>=1;i--)
    {
        rank[i]=i;
        next[i]=pos[a[i]],pos[a[i]]=i;
    }
    sort(rank+1,rank+n+1,cmp);
    int j=1,ans=0,l,r;
    for(int i=0;i<n;i++)
    {
        if(i) tree[i]=tree[i-1];
        while(j<=n&&last[rank[j]]==i)
        {
            tree[i]=change(tree[i],0,n+1,next[rank[j]],rank[j],a[rank[j]]);
            j++;
        }
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&l,&r);
        l=(l+ans)%n+1;
        r=(r+ans)%n+1;
        if(l>r) swap(l,r);
        ans=query(tree[l-1],0,n+1,r+1,n+1,l,r);
        printf("%d\n",ans);
    }
    return 0;
}
Problem3505

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
int gcd(int x,int y)
{
	if(x==0)return y;
	return gcd(y%x,x);
}
int main()
{
	LL n,m;
	scanf("%lld%lld",&n,&m);
	n++;m++;
	LL ans = n*m*(n*m-1)*(n*m-2);
	ans = ans/(LL)6;
	for(int i = 0;i< n;i++)
	{
		for(int j = 0;j< m;j++)
		{
			LL len = min(i,j);
			if(!i)len = j-1;
			if(!j)len = i-1;
			if(i&&j)len = gcd(i,j)-1;
			len = max(0ll,len);
			if(len==0)continue;
			if(i&&j)ans-=len*(n-i)*(m-j)*2;
			else ans-=len*(n-i)*(m-j);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3509

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mxs = 30005;
const int N = 1e5+5;
const int size = 1800;
const double PI = 3.14159265358979323;
int n;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}a[524299],b[524299];

int num[N],pos[N],L[N],R[N];
int st[N],end[N],tot,lim;
int cnt[400][60005];
int cnt_nxt[60005],cnt_pre[60005];
ll ans[N];

void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*2*type/i),sin(PI*2*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = a[j+k+(i>>1)]*w;
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}	
	if(type==-1)
		for(int i = 0;i<len;i++)a[i].x/=len*4,a[i].y/=len;
}

void conv(int len)
{
	memset(a,0,sizeof(cp)*(len+1));
	memset(b,0,sizeof(cp)*(len+1));
	for(int i = 0;i<=lim;i++)a[i] = cp(L[i]+R[i],L[i]-R[i]);
	FFT(a,len,1);
	for(int i = 0;i<len;i++)b[i]=a[i]*a[i];
	FFT(b,len,-1);
	for(int i = 0;i<len;i++)ans[i] = (ll)(b[i].x+0.5);
}

void div_block()
{
	for(int i = 1;i<= n;i++)pos[i] = (i-1)/size+1;
	tot = pos[n];
	for(int i = 1;i<= tot;i++)st[i] = (i-1)*size+1,end[i] = i*size;
	end[tot] =n;
	for(int i = 1;i<= tot;i++)
		for(int j = st[i];j<=end[i];j++)
			cnt[i][num[j]]++;
}
int len;
void init()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&num[i]);
	for(int i = 1;i<= n;i++)lim=max(lim,num[i]);
	len = 1;
	for(;len<=2*lim;len<<=1);
}

ll res;
void calc(int p)
{
	int t = num[p]<<1;
	int cur = pos[p];
	for(int i = st[cur];i<p;i++)if(t>=num[i])res+=R[t-num[i]];
	for(int i = p+1;i<= end[cur];i++)
		if(t>=num[i])
		{
			res+=cnt_pre[t-num[i]];
			res+=L[t-num[i]];
			if (cur == 1) continue;
		}
	if (p <= end[1] || p >= st[tot]) return;
    res += ans[t];
}

void solve()
{
	for(int i = 1;i<= n;i++)R[num[i]]++;
	for(int i = 1;i<= tot;i++)
	{
		memset(cnt_pre,0,sizeof(int)*(lim+1));
		for(int j = st[i];j<=end[i];j++)cnt_nxt[num[j]]++;
		for(int j = 0;j<= lim;j++)R[j]-=cnt[i][j];
		if(i!=1&&i!=tot)conv(len);
		for(int j = st[i];j<= end[i];j++)
		{
			cnt_nxt[num[j]]--;
			calc(j);
			cnt_pre[num[j]]++;
		}
		for(int j = 0;j<= lim;j++)L[j]+=cnt[i][j];
		//printf("%lld\n",res);
	}
	printf("%lld\n",res);
}
int main()
{
	//freopen("3509.in","r",stdin);
	//freopen("3509.out","w",stdout);
	init();
	div_block();
	solve();
	return 0;
}
Problem3521

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 0x3f3f3f3f;
int v[N],stack[N],top,nxt[N],fv[N],b[N],pre[N];
char s[N];
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
	{
		if(s[i]=='p')pre[i] = pre[i-1]+1;
		else pre[i] = pre[i-1]-1;
	}
	for(int i = 1;i<= n;i++)
	{
		while(top>0&&pre[i]-pre[stack[top]-1]<0)
		{
			nxt[stack[top]] = i-1;
			top--;
		}
		if(top)fv[i] = stack[1];
		else if(pre[i]-pre[i-1]==1)fv[i] = i;
		else fv[i] = INF;
		if(pre[i]-pre[i-1]==1)stack[++top] = i;
	}
	while(top>0)
	{
		nxt[stack[top]] = n;
		top--;
	}
	int L,R,mid,head = 0;
	for(int i = n;i>= 1;i--)
	{
		while(top>0&&pre[stack[top]]-pre[i-1]<0)
		{
			L = 2,R = head+1;
			while(L<R)
			{
				mid = (L+R)>>1;
				if(nxt[b[mid]]>=stack[top])L = mid+1;
				else R = mid;
			}
			ans = max(ans,stack[top]-max(fv[stack[top]]-1,b[L-1]-1));
			top--;
		}
		if(pre[i]-pre[i-1]==1)
		{
			stack[++top] = i;
			while(head&&nxt[b[head]]<=nxt[i])head--;
			b[++head] = i;
		}
	}
	while(top>0)
	{
		L = 2,R = head+1;
		while(L<R)
		{
			mid = (L+R)>>1;
			if(nxt[b[mid]]>=stack[top])L = mid+1;
			else R = mid;
		}
		ans = max(ans,stack[top]-max(fv[stack[top]]-1,b[L-1]-1));
		top--;
	}
	printf("%d\n",ans);
	return 0;
}
Problem3522

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
typedef long long LL;
struct E
{int next,to;}e[N<<1];
int head[N],tot,tmp[N],g[N],f[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa,int dep)
{
	tmp[dep]++;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,dep+1);
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	LL ans = 0;
	for(int rt = 1;rt<= n;rt++)
	{
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		for(int i = head[rt];i;i = e[i].next)
		{
			memset(tmp,0,sizeof(tmp));
			dfs(e[i].to,rt,1);	
			for(int j = 1;j<= n;j++)
			{
				ans+=(LL)g[j]*tmp[j];
				g[j]+=f[j]*tmp[j];
				f[j]+=tmp[j];
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3523

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
struct H
{
	int col,num,se;
}heap[N];
bool cmp(H a,H b)
{
	if(a.num!=b.num)
		return a.num<b.num;
	return a.se<b.se;
}
int a[N],ans[N],cnt;
int main()
{
	int n,s,t;
	scanf("%d%d%d",&n,&s,&t);
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum = sum+a[i];
	}
	if(sum==1&&s==t)
		{printf("%d\n",1);return 0;}
	else if(sum==1){printf("0\n");return 0;}
	for(int i = 1;i<= n;i++)
	{
		if(a[i]-(i==s)-(i==t)>0)
		{
		heap[++cnt].col = i;
		heap[cnt].num = a[i]-(i==s)-(i==t);
		heap[cnt].se = i==t;
		push_heap(heap+1,heap+cnt+1,cmp);
		}else if(a[i]-(i==s)-(i==t)<0)
		{printf("0\n");return 0;}
	}
	int i;
	ans[1] = s,ans[sum] = t; 
	for(i = 2;i< sum;i++)
	{
		H x = heap[1];
		pop_heap(heap+1,heap+1+cnt,cmp);
		cnt--;
		if(x.col==ans[i-1]&&cnt!=0)
		{
			H tmp = x;
			x = heap[1];
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			ans[i] = x.col;
			x.num--;
			if(x.num)
			{
				heap[++cnt] = x;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
			heap[++cnt] = tmp;
			push_heap(heap+1,heap+cnt+1,cmp);
			continue;
		}
		else if(x.col!=ans[i-1])
		{
			ans[i] = x.col;
			x.num--;
			if(x.num)
			{
				heap[++cnt] = x;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
		if(!cnt&&ans[i]==0)
			{printf("0\n");return 0;}
	}
	if(ans[sum]!=ans[sum-1]||sum==1)
	{
		for(i = 1;i< sum;i++)
			printf("%d ",ans[i]);
		printf("%d\n",ans[sum]);
	}
	else printf("0\n");
	return 0;
}
Problem3524

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 1e7+5;
int root[N];
int ls[M],rs[M],sum[M];
int cnt,n,m;
void update(int l,int r,int rt1,int &rt2,int v)
{
	rt2 = ++cnt;
	sum[rt2] = sum[rt1]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[rt2] = ls[rt1],rs[rt2] = rs[rt1];
	if(v<=mid)update(l,mid,ls[rt1],ls[rt2],v);
	else update(mid+1,r,rs[rt1],rs[rt2],v);
}
int ask(int L,int R)
{
	int l,r,tmp = (R-L+1)>>1;
	int rt1 = root[L-1],rt2 = root[R];
	l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[rt2]-sum[rt1]<=tmp)return 0;
		if(sum[ls[rt2]]-sum[ls[rt1]]>tmp)
		{
			r = mid;
			rt1 = ls[rt1],rt2 = ls[rt2];
		}else if(sum[rs[rt2]]-sum[rs[rt1]]>tmp)
		{
			l = mid+1;
			rt1 = rs[rt1],rt2 = rs[rt2];
		}
		else return 0;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		int x;
		scanf("%d",&x);
		update(1,n,root[i-1],root[i],x);
	}
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",ask(x,y));
	}
	return 0;
}
Problem3527

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double x=0,double y=0):x(x),y(y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int len,int type)
{
	int t=0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*type*2/i),sin(PI*type*2/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w = cp(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
double ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<=len;i++)
		c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<=len;i++)
		ans[i]=c[i].x;
}
int main()
{
	int n;
	scanf("%d",&n);
	n--;
	for(int i = 0;i<= n;i++)scanf("%lf",&x[i].x);
	for(int i = 0;i<n;i++)
		y[i].x = (-1.0)/((double)(n-i)*(n-i));
	for(int i = n+1;i<=2*n;i++)
		y[i].x = -y[2*n-i].x;
	int m = 4*n,L = 1,nn = n;
	for(n=1;n<=m;n=n<<1)L++;
	conv(x,y,z,n);
	//for(int i = 0;i<= m;i++)ans[i] = c[i].x;
	for(int i = nn;i<= 2*nn;i++)printf("%.5lf\n",ans[i]);
	return 0;
}
Problem3529

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
const ll mod = (1ll<<31)-1;
bool vis[N];
int mu[N],prime[N],cnt;
ll G[N],g[N];
struct To
{int no;ll val;}g_no[N];
bool cmp(const To &a,const To &b){return a.val<b.val;}
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] =i;
			mu[i] = -1;
		}
		for(int j = 1;j<=cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		for(int j = 1;j*i<N;j++)
			g[i*j]=(g[i*j]+i)&mod;
	for(int i = 1;i<N;i++)
		g_no[i].val = g[i],g_no[i].no = i;
	sort(g_no+1,g_no+N,cmp);
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		G[i]=(G[i]+y)&mod;
}
ll getans(int x)
{
	ll ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans=(ans+G[i])&mod;
	return ans;
}
struct A
{int a,no,n,m;}ask[N];
bool cmpask(const A &a,const A &b){return a.a<b.a;}
ll ans_no[N];
void solve(int n,int m,int no)
{
	ll ans = 0;
	int last;
	for(int i = 1;i<=n&&i<=m;i =last+1)
	{
		last = min(n/(n/i),m/(m/i));
		ans = (ans+(ll)(n/i)*(m/i)*((getans(last)-getans(i-1))%(mod+1)+mod+1))&mod;
	}
	ans_no[no] = ans;
}
int main()
{
	int q;
	scanf("%d",&q);
	quick_mu();
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].n,&ask[i].m,&ask[i].a);
		ask[i].no = i;
	}
	sort(ask+1,ask+q+1,cmpask);
	int r = 1;
	for(int i = 1;i<= q;i++)
	{
		while(g_no[r].val<=ask[i].a&&r<N)
		{
			for(int j = 1;j*g_no[r].no<N;j++)
				update(j*g_no[r].no,g_no[r].val*mu[j]);
			r++;
		}
		solve(ask[i].n,ask[i].m,ask[i].no);
	}
	for(int i=1;i<= q;i++)
		printf("%lld\n",ans_no[i]);
	return 0;
}
Problem3530

#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define mod 1000000007
#define LL long long
#include <queue>
using namespace std;
struct trie
{
    int ch[12],mark,fail,last;
}t[2005];
char N[1500],s[1500];
int m,tot=0,n[2000],l;
LL f[1205][2005][3];
void Insert(char s[])
{
    int x=0;
    for (int i=0;i<strlen(s);i++)
    {
        int c=s[i]-'0';
        if (!t[x].ch[c])
            t[x].ch[c]=++tot;
        x=t[x].ch[c];
    }
    t[x].mark=1;
}
void Make_fail()
{
    queue<int> q;
    for (int i=0;i<=9;i++)
        if (t[0].ch[i]) 
            q.push(t[0].ch[i]);
    while (!q.empty())
    {
        int x=q.front();
        q.pop();
        for (int i=0;i<=9;i++)
            if (t[x].ch[i])
            {
                int y=t[x].ch[i];
                q.push(y);
                int v=t[x].fail;
                while (v&&!t[v].ch[i])
                    v=t[v].fail;
                t[y].fail=v=t[v].ch[i];
                t[y].last=t[v].mark?v:t[v].last;
            }
    }
}
void Add(LL &a,LL b)
{
    a=(a+b)%mod;
}
int C(int a,int b)
{
    if (a==b) return 1;
    if (a<b) return 0;
    return 2;
}
void DP()
{
    LL ans=0;
    for (int k=1;k<=9;k++)
    {
        int v=t[0].ch[k];
        if (!t[v].mark&&!t[v].last)
            f[1][t[0].ch[k]][C(k,n[1])]+=1;
    }
    for (int j=0;j<=tot;j++)
        ans=(ans+f[1][j][0]+f[1][j][1]+f[1][j][2])%mod;
    for (int i=1;i<l;i++)
    {
        for (int j=0;j<=tot;j++)
            if (f[i][j][0]||f[i][j][1]||f[i][j][2])
                for (int k=0;k<=9;k++)
                {
                    int v=j;
                    while (v&&!t[v].ch[k])
                        v=t[v].fail;
                    v=t[v].ch[k];
                    if (!t[v].mark&&!t[v].last)
                    {
                        int x=C(k,n[i+1]);
                        if (x==0)
                            Add(f[i+1][v][0],f[i][j][0]+f[i][j][1]),
                            Add(f[i+1][v][2],f[i][j][2]);
                        if (x==1)
                            Add(f[i+1][v][0],f[i][j][0]),
                            Add(f[i+1][v][1],f[i][j][1]),
                            Add(f[i+1][v][2],f[i][j][2]);
                        if (x==2)
                            Add(f[i+1][v][0],f[i][j][0]),
                            Add(f[i+1][v][2],f[i][j][1]+f[i][j][2]);
                    }
                }
        for (int j=0;j<=tot;j++)
        {
            Add(ans,f[i+1][j][0]+f[i+1][j][1]);
            if (i+1!=l)
                Add(ans,f[i+1][j][2]);
        }
    }
    printf("%d\n",(int)ans%mod);
}
int main()
{
    scanf("%s",N);
    l=strlen(N);
    for (int i=1;i<=l;i++)
        n[i]=N[i-1]-'0';
    scanf("%d",&m);
    for (int i=1;i<=m;i++)
        scanf("%s",s),Insert(s);
    Make_fail();
    DP();
    return 0;
}
Problem3531

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define N 100005
#define M 10000005
struct seg{int ls,rs,sum,mw;}t[M];
int tpn,n;
struct E{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x]= tot;
}
int top[N],deep[N],fa[N],size[N],son[N],w[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x]= ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int score[N],color[N];
int root[N];
void update(int p,int l,int r,int x,int b)
{
	if(l==r){t[p].sum = b,t[p].mw= b;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)
	{
		if(t[p].ls==0)t[p].ls= ++tpn;
		update(t[p].ls,l,mid,x,b);
	}else
	{
		if(t[p].rs==0)t[p].rs= ++tpn;
		update(t[p].rs,mid+1,r,x,b);
	}
	t[p].sum = t[t[p].ls].sum+t[t[p].rs].sum;
	t[p].mw = max(t[t[p].ls].mw,t[t[p].rs].mw);	
}
int getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return t[p].mw;
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)
		ans = max(ans,getmax(t[p].ls,l,mid,a,b));
	if(b>mid)
		ans = max(ans,getmax(t[p].rs,mid+1,r,a,b));
	return ans;
}
int getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return t[p].sum;
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<= mid)
		ans+=getsum(t[p].ls,l,mid,a,b);
	if(b>mid)
		ans+=getsum(t[p].rs,mid+1,r,a,b);
	return ans;
}
int get_ans(int x,int y,int opt,int c)
{
	int ans = 0;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)ans += getsum(root[c],1,n,w[top[x]],w[x]);
		else ans = max(ans,getmax(root[c],1,n,w[top[x]],w[x]));
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)ans += getsum(root[c],1,n,w[y],w[x]);
	else ans = max(ans,getmax(root[c],1,n,w[y],w[x]));
	return ans;
}
int main()
{
	for(int i = 1;i<= N-5;i++)
		root[i] = ++tpn;
	int x,y,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&score[i],&color[i]);
	for(int i = 1;i<n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(root[color[i]],1,n,w[i],score[i]);
	char j[5];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",j,&x,&y);
		if(j[1]=='S')printf("%d\n",get_ans(x,y,1,color[x]));
		else if(j[1]=='M')printf("%d\n",get_ans(x,y,0,color[x]));
		else if(j[1]=='W')
		{
			score[x] = y;
			update(root[color[x]],1,n,w[x],y);
		}else
		{
			update(root[color[x]],1,n,w[x],0);
			color[x] = y;
			update(root[color[x]],1,n,w[x],score[x]);
		}
	}
	return 0;
}
Problem3538

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int M = 50005;
bool v[N];
struct E
{int next,to,val;};
queue<int>Q;
struct G
{
	E e[M<<1];
	int head[N],tot,minn;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val = f;
		head[x] = tot;
	}
	int dis[N];
	void spfa(int s,int t)
	{
		memset(dis,0x3f,sizeof(dis));
		dis[s] = 0;
		v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i = e[i].next)
			{
				if(dis[x]+e[i].val<dis[e[i].to])
				{
					dis[e[i].to] = dis[x]+e[i].val;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
			}
		}
		minn = dis[t];
	}
}g1,g2,g;
int main()
{
	int n,m,x,y,u,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		g1.add(y,x,u);
		g2.add(y,x,w);
	}
	g1.spfa(n,1);
	g2.spfa(n,1);
	for(int i = 1;i<= n;i++)
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			int t = g1.e[j].to;
			int cnt = 0;
			if(g1.dis[i]+g1.e[j].val!=g1.dis[t])cnt++;
			if(g2.dis[i]+g2.e[j].val!=g2.dis[t])cnt++;
			g.add(t,i,cnt);
		}
	g.spfa(1,n);
	printf("%d\n",g.minn);
	return 0;
}
Problem3540

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
const int LIM = (N<<1)+5;
struct C
{int k,s;}cow[N];
bool cmp(C a,C b)
{return a.s<b.s;}
int pos[(N<<1)+5];
int main()
{	
	int n,x;
	char tmp[3];
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%s",&x,tmp);
		if(tmp[0]=='W')cow[i].k = -1;
		else cow[i].k = 1;
		cow[i].s =x;
	}
	sort(cow+1,cow+n+1,cmp);
	memset(pos,0x3f,sizeof(pos));
	int sum = n,ans = 0;
	pos[sum] = cow[1].s;
	for(int i = 1;i< n;i++)
	{
		sum+=cow[i].k;
		pos[sum] = min(pos[sum],cow[i+1].s);
	}
	for(int i = 2*n;i>=0;i--)
		pos[i] = min(pos[i],pos[i+2]);
	sum = n;
	for(int i = 1;i<= n;i++)
	{
		sum+=cow[i].k;
		ans = max(cow[i].s-pos[sum],ans);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3545

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 5e6+5;
int sum[M],ls[M],rs[M],tot,root[N],maxn;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void Insert(int &p,int l,int r,int pos)
{
	if(!p)p=++tot;
	if(l==r)
	{
		sum[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)Insert(ls[p],l,mid,pos);
	else Insert(rs[p],mid+1,r,pos);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int merge(int x,int y,int l,int r)
{
	if(!x||!y)return x+y;
	if(l==r)
	{
		sum[x] = sum[x]+sum[y];
		return x;
	}
	int mid = (l+r)>>1;
	ls[x] = merge(ls[x],ls[y],l,mid);
	rs[x] = merge(rs[x],rs[y],mid+1,r);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
struct edge
{
	int x,y,w;
	bool operator <(const edge &s)const
	{
		return w<s.w;
	}
}e[5*N];
struct Ask
{
	int p,v,k,no;
	bool operator <(const Ask &s)const
	{
		return v<s.v;
	}
}ask[5*N];
int hill[N],ans[5*N];
int getans(int p,int k)
{
	if(k<=0)return -1;
	int l = 1,r = maxn,ans=-1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[ls[p]]>=k)
			p = ls[p],r=mid;
		else 
		{
			k-=sum[ls[p]];
			p = rs[p],l= mid+1;
		}
	}
	return l;
}
int main()
{
	int n,m,q;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<=n;i++)
		scanf("%d",&hill[i]),maxn = max(maxn,hill[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].p,&ask[i].v,&ask[i].k);
		ask[i].no = i;
	}
	sort(e+1,e+m+1);sort(ask+1,ask+q+1);
	for(int i = 1;i<= n;i++)
		Insert(root[i],1,maxn,hill[i]);
	int j = 1;
	for(int i = 1;i<= q;i++)
	{
		while(j<=m&&e[j].w<=ask[i].v)
		{
			int fx = getfa(e[j].x),fy = getfa(e[j].y);
			if(fx==fy){j++;continue;}
			fa[fy] = fx;
			root[fx] = merge(root[fx],root[fy],1,maxn);
			j++;
		}
		int tmp = getfa(ask[i].p);
		ans[ask[i].no] = getans(root[tmp],sum[root[tmp]]-ask[i].k+1);
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int sed = 299;
typedef unsigned long long ll;
const int N = 6e6+5;
ll pow[205];
ll hash[N];
char s[205];
int cnt;
int main()
{
	int n,l,q;
	pow[0]=1;
	for(int i = 1;i<205;i++)pow[i]=pow[i-1]*sed;
	scanf("%d%d%d",&n,&l,&q);
	for(int i = 1;i<= n;i++)
	{
		ll tmp = 0;
		scanf("%s",s+1);
		int lth = strlen(s+1);
		for(int i = 1;i<=lth;i++)
			tmp = tmp*sed+s[i];
		for(int i = 1;i<=lth;i++)
		{
			ll tt = tmp-s[i]*pow[lth-i];
			hash[++cnt] = tt;
		}
	}
	sort(hash+1,hash+cnt+1);
	ll ans = 0;
	int cc = 0;
	for(int i = 1;i<= cnt;i++)
	{
		if(i==1||hash[i]!=hash[i-1])
			cc=-1;
		cc++;
		ans+=cc;
	}
	printf("%llu\n",ans);
	return 0;
}
Problem3566

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const double eps = 1e-6;
struct E{int next,to;double p;}e[N<<2];
int head[N],tot;
void add(int x,int y,double val)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].p = val;
	head[x] = tot;
}
double g[N],f[N],q[N];
void dfs(int x,int fa)
{
	double tmp = 1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			tmp*=(1.0-e[i].p*f[e[i].to]);
		}	
	}
	f[x] = 1.0-tmp*(1.0-q[x]);	
}
void dfs2(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		double tmp = 1-f[e[i].to]*e[i].p;
		if(fabs(tmp)<eps)g[e[i].to] = 1;
		else
		{
			double y = (g[x]-f[e[i].to]*e[i].p)/(1-f[e[i].to]*e[i].p);
			g[e[i].to] = f[e[i].to]+y*e[i].p-f[e[i].to]*y*e[i].p;
		}
		dfs2(e[i].to,x);
	}
}
int main()
{
	int n,x,y;
	double p;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%lf",&x,&y,&p);
		add(x,y,p/100.0);
		add(y,x,p/100.0);
	}
	for(int i = 1;i<= n;i++)
		{scanf("%lf",&q[i]);q[i]/=100.0;}
	dfs(1,0);
	g[1] = f[1];
	dfs2(1,0);
	double ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=g[i];
	printf("%.6f",ans);
	return 0;
}
Problem3572

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+100;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;};
int size[N],fa[N][20],dep[N],dfn[N],Dfn;
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;
	}
	void dfs(int x,int f)
	{
		fa[x][0] = f;
		dep[x] = dep[f]+1;
		size[x] = 1;
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=f)
			{
				dfs(e[i].to,x);
				size[x]+=size[e[i].to];
			}
	}
	void init(int n)
	{
		for(int j = 1;j<= 19;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 19;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 19;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	int jump(int x,int h)
	{
		for(int i = 19;i>=0;i--)
			if(dep[fa[x][i]]>=h)
				x=fa[x][i];
		return x;
	}
}tree;
int h[N],stk[N],top;
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int father[N],rec[N],val[N],dis[N],ans[N],tr[N],len[N],near[N];
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i= 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		tree.add(x,y);
	}
	tree.dfs(1,0);
	tree.init(n);
	int q,m;
	scanf("%d",&q);
	while(q--)
	{
		scanf("%d",&m);
		int cnt = 0;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&h[i]);
			tr[++cnt] = h[i];
			rec[i] = near[h[i]]=h[i];
			dis[h[i]]=ans[h[i]]=0;
		}
		top = 0;
		sort(h+1,h+m+1,cmp);
		for(int i=1;i<=m;i++)
		{
			if(!top)father[stk[++top]=h[i]]=0;
			else
			{
				int lca = tree.getlca(stk[top],h[i]);
				while(dep[lca]<dep[stk[top]])
				{
					if(dep[lca]>=dep[stk[top-1]])
						father[stk[top]]=lca;
					top--;
				}
				if(stk[top]!=lca)
				{
					father[lca]=stk[top];
					stk[++top]=tr[++cnt]=lca;
					near[lca]=0,dis[lca]=INF;
				}
				father[stk[++top]=h[i]]=lca;
			}
		}
		sort(tr+1,tr+cnt+1,cmp);
		for(int i = 1;i<= cnt;i++)
		{
			val[tr[i]]=size[tr[i]];
			len[tr[i]]=dep[tr[i]]-dep[father[tr[i]]];
		}
		for(int i = cnt;i>=2;i--)
		{
			if(dis[father[tr[i]]]>dis[tr[i]]+len[tr[i]])
			{
				dis[father[tr[i]]]=dis[tr[i]]+len[tr[i]];
				near[father[tr[i]]]=near[tr[i]];
			}else if(dis[father[tr[i]]]==dis[tr[i]]+len[tr[i]])
				near[father[tr[i]]]=min(near[father[tr[i]]],near[tr[i]]);
		}
		for(int i = 2;i<= cnt;i++)
		{
			if(dis[tr[i]]>dis[father[tr[i]]]+len[tr[i]])
			{
				dis[tr[i]] = dis[father[tr[i]]]+len[tr[i]];
				near[tr[i]] = near[father[tr[i]]];
			}else if(dis[tr[i]]==dis[father[tr[i]]]+len[tr[i]])
				near[tr[i]]=min(near[father[tr[i]]],near[tr[i]]);
		}
		for(int i = 1;i<= cnt;i++)
		{
			if(i==1)ans[near[tr[i]]]=n-size[tr[i]];
			else
			{
				int x = tree.jump(tr[i],dep[father[tr[i]]]+1);
				int s = size[x]-size[tr[i]];
				val[father[tr[i]]]-=size[x];
				if(near[father[tr[i]]]==near[tr[i]])
					ans[near[tr[i]]]+=s;
				else
				{
					int num = dis[father[tr[i]]]+dis[tr[i]]+len[tr[i]]+1;
					int mid = dep[tr[i]]+dis[tr[i]]-(num+1)/2+1;
					if((num&1)&&near[tr[i]]>near[father[tr[i]]])mid++;
					x=size[x]-size[tree.jump(tr[i],mid)];
					ans[near[father[tr[i]]]]+=x;
					ans[near[tr[i]]]+=s-x;
				}
			}
		}
		for(int i = 1;i<= cnt;i++)
			ans[near[tr[i]]]+=val[tr[i]];
		for(int i = 1;i<= m;i++)
			printf("%d ",ans[rec[i]]);
		printf("\n");
	}
	return 0;
}
Problem3586

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
typedef long double ld;
int tt,n,l,t;
char s[10];
int trie[60][26],pos[60],tot,fail[60];
ld f[60][356],p[26],a[60][60];
queue<int> q;
void mkfail()
{
	q.push(0);
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=0;i<t;i++)
		{
			if(trie[x][i])
			{
				if(x) fail[trie[x][i]]=trie[fail[x]][i];
				q.push(trie[x][i]);
			}else trie[x][i]=trie[fail[x]][i];
		}
	}
}
void Gauss(int n)
{
	for(int i=0;i<=n;i++)
	{
		ld mx=0;int pos;
		for(int j=i;j<=n;j++)
		{
			if(fabs(a[j][i])>mx)
			{
				mx=fabs(a[j][i]);
				pos=j;
			}
		}
		for(int j=i;j<=n+1;j++) swap(a[i][j],a[pos][j]);
		for(int j=i+1;j<=n;j++)
		{
			ld f=a[j][i]/a[i][i];
			for(int k=i;k<=tot+1;k++)
				a[j][k]-=f*a[i][k];
		}
	}
	for(int i=n;i>=0;i--)
	{
		for(int j=i+1;j<=n;j++)
			a[i][tot+1]-=a[i][j]*a[j][tot+1];
		a[i][tot+1]/=a[i][i];
	}
}

void calc(int x)
{
	memset(a,0,sizeof a);
	for(int i=0;i<=tot;i++)
	{
		a[i][i]=1;
		if(pos[i]!=-1&&((1<<pos[i])&x)) a[i][tot+1]=f[i][x^(1<<pos[i])];
		else
		{
			a[i][tot+1]=1;
			for(int j=0;j<t;j++)
				a[i][trie[i][j]]-=p[j];
		}
	}
	Gauss(tot);
	for(int i=0;i<=tot;i++) f[i][x]=a[i][tot+1];
}
int main()
{
	scanf("%d",&tt);
	while(tt--)
	{
		memset(trie,0,sizeof trie);
		memset(pos,-1,sizeof pos);
		memset(fail,0,sizeof fail);
		memset(f,0,sizeof f);
		tot=0;
		scanf("%d%d%d",&n,&l,&t);
		for(int i=0;i<n;i++)
		{
			scanf("%s",s);
			int id=0;
			for(int j=0;s[j];j++)
				if(trie[id][s[j]-'a']) id=trie[id][s[j]-'a'];
				else id=trie[id][s[j]-'a']=++tot;
			pos[id]=i;
		}
		for(int i=0,x;i<t;i++)
		{
			scanf("%d",&x);
			p[i]=x/10000.0;
		}
		mkfail();
		for(int i=1;i<(1<<n);i++)
			calc(i);
		printf("%.10f\n",(double)f[0][(1<<n)-1]);
	}
	return 0;
}
Problem3590

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int S = 1<<12;
const int N = 13;
const int M = 85;
const int INF = 5e8;
struct E
{int next,to,val;}e[M];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
int g[S][N][N],h[S][N][2],n,m;
int f[S];
void graph_init()
{
	memset(head,0,sizeof(head));
	tot = 0;
	int x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
}
void edge_init()
{
	for(int i = 0;i<1<<n;i++)for(int j = 0;j<= n;j++)for(int k = 0;k<= n;k++)
		g[i][j][k] = INF;
	for(int i = 0;i<1<<n;i++)for(int j = 0;j<= n;j++)for(int k = 0;k<= 1;k++)
		h[i][j][k] = INF;
	for(int i = 0;i<n;i++)
		g[i<<1][i+1][i+1] = 0;
	for(int i = 1;i<=n;i++)
		for(int j = head[i];j;j = e[j].next)
		{
			int l = i,r = e[j].to;
			int s = (1<<(l-1))|(1<<(r-1));
			g[s][l][r] = min(g[s][l][r],e[j].val);
		}
	for(int s = 0;s<1<<n;s++)
	{
		for(int l = 1;l<= n;l++)
			for(int r = 1;r<= n;r++)
				if((s|(1<<(l-1))|(1<<(r-1)))==s)
					for(int p = head[r];p;p=e[p].next)
					{
						int nr = e[p].to;
						if((s|(1<<(nr-1)))!=s)
							g[s|(1<<(nr-1))][l][nr] = 
							min(g[s|(1<<(nr-1))][l][nr],g[s][l][r]+e[p].val);
					}
	}
	for(int s = 0;s<1<<n;s++)
		for(int i = 1;i<= n;i++)
			if((s|(1<<(i-1)))==s)
				for(int j = head[i];j;j = e[j].next)
				{
					int to = e[j].to;
					if((s|(1<<(to-1)))!=s)
					{
						if(e[j].val<=h[s][to][0])
						{
							h[s][to][1] = h[s][to][0];
							h[s][to][0] = e[j].val;
						}else if(e[j].val<h[s][to][1])
							h[s][to][1] = e[j].val;
					}
				}
}
int calc_sta(int x)
{
	int sta = 1;
	for(x = x&(x-1);x;x = x&(x-1))
		sta++;
	return sta;
}
void dp()
{
	for(int i = 1;i<1<<n;i++)
		f[i] = INF;
	for(int i = 0;i<n;i++)
		f[1<<i] = 0;
	for(int i = 1;i<1<<n;i++)
		if(calc_sta(i)>=2)
			for(int s = i&(i-1);s;s = (s-1)&i)
			{
				int t = i-s;
				for(int l = 1;l<= n;l++)
					for(int r = 1;r<= n;r++)
						if((s|(1<<(l-1)))==s&&(s|(1<<(r-1)))==s)
						{
							if(l==r)
								f[i] = min(f[i],f[t]+g[s][l][r]+h[t][l][0]+h[t][l][1]);
							else 
								f[i] = min(f[i],f[t]+g[s][l][r]+h[t][l][0]+h[t][r][0]);
						}

			}
	if(f[(1<<n)-1]<INF)printf("%d\n",f[(1<<n)-1]);
	else printf("impossible\n");
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		graph_init();
		edge_init();
		dp();
	}
	return 0;
}
Problem3597

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const int N = 5005;
const int M = 6005;
struct Road
{int x,y,a,b,c,d;}r[M];
struct E
{int next,to;double val;}e[M];
int head[N],tot,n,m;
void add(int x,int y,double f)
{e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].val=f;}
bool vis[N];double dis[N];
bool flag;
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(dis[e[i].to]>dis[x]+e[i].val)
		{
			if(vis[e[i].to])flag = true;
			else
			{
				dis[e[i].to] = dis[x]+e[i].val;
				dfs(e[i].to);
			}
		}
	}
	vis[x] = false;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(dis,0,sizeof(dis));
	memset(vis,0,sizeof(vis));
	flag = false;tot = 0;
}
bool check(double ans)
{
	init();
	for(int i = 1;i<= m;i++)
	{
		add(r[i].x,r[i].y,r[i].b+r[i].d+ans);
		if(r[i].c)add(r[i].y,r[i].x,r[i].a-r[i].d+ans);
	}
	for(int i = 1;i<= n && !flag;i++)
		dfs(i);
	return flag;
}
int main()
{
	scanf("%d%d",&n,&m);
	n+=2;
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d%d%d%d",&r[i].x,&r[i].y,&r[i].a,&r[i].b,&r[i].c,&r[i].d);
	double l = 0,r = 1e8;
	while(fabs(r-l)>eps)
	{
		double mid = (l+r)/2;
		if(check(mid))l=mid;
		else r = mid;
	}
	printf("%.2lf\n",l);
	return 0;
}
Problem3611

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+1000;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;};
int dep[N],fa[N][22],dfn[N],Dfn;
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dfs(int x,int ff)
	{
		dep[x] = dep[ff]+1;
		fa[x][0]=ff;
		dfn[x] =++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=ff)
				dfs(e[i].to,x);
	}
	void init(int n)
	{
		for(int j = 1;j<= 21;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int lca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 21;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 21;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
}tree;
vector<int>to[N];
vector<int>val[N];
void add(int x,int y,int f)
{
	if(x==y)return ;
	to[x].push_back(y);
	to[y].push_back(x);
	val[x].push_back(f);
	val[y].push_back(f);
}
int size[N];
bool v[N];
ll ans1,ans2,ans3;
void Tree_DP(int x,int from)
{
	static long long f[N],g[N],max_dis[N],min_dis[N];
	//f[x]表示以x为根的子树中有多少关键点
	//g[x]表示以x为根的子树中所有关键点到x的距离之和
	//max_dis[x]/min_dis[x]表示节点x为根的子树中的关键点到x的距离的最大/最小值
	int i;
	f[x]=v[x];g[x]=0;
	max_dis[x]=(v[x]?0:-INF);
	min_dis[x]=(v[x]?0:INF);
	int sz = to[x].size();
	for(i=0;i<sz;i++)
	{
		int t = to[x][i];
		if(t==from)
			continue;
		Tree_DP(t,x);
		int dis=val[x][i];
		ans1+=(g[x]+f[x]*dis)*f[t]+g[t]*f[x];
		ans2=min(ans2,min_dis[x]+min_dis[t]+dis);
		ans3=max(ans3,max_dis[x]+max_dis[t]+dis);
		f[x]+=f[t];
		g[x]+=g[t]+f[t]*dis;
		max_dis[x]=max(max_dis[x],max_dis[t]+dis);
		min_dis[x]=min(min_dis[x],min_dis[t]+dis);
	}
	v[x] = false,to[x].clear(),val[x].clear();
}
/*void dfs(int x,int ff,int dis)
{
	size[x] = v[x];
	if(v[x]&&dis)ans2 = min(ans2,dis),dis = 0;
	int sz = to[x].size();
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
		{
			dfs(t,x,dis+val[x][i]);
			size[x]+=size[t];
			ans1+=(ll)(tn-size[t])*size[t]*val[x][i];
		}
	}
	v[x] = false;
	to[x].clear(),val[x].clear();
}
int end,maxdis;
void get_rope(int x,int dis,int ff)
{
	if(dis&&dis>maxdis&&v[x])
	{
		maxdis = dis;
		end = x;
	}
	int sz = to[x].size();
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
			get_rope(t,dis+val[x][i],x);
	}
}*/
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int h[N],stk[N],top;
int main()
{
	int n,q,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		tree.add(x,y);
	}
	tree.dfs(1,0);
	tree.init(n);
	scanf("%d",&q);
	while(q--)
	{
		int k;
		scanf("%d",&k);
		for(int i = 1;i<= k;i++)
			scanf("%d",&h[i]),v[h[i]]=true;
		sort(h+1,h+k+1,cmp);
		top = 0;
		stk[++top]=h[1];
		for(int i = 2;i<= k;i++)
		{
			int u = h[i];
			int lca = tree.lca(u,stk[top]);
			while(true)
			{
				if(dep[lca]>=dep[stk[top-1]])
				{
					int len = dep[stk[top]]-dep[lca];
					add(lca,stk[top--],len);
					break;
				}
				add(stk[top-1],stk[top],dep[stk[top]]-dep[stk[top-1]]);
				top--;
			}
			if(stk[top]!=lca)stk[++top]=lca;
			if(stk[top]!=u)stk[++top]=u;
		}
		for(int i = 1;i<top;i++)
			add(stk[i],stk[i+1],dep[stk[i+1]]-dep[stk[i]]);
		ans1 = 0,ans2 = INF,ans3 = -INF;
		Tree_DP(h[1],-1);
		printf("%lld %lld %lld\n",ans1,ans2,ans3);
	}
	return 0;
}
Problem3613

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int mod;
typedef long long LL;
const int N = 5000005;
int a[N],sa,sb,sc,sd,n;
int F(int x)
{
	LL ans = 0;
	LL x2 = (LL)x*x%mod;LL x3 = x2*x%mod;
	ans = (((ans+(LL)sa*x3%mod)%mod+(LL)sb*x2%mod)%mod+(LL)sc*x%mod)%mod+sd;
	ans = ans%mod;
	return ans;
}
bool judge(int b)
{
	int mx = 1;
	for(int i = 1;i<= n;i++)
	{
		mx = max(mx,a[i]-b);
		if(mx>a[i]+b)return false;
	}
	return true;
}
int main()
{
	scanf("%d%d%d%d%d%d%d",&n,&sa,&sb,&sc,&sd,&a[1],&mod);
	for(int i = 2;i<= n;i++)
		a[i] = (F(a[i-1])+F(a[i-2]))%mod;
	int l = 0,r = mod+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(judge(mid))r = mid;
		else l = mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem3622

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int mod =1e9+9;
typedef long long ll;
int n,k;
ll f[N][N];
ll c[N][N],fac[N],g[N];
void init()
{
	fac[0] = 1;
	for(int i = 1;i<N;i++)
		fac[i] = fac[i-1]*i%mod;
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}	
}
int a[N],b[N],next[N];
int main()
{
	init();
	int n,k;
	scanf("%d%d",&n,&k);
	if((n+k)&1){printf("0\n");return 0;}
	k=(k+n)/2;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	int j = 1;
	for(int i = 1;i<= n;i++)
	{
		while(b[j]<a[i]&&j<=n)j++;
		next[i]=j-1;
	}
	f[0][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		f[i][0]=1;
		for(int j = 1;j<= i;j++)
			(f[i][j]+=f[i-1][j-1]*max(next[i]-j+1,0)+f[i-1][j])%=mod;
	}
	for(int i = n;i>=k;i--)
	{
		g[i] = (ll)f[n][i]*fac[n-i]%mod;
		for(int j = i+1;j<= n;j++)
			(g[i]+=mod-g[j]*c[j][i]%mod)%=mod;
	}
	printf("%lld\n",g[k]);
	return 0;
}
Problem3624

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int M = 100005;
int fa[N];
struct E{int x,y;}e1[M],e2[M];
int cnt1,cnt2;
int ansx[M],ansy[M],ansc[M];
int ans_cnt,n,m,k;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
bool Find_Must()
{
	int block = n;
	for(int i = 1;i<= cnt2;i++)
	{
		int fx = getfa(e2[i].x),fy = getfa(e2[i].y);
		if(fx==fy)continue;
		block--;
		uni(e2[i].x,e2[i].y);
		if(block==1)break;
	}
	for(int i = 1;i<= cnt1;i++)
	{
		int fx = getfa(e1[i].x),fy = getfa(e1[i].y);
		if(fx==fy)continue;
		block--;
		ans_cnt++;
		ansx[ans_cnt] = e1[i].x;ansy[ans_cnt] = e1[i].y;
		ansc[ans_cnt] = 0;
		uni(e1[i].x,e1[i].y);
		if(block==1)break;
	}
	if(ans_cnt>k)return false;
	else return true;
}
bool build()
{
	int block = n,tmp = 0;
	for(int i = 1;i<= ans_cnt;i++)
	{
		uni(ansx[i],ansy[i]);
		block--;
		tmp++;
	}
	for(int i = 1;i<= cnt1;i++)
	{
		int fx = getfa(e1[i].x),fy = getfa(e1[i].y);
		if(fx==fy)continue;
		block--;
		tmp++;
		ans_cnt++;
		ansx[ans_cnt] = e1[i].x;ansy[ans_cnt] = e1[i].y;
		ansc[ans_cnt] = 0;
		uni(e1[i].x,e1[i].y);
		if(block==1||tmp==k)break;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		int fx = getfa(e2[i].x),fy = getfa(e2[i].y);
		if(fx==fy)continue;
		block--;
		ans_cnt++;
		ansx[ans_cnt] = e2[i].x;ansy[ans_cnt] = e2[i].y;
		ansc[ans_cnt] = 1;
		uni(e2[i].x,e2[i].y);
		if(block==1)break;
	}
	if(tmp!=k)return false;
	else return true;
}
int main()
{
	int x,y,c;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		if(c==0){e1[++cnt1].x = x;e1[cnt1].y = y;}
		else {e2[++cnt2].x = x;e2[cnt2].y = y;}
	}
	if(!Find_Must())printf("no solution\n");
	memset(fa,0,sizeof(fa));
	if(!build())printf("no solution\n");
	else
	{
		for(int i = 1;i<= ans_cnt;i++)
			printf("%d %d %d\n",ansx[i],ansy[i],ansc[i]);
	}
	return 0;
}
Problem3625

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 261244<<1;
typedef long long ll;
const int mod = 998244353;
const int Inv2 = 499122177;
int a[N],b[N],c[N],cnt=0;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
void NTT(int *a,int len,int type)
{
	int t = 0,i,j,k,wn,tmp,w;
	for(i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(j = len>>1;(t^=j)<j;j=j>>1);
	}
	for(i = 2;i<= len;i<<=1)
	{
		wn = quick_pow(5,(mod-1)/i);
		for(j = 0;j<len;j+=i)
		{
			w = 1;
			for(k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
			{
				tmp = (ll)a[j+k+(i>>1)]*w%mod;
				a[j+k+(i>>1)] = (a[j+k]-tmp+mod)%mod;
				a[j+k] = (a[j+k]+tmp)%mod;
			}
		}
	}
	if(type==-1)
	{
		for(i = 1;i<(len>>1);i++)
			swap(a[i],a[len-i]);
		int Inv = quick_pow(len,mod-2);
		for(i = 0;i<len;i++)
			a[i] = (ll)a[i]*Inv%mod;
	}
	/*printf("#case %d:",++cnt);
	for(int i = 0;i<len;i++)
		printf("%d ",a[i]);
	printf("\n");*/
}
void Get_Inv(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = quick_pow(a[0],mod-2);
		return ;
	}
	Get_Inv(a,b,len>>1);
	static int tmp[N];
	memcpy(tmp,a,sizeof(int)*len);
	memset(tmp+len,0,sizeof(int)*len);
	NTT(tmp,len<<1,1);
	NTT(b,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i] = (ll)b[i]*(2-(ll)b[i]*tmp[i]%mod+mod)%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(ll)*len);
}
void Get_Root(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = 1;
		return ;
	}
	Get_Root(a,b,len>>1);
	static int tmpa[N],tmpb[N];
	memset(tmpb,0,sizeof(int)*len);  
    memset(tmpb+len,0,sizeof(int)*len);
	Get_Inv(b,tmpb,len);
	memcpy(tmpa,a,sizeof(int)*len);
	memset(tmpa+len,0,sizeof(int)*len);
	NTT(tmpa,len<<1,1),NTT(b,len<<1,1),NTT(tmpb,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i] = (ll)(b[i]+(ll)tmpa[i]*tmpb[i]%mod)%mod*Inv2%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(int)*len);
}
int main()
{
	int n,m,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		if(k<=m)a[k]++;
	}
	int len = 1;
	for(int i=1<<30;i;i>>=1)  
        if(m&i)  
            {len=i<<1;break;} 
	for(int i = 0;i<len;i++)
		if(a[i])a[i]=mod-4;
	a[0]++;
	Get_Root(a,b,len);
	memcpy(a,b,sizeof(int)*len);
	a[0]++;
	memset(b,0,sizeof(int)*len);
	Get_Inv(a,b,len);
	for(int i = 1;i<= m;i++)
		printf("%d\n",b[i]*2%mod);
	return 0;
}
Problem3627

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 2e4+5;
const int P = 60;
const int T = 80;
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
struct Trie
{
	int ch[N*20][T],cnt;
	int lazy[N*20],sign;
	char s[T];
	int insert()
	{
		scanf("%s",s+1);
		int x = 0,alp;
		for(int i = 1;s[i];i++)
		{
			alp = s[i]-'0';
			if(!ch[x][alp])ch[x][alp]=++cnt;
			x = ch[x][alp];
		}
		if(!lazy[x])lazy[x] = ++sign;
		return lazy[x];
	}
	int judge()
	{
		for(int i=1;s[i];i++)
            if(i>=5&&s[i]=='t'&&s[i-1]=='r'&&s[i-2]=='a'&&s[i-3]=='t'&&s[i-4]=='s')return 1;
        for(int i=1;s[i];i++)
        	if(i>=3&&s[i]=='s'&&s[i-1]=='a'&&s[i-2]=='g')return 2;
        for(int i=1;s[i];i++)
        	if(i>=3&&s[i]=='d'&&s[i-1]=='n'&&s[i-2]=='e')return 3;
        return 0;
	}
}trie;
struct E
{
	int u,v,next;
	double val;
}e[M<<1],E[15][P*P*2];
int head[N],tot;
int Head[15][P],cnt[15];
void add(int x,int y,double f)
{
	e[++tot].u = x;
	e[tot].v = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void ADD(int l,int x,int y,double f)
{
	E[l][++cnt[l]].u = x;
	E[l][cnt[l]].v = y;
	E[l][cnt[l]].val = f;
	E[l][cnt[l]].next = Head[l][x];
	Head[l][x] = cnt[l];
	//printf("%d %d %d %.5lf\n",l,x,y,f);
}
struct Point
{
	int x,y;
	Point(){}
	Point(int x,int y):x(x),y(y){}
};
queue<Point>Q;
double dis[15][N],aver[N];
bool in[15][N];
int n,m,light,gas,cost;
bool red[N];
int sta[N],gass[N],num;
char tmp[T];
void SPFA(int s)
{
	while(!Q.empty())Q.pop();
	memset(dis,0x7f,sizeof(dis));
	dis[0][s] = 0;
	in[0][s] = true;
	Q.push(Point(0,s));
	while(!Q.empty())
	{
		Point tt = Q.front();
		Q.pop();
		in[tt.x][tt.y] = false;
		for(int i = head[tt.y];i;i=e[i].next)
		{
			int to = e[i].v,temp = tt.x+red[to];
			if(temp<=light&&dis[tt.x][tt.y]+e[i].val+aver[to]<=gas&&dis[temp][to]>dis[tt.x][tt.y]+e[i].val+aver[to])
			{
				dis[temp][to] = dis[tt.x][tt.y]+e[i].val+aver[to];
				if(!in[temp][to])
				{
					in[temp][to] =true;
					Q.push(Point(temp,to));
				}
			}
		}
	}
}
double spfa(int s,int t)
{
	while(!Q.empty())Q.pop();
	memset(dis,0x7f,sizeof(dis));
	dis[0][s] = 0;
	in[0][s] = true;
	Q.push(Point(0,s));
	while(!Q.empty())
	{
		Point tt = Q.front();
		Q.pop();
		in[tt.x][tt.y] = false;
		for(int j = 0;j+tt.x<=light;j++)
		{
			for(int i = Head[j][tt.y];i;i=E[j][i].next)
			{
				int to = E[j][i].v;
				if(dis[j+tt.x][to]>dis[tt.x][tt.y]+cost+E[j][i].val)
				{
					dis[j+tt.x][to] = dis[tt.x][tt.y]+cost+E[j][i].val;
					if(!in[j+tt.x][to])
					{
						in[j+tt.x][to] = true;
						Q.push(Point(j+tt.x,to));
					}
				}
			}
		}
	}
	double ans = 99999999999.999;
	for(int i = 0;i<= light;i++)
		ans = min(ans,dis[i][t]);
	return ans;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&light,&gas,&cost);
	int k,s,t,v,ia,ib;
	double a,b,c;
	for(int i = 1;i<= n;i++)
	{
		trie.insert();
		if(k = trie.judge())
		{
			sta[i] = ++num;
			gass[num] = i;
			if(k==1)s=i;
			if(k==3)t=i;
		}
		scanf("%lf%lf",&a,&b);
		if(k==1||k==3)continue;
		if(a>eps)
            red[i]=1,aver[i]=a*a/2.0/(a+b);
	}
	for(int i = 1;i<= m;i++)
	{
		ia = trie.insert();
		ib = trie.insert();
		scanf("%s",tmp);
		scanf("%lf",&c);
		add(ia,ib,c),add(ib,ia,c);
	}
	for(int i = 1;i<= num;i++)
	{
		SPFA(gass[i]);
		for(int j = 1;j<= num;j++)
		{
			v = gass[j];
			if(j!=i)
			{
				for(int k = 0;k<=light;k++)
					if(dis[k][v]<INF)
						ADD(k,i,j,dis[k][v]);
			}
		}
	}
	printf("%.3lf\n",spfa(sta[s],sta[t])-cost);
	return 0;
}
Problem3629

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int prime[N],cnt;
ll Ans[10000005];
bool v[N];
void quick_prime()
{
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
			prime[++cnt]=i;
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
bool check_prime(int x)
{
	if(x==1)return false;
	for(int i = 1;prime[i]*prime[i]<= x;i++)
		if(x%prime[i]==0)return false;
	return true;
}
void getans(ll ans,int pos,ll left)
{
	if(left==1)
	{
		Ans[++Ans[0]]=ans;
		return ;
	}
	if(left-1>=prime[pos]&&check_prime(left-1))
		Ans[++Ans[0]] = ans*(left-1);
	for(int i = pos;prime[i]*prime[i]<=left;i++)
	{
		ll sum = 1+prime[i],powe = prime[i];
		for(;sum<=left;powe*=prime[i],sum+=powe)
			if(left%sum==0)
			{
				getans(ans*powe,i+1,left/sum);
			}
	}
}
int main()
{
	ll n;
	quick_prime();
	while(scanf("%lld",&n)!=EOF)
	{
		Ans[0] = 0;
		getans(1,1,n);
		sort(Ans+1,Ans+Ans[0]+1);
		printf("%lld\n",Ans[0]);
		for(int i = 1;i<= Ans[0];i++)
			printf("%lld%c",Ans[i],i==Ans[0]?'\n':' ');
	}
	return 0;
}
Problem3630

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
queue<int>Q;
const int N = 6010;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
typedef long long ll;
struct S
{
	int x1,y1,x2,y2,x,y,r;
	int k;
}s[N];
ll getdis(int x1,int y1,int x2,int y2)
{
	return (ll)(x1-x2)*(x1-x2)+(ll)(y1-y2)*(y1-y2);
}
bool check(int i,int j)
{
	int typ = s[i].k+s[j].k;
	if(typ==2)
	{
		return getdis(s[i].x,s[i].y,s[j].x,s[j].y)<=(ll)(s[i].r+s[j].r)*(s[i].r+s[j].r);
	}
	if(typ==3)
	{
		if(s[i].k==1)swap(i,j);
		if(getdis(s[i].x1,s[i].y1,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x1,s[i].y2,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x2,s[i].y1,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x2,s[i].y2,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(s[i].y1<=s[j].y&&s[i].y2>=s[j].y)
			if(abs(s[i].x2-s[j].x)<=s[j].r||abs(s[i].x1-s[j].x)<=s[j].r)
				return true;
		if(s[i].x1<s[j].x&&s[i].x2>s[j].x)
			if(abs(s[i].y2-s[j].y)<=s[j].r||abs(s[i].y1-s[j].y)<=s[j].r)
				return true;
		if(s[i].x1<=s[j].x&&s[i].x2>=s[j].x&&s[i].y1<=s[j].y&&s[i].y2>=s[j].y)
			return true;
	}
	if(typ==4)
	{
		if((s[i].x1>=s[j].x1&&s[i].x1<=s[j].x2)||(s[i].x2>=s[j].x1&&s[i].x2<=s[j].x2))
        if((s[i].y1>=s[j].y1&&s[i].y1<=s[j].y2)||(s[i].y2>=s[j].y1&&s[i].y2<=s[j].y2))return 1;
        if(s[i].x1<=s[j].x1&&s[j].x2<=s[i].x2&&s[j].y1<=s[i].y1&&s[i].y2<=s[j].y2)return 1;
        swap(i,j);
        if((s[i].x1>=s[j].x1&&s[i].x1<=s[j].x2)||(s[i].x2>=s[j].x1&&s[i].x2<=s[j].x2))
        if((s[i].y1>=s[j].y1&&s[i].y1<=s[j].y2)||(s[i].y2>=s[j].y1&&s[i].y2<=s[j].y2))return 1;
        if(s[i].x1<=s[j].x1&&s[j].x2<=s[i].x2&&s[j].y1<=s[i].y1&&s[i].y2<=s[j].y2)return 1;
	}
	return false;
}
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f1,int f2)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f1;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f2;
}
int d[N],st,ed;
bool bfs(int s,int t)
{
	for(int i = st;i<= ed;i++)
		d[i] = -1;
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
void display(int S,int T)
{
	for(int i = S;i<= T;i++)
		for(int j = head[i];j;j=e[j].next)
			printf("%d %d:%d\n",i,e[j].to,e[j].f);
}
int main()
{
	int cx,cy,n;
	scanf("%d%d%d",&cx,&cy,&n);
	int S = 1,T = (n+1)<<1;
	st = S,ed = T;
	s[0].k = 2,s[0].x1 = 0,s[0].y1 = cy,s[0].x2 = cx,s[0].y2 = cy;
	s[n+1].k = 2,s[n+1].x1 = 0,s[n+1].y1 = 0,s[n+1].x2=cx,s[n+1].y2 = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&s[i].k);
		if(s[i].k==1)scanf("%d%d%d",&s[i].x,&s[i].y,&s[i].r);
		else scanf("%d%d%d%d",&s[i].x1,&s[i].y1,&s[i].x2,&s[i].y2);
		for(int j = 0;j<i;j++)
			if(check(i,j))
				add(j<<1|1,i<<1,INF,0),add(i<<1|1,j<<1,INF,0);
	}
	for(int i = 1;i<= n;i++)
		if(check(i,n+1))
			add(i<<1|1,(n+1)<<1,INF,0),add((n+1)<<1|1,i<<1,INF,0);
	for(int i = 1;i<= n;i++)add(i<<1,i<<1|1,1,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem3631

#include <stdio.h>
#include <algorithm>
using namespace std;
#define N 300005
struct M
{
    int next,to;    
}edge[N*2];
int head[N],tot,num[N],cnt[N],fa[N][20],dep[N],line[N];
void add(int x,int y)
{
    edge[++tot].to = y;
    edge[tot].next = head[x];
    head[x] = tot;
}
bool v[N];
void dfs(int x)
{
    v[x] = true;
    for(int i = head[x];i;i = edge[i].next)
    {
        if(!v[edge[i].to])
        {
            fa[edge[i].to][0] = x;
            dep[edge[i].to] = dep[x]+1;
            dfs(edge[i].to);
        }
    }    
    return ;
}
void work(int n)
{
    for(int j = 1;j<= 18;j++)
        for(int i = 1;i<= n;i++)
            fa[i][j] = fa[fa[i][j-1]][j-1];
    return ;
}
int lca(int x,int y)
{
    int re;
    if(dep[x]<dep[y])swap(x,y);
    for(int j = 18;j>= 0;j--)
    {
        if(dep[fa[x][j]]>=dep[y])
            x = fa[x][j];
    }
    if(x==y)return x;
    for(int j = 18;j>= 0;j--)
    {
        if(fa[x][j]!=fa[y][j])
            x = fa[x][j],y = fa[y][j];
        else re = fa[x][j];
    }
    return re;
}
bool cha[N];
void dfs2(int x)  
{   
    for (int i=head[x];i;i=edge[i].next)       
        if (edge[i].to!=fa[x][0])          
        {           
            dfs2(edge[i].to);              
			cnt[x] = cnt[x]+cnt[edge[i].to];  
        }
    return ;  
}  
int main()
{
    int n,x,y,z;
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&num[i]);
    }
    for(int i = 1;i<n;i++)
    {
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    fa[1][0] = 1;
    dfs(1);
    work(n);
    for(int i = 1;i<n;i++)
    {
        x = num[i],y = num[i+1];
        int tmp = lca(x,y);
        cnt[x]++;cnt[y]++;
        cnt[tmp]--;
		if(tmp!=1)cnt[fa[tmp][0]]--;
    }
    dfs2(1);
   	for(int i = 2;i<= n;i++)cnt[num[i]]--;
    for(int i = 1;i<= n;i++)
    {
        printf("%d\n",cnt[i]);
    }
    return 0;
}
Problem3631

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int fa[300005],top[300005],son[300005],size[300005],w[300005],deep[300005],id[300005];
struct E
{int next,to;}e[600005];
int head[300005],tot,n;
bool v[300005];
int me = (300000<<1)+1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs1(int x,int dep)
{
	v[x] = true;
	size[x]++;
	deep[x] = dep;
	for(int i = head[x];i;i = e[i].next)
	{
		int t = e[i].to;
		if(!v[t])
		{
			dfs1(t,dep+1);
			size[x]+=size[t];
			if(size[t]>size[son[x]])son[x] = t;
			fa[t] = x;
		}
	}
}
int cnt;
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	id[cnt] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int num[300005],ans[300005];
int f[300005<<2];
void push_down(int p)
{
	f[p<<1]+=f[p];
	f[(p<<1)+1]+=f[p];
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b){f[p]++;return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)
		update(p<<1,l,mid,a,b);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b);
	return ;
}
void getans(int p,int l,int r)
{
	if(l==r){ans[id[l]] = f[p];return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	getans(p<<1,l,mid);
	getans((p<<1)+1,mid+1,r);
}
void get_cut(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		update(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	update(1,1,n,w[y],w[x]);
}
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<n;i++)
		get_cut(num[i],num[i+1]);
	getans(1,1,n);
	for(int i = 1;i<= n;i++)
	{
		if(num[1]!=i)printf("%d\n",ans[i]-1);
		else printf("%d\n",ans[i]);
	}
	return 0;
}
Problem3653

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int M = 1e7+5;
typedef long long ll;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int dfn[N],Dfn,dep[N],size[N],end[N],R,root[N];
struct P
{
	int dep,size,dfn;
	P(){}
	P(int dep,int size,int dfn):dep(dep),size(size),dfn(dfn){}
	bool operator <(const P &s)const
	{
		return dfn<s.dfn;
	}
}p[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa)
{
	dep[x]=dep[fa]+1;
	R = max(R,dep[x]);
	size[x]=1;
	dfn[x]=++Dfn;
	for(int i =head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			size[x]+=size[e[i].to];
		}
	end[x] = Dfn;
}
int ls[M],rs[M];
ll sum[M];
void update(int &p,int pre,int l,int r,int pos,int v)
{
	p = ++tot;
	sum[p] = sum[pre];
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(l==r)
	{
		sum[p]+=v;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,v);
	else update(rs[p],rs[pre],mid+1,r,pos,v);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
ll getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	ll ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs(1,0);
	for(int i = 1;i<= n;i++)
		p[i] = P(dep[i],size[i],dfn[i]);
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],1,R,p[i].dep,p[i].size-1);
	int p,k;
	while(q--)
	{
		scanf("%d%d",&p,&k);
		ll ans = getans(root[end[p]],1,R,dep[p]+1,min(dep[p]+k,R));
		ans = ans-getans(root[dfn[p]-1],1,R,dep[p]+1,min(dep[p]+k,R));
		ans+=(ll)(size[p]-1)*min(k,dep[p]-1);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem3669

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 1e5+5;
struct E
{
	int x,y,a,b;
	bool operator <(const E &s)const
	{
		return a<s.a;
	}
}e[M];
int Fa[N];
int getfa(int x)
{
	if(Fa[x]==x||!Fa[x])return Fa[x]=x;
	else   return Fa[x] = getfa(Fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	Fa[x] = y;
}
int ch[N+M][2],fa[N+M],size[N+M],val[N+M],mx[N+M];
bool rev[N+M];
inline bool is_root(int p)
{
	return ch[fa[p]][0]!=p&&ch[fa[p]][1]!=p;
}
inline void init(int p,int v)
{
	ch[p][0]=ch[p][1]=fa[p]=0;
	val[p]=v,mx[p] = p;
}
inline void reverse(int p)
{
	rev[p]^=1;
	swap(ch[p][0],ch[p][1]);
}
inline void Push_down(int p)
{
	if(!is_root(p))Push_down(fa[p]);
	if(rev[p])
	{
		if(ch[p][0])reverse(ch[p][0]);
		if(ch[p][1])reverse(ch[p][1]);
		rev[p] = false;
	}
}
inline void Push_up(int p)
{
	size[p] = size[ch[p][0]]+1+size[ch[p][1]];
	int ls = mx[ch[p][0]],rs = mx[ch[p][1]];
	if(val[ls]>=val[p]&&val[ls]>=val[rs])mx[p] = ls;
	else if(val[rs]>=val[p]&&val[rs]>=val[ls])mx[p] = rs;
	else mx[p] = p;
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		else if(ch[z][1]==y)ch[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y),Push_up(x);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[z][0]==y)^(ch[y][0]==x))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;
	ch[y][0] = 0;
	Push_up(y);
}
int getans(int x,int y)
{
	move_to_root(x);
	access(y);splay(y);
	return mx[y];
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].a,&e[i].b);
	sort(e+1,e+m+1);
	for(int i = 1;i<= m;i++)val[i+n] = e[i].b;
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= m;i++)
	{
		x = e[i].x,y = e[i].y;
		int fx = getfa(x),fy = getfa(y);
		if(fx!=fy)
		{
			link(x,i+n);link(i+n,y);
			merge(fx,fy);
		}else
		{
			int k = getans(x,y);
			if(val[k]>e[i].b)
			{
				cut(e[k-n].x,k);
				cut(k,e[k-n].y);
				link(x,i+n);link(i+n,y);
			}
		}
		if(getfa(1)==getfa(n))
			ans = min(ans,e[i].a+val[getans(1,n)]);
	}
	if(ans!=0x3f3f3f3f)printf("%d\n",ans);
	else puts("-1");
	return 0;
}
Problem3670

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
const int mod = 1e9+7;
char s[N];
int nxt[N],dep[N],len;
void getnxt()
{
	int i = 0,j = -1;
	nxt[i] = j;
	dep[i] = 0;
	while(i<len)
	{
		if(j==-1||s[i]==s[j])
		{
			i++,j++;
			dep[i] = dep[j]+1;
			nxt[i] = j;
		}else j = nxt[j];
	}
}
void getans()
{
	int i = 0,j = -1;
	ll ans = 1;
	while(i<len)
	{
		if(j==-1||s[i]==s[j])
		{
			i++,j++;
			while(j!=-1&&(j<<1)>i)
				j = nxt[j];
			if(j!=-1&&i!=-1)
				ans = ans*(dep[j]+1)%mod;
		}else
			j = nxt[j];
	}
	printf("%lld\n",ans);
}	
int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%s",s);
		len = strlen(s);
		getnxt();
		getans();
	}
	return 0;
}
Problem3671

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5001;
typedef long long ll;
int X[N*N],mp[N][N];
bool us[N][N];
int l[N],r[N],ans[N<<1],top;
int main()
{
	int a,b,c,d,n,m,q;
	scanf("%d%d%d%d%d",&X[0],&a,&b,&c,&d);
	scanf("%d%d%d",&n,&m,&q);
	int end = n*m;
	for(int i = 1;i<= end;i++)
		X[i] = ((ll)a*X[i-1]%d*X[i-1]%d+(ll)b*X[i-1]%d+c)%d;
	for(int i = 1;i<= end;i++)
		mp[(i-1)/m+1][(i-1)%m+1] = i;
	for(int i = 1;i<= end;i++)
	{
		int j = X[i]%i+1;
		swap(mp[(i-1)/m+1][(i-1)%m+1],mp[(j-1)/m+1][(j-1)%m+1]);
	}
	for(int t = 1;t<= q;t++)
	{
		int i,j;
		scanf("%d%d",&i,&j);
		swap(mp[(i-1)/m+1][(i-1)%m+1],mp[(j-1)/m+1][(j-1)%m+1]);
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			X[mp[i][j]] = (i-1)*m+j;
	for(int i = 1;i<= n;i++)l[i]=1,r[i]=m;
	for(int i = 1;i<= end;i++)
	{
		if(us[(X[i]-1)/m+1][(X[i]-1)%m+1])continue;
		ans[++top] = i;
		if(top>=n+m-1)break;
		int x = (X[i]-1)/m+1,y = (X[i]-1)%m+1;
		for(int j = x+1;j<= n;j++)
			for(int k = l[j];k<y;k++)us[j][k]=true,l[j]++;
		for(int j = x-1;j>=1;j--)
			for(int k = r[j];k>y;k--)us[j][k]=true,r[j]--;
	}
	for(int i = 1;i< top;i++)
		printf("%d ",ans[i]);
	printf("%d\n",ans[top]);
	return 0;
}
Problem3672

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
typedef long long ll;
struct E
{int next,to;ll val;}e[N<<1];
int head[N],tot,fa[N];
ll dis[N];
void add(int x,int y,ll f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
void dfs(int x)
{
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa[x])
	{
		fa[e[i].to] = x;
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to);
	}
}
ll p[N],q[N],l[N];
int f[N],size[N],sum,root;
bool used[N];
void get_root(int x,int pre)
{
	f[x] = 0,size[x] = 1;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre&&!used[e[i].to])
	{
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int seq[N];
inline bool cmp(int x,int y){return dis[x]-l[x]>dis[y]-l[y];}
void Dfs(int x,int pre)
{
	seq[++tot] = x;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre&&!used[e[i].to])
		Dfs(e[i].to,x);
}
ll dp[N];
inline double slope(int x,int y)
{
	return (double)(dp[x]-dp[y])/(double)(dis[x]-dis[y]);
}
int stack[N],top;
double k[N];
void Insert(int x)
{
	while(top>1&&slope(x,stack[top])>slope(stack[top],stack[top-1]))
		top--;
	stack[++top] = x;
	k[top] = -slope(x,stack[top-1]);
}
void solve(int x)
{
	if(sum<=1)return ;
	root = 0;
	get_root(x,0);
	int now = root;
	for(int i = head[fa[now]];i;i=e[i].next)
		if(e[i].to==now&&!used[e[i].to])
		{
			used[now] = true;
			sum = size[x]-size[now];
			solve(x);
			break;
		}
	for(int i = fa[now];i!=fa[x];i=fa[i])
		if(dis[now]-dis[i]<=l[now])
			dp[now]=min(dp[now],dp[i]+(dis[now]-dis[i])*p[now]+q[now]);
	tot = 0;
	for(int i = head[now];i;i=e[i].next)
		if(e[i].to!=fa[now]&&!used[e[i].to])
			Dfs(e[i].to,now);
	sort(seq+1,seq+tot+1,cmp);
	top = 0;
	for(int i = 1,j = now;i<= tot;i++)
	{
		for(;j!=fa[x]&&dis[j]>=dis[seq[i]]-l[seq[i]];j=fa[j])
			Insert(j);
		if(top==1)
		{	
			if(dis[seq[i]]-dis[stack[top]]<=l[seq[i]])
				dp[seq[i]] = min(dp[seq[i]],dp[stack[top]]+
								(dis[seq[i]]-dis[stack[top]])*p[seq[i]]+q[seq[i]]);
		}else
		{
			int ot=min(top,upper_bound(k+2,k+top+1,-p[seq[i]])-k-1);
			if(dis[seq[i]]-dis[stack[ot]]<=l[seq[i]])
			dp[seq[i]] = min(dp[seq[i]],dp[stack[ot]]+
							(dis[seq[i]]-dis[stack[ot]])*p[seq[i]]+q[seq[i]]);
		}
	}
	for(int i = head[now];i;i=e[i].next)
		if(e[i].to!=fa[now]&&!used[e[i].to])
		{
			used[e[i].to] = true;
			sum = size[e[i].to];
			solve(e[i].to);
		}
}
int main()
{
	int n,t,a;ll b;
	scanf("%d%d",&n,&t);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%lld",&a,&b);
		add(i,a,b);
		scanf("%lld%lld%lld",&p[i],&q[i],&l[i]);
	}
	dfs(1);
	for(int i = 2;i<= n;i++)dp[i]=1ll<<60;
	sum = f[root=0] = n;
	used[1] = true;
	solve(1);
	for(int i = 2;i<= n;i++)printf("%lld\n",dp[i]);
	return 0; 
}
Problem3685

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int sum[N<<2],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
void update(int p,int l,int r,int x,int c)
{
	if(l==r)
		{sum[p]+=c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,c);
	else update(p<<1|1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int getans(int p,int l,int r,int no,int s)
{
	if(l==r)return l;
	int mid = (l+r)>>1;
	if(s+sum[p<<1]<no)
		return getans(p<<1|1,mid+1,r,no,s+sum[p<<1]);
	else return getans(p<<1,l,mid,no,s);
}
int check(int p,int l,int r,int a,int b)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ret = 0;
	if(a<=mid)ret+=check(p<<1,l,mid,a,b);
	if(b>mid)ret+=check(p<<1|1,mid+1,r,a,b);
	return ret;
}
void work(int opt)
{
	int x;
	if(opt<=2||opt>=5)x = read();
	x++;
	if(opt==1){if(check(1,1,n,x,x)==0)update(1,1,n,x,1);}
	else if(opt==2){if(check(1,1,n,x,x)==1)update(1,1,n,x,-1);}
	else if(opt==3){if(sum[1]==0)printf("-1\n");else printf("%d\n",getans(1,1,n,1,0)-1);}
	else if(opt==4){if(sum[1]==0)printf("-1\n");else printf("%d\n",getans(1,1,n,sum[1],0)-1);}
	else if(opt==5)
		{	
			int tmp = check(1,1,n,1,x-1);
			if(tmp==0)printf("-1\n");
			else printf("%d\n",getans(1,1,n,tmp,0)-1);
		}
	else if(opt==6)
		{
			int tmp = check(1,1,n,x+1,n);
			if(tmp==0)printf("-1\n");
			else printf("%d\n",getans(1,1,n,sum[1]-tmp+1,0)-1);
		}
	else{if(check(1,1,n,x,x)==1)printf("1\n");else printf("-1\n");}
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		x = read();
		work(x);
	}
	return 0;
}
Problem3688

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int MOD = 100007;
const int TOP = 100000;
struct Tree_s
{
	int c[TOP+5];
	void update(int x,int y)
	{
		for(int i = x;i<TOP;i+=i&(-i))
			(c[i] +=y)%=MOD;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			(ans+=c[i])%=MOD;
		return ans;
	}

}g[2][15],f[2][15];
int G[N][15],F[N][15];
struct P
{int x,y;}pos[N];
bool cmp(P a,P b)
{
	return a.x<b.x;
}
int main()
{	
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&pos[i].x,&pos[i].y);
	sort(pos+1,pos+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		F[i][0] = 1;
		G[i][0] = 1;
		f[0][0].update(pos[i].y,F[i][0]),f[1][0].update(TOP-pos[i].y,F[i][0]);
		g[0][0].update(pos[i].y,G[i][0]),g[1][0].update(TOP-pos[i].y,G[i][0]);
		for(int j = 1;j<= k;j++)
		{
			F[i][j] = (F[i][j]+g[0][j-1].getans(pos[i].y-1)+f[0][j].getans(pos[i].y-1))%MOD;
			G[i][j] = (G[i][j]+g[1][j].getans(TOP-pos[i].y-1)+f[1][j-1].getans(TOP-pos[i].y-1))%MOD;
			f[0][j].update(pos[i].y,F[i][j]),f[1][j].update(TOP-pos[i].y,F[i][j]);
			g[0][j].update(pos[i].y,G[i][j]),g[1][j].update(TOP-pos[i].y,G[i][j]);
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		ans = (ans+F[i][k]+G[i][k])%MOD;
	printf("%d\n",ans);
	return 0;
}
Problem3694

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 100005;
const int N = 4005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,dis[N],dep[N],top[N],son[N],size[N],w[N],fa[N],cnt,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	e[tot].val = f;
	head[y] = tot;
}
struct S
{int u,v,val;}b[M<<1];
int snum;
void add_s(int x,int y,int f)
{
	b[++snum].u = x;
	b[snum].v = y;
	b[snum].val = f;
}
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x]++;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=f)
		{
			dis[e[i].to] = dis[x]+e[i].val;
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
void dfs2(int x,int tp)
{
	w[x] = ++cnt;
	top[x] = tp;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int minn[N<<2],lazy[N<<2];
void push_down(int l,int r,int p)
{
	if(l==r||lazy[p]==INF)return ;
	minn[p<<1] = min(minn[p<<1],lazy[p]);
	minn[p<<1|1] = min(minn[p<<1|1],lazy[p]);
	lazy[p<<1] = min(lazy[p<<1],lazy[p]);
	lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
	lazy[p] = INF;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(l,r,p);
	if(l>=a&&r<=b)
	{
		minn[p] = min(minn[p],c);
		lazy[p] = min(lazy[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid) update(p<<1|1,mid+1,r,a,b,c);
	minn[p] = min(minn[p<<1],minn[p<<1|1]);
}
int getans(int p,int l,int r,int x)
{
	push_down(l,r,p);
	if(l==r)
		return minn[p];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int get_cut(int x,int y,int c,int opt)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		if(opt)update(1,1,n,w[top[x]],w[x],c);
		x = fa[top[x]];
	}
	if(x==y)return x;
	if(dep[x]<dep[y])swap(x,y);
	if(opt)update(1,1,n,w[y]+1,w[x],c);
	return y;
}
int main()
{
	int a,d,l,t;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a,&d,&l,&t);
		if(t)add(a,d,l);
		else add_s(a,d,l);
	}
	dfs1(1,0);
	dfs2(1,1);
	memset(minn,0x3f,sizeof(minn));
	memset(lazy,0x3f,sizeof(lazy));
	for(int i = 1;i<= snum;i++)
	{
		int lca = get_cut(b[i].u,b[i].v,0,0);
		int tmp = dis[b[i].u]+b[i].val+dis[b[i].v];
		get_cut(b[i].v,lca,tmp,1);
		get_cut(b[i].u,lca,tmp,1);
	}
	for(int i = 2;i<=n;i++)
	{
		int tmp = getans(1,1,n,w[i]);
		if(tmp==INF)printf("-1 ");
		else printf("%d ",tmp-dis[i]);
	}
	return 0;
}
Problem3697

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int sum,root,f[N],size[N],n;
bool used[N];
void get_root(int x,int fa)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] =max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int G[N<<1][2],F[N<<1][2],t[N<<1];
int maxdep;
void get_sum(int x,int fa,int num,int dep)
{
	maxdep = max(maxdep,dep);
	if(t[num])G[num][1]++;
	else G[num][0]++;
	t[num]++;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			get_sum(e[i].to,x,num+e[i].val,dep+1);
	t[num]--;
}
LL ans;
void calc(int x)
{
	F[n][0] = 1;
	int mx = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			maxdep = 0;
			get_sum(e[i].to,x,n+e[i].val,1);
			mx = max(mx,maxdep);
			ans+=(F[n][0]-1)*G[n][0];
			for(int j = -maxdep;j<= maxdep;j++)
			{
				ans+=(LL)F[n-j][0]*G[n+j][1];
				ans+=(LL)F[n-j][1]*G[n+j][0];
				ans+=(LL)F[n-j][1]*G[n+j][1];
			}
			for(int j = n-maxdep;j<= n+maxdep;j++)
				{F[j][0]+=G[j][0],F[j][1]+=G[j][1];G[j][0] = G[j][1] = 0;}
		}
	for(int i = n-mx;i<= n+mx;i++)
		F[i][0] = F[i][1] = 0;
}
void work(int x)
{
	calc(x);
	used[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(used[e[i].to])continue;
		sum = size[e[i].to];
		root = 0;
		get_root(e[i].to,0);
		work(root);
	}
}
int main()
{
	int x,y,z;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(!z)z = -1;
		add(x,y,z),add(y,x,z);
	}
	f[0] = 0x3f3f3f3f;
	root = 0;sum = n;
	get_root(1,0);
	work(1);
	printf("%lld\n",ans);
	return 0;
}
Problem3702

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL cnt1,cnt2;
const int N = 200005;
int root[N<<1],L[N<<1],R[N<<1],ls[4000005],rs[4000005],sum[4000005],cv[N<<1],tot,seg,n;
void scantree(int x)
{
	scanf("%d",&cv[x]);
	if(!cv[x])
	{
		L[x]=++tot;
		scantree(L[x]);
		R[x]=++tot;
		scantree(R[x]);
	}
}
void build(int &p,int l,int r,int c)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		sum[p] = 1;
		return ;
	}
	int mid = (l+r)>>1;
	if(c<=mid)build(ls[p],l,mid,c);
	else build(rs[p],mid+1,r,c);
	sum[p] = sum[rs[p]]+sum[ls[p]];
}
int merge(int x,int y)
{
	if(!x)return y;
	if(!y)return x;
	cnt1+=(LL)sum[ls[x]]*sum[rs[y]];
	cnt2+=(LL)sum[rs[x]]*sum[ls[y]];
	ls[x] = merge(ls[x],ls[y]);
	rs[x] = merge(rs[x],rs[y]);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
LL ans;
void solve(int x)
{
	if(!x)return ;
	solve(L[x]);solve(R[x]);
	if(!cv[x])
	{
		cnt1 = cnt2 = 0;
		root[x] = merge(root[L[x]],root[R[x]]);
		ans+=min(cnt1,cnt2);
	}
}
int main()
{
	scanf("%d",&n);
	tot++;
	scantree(1);
	for(int i = 1;i<= tot;i++)
		if(cv[i])build(root[i],1,n,cv[i]);
	solve(1);
	printf("%lld\n",ans);
	return 0;
}
Problem3709

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct Data{int x,y,id;}a[N],b[N];
bool cmp1(const Data &m,const Data &n)
{
	return m.x<n.x;
}
bool cmp2(const Data &m,const Data &n)
{
	return m.y>n.y;
}
int main()
{
	int cnt1,cnt2;
	cnt1 = cnt2 = 0;
	int n,x,y;
	long long z;
	scanf("%d%lld",&n,&z);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		if(y>=x){a[++cnt1].x = x,a[cnt1].y = y,a[cnt1].id = i;}
		else{b[++cnt2].x = x,b[cnt2].y = y,b[cnt2].id = i;}
	}
	sort(a+1,a+cnt1+1,cmp1);
	sort(b+1,b+cnt2+1,cmp2);
	for(int i = 1;i<= cnt1;i++)
	{
		if(z-a[i].x<=0){printf("NIE\n");return 0;}
		z+=a[i].y-a[i].x;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		if(z-b[i].x<=0){printf("NIE\n");return 0;}
		z+=b[i].y-b[i].x;
	}
	printf("TAK\n");
	for(int i = 1;i<= cnt1;i++)
		printf("%d ",a[i].id);
	for(int i = 1;i<= cnt2;i++)
		printf("%d ",b[i].id);
	return 0;
}
Problem3711

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define P 1000000007
#define GET (ch>='0'&&ch<='9')
#define MAXN 1000005
#define lchild rt<<1,l,mid
#define rchild rt<<1|1,mid+1,r
#define ln rt<<1
#define rn rt<<1|1
#define MAXINT 1000000
using namespace std;
int n;
int c[MAXN],d[MAXN],g[MAXN];
struct node
{
	int x,y;
	node()  {   x=y=0;  }
	node(int tx,int ty) {   x=tx;y=ty;  }
	inline node operator + (const node& b)
	{
		if (x<b.x)  return  b;
		if (x>b.x)  return  (node){x,y};
		return (node){x,(y+b.y)%P};
	}
	inline node operator + (int tx) {   return (node){x+tx,y};  }
	inline void operator +=(const node& b)  {   *this=*this+b;  }
}f[MAXN];
struct seg
{
	int l,r;
	int pos,vald;
	node f,flag;
}tree[(MAXN<<1)+(int)(1e5)];
inline void build1(int rt=1,int l=0,int r=n)
{
	tree[rt].l=l;tree[rt].r=r;
	if (l==r)   {   tree[rt].pos=l;tree[rt].vald=d[l];return;   }
	int mid=(l+r)>>1;build1(lchild);build1(rchild);
	tree[rt].pos=c[tree[ln].pos]>c[tree[rn].pos]?tree[ln].pos:tree[rn].pos;
	tree[rt].vald=min(tree[ln].vald,tree[rn].vald);
}
inline void build2(int rt=1,int l=0,int r=n)
{
	tree[rt].flag=(node){-MAXINT,0};
	if (l==r)   {   tree[rt].vald=d[l];tree[rt].f=f[l];return;  }
	int mid=(l+r)>>1;build2(lchild);build2(rchild);
	tree[rt].f=tree[ln].f+tree[rn].f;
	tree[rt].vald=min(tree[ln].vald,tree[rn].vald);
}
inline void modify_add(int rt,int l,int r,node delta)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&R<=r) {   tree[rt].flag+=delta;return;    }
	if (r<=mid) modify_add(ln,l,r,delta);
	else    if (l>mid)  modify_add(rn,l,r,delta);
	else    modify_add(ln,l,mid,delta),modify_add(rn,mid+1,r,delta);
}
inline int query_c(int rt,int l,int r)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].pos;
	if (r<=mid) return query_c(ln,l,r);
	if (l>mid)  return query_c(rn,l,r);
	int t1=query_c(ln,l,mid),t2=query_c(rn,mid+1,r);    
	return c[t1]>c[t2]?t1:t2;
}
inline int query_d(int rt,int l,int r)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].vald;
	if (r<=mid) return query_d(ln,l,r);
	if (l>mid)  return query_d(rn,l,r);
	return min(query_d(ln,l,mid),query_d(rn,mid+1,r));
}
inline node query_f(int rt,int l,int r)
{
	if (l>r)    return node(-MAXINT,0);
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].f;
	if (r<=mid) return query_f(ln,l,r);
	if (l>mid)  return query_f(rn,l,r);
	return query_f(ln,l,mid)+query_f(rn,mid+1,r);
}
inline void modify_cov(int rt,int x,node delta)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (L==R)   {   tree[rt].f=delta;return;    }
	if (x<=mid) modify_cov(ln,x,delta); else    modify_cov(rn,x,delta);
	tree[rt].f=tree[ln].f+tree[rn].f;
}
node ask(int x)
{
	int rt=1,L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	node t=node(-MAXINT,0);
	while (L!=R)
	{
		t+=tree[rt].flag;
		mid=(L+R)>>1;rt<<=1;
		if (x>mid)  rt|=1;
		L=tree[rt].l,R=tree[rt].r;
	}
	t+=tree[rt].flag;
	return t;
}
inline void update(int l,int mid,int r)
{
	int i=max(c[mid]+l,mid);
	if (i>r||g[i]>=mid) return;
	int newl=max(l,g[i]),newr=i-c[mid];
	node tmp=query_f(1,newl,newr)+1;
	for (;i<=mid-1+c[mid]&&i<=r;i++)
	{
		if (g[i]>newl)
		{
			if (g[i]>=mid)  return;
			newl=g[i];tmp=query_f(1,newl,newr)+1;
		}
		f[i]+=tmp;newr++;
		if (newr>=newl) tmp+=f[newr]+1;
	}
	while (i<=r)
	{
		if (g[i]>newl)
		{
			if (g[i]>=mid)  return;
			newl=g[i];
		}
		tmp=query_f(1,newl,mid-1)+1;
		int t=query_d(1,newl+1,n);
		if (t>r)    {   modify_add(1,i,r,tmp);return;   }
		modify_add(1,i,t-1,tmp);i=t;
	}
}
void solve(int l,int r)
{
	if (l==r)
	{
		if (l)  modify_cov(1,l,f[l]=f[l]+ask(l));
		return;
	}
	int mid=query_c(1,l+1,r);
	solve(l,mid-1);update(l,mid,r);solve(mid,r);
}
int main()
{
	scanf("%d",&n);
	int i=0,j=0;
	for (i=1;i<=n;i++)scanf("%d%d",&c[i],&d[i]);	
	build1();
	for (i=0;i<=n;i++)  d[i]=n+1,f[i]=node(-MAXINT,0);
	f[0]=node(0,1);
	for (i=0;i<=n;i++)
	{
		while (j<i&&i-j>query_d(1,j+1,i))   j++;
		g[i]=j;
		if (d[g[i]]>n)  d[g[i]]=i;
	}
	build2();solve(0,n);
	printf(f[n].x>0?"%d %d\n":"NIE\n",f[n].x,f[n].y);
}
Problem3712

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e5+5;
const int K = 5e5+5;
int no[N],g[N],dep[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,fa[N][20],dfn[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	fa[y][0] = x;
}
struct Opt
{int x,y,dp,no;}opt[K];
bool cmp(const Opt &a,const Opt &b)
{
	if(a.dp==b.dp)return a.no<b.no;
	else return a.dp>b.dp;
}
void dfs(int x,int id)
{
	dfn[x] = id;
	for(int j = 1;j<= 19;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
	for(int i = head[x];i;i=e[i].next)
		dep[e[i].to] = dep[x]+1,
		dfs(e[i].to,id);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 19;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 19;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&g[i]),no[i]=i;
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(n+i,no[x]),add(n+i,no[y]);
		no[y] = n+i;
	}
	int tot = 0;
	for(int i = 1;i<= n+m;i++)if(!fa[i][0])dfs(i,++tot);
	int ask = 0;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		if(dfn[x]==dfn[y])opt[++ask] = (Opt){x,y,dep[getlca(x,y)],i};
	}
	sort(opt+1,opt+ask+1,cmp);
	long long ans = 0;
	for(int i = 1;i<= ask;i++)
	{
		int gd = min(g[opt[i].x],g[opt[i].y]);
		g[opt[i].x]-=gd,g[opt[i].y]-=gd;
		ans+=2*gd;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3714

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 4e6+5;
struct E
{int x,y,val;}e[M];
bool cmp(const E &a,const E &b)
{
	return a.val<b.val;
}
int fa[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,tot = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)
		{
			scanf("%d",&x);
			e[++tot].x = i-1,e[tot].y = j,e[tot].val = x;
		}
	for(int i = 0;i<=n;i++)fa[i] = i;
	sort(e+1,e+tot+1,cmp);
	long long ans = 0;
	for(int i = 1;i<= tot;i++)
	{
		int tx = e[i].x,ty = e[i].y;
		tx = getfa(tx),ty = getfa(ty);
		if(tx==ty)continue;
		ans+=e[i].val;
		uni(tx,ty);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3716

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 200005;
int n,m;
ll w,h,x,y,v,ans;
struct data
{
	ll x,y,v;
	bool operator<(const data &s)const
	{
		if(x==s.x)return y<s.y;
		return x<s.x;
	}
}p[N<<1];
struct Data
{
	ll y,v;
	bool operator<(const Data &s)const
	{
		return y<=s.y;
	}
};
set<Data>s;
set<Data>::iterator it;
int main()
{
	scanf("%d%d%lld%lld",&n,&m,&w,&h);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&v);
		x = x*h,y = y*w;
		p[i].x = x+y,p[i].y = y-x,p[i].v=v;
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&v);
		x = x*h,y = y*w;
		p[n+i].x = x+y,p[n+i].y = y-x,p[n+i].v=-v;
	}
	sort(p+1,p+m+n+1);
	for(int i = 1;i<= n+m;i++)
		for(y=p[i].y,v=p[i].v;v;ans-=it->v,v+=it->v,s.erase(it))
		{
			it = s.lower_bound((Data){y,0});
			if(it==s.end()||it->y!=y)
			{
				if(v>0){s.insert((Data){y,v});ans+=v;break;}
				else if(it==s.begin())break;
				else y = (--it)->y;
			}
		}
	printf("%lld\n",ans);
	return 0;
}
Problem3717

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = (1<<24)+5;
int f[N],g[N];
int a[N],c[105];
bool cmp(const int &a,const int &b)
{
	return a>b;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&c[i]);
	for(int i = n;i;i--)a[1<<(i-1)]=a[i];
	sort(c+1,c+m+1,cmp);
	int end = (1<<n),tmp,x;
	for(int i = 1;i<end;i++)
	{
		f[i] = m+1,g[i] = -1;
		for(int j = i;j;j-=tmp)
		{
			tmp = j&(-j),x = i-tmp;
			if(a[tmp]<=g[x]&&(f[x]<f[i]||(f[x]==f[i]&&g[x]-a[tmp]>g[i])))f[i]=f[x],g[i]=g[x]-a[tmp];
			else if((f[x]+1<f[i]||(f[x]+1==f[i]&&c[f[x]+1]-a[tmp]>g[i]))&&c[f[x]+1]>=a[tmp])f[i]=f[x]+1,g[i]=c[f[x]+1]-a[tmp];
		}
	}
	if(f[end-1]>m)printf("NIE\n");
	else printf("%d\n",f[end-1]);
	return 0;
}
Problem3718

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct C
{int a,b,c;}car[N];
int id[N];
bool cmp(const C &x,const C &y)
{
	return x.a>y.a;
}
int getid(int x,int tot)
{
	int l = 1,r = tot+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l=mid+1;
		else r = mid;
	}
	return l;
}
int c[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = max(c[i],y);
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans = max(ans,c[i]);
	return ans;
}
void work()
{
	memset(c,0,sizeof(c));
	int x1,x2,y1,y2;
	int n,w;
	scanf("%d%d",&n,&w);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		car[i].a = min(x1,x2);
		car[i].c = abs(y2-y1);
	}
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		car[i].b = min(x1,x2);id[i] = car[i].b;
	}
	sort(id+1,id+n+1);
	int tot = 0;
	id[0]=-1;
	for(int i = 1;i<= n;i++)
		if(id[tot]!=id[i])
			id[++tot] = id[i];
	sort(car+1,car+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		int pos = getid(car[i].b,tot);
		int maxn = getans(pos-1);
		if(w-maxn<car[i].c){printf("NIE\n");return ;}
		update(pos,car[i].c);
	}
	printf("TAK\n");
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)work();
	return 0;
}
Problem3719

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int S = 1e6+5;
const int size = 1e6;
struct data
{
	int x1,y1,x2,y2;
	bool operator <(const data &s)const
	{
		if(x1==s.x1)
		{
			if(x2==s.x2)
			{
				if(y1==s.y1)return y1<s.y1;
				else return y2<s.y2;
			}else return x2<s.x2;
		}else return x1<s.x1;
	}
}s[N],Ans[N];
int fa[N],st[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void merge(int a,int b)
{
	int x = getfa(a),y = getfa(b);
	if(x==y)return ;
	s[a].x1 = min(s[a].x1,s[b].x1),s[a].x2 = max(s[a].x2,s[b].x2);
	s[a].y1 = min(s[a].y1,s[b].y1),s[a].y2 = max(s[a].y2,s[b].y2);
	fa[y] = a;
}
struct node{ vector<int>q1,q2;}tr[S<<2];
bool cmp(int a,int b)
{
	return s[a].y2==s[b].y2?a<b:s[a].y2<s[b].y2;
}
int sta[S],top;
void Insert(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b){sta[++top]=p;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Insert(p<<1,l,mid,a,b);
	if(b >mid)Insert(p<<1|1,mid+1,r,a,b);
}
void update(int rt,int x)
{
	for(;rt;rt>>=1)tr[rt].q1.push_back(x);
}
int find_rt(int p,int l,int r,int x)
{
	if(l==r)return p;
	int mid = (l+r)>>1;
	if(x<=mid)return find_rt(p<<1,l,mid,x);
	else return find_rt(p<<1|1,mid+1,r,x);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&s[i].x1,&s[i].x2,&s[i].y1,&s[i].y2);
		s[i].x1++,s[i].y1++;fa[i]=st[i]=i;
	}
	sort(st+1,st+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		bool flag = true;
		while(flag)
		{
			top = 0;flag = false;
			Insert(1,1,size,s[st[i]].x1,s[st[i]].x2);
			for(int j = 1;j<= top;j++)
				for(int k = tr[sta[j]].q1.size()-1;k>=0;k--)
				{
					int y = tr[sta[j]].q1[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[sta[j]].q1.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[sta[j]].q1.pop_back();
				}
			for(int now = find_rt(1,1,size,s[st[i]].x1);now;now>>=1)
				for(int k = tr[now].q2.size()-1;k>=0;k--)
				{
					int y = tr[now].q2[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[now].q2.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[now].q2.pop_back();
				}
			for(int now = find_rt(1,1,size,s[st[i]].x2);now;now>>=1)
				for(int k = tr[now].q2.size()-1;k>=0;k--)
				{
					int y = tr[now].q2[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[now].q2.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[now].q2.pop_back();
				}
		}
		update(find_rt(1,1,size,s[st[i]].x1),st[i]);
		if(s[st[i]].x1!=s[st[i]].x2)
			update(find_rt(1,1,size,s[st[i]].x2),st[i]);
		top = 0;
		Insert(1,1,size,s[st[i]].x1,s[st[i]].x2);
		for(int j = 1;j<= top;j++)
			tr[sta[j]].q2.push_back(st[i]);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i)
		{
			Ans[++ans] = s[i];
			Ans[ans].x1--,Ans[ans].y1--;
		}
	printf("%d\n",ans);
	sort(Ans+1,Ans+ans+1);
	for(int i = 1;i<= ans;i++)
		printf("%d %d %d %d\n",Ans[i].x1,Ans[i].x2,Ans[i].y1,Ans[i].y2);
	return 0;
}
Problem3722

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int col[N],typ[N];
int dfs(int x,int fa)
{
	if(typ[x]<=0)return col[x];
	int sum = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			sum+=dfs(e[i].to,x);
	if(sum<0)return -1;
	else if(sum>0)return 1;
	return 0;
}
int ans[N],top;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&typ[i]);
		if(typ[i]==-2)col[i] = 1;
		else if(typ[i]==-1)col[i] = -1;
		else if(typ[i]>0)
		{
			int m = typ[i],x;
			while(m--)
				scanf("%d",&x),add(i,x);
		}
	}
	if(dfs(1,0)<0)printf("NIE\n");
	else
	{
		for(int i = 1;i<= n;i++)
			if(typ[i]==0)
			{
				col[i] = 1;
				if(dfs(1,0))ans[++top] = i;
				col[i] = 0;
			}
		printf("TAK %d\n",top);
		for(int i = 1;i<= top;i++)
		{
			printf("%d",ans[i]);
			if(i!=top)printf(" ");
		}
	}
	return 0;
}
Problem3725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
char s[N];
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	int last,now = 0,mn = n;
	for(int i = 1;i<= n;i++)
		if(s[i]!='*')
		{
			if(!last||last == s[i])last = s[i],now = i;
			else
			{
				mn = min(mn,i-now);
				last = s[i],now = i;
			}
		}
	printf("%d\n",n-mn+1);
	return 0;
}
Problem3726

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
char s[N];
int l0[N],r0[N],l1[N],r1[N],a[N],b[N],nxt[N],pre[N],G[N],NXT[N];
int L[N],R[N],ans;
void add(int x,int y){NXT[y]=G[x];G[x]=y;}
void del(int x){nxt[pre[x]]=nxt[x];pre[nxt[x]]=pre[x];}
int main()
{
	int n,m,i,j;
	scanf("%d%d",&n,&m);
	for(i = 1;i<= m;i++)l0[i]=l1[i]=1,r0[i]=r1[i]=m;
	for(int T = 1;T<= n;T++)
	{
		scanf("%s",s+1);
		for(i=j=1;i<=m;i++)
			if(s[i]=='.')
			{
				a[i]++,b[i]++;
				if(l0[i]<j)l0[i]=j;
				if(l1[i]<j)l1[i]=j;
			}else
			{
				b[i]=a[i]+1,a[i]=0;
				l1[i]=l0[i],l0[i]=1;
				if(l1[i]<j)l1[i]=j;
				j=i+1;
			}
		for(i=j=m;i>=1;i--)
			if(s[i]=='.')
			{
				if(r0[i]>j)r0[i]=j;
				if(r1[i]>j)r1[i]=j;
			}else
			{
				r1[i]=r0[i],r0[i]=m;
				if(r1[i]>j)r1[i]=j;
				j=i-1;
			}
		for(i = 0;i<= T;i++)G[i]=0;
		for(i = m;i;i--)add(a[i],i),pre[i]=i-1,nxt[i]=i+1;
		for(pre[1]=0,nxt[m]=m+1,i=T;~i;i--)
			for(j=G[i];j;j=NXT[j])
				L[j]=pre[pre[j]],del(j);
		for(i = 0;i<= T;i++)G[i]=0;
		for(i = 1;i<=m;i++)add(a[i],i),pre[i]=i-1,nxt[i]=i+1;
		for(pre[1]=0,nxt[m]=m+1,i=T;~i;i--)
			for(j=G[i];j;j=NXT[j])
				R[j]=nxt[nxt[j]],del(j);
		for(i = 1;i<=m;i++)
		{
			ans = max(ans,(r1[i]-l1[i]+1)*b[i]);
			if(!a[i])continue;
			j = l0[i];
			if(j>1&&b[j-1]>=a[i]){if(L[i])j=L[i]+1;else j--;}
			ans = max(ans,(r0[i]-j+1)*a[i]);
			j = r0[i];
			if(j<m&&b[j+1]>=a[i]){if(R[i])j=R[i]-1;else j++;}
			ans = max(ans,(j-l0[i]+1)*a[i]);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem3727

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 3e5+5;
int fa[N],dis[N];
struct EDGE
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct Fac
{
	LL c,a;
	void operator +=(const Fac &S)
		{c+=S.c;a+=S.a;}
	void operator -=(const Fac &S)
		{c-=S.c;a-=S.a;}
	void operator *=(int y)
		{c*=y,a*=y;}
}two_size[N],two_a[N];
void dfs(int x,int f)
{
	fa[x] = f;
	if(x!=1)dis[x] = dis[f]+1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
}
LL size[N],a[N],b[N];
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		scanf("%lld",&b[i]);
	dfs(1,0);
	for(int i = 2;i<= n;i++)
		two_size[i] = (Fac){b[fa[i]]-b[i],1};
	for(int i = 2;i<= n;i++)
	{
		two_a[i]+=two_size[i];
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to!=fa[i])
				two_a[i]-=two_size[e[j].to];
	}
	Fac b1;
	b1.c = 0,b1.a = 0;
	for(int i = 2;i<= n;i++)
	{
		Fac tmp = two_a[i];
		tmp*=dis[i];
		b1+=tmp;
	}
	size[1] = (b[1]*2-b1.c)/b1.a;
	for(int i = 2;i<= n;i++)
		size[i] = (two_size[i].c+size[1])/2;
	for(int i = 1;i<= n;i++)
	{
		a[i]+=size[i];
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to!=fa[i])
				a[i]-=size[e[j].to];
		printf("%lld",a[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem3728

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
bool cmp1(const int &a,const int &b){return a<b;}
bool cmp2(const int &a,const int &b){return b<a;}
int heap[N],ans[N],cnth,cnta;
int lamp[N],lst[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&lamp[i]);
	for(int i = 1;i<= n;i++)
		scanf("%d",&lst[i]);
	sort(lamp+1,lamp+n+1,cmp2);
	sort(lst+1,lst+n+1,cmp2);
	int j = 1;
	long long tans = 0;
	for(int i = 1;i<= n;i++)
	{
		while(j<=n&&lamp[j]>=lst[i])
		{
			heap[++cnth] = lamp[j];
			push_heap(heap+1,heap+cnth+1,cmp2);
			j++;
		}
		if(cnth<=0&&k>=1)k--,tans+=lst[i];
		else if(cnth<=0){printf("NIE\n");return 0;}
		else
		{
			tans+=heap[1];
			ans[++cnta] = heap[1]-lst[i];
			push_heap(ans+1,ans+cnta+1,cmp1);
			pop_heap(heap+1,heap+cnth+1,cmp2);
			cnth--;
		}
	}
	while(k&&cnta)
	{
		tans-=ans[1];
		pop_heap(ans+1,ans+cnta+1,cmp1);
		cnta--,k--;
	}
	printf("%lld\n",tans);
	return 0;
}
Problem3730

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e7;
int rot[N][2],cnt,n,m;
int ls[M],rs[M],sum[M],a[N];
void update(int &p,int l,int r,int pos,int val)
{
	if(!p)p = ++cnt;
	sum[p]+=val;
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],l,mid,pos,val);
	else update(rs[p],mid+1,r,pos,val);
	//sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	if(a>b)return 0;
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int pos[N],T,log_2[N<<1];
int min_dpt[N<<1][18],dpt[N];
void dfs(int x,int from)
{
	min_dpt[pos[x]=++T][0] = dpt[x];
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=from)
		{
			dpt[e[i].to] = dpt[x]+1;
			dfs(e[i].to,x);
			min_dpt[++T][0] = dpt[x];
		}
}
void build_lca()
{
	for(int i = 2;i<=T;i++)
		log_2[i] = log_2[i>>1]+1;
	for(int j = 1;j<= log_2[T];j++)
		for(int i = 1;i+(1<<j)-1<=T;i++)
			min_dpt[i][j] = min(min_dpt[i][j-1],min_dpt[i+(1<<(j-1))][j-1]);
}
int get_lcadpt(int x,int y)
{
	x = pos[x],y = pos[y];
	if(x>y)swap(x,y);
	int l = log_2[y-x+1];
	return min(min_dpt[x][l],min_dpt[y-(1<<l)+1][l]);
}
int getdis(int x,int y)
{
	return dpt[x]+dpt[y]-2*get_lcadpt(x,y);
}
bool used[N];
int size[N],f[N],Sum,father[N];
void get_size(int x,int pre)
{
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_size(e[i].to,x);
			size[x]+=size[e[i].to];
		}
}
int root;
void get_root(int x,int pre)
{
	size[x] = 1,f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],Sum-size[x]);
	if(f[x]<f[root])root = x;
}
int stack[N],top;
void DFS(int x,int pre)
{
	stack[++top] = x;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
			DFS(e[i].to,x);
}
void Build(int x,int pre)
{
	get_size(x,0);
	Sum = size[x];f[0] = Sum,root = 0;
	get_root(x,0);
	x = root;
	father[x] = pre;
	used[x] = true;
	top = 0;
	DFS(x,0);
	for(int i = 1;i<= top;i++)
	{
		int y = stack[i];
		update(rot[x][0],0,n,getdis(y,x),a[y]);
		update(rot[x][1],0,n,getdis(y,father[x]),a[y]);
	}
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
			Build(e[i].to,x);
}
void Update(int x,int del)
{
	for(int i = x;i;i=father[i])
	{
		update(rot[i][0],0,n,getdis(x,i),del);
		if(father[i])update(rot[i][1],0,n,getdis(x,father[i]),del);
	}
	a[x]+=del;
}
int Getans(int x,int k)
{
	int ans = 0;
	for(int i = x;i;i=father[i])
	{
		int Dis = getdis(i,x);
		if(Dis<=k)
			ans = ans+getans(rot[i][0],0,n,0,k-Dis);
		if(father[i])
		{
			int Dis2 = getdis(father[i],x);
			if(Dis2<=k)ans = ans-getans(rot[i][1],0,n,0,k-Dis2);
		}
	}
	return ans;
}
int main()
{
	//freopen("x.in","r",stdin);
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	int opt;
	dpt[1] = 1;
	dfs(1,0);
	build_lca();
	Build(1,0);
	int lastans = 0;
	while(m--)
	{
		scanf("%d%d%d",&opt,&x,&y);
		x = x^lastans,y = y^lastans;
		if(opt==0)
			printf("%d\n",lastans = Getans(x,y));
		else Update(x,y-a[x]);
	}
	return 0;
}
Problem3733

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e4+10;
typedef long long ll;
ll f[N][35];
int fac[N],n,m,k;
bool dfs(int now,int x,int pro)
{
	if(!x)return pro==n;
	x--;
	for(;now+x<=m;now++)
	{
		if(f[now][x]<0)return false;
		if((ll)pro*f[now][x]>n)return false;
		if(dfs(now+1,x,pro*fac[now]))return true;
	}
	return false;
}
int main()
{
	int test;
	scanf("%d",&test);
	while(test--)
	{
		m=0;
		scanf("%d%d",&n,&k);
		for(int i = 1;i*i<=n;i++)
			if(n%i==0)
			{
				fac[++m] = i;
				if(i*i!=n)fac[++m] = n/i;
			}
		sort(fac+1,fac+m+1);
		ll pro = 1;
		for(int i = 1;i<= m;i++)
		{
			pro = 1;
			for(int j = 0;j<k&&i+j<=m;f[i][j++]=pro)
			if(pro>0)
			{
				pro = pro*fac[i+j];
				if(pro>n)pro = -1;
			}
		}
		if(dfs(1,k,1))printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem3735

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	ll pos;int i;
	data(){}
	data(ll _pos,int _i):pos(_pos),i(_i){}
	bool operator <(const data &s)const
	{
		if(pos==s.pos)return i>s.i;
		return pos>s.pos;
	}
}heap[N];
int cnt,a[N];ll n,L,R,now;int k;
ll Ans[N];
bool check(ll mid)
{
	ll ans = n;
	for(int i = 1;i<= k;i++)
	{
		ans-=mid/a[i];
		if(ans<0)return false;
	}
	return true;
}
int main()
{
	scanf("%lld%d",&n,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&a[i]);
		R = max(R,1ll*a[i]);
	}
	L = R+1,R = R*n;
	ll ans = 0;
	while(L<=R)
	{
		ll mid = (L+R)>>1;
		if(check(mid))L=mid+1,ans=mid;
		else R = mid-1;
	}
	R = ans;
	for(int i = 1;i<= k;i++)R = min(R,max((ans/a[i]-1)*a[i],0ll));
	cnt = 0;
	for(int i = 1;i<= k;i++)
	{
		now+=R/a[i];
		heap[++cnt] = data(R/a[i]*a[i],i);
		push_heap(heap+1,heap+cnt+1);
	}
	while(now<n)
	{
		data tmp = heap[1];
		pop_heap(heap+1,heap+cnt+1);
		Ans[tmp.i] = ++now;
		tmp.pos+=a[tmp.i];
		heap[cnt] = tmp;
		push_heap(heap+1,heap+cnt+1);
	}
	for(int i = 1;i< k;i++)
		printf("%lld ",Ans[i]);
	printf("%lld\n",Ans[k]);
	return 0;
}
Problem3736

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2505;
int n,m,ml,mw,s,tmp[N][N],f[2][N],L[2][N],R[2][N],l[N],r[N];
int mxc[N],mxr[N];
char str[N];
bool a[N][N];
void solve(int mxc[])
{
	for(int j = 1;j<= m;j++)
		L[0][j] = 0,R[0][j] = m+1,f[0][j] = 0;
	for(int i = 1,cur = 1;i<= n;i++)
	{
		l[0] = 0,r[m+1] = m+1;
		for(int j = m;j;j--)
			if(a[i][j])r[j]=r[j+1];
			else r[j]=j;
		for(int j = 1;j<= m;j++)
			if(a[i][j])
			{
				l[j] = l[j-1];
				f[cur][j] = f[cur^1][j]+1;
				L[cur][j] = max(L[cur^1][j],l[j]);
				R[cur][j] = min(R[cur^1][j],r[j]);
				int r = f[cur][j],c = R[cur][j]-L[cur][j]-1;
				mxc[r] = min(mxc[r],c);
				if(!a[i+1][j])
				{
					for(int p = r+1;p<= n;p++)
						if(mxc[p])
							mxc[p]=0;
						else break;
				}
			}else
				l[j] = j,f[cur][j]=L[cur][j]=0,R[cur][j]=m+1;
		cur^=1;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",str+1);
		for(int j = 1;j<= m;j++)
			a[i][j]=str[j]=='X';
	}
	memset(mxc,0x3f,sizeof(mxc));
	memset(mxr,0x3f,sizeof(mxr));
	solve(mxc);
	for(int j = 1;j<= m;j++)
		for(int i = 1;i<= n>>1;i++)
			swap(a[i][j],a[n-i+1][j]);
	solve(mxc);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			tmp[j][i]=a[i][j],a[i][j]=false;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			a[i][j]=tmp[i][j];
	swap(n,m);
	solve(mxr);
	for(int j = 1;j<= m;j++)
		for(int i = 1;i<= n>>1;i++)
			swap(a[i][j],a[n-i+1][j]);
	solve(mxr);
	swap(n,m);
	mxr[0] = n+1;
	for(int i = n,j=1;j<= m;j++)
		for(;i>mxr[j];i--)
			mxc[i] = min(mxc[i],j-1);
	for(int i = 1;i<=n;i++)
		if(i*mxc[i]>s)
			s=i*mxc[i],ml=i,mw=mxc[i];
	printf("%d %d\n",ml,mw);
	return 0;
}
Problem3737

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <algorithm>
using namespace std;
typedef long long LL;
#define rep(i,j,n) for(int i=j;i<=n;i++)
char c;
bool t[4010010];
LL n,p[1000000],ans[1000000];
int T,tot,tott,len,S=10;
void pre()
{
    memset(t,true,sizeof(t));
    rep(i,2,4010000) 
    	if(t[i])
    	{
        	p[++len]=i;
       		rep(j,i,4010000/i) t[i*j]=false;
    	}
}
inline LL muti_mod(LL a,LL b,LL c)
{
    a%=c;
    b%=c;
    LL ret=0;
    while(b)
    {
        if(b&1){ret+=a;if(ret>=c)ret-=c;}
        a<<=1;
        if(a>=c)a-=c;
        b>>=1;
    }
    return ret;
}
inline LL pow_mod(LL x,LL n,LL mod)
{
    if(n==1)return x%mod;
    int bit[50],k=0;
    while(n)
    {
        bit[k++]=n&1;
        n>>=1;
    }
    LL ret=1;
    for(;k>0;k--)
    {
        ret=muti_mod(ret,ret,mod);
        if (bit[k-1]==1) ret=muti_mod(ret,x,mod);
    }
    return ret;
}
inline bool check(LL a,LL n,LL x,LL t)
{
    LL ret=pow_mod(a,x,n),last=ret;
    for(int i=1;i<=t;i++)
    {
        ret=muti_mod(ret,ret,n);
        if(ret==1&&last!=1&&last!=n-1) return true;
        last=ret;
    }
    if(ret!=1) return true;
    return false;
}
inline bool prime(LL n)
{
    if(n<2)return false;
    if(n==2)return true;
    if((n&1)==0) return false;
    LL x=n-1;LL t=0;
    while((x&1)==0){x>>=1;t++;}
    for(int i=0;i<S;i++)
    {
        LL a=rand()%(n-1)+1;
        if(check(a,n,x,t)) return false;
    }
    return true;
}
void find(LL n,int list,LL now)
{
    if(n==1){ans[tot++]=now;return;}
    if(1&n) return;
    LL N=now,m,maxi=int(sqrt(n))+1;
    rep(i,list,len) if(p[i]>maxi)break;else if(n%(p[i]-1)==0)
    {
        m=n/(p[i]-1);
        N*=p[i];
        find(m,i+1,N);
        while(m%p[i]==0)
        {
            m/=p[i];N*=p[i];
            find(m,i+1,N);
        }
        N=now;
    }
    if(n+1>=p[list])
    {
        if(n+1>p[len]){if(prime(n+1))ans[tot++]=N*(n+1);}
        else{if(t[n+1])ans[tot++]=N*(n+1);}
    }
}
int main()
{
    scanf("%d",&T);
    pre();
    while(T--)
    {
        scanf("%lld",&n);tot=0;
        if(1&n){
            if(n==1){puts("2");puts("1 2");}else puts("0"),puts("");
            continue;
        }
        find(n,1,1);
        sort(ans,ans+tot);
        printf("%d\n",tot);
        rep(i,0,tot-2) printf("%lld ",ans[i]);
        if(tot)printf("%lld\n",ans[tot-1]);else{puts("");};
    }
}
Problem3744

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
const int B = 305;
int c[N],sum[B][B],Sum[B][N];
int a[N],b[N],bel[N],bs[B],be[B],n,L,cnt,size;
int Find(int x)
{
	int l = 1,r = L+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(b[mid]<x)l=mid+1;
		else r = mid;
	}
	return l;
}
void update(int x,int y)
{
	for(int i = x;i<=n;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void Update(int id,int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		sum[id][i]+=y;
}
int Getans(int id,int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=sum[id][i];
	return ans;
}
void UPDATE(int id,int x,int y)
{
	for(int i = x;i<=n;i+=i&(-i))
		Sum[id][i]+=y;
}
int GETANS(int id,int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=Sum[id][i];
	return ans;
}
int ni[B];
int main()
{
	//freopen("noon.in","r",stdin);
	//freopen("noon.out","w",stdout);
	//freopen("x.in","r",stdin);
	scanf("%d",&n);
	size = floor(sqrt(n));
	for(int i = 1;i<= n;i+=size)
	{
		bs[++cnt]=i;be[cnt]=min(n,i+size-1);
		for(int j = bs[cnt];j<=be[cnt];j++)
			bel[j]=cnt;
	}
	for(int i =1;i<= n;i++)
		scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	for(int i = 1;i<= n;i++)
		if(b[i]!=b[L])
			b[++L]=b[i];
	for(int i = 1;i<= n;i++)a[i]=Find(a[i]);
	//for(int i = 1;i<= n;i++)printf("%d ",a[i]);
	//printf("\n");
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],1);
		for(int j = i+1;j<=cnt;j++)
		{
			int t = 0;
			for(int k = bs[j];k<=be[j];k++)
				t+=getans(n)-getans(a[k]);
			Update(i,j,t);
		}
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],-1);
	}
	for(int i=1;i<=cnt;i++)
		for(int j = 1;j<=be[i];j++)
			UPDATE(i,a[j],1);
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = bs[i];j<=be[i];j++)
		{
			ni[i]+=getans(n)-getans(a[j]);
			update(a[j],1);
			//if(i==1)printf("%d\n",ni[i]);
		}
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],-1);
	}
	//for(int i = 1;i<= cnt;i++)
	//	printf("%d\n",ni[i]);
	int q,ans=0;
	scanf("%d",&q);
	while(q--)
	{
		int l,r,j,k;
		scanf("%d%d",&j,&k);
		j^=ans,k^=ans;
		ans = 0;
		l = bel[j],r=bel[k];
		if(r-l<=1)
		{
			for(int i = j;i<= k;i++)
			{
				ans+=getans(n)-getans(a[i]);
				update(a[i],1);
			}
			for(int i = j;i<=k;i++)
				update(a[i],-1);
		}else
		{
			for(int i = l+1;i<= r-1;i++)
			{
				ans+=ni[i];
				ans+=Getans(i,r-1)-Getans(i,i);
				//printf("%d\n",ans);
			}
			for(int i = j;i<=be[l];i++)
			{
				ans+=getans(n)-getans(a[i]);
				ans+=GETANS(r-1,a[i]-1)-GETANS(l,a[i]-1);
				update(a[i],1);
				//printf("%d\n",ans);
			}
			for(int i = bs[r];i<=k;i++)
			{
				ans+=getans(n)-getans(a[i]);
				ans+=GETANS(r-1,n)-GETANS(r-1,a[i])-GETANS(l,n)+GETANS(l,a[i]);
				update(a[i],1);
				//printf("%d\n",ans);
			}
			for(int i=j;i<=be[l];i++)update(a[i],-1);
			for(int i=bs[r];i<=k;i++)update(a[i],-1);
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem3747

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
int w[N],f[N],next[N],last[N];
LL maxn[N<<2],lazy[N<<2];
void push_down(int p,int l,int r)
{
	if(lazy[p]==0||l==r)return ;
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=c;
		maxn[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
/*LL getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return maxn[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
	return ans;
}*/
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&f[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d",&w[i]);
	for(int i = n;i>=1;i--)
	{
		next[i] = last[f[i]];
		last[f[i]] = i;
	}
	for(int i = 1;i<= m;i++)
		if(last[i])
		{
			if(!next[last[i]])update(1,1,n,last[i],n,w[i]);
			else update(1,1,n,last[i],next[last[i]]-1,w[i]);
		}
	LL ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = max(ans,maxn[1]);
		int t = next[i];
		if(t)
		{
			update(1,1,n,i,t-1,-w[f[i]]);
			if(next[t])update(1,1,n,t,next[t]-1,w[f[i]]);
			else update(1,1,n,t,n,w[f[i]]);
		}else update(1,1,n,i,n,-w[f[i]]);
	}
	printf("%lld",ans);
	return 0;
}
Problem3748

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 507;
int f[N] = {0,1,0,0,2,2,0,0,0,3,3,0,0,3,3,0,4,4,0,0,4,4,0,0,0,4,4,0,0,4,4,0,0,0,5,5,6,6,5,5,6,5,5,0,0,5,5,0,0,6,5,5,6,6,5,5,6,6,7,7,0,6,6,7,8,6,6,0,8,7,6,6,0,8,6,6,0,6,6,7,8,6,6,7,7,7,6,6,7,7,6,6,0,8,7,7,0,9,7,7,7,7,7,7,7,7,7,9,0,8,7,7,0,8,7,7,8,8,8,7,7,8,8,7,7,8,7,7,0,8,7,7,9,8,8,7,7,9,8,7,7,8,8,8,9,8,8,8,8,8,8,8,8,8,8,8,9,10,8,8,9,9,8,8,8,8,8,8,8,8,8,9,9,10,8,8,9,10,8,8,9,9,9,8,8,9,9,8,8,10,8,8,9,10,8,8,9,9,9,8,8,9,9,8,8,9,9,9,9,10,9,9,9,10,9,9,9,9,10,9,9,9,9,9,9,10,9,9,9,9,9,9,9,9,9,9,9,10,10,9,9,10,10,9,9,9,9,9,9,9,9,9,10,10,10,9,9,11,10,9,9,10,10,10,9,9,10,10,9,9,10,9,9,11,10,9,9,11,10,10,9,9,10,10,9,9,10,10,10,11,10,10,10,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,10,10,10,11,10,10,10,10,11,10,10,10,10,10,10,11,10,10,10,10,10,10,10,10,10,10,10,11,11,10,10,11,11,10,10,10,10,10,10,10,10,10,11,11,11,10,10,11,11,10,10,11,11,11,10,10,11,11,10,10,11,10,10,11,11,10,10,11,12,11,10,10,11,11,10,10,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,12,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,12,12,11,11,11,11,11,11,11,11,11,12,12,12,11,11,12,12,11,11,12,12,12,11,11,12,12,11,11,12,11,11,12,12,11,11,12,12,12,11,11,12,12,11,11};
int v[N],sum[N];
LL F(LL x)
{
	return x*(x+1)*(x*2+1)/6;
}
int main()
{
	LL n;
	scanf("%lld",&n);
	for(int i = 2;i<N;i++)
		if(f[i])
			for(int j = 1;j<i;j++)
				if(!f[j]||f[i]<f[j])v[j] = 1;
	for(int i = 2;i<N;i++)sum[i] = sum[i-1]+v[i];
	if(n<N)
	{
		if(f[n]!=0)printf("%d %d\n",f[n],sum[n]);
		else printf("- %d\n",sum[n]);
		return 0;
	}
	int L = 1,R = 2e6;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(F(mid)<n)L = mid+1;
		else R = mid;
	}
	bool flag = false;
	if(F(L)-n<=(LL)506&&F(L)-n>0)
		if(f[F(L)-n]==0)
			printf("%d ",L+1),flag = true;
	if(!flag)printf("%d ",L);
	LL ans;
	int i;
	for(ans=(LL)(L-12)*31+sum[N-1],i=1;i<=128;i++)if(!f[i]&&F(L)-i<=n)ans++;
	printf("%lld",ans);
	return 0;
}
Problem3749

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int f[N][5],a[N],n,ans[N];
bool work(int u)
{
	memset(f,0,sizeof(f));
	f[1][u] = 1;
	for(int i = 2;i<= n;i++)
	{
		if(f[i-1][1]&&a[i-1]<=2*a[i])f[i][1] = 1;
		if(f[i-1][4]&&a[i-1]<=a[i])f[i][1] = 4;
		if(f[i-1][2]&&a[i-1]*2>=a[i])f[i][2] = 2;
		if(f[i-1][3]&&a[i-1]>=a[i])f[i][2] = 3;
		if(f[i-1][1]&&a[i-1]<=a[i])f[i][3] = 1;
		if(f[i-1][4]&&2*a[i-1]<=a[i])f[i][3] = 4;
		if(f[i-1][2]&&a[i-1]>=a[i])f[i][4] = 2;
		if(f[i-1][3]&&a[i-1]>=a[i]*2)f[i][4] = 3;
	}
	if(f[n][u]==0)return false;
	for(int i=n;i>=1;i--)
	{
        if(u==1)ans[i-1]=(i-1)%(n-1)+1;
        if(u==2)ans[i]=(i-1)%(n-1)+1;
        if(u==3)ans[i-1]=ans[i]=(i-1)%(n-1)+1;
        u=f[i][u];
    }
    for(int i = 1;i<n-1;i++)printf("%d ",ans[i]);
    printf("%d\n",ans[n-1]);
	return true;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	a[++n] = a[1];
	for(int i = 1;i<=4;i++)if(work(i))return 0;
	printf("NIE\n");
	return 0;
}
Problem3771

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double x = 0,double y = 0):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);
	}
}a[N],b[N],c[N],d[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i=2;i<=len;i=i<<1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w = cp(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int A[N];
int main()
{
	int maxa = -1,n;
	scanf("%d",&n);
	n--;
	for(int i = 0;i<= n;i++)
	{
		scanf("%d",&A[i]);
		a[A[i]].x=1,b[2*A[i]].x=1,c[3*A[i]].x=1;
		maxa = max(maxa,3*A[i]);
	}
	int m=maxa,L=0;
    for(n=1;n<=m;n<<=1)L++;
    FFT(a,n,1),FFT(b,n,1),FFT(c,n,1);
	for(int i = 0;i<=n;i++)
	{
		cp tmp = cp(1.0/6.0,0),tmp2 = cp(3.0,0),tmp3 = cp(2.0,0),tmp4 = cp(1.0/2.0,0);
		d[i]=d[i]+(a[i]*a[i]*a[i]-tmp2*a[i]*b[i]+tmp3*c[i])*tmp;
        d[i]=d[i]+(a[i]*a[i]-b[i])*tmp4;
        d[i]=d[i]+a[i];
	}
	FFT(d,n,-1);
	for(int i = 0;i<= maxa;i++)
	{
		int ans = (int)(d[i].x+0.1);
		if(ans!=0)printf("%d %d\n",i,ans);
	}
	return 0;
}
Problem3772

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int M = 4e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,m;
struct Ask
{int x,y;}ask[N];
bool cmp(Ask a,Ask b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
	e[++tot].to = x;e[tot].next = head[y];head[y]=tot;
}
int fa[N][18],root[N];
int ls[M],rs[M],sum[M];
int in[N],end[N],ind,dep[N],cnt;
int getans(int x,int y,int u,int v,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[x]+sum[y]-sum[u]-sum[v];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=getans(ls[x],ls[y],ls[u],ls[v],l,mid,a,b);
	if(b>mid) ans+=getans(rs[x],rs[y],rs[u],rs[v],mid+1,r,a,b);
	return ans;
}
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p] = sum[pre]+val;
		return ;
	}
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)
		update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
void dfs(int x)
{
	in[x] = ++ind;
	dep[x] = dep[fa[x][0]]+1;
	for(int j = 1;j<= 17;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
	for(int i = head[x];i;i=e[i].next)
	{
		if(e[i].to==fa[x][0])continue;
		fa[e[i].to][0] = x;
		dfs(e[i].to);
	}
	end[x] = ++ind;
}
vector<int>a[N];
void dfs2(int x)
{
	root[x] = root[fa[x][0]];
	for(int i = 0;i<a[x].size();i++)
	{
		update(root[x],root[x],1,ind,in[a[x][i]],1);
		update(root[x],root[x],1,ind,end[a[x][i]],-1);
	}
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
			dfs2(e[i].to);
}
ll ans = 0;
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void solve()
{
	for(int i = 1;i<= m;i++)
	{
		int x=ask[i].x,y = ask[i].y;int u = getlca(x,y),v = fa[u][0];
		ans+=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[x]);
		ans+=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[y]);
		ans-=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[u]);
		ans--;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		a[x].push_back(y);
		ask[i].x = x,ask[i].y = y;
	}
	sort(ask+1,ask+m+1,cmp);
	dfs(1);
	dfs2(1);
	solve();
	ll b = (ll)m*(m-1)/2;
	int j;
	for(int i = 1;i<= m;i=j)
		for(j=i;ask[i].x==ask[j].x&&ask[i].y==ask[j].y;j++)
			ans-=(ll)(j-i)*(j-i-1)/2;
	ll t = gcd(ans,b);
	ans = ans/t,b = b/t;
	printf("%lld/%lld\n",ans,b);
	return 0;
}
Problem3774

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e4+4;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].f = 0;
}
queue <int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] =-1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
	{
		ans+=get_mxf(s,t,INF);
	}
	return ans;
}
int n,m;
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
inline int id1(int i,int j)
{
	return i*m+j-m;
}
inline int id2(int i,int j)
{
	return i*m+j-m+n*m;
}
int main()
{
	int ans = 0;
	scanf("%d%d",&n,&m);
	int x;
	int S = 0, T = 2*n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			if((i+j)&1)
				add(S,id1(i,j),x);
			else 
				add(id1(i,j),T,x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			ans+=2*x;
			if((i+j)&1)
				add(S,id2(i,j),x),add(id1(i,j),T,x);
			else 
				add(id2(i,j),T,x),add(S,id1(i,j),x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if((i+j)&1)
			{
				add(id2(i,j),id1(i,j),INF);
				for(int d = 0;d<4;d++)
				{
					int xx = i+dx[d],yy = j+dy[d];
					if(xx<=0||yy<=0||xx>n||yy>m)continue;
					add(id2(i,j),id1(xx,yy),INF);
				}
			}else
			{
				add(id1(i,j),id2(i,j),INF);
				for(int d = 0;d<4;d++)
				{
					int xx = i+dx[d],yy = j+dy[d];
					if(xx<=0||yy<=0||xx>n||yy>m)continue;
					add(id1(xx,yy),id2(i,j),INF);
				}
			}
	ans-=dinic(S,T);
	printf("%d\n",ans);
	return 0;
}
Problem3786

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int Inv = 20000307;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct Splay
{
	Splay *ls,*rs,*fa;
	int pos,neg,sta,lazy;
	LL num,sum;
	Splay(LL x,int s);
	void push_up();
	void push_down();
	void Add(LL x);
}*null = new Splay(0,0),*root,*tree[N][2];
Splay :: Splay(LL x,int s)
{
	ls = rs = fa = null;
	num = x*(s==1?1:-1);
	sta = s;
	neg = pos = 0;
	if(sta==1)pos++;
	if(sta==2)neg++;
	lazy = 0;
}
void Splay :: push_up()
{
	sum = ls->sum+rs->sum+num;
	pos = ls->pos+rs->pos+(sta==1);
	neg = ls->neg+rs->neg+(sta==2);
}
void Splay :: push_down()
{
	if(lazy)
	{
		ls->Add(lazy);
		rs->Add(lazy);
		lazy = 0;
	}
}
void Splay :: Add(LL x)
{
	if(this==null)return ;
	num+=x*(sta==1?1:-1);
	sum+=x*(pos-neg);
	lazy+=x;
}
void Push_down(Splay *x)
{
	static Splay *stack[N<<1];
	static int top = 0;
	for(;x!=null;x = x->fa)
		stack[++top] = x;
	while(top)
		stack[top--]->push_down();
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)
		root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)
		root = x;
}
void splay(Splay *x,Splay *target)
{
	Push_down(x);
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==target)break;
		if(z==target)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
Splay* Insert(LL x,int s)
{
	Splay *y = root;
	while(y->rs!=null)
		y = y->rs;
	y->rs = new Splay(x,s);
	y->rs->fa = y;
	y->push_up();
	splay(y->rs,null);
	return root;
}
Splay* find_min(Splay *x)
{
	while(x->ls!=null)
		x = x->ls;
	return x;
}
Splay* find_max(Splay *x)
{
	while(x->rs!=null)
		x = x->rs;
	return x;
}
void move_to_root(Splay *x,Splay *y)
{
	splay(x,null);
	Splay *tmp1 = find_max(root->ls);
	splay(y,null);
	Splay *tmp2 = find_min(root->rs);
	splay(tmp1,null);
	splay(tmp2,root);
}
LL a[N];
void dfs(int x)
{
	tree[x][0] = Insert(a[x],1);
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to);
	tree[x][1] = Insert(a[x],2);
}
int main()
{
	int n,f;
	LL x,y;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d",&f);
		add(f,i);
	}
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	root = new Splay(Inv,3);
	dfs(1);
	Insert(Inv,4);
	int m;
	scanf("%d",&m);
	char opt[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')
		{
			scanf("%lld",&x);
			move_to_root(tree[1][0],tree[x][0]);
			printf("%lld\n",root->rs->ls->sum);
		}else if(opt[0]=='C')
		{
			scanf("%lld%lld",&x,&y);
			move_to_root(tree[x][0],tree[x][1]);
			Splay *tmp = root->rs->ls;
			root->rs->ls = null;
			root->rs->push_up();
			root->push_up();
			splay(tree[y][0],null);
			splay(find_min(root->rs),root);
			root->rs->ls = tmp;
			tmp->fa = root->rs;
			root->rs->push_up();
			root->push_up();
		}
		else
		{
			scanf("%lld%lld",&x,&y);
			move_to_root(tree[x][0],tree[x][1]);
			root->rs->ls->Add(y);
		}
	}
	return 0;
}
Problem3790

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
char s[N];
char a[N];
int no[N];
int p[N],maxp,id;
struct Q
{int l,r;}q[N];
vector<int>w[N];
int f[N],c[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = min(c[i],y);
}
int getans(int x)
{
	int ans = 0x3f3f3f3f;
	for(int i = x;i>0;i-=i&(-i))
		ans = min(ans,c[i]);
	return ans;
}
int main()
{
	while(scanf("%s",s+1)!=EOF)
	{
		memset(p,0,sizeof(p));
		int n = strlen(s+1);
		int len = 0;
		for(int i = 1;i<=n;i++)
		{
			a[++len]=s[i];
			no[len] = i;
			if(i!=n)a[++len]='^';
		}
		maxp = id = 1;
		for(int i = 1;i<= len;i++)
		{
			p[i] = max(0,min(p[2*id-i],maxp-i));
			while(i+p[i]<=len&&i-p[i]>=1&&a[i+p[i]]==a[i-p[i]])p[i]++;
			p[i]--;
			if(i+p[i]>maxp){maxp = i+p[i],id = i;}
			q[i]=(Q){no[i-p[i]]?no[i-p[i]]:no[i-p[i]+1],no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1]};
		}
		for(int i = 1;i<= len;i++)
			w[i].clear();
		for(int i = 1;i<=len;i++)
			if(q[i].l<=q[i].r)
				w[q[i].r].push_back(q[i].l);
		memset(f,0x3f,sizeof(f));
		memset(c,0x3f,sizeof(c));
		update(n+1,0);
		for(int i = 1;i<= n;i++)
		{
			for(int j = 0;j<w[i].size();j++)
				f[i] = min(f[i],getans(n-w[i][j]+2)+1);
			update(n-i+1,f[i]);
		}
		printf("%d\n",f[n]-1);
	}
	return 0;
}
Problem3812

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int S = 1<<15;
const LL mod = 1e9+7;
LL c[250][250];
LL f[S],g[S],h[S],power_2[S];
int in[S],out[S],dig[S];
int Count(int x)
{
	return dig[x>>8] + dig[x&255] ;
}
int main()
{
	int n,m,x,y,i;
	scanf("%d%d",&n,&m);
	for(i = 1;i<1<<8;i++)
		dig[i] = dig[i>>1]+(i&1);
	for(power_2[0]=1,i=1;i<=m;i++)
		power_2[i]=(power_2[i-1]<<1)%mod;
	for(i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		//add(x,y);
		//f[(1<<(x-1))|(1<<(y-1))]+=1;
		out[1<<(x-1)]|=1<<(y-1);
		in[1<<(y-1)]|=1<<(x-1);
	}
	for(i = 1;i<1<<n;i++)
	{
		int one = i&(-i),sta = i^one;
		h[i] = h[sta]+Count(in[one]&sta)+Count(out[one]&sta);
		for(int j = sta;j;j = (j-1)&sta)
			(g[i]+=mod-f[i^j]*g[j]%mod)%=mod;
		static int w[1<<15];
		f[i] = power_2[h[i]];
		for(int j = i;j;j = (j-1)&i)
		{
			if(j==i)w[j] = 0;
			else
			{
				int tmp = (i^j)&(-(i^j));
				w[j] = w[j^tmp]-Count(out[tmp]&(i^j))+Count(j&in[tmp]);
			}
			(f[i]+=mod-power_2[h[i^j]+w[j]]*g[j]%mod)%=mod;
		}
		(g[i]+=f[i])%=mod;
	}
	printf("%lld\n",f[(1<<n)-1]);
	return 0;
}
Problem3813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
const int mod = 19961993;
typedef pair<ll,ll> PLL;
pair <ll,ll> val[N<<2];
int prime[105],env[105],cnt;
bool v[405];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void init()
{
	for(int i = 2;cnt<=60;i++)
	{
		if(!v[i])prime[++cnt]=i;
		for(int j = 1;j<=cnt&&i*prime[j]<=400;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
	for(int i = 1;i<= 60;i++)
		env[i] = quick_pow(prime[i],mod-2);
}
void push_up(int p)
{
	val[p].first = val[p<<1].first|val[p<<1|1].first;
	val[p].second = val[p<<1].second*val[p<<1|1].second%mod;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		val[p].first|=1<<2;
		val[p].second = 3;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void update(int p,int l,int r,int x,ll v)
{
	if(l==r)
	{
		val[p].first = 0;
		for(int i = 1;i<= 60;i++)
			if(v%prime[i]==0)
				val[p].first|=(1ll<<i);
		val[p].second = v%mod;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,v);
	else update(p<<1|1,mid+1,r,x,v);
	push_up(p);
}
PLL uni(PLL a,PLL b)
{
	a.first |= b.first;
	(a.second *= b.second)%=mod;
	return a;
}
pair<ll,ll> getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return val[p];
	pair <ll,ll>ans;
	int mid = (l+r)>>1;
	ans.first = 0,ans.second = 1;
	if(a<=mid)ans=uni(ans,getans(p<<1,l,mid,a,b));
	if(b >mid)ans=uni(ans,getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
int main()
{
	int n = 1e5;
	int m;
	init();
	build(1,1,n);
	scanf("%d",&m);
	while(m--)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		if(a==1)
			update(1,1,n,b,c);
		else
		{
			PLL ans = getans(1,1,n,b,c);
			ll Ans = ans.second;
			for(int i =1;i<= 60;i++)
				if((ans.first>>i)&1)
					Ans = Ans*(prime[i]-1)%mod*env[i]%mod;
			printf("%lld\n",Ans);
		}
	}
	return 0;
}
Problem3827

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int INF = 0x3f3f3f3f;
int dis[N],nxt[N<<1],dep[N<<1];
int n,s;
int work(int x)
{
	int fa = x;
	for(;fa<x+n;fa = nxt[fa]);
	for(int i = nxt[x],j = x;i!=fa;j = i,i = nxt[i])nxt[j] = fa;
	return dep[x]-dep[fa];
}
int main()
{
	scanf("%d%d",&n,&s);
	int max_d = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&dis[i]);
		max_d = max(max_d,dis[i]);
	}
	while(s--)
	{
		int d;
		scanf("%d",&d);
		if(d<max_d){printf("NIE\n");continue;}
		int j = 1,sum = 0;
		int end = n<<1;
		for(int i = 1;i<= end;i++)
		{
			while(j<end&&sum+dis[j>n?j-n:j]<=d)
			{
				sum = sum+dis[j>n?j-n:j];
				j++;
			}
			sum-=dis[i>n?i-n:i];
			nxt[i] = j;
		}
		dep[end] = 0;
		for(int i = end;i>=1;i--)
			dep[i] = dep[nxt[i]]+1;
		int ans = INF;
		for(int i = 1;i<= n;i++)ans = min(ans,work(i));
		printf("%d\n",ans);
	}
	return 0;
}
Problem3828

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int last[N],a[N],tmp[N],stack[N],top,cnt,n,k;
struct Line
{
	int lth,col[N],nxt[N],last[N],Min[N],end[N];
	void init()
	{
		top = 0;
		for(int i = 1;i<= lth;i++)scanf("%d",&tmp[i]);
		for(int i = 1;i< lth;i++)nxt[tmp[i]] = tmp[i+1];
		for(int i = n;i>=1;i--)
		{
			end[i] = 0;
			if(col[i]==tmp[lth])end[i] = i;
			else if(nxt[col[i]]&&last[nxt[col[i]]])
				end[i] = end[last[nxt[col[i]]]];
			if(col[i]==tmp[1]&&end[i])stack[++top] = i;
			last[col[i]] = i;
		}
		stack[top+1] = 1;
		for(int i = 1;i<=top;i++)
			for(int j = stack[i]-1;j>= stack[i+1];j--)
				Min[j] = end[stack[i]];
	}
}a1,a2;
struct Seg
{int l,r;}seg[N];
bool cmp(Seg a,Seg b)
{
	return a.l<b.l;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		a1.col[i] = a[i],a2.col[i] = a[n-i+1];
	scanf("%d%d",&a1.lth,&a2.lth);
	a1.init();
	a2.init();
	for(int i = 1;i<= n;i++)
	{
		if(a1.last[a2.col[i]])
		{
			int tmp1 = a1.Min[a1.last[a2.col[i]]],tmp2 = a2.Min[i];
			if(tmp1&&tmp2&&tmp1<=n-tmp2+1)
				seg[++cnt] = (Seg){tmp1,n-tmp2+1};
		}
	}
	sort(seg+1,seg+cnt+1,cmp);
	int L = seg[1].l,R = seg[1].r,top = 0;
	for(int i = 2;i<= cnt;i++)
	{
		if(seg[i].l>R)
		{
			for(int j = L;j<=R;j++)
				if(a[j]==tmp[a2.lth])stack[++top] = j;
			L = seg[i].l,R = seg[i].r;
		}
		else R = max(seg[i].r,R);
	}
	for(int j = L;j<=R;j++)
		if(a[j]==tmp[a2.lth])stack[++top] = j;
	printf("%d\n",top);
	for(int i = 1;i<=top;i++)
		printf("%d ",stack[i]);
	//printf("%d\n",stack[top]);
	return 0;
}
Problem3829

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
struct P
{
	int f,size;
}p[N];
bool cmp(P a,P b)
{
	return a.f-a.size>b.f-b.size;
}
int size[N],f[N],c[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
P stack[N];
int top;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			p[e[i].to].size+=2;
			p[e[i].to].f = max(p[e[i].to].f+1,p[e[i].to].size);
			stack[++top] = p[e[i].to];
		}
	sort(stack+1,stack+top+1,cmp);
	p[x].f = c[x];
	for(int i = 1;i<=top;i++)
	{
		p[x].f = max(p[x].f,stack[i].f+p[x].size);
		p[x].size+=stack[i].size;
	}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	printf("%d\n",max(p[1].f,p[1].size+c[1]));
	return 0;
}
Problem3830

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
const LL INF = 1e18;
LL c[N];
LL f[N],a[N];
int n;
LL s;
void update(int x,LL t)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = min(c[i],t);
}
LL getans(int x)
{
	LL ans = INF;
	for(int i = x;i>0;i-=i&(-i))
		ans = min(ans,c[i]);
	return ans;
}
int main()
{
	memset(c,0x3f,sizeof(c));
	scanf("%d%lld",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	for(int i = 2;i<= n;i++)
		a[i] = max(a[i],a[i-1]+1);
	int L,R,mid;
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = i;
		while(L<R)
		{
			mid = (L+R)>>1;
			if(f[mid]-mid-1<=a[i]-i)
				L = mid+1;
			else R = mid;
		}
		f[i] = a[i]-L+i+s*2;
		if(L!=i)f[i] = min(f[i],getans(n-L+1)+s*2+i*2);
		update(n-i+1,f[i]-2*i-2);
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem3831

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int line[N],L,R,a[N],f[N];
bool smaller(int i,int j)
{
	if(f[i]!=f[j])
		return f[i]<f[j];
	return a[i]>a[j];
}
int main()
{
	int n,k,t;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&k);
		memset(f,0x3f,sizeof(f));
		L = 0,R = 0;line[R] = 1;
		f[1] = 0;
		for(int i = 2;i<= n;i++)
		{
			while(L<=R&&line[L]<i-k)L++;
			f[i] = min(f[i],f[line[L]]+(a[line[L]]<=a[i]));
			while(L<=R&&smaller(i,line[R]))R--;
			line[++R] = i;
		}
		printf("%d\n",f[n]);
	}
	return 0;
}
Problem3832

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e6+5;
const int N = 5e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[M],fe[M];
int head[N],fh[N],tot;
int line[N],top;
int g[N],f[N],ind[N];
void add(int x,int y)
{
	ind[y]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	fe[tot].to = x;
	fe[tot].next = fh[y];
	fh[y] = tot;
}
queue<int>Q;
int heap[M<<1],dele[M<<1],ch,cd;
int main()
{
	//freopen("raj.in","r",stdin);
	//freopen("raj.out","w",stdout);
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i);
	while(!Q.empty())
	{
		x = Q.front();
		Q.pop();
		line[++top] = x;
		for(int i = head[x];i;i = e[i].next)
			if(!--ind[e[i].to])
				Q.push(e[i].to);
	}
	for(int i = 1;i<= top;i++)
	{
		int tmp = line[i];
		f[tmp] = max(f[tmp],1);
		for(int j = head[tmp];j;j = e[j].next)
			f[e[j].to] = max(f[e[j].to],f[tmp]+1);
	}
	for(int i = top;i>= 1;i--)
	{
		int tmp = line[i];
		g[tmp] = max(g[tmp],1);
		for(int j = head[tmp];j;j = e[j].next)
			g[tmp] = max(g[tmp],g[e[j].to]+1);
	}
	for(int i = 1;i<= n;i++)
	{
		heap[++ch] = g[i];
		push_heap(heap+1,heap+ch+1);
	}
	int ans_len = INF,ans;
	for(int i = 1;i<= top;i++)
	{
		x = line[i];
		for(int j = fh[x];j;j = fe[j].next)
		{
			dele[++cd] = f[fe[j].to]+g[x];
			push_heap(dele+1,dele+cd+1);
		}
		dele[++cd] = g[x];
		push_heap(dele+1,dele+cd+1);
		while(dele[1]==heap[1]&&cd>=1&&ch>=1)
		{
			pop_heap(dele+1,dele+cd+1);
			cd--;
			pop_heap(heap+1,heap+ch+1);
			ch--;
		}
		if(ch&&heap[1]<ans_len)
		{
			ans_len = heap[1];
			ans = x;
		}
		for(int j=head[x];j;j = e[j].next)
		{
			heap[++ch] = f[x]+g[e[j].to];
			push_heap(heap+1,heap+ch+1);
		}
		heap[++ch] = f[x];
		push_heap(heap+1,heap+ch+1);
	}
	printf("%d %d\n",ans,ans_len-1);
	return 0;
}
Problem3834

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		x1--;
		x2--;
		int last = 0,ans = -1;
		for(int i = 1;i<= y1&&i<=y2;i = last+1)
		{
			last = min(y1/(y1/i),y2/(y2/i));
			if(y1/last>x1/last&&y2/last>x2/last)
				ans = max(ans,last);
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem3835

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int sum[N],max_dep;
void dfs(int x,int dep)
{
	max_dep = max(max_dep,dep);
	sum[dep]++;
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to,dep+1);
}
struct Ask
{int k,no,ans;}qur[N];
bool cmp(Ask a,Ask b){return a.k<b.k;}
bool ret(Ask a,Ask b){return a.no<b.no;}
int line[N],L,R;
double calc(int i,int j)
{
	return (double)(sum[i]-sum[j])/(double)(i-j);
}
int main()
{
	int n,q,x;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&qur[i].k);
		qur[i].no = i;
	}
	sort(qur+1,qur+1+q,cmp);
	for(int i = 2;i<=n;i++)
	{
		scanf("%d",&x);
		add(x,i);
	}
	dfs(1,1);
	for(int i = max_dep;i>=1;i--)
		sum[i]+=sum[i+1];
	R = -1;
	for(int i = 1;i<= max_dep;i++)
	{
		while(L<R&&calc(i,line[R-1])>=calc(line[R],line[R-1]))R--;
		line[++R] = i;
	}
	for(int t = 1;t<= q;t++)
	{
		int i = qur[t].k;
		while(L<R&&i*line[L]+sum[line[L]]<i*line[L+1]+sum[line[L+1]])L++;
		qur[t].ans = line[L];
	}
	sort(qur+1,qur+q+1,ret);
	for(int i = 1;i< q;i++)
		printf("%d ",max(max_dep,(sum[qur[i].ans]+qur[i].k-1)/qur[i].k+qur[i].ans-1));
	printf("%d\n",max(max_dep,(sum[qur[q].ans]+qur[q].k-1)/qur[q].k+qur[q].ans-1));
	return 0;
}
Problem3837

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;

const int N = 1e5+5;
const int M = 1e7+5;
int n,Ans1,Ans2,Maxx;
int A[N],B[N];
int p[M],v[M],vis[M],f[M];

inline void First()
{
	for(int i=2;i<=Maxx;i++)
	{
		if(!p[i]) p[++*p]=i,v[i]=*p;
		for(int j=1;j<=*p&&p[j]*i<=Maxx;j++)
		{
			p[p[j]*i]=1; v[p[j]*i]=j;
			if(i%p[j]==0) break;
		}
	}
}

int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}

int main()
{
	srand(2037);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&A[i]),Maxx=max(Maxx,A[i]);
	First();
	for(int K=1;K<=4;K++)
	{
		int x=A[rand()%n+1],cnt=0,w=0,Max=0,nAns=0;
		for(int i=1;i<=n;i++)
			if(A[i]!=x) B[++cnt]=A[i]<x?(x-A[i]):(A[i]-x);
			else w++;
		for(int i=1;i<=*p;i++) vis[i]=f[i]=0;
		for(int i=1;i<=cnt;i++)
		{
			int now=B[i];
			for(;now^1;now/=p[v[now]])
			{
				vis[v[now]]++;
				f[v[now]]=gcd(f[v[now]],B[i]);
				int y=p[v[now]];
				while((now/y)%y==0) now/=y;
			}
		}
		for(int i=1;i<=*p;i++)
			if(vis[i]>vis[Max]||(vis[i]==vis[Max]&&f[i]>nAns)) Max=i,nAns=f[i];
		if(vis[Max]+w>Ans1) Ans1=vis[Max]+w,Ans2=nAns;
		else if(vis[Max]+w==Ans1&&nAns>Ans2) Ans2=nAns;
	}
	printf("%d %d\n",Ans1,Ans2);
	return 0;
}
Problem3838

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
const int M = (N<<1)+5e4;
const int INF = 1e9+10;
ll ans;
int A[N],B[N],aa[M],ab[M],ba[M],bb[M],lazy[M],vm[M],n,k;
struct data
{
	int x,y;
	data(){}
	data(int _x,int _y):x(_x),y(_y){}
	data operator +(const data &b){return A[x]+B[y]<A[b.x]+B[b.y]?*this:b;}
}va[M],vb[M],vc[M],t;
inline void add(int x,int p)
{
	vm[x]+=p;
	lazy[x]+=p;
}
inline void Push_down(int p)
{
	if(!lazy[p])return ;
	add(p<<1,lazy[p]),add(p<<1|1,lazy[p]);
	lazy[p]=0;
}
inline void Push_up(int p)
{
	int ls = p<<1,rs = p<<1|1;
	va[p] = va[ls]+va[rs]+data(aa[ls],ab[rs]);
	vc[p] = vc[ls]+vc[rs]+data(aa[rs],ab[ls]);
	vb[p] = vb[ls]+vb[rs];
	aa[p] = A[aa[ls]]<A[aa[rs]]?aa[ls]:aa[rs];
	ab[p] = B[ab[ls]]<B[ab[rs]]?ab[ls]:ab[rs];
	if(vm[ls]<vm[rs])
	{
		vb[p] = vb[p]+vc[rs]+data(aa[rs],bb[ls]);
		ba[p] = ba[ls];
		bb[p] = B[ab[rs]]<B[bb[ls]]?ab[rs]:bb[ls];
		vm[p] = vm[ls];
	}
	else if(vm[ls]>vm[rs])
	{
		vb[p] = vb[p]+vc[ls]+data(ba[rs],ab[ls]);
		ba[p] = A[aa[ls]]<A[ba[rs]]?aa[ls]:ba[rs];
		bb[p] = bb[rs];
		vm[p] = vm[rs];
	}else
	{
		vb[p] = vb[p]+data(ba[rs],bb[ls]);
		ba[p] = ba[ls];
		bb[p] = bb[rs];
		vm[p] = vm[ls];
	}
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		va[p]=vc[p]=data(l,l),vb[p]=data(0,0);
		aa[p]=ba[p]=ab[p]=l;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	Push_up(p);
}
void Add(int p,int l,int r,int a,int b,int val)
{
	if(l>=a&&r<=b)
	{
		add(p,val);
		return ;
	}
	Push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)Add(p<<1,l,mid,a,b,val);
	if(b >mid)Add(p<<1|1,mid+1,r,a,b,val);
	Push_up(p);
}
void Change(int p,int l,int r,int pos)
{
	if(l==r)return ;
	Push_down(p);int mid = (l+r)>>1;
	if(pos<=mid)Change(p<<1,l,mid,pos);
	else Change(p<<1|1,mid+1,r,pos);
	Push_up(p);
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&A[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&B[i]);
	A[0]=B[0]=INF;
	build(1,0,n);
	while(k--)
	{
		t = va[1]+vb[1];
		int i = t.x,j = t.y;
		ans += A[i]+B[j];
		if(i<j)Add(1,0,n,i,j-1,1);
		if(j<i)Add(1,0,n,j,i-1,-1);
		A[i] = INF,Change(1,0,n,i);
		B[j] = INF,Change(1,0,n,j);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3864

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int S = 1<<15;
char let[]={'A','C','G','T'};
char s[20];
int f[2][S],trs[S][4],cnt[S],n,m,ans[20];
void init()
{
	for(int i = 0;i<1<<n;i++)
	{
		static int f[20],g[20];
		for(int j = 1;j<= n;j++)
			f[j] = f[j-1]+((i&(1<<(j-1)))?1:0);
		cnt[i] = f[n];
		for(int k = 0;k<4;k++)
		{
			for(int j = 1;j<= n;j++)
			{
				g[j] =max(g[j-1],f[j]);
				if(let[k]==s[j])
					g[j] = max(f[j-1]+1,g[j]);
			}
			trs[i][k] = 0;
			for(int j = 1;j<= n;j++)
				if(g[j]-g[j-1]==1)
					trs[i][k]|=1<<(j-1);
		}
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%s%d",s+1,&m);
		n = strlen(s+1);
		init();
		int pre = 0,now = 1;
		memset(f,0,sizeof(f));
		f[pre][0] = 1;
		for(int i = 1;i<= m;i++)
		{
			memset(f[now],0,sizeof(f[now]));
			for(int j = 0;j<1<<n;j++)
				for(int k = 0;k<4;k++)
					(f[now][trs[j][k]]+=f[pre][j])%=mod;
			swap(now,pre);
		}
		memset(ans,0,sizeof(ans));
		for(int i = 0;i<1<<n;i++)
			(ans[cnt[i]]+=f[pre][i])%=mod;
		for(int i = 0;i<= n;i++)
			printf("%d\n",ans[i]);
	}
	return 0;
}
Problem3872

#include <stdio.h>
#include <cctype>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int d[N];
void add(int x,int y)
{
	d[x]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
LL low[N],upn[N],a[N],maxa;
bool v[N];
queue<int>Q;
void bfs(int x)
{
	v[x] = true;
	Q.push(x);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!v[e[i].to])
			{
				Q.push(e[i].to);
				v[e[i].to] = true;
				if(low[x]*(d[x]-1)>maxa)low[e[i].to] = maxa+1;
				else low[e[i].to] = low[x]*(d[x]-1);
				if(upn[x]*(d[x]-1)+d[x]-2>maxa)upn[e[i].to] = maxa+1;
				else upn[e[i].to] = upn[x]*(d[x]-1)+d[x]-2;
			}
	}
}
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
LL read()
{
	static char ch;
	static LL D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
int main()
{
	int n,g,k;
	n = read(),g = read(),k =read();
	for(int i = 1;i<= g;i++)
	{
		a[i] = read();
		maxa = max(maxa,a[i]);
	}
	int s,t,x,y;
	for(int i = 1;i<n;i++)
	{
		x = read();y = read();
		add(x,y),add(y,x);
		if(i==1)s = x,t = y;
	}
	v[s] = v[t] = true;
	low[s] = low[t] = upn[s] = upn[t] = k;
	bfs(s);bfs(t);
	sort(a+1,a+g+1);
	LL ans = 0;
	for(int i = 1;i<= n;i++)
		if(d[i]==1)
		{
			int l = lower_bound(a+1,a+g+1,low[i])-a;
			int r = upper_bound(a+1,a+g+1,upn[i])-a;
			if(r>g||a[r]>upn[i])r--;
			ans+=(r-l+1);
		}
	printf("%lld\n",ans*k);
	return 0;
}
Problem3881

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 2e6+5;
char s[N];
int ch[N][26],fail[N],q[N],cnt,h,t;
int s_p[N];
int c[N],Dfn,fa[N][22],dfn[N],dep[N],end[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void dfs(int x)
{
	dfn[x] = ++Dfn;
	dep[x] = dep[fa[x][0]]+1;
	for(int i = head[x];i;i=e[i].next)
	{
		fa[e[i].to][0] = x;
		dfs(e[i].to);
	}
	end[x] = Dfn;
}
void Init()
{
	for(int j = 1;j<= 21;j++)
		for(int i = 1;i<= cnt;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 21;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 21;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void init()
{
	cnt = 1;
	for(int i = 0;i<26;i++)
		ch[0][i] = 1;
}
void insert(int id)
{
	int now = 1,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
		now = ch[now][s(i)];
		i++;
	}
	s_p[id] = now;
}
void build()
{
	h = 0,t = -1;
	q[++t] = 1,fail[0] = 1;
	while(h<=t)
	{
		int x = q[h++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[x][i];
			if(!j)
			{
				ch[x][i]=ch[fail[x]][i];
				continue;
			}
			int k = fail[x];
			while(!ch[k][i])k = fail[k];
			fail[j] = ch[k][i];
			q[++t]=j;
			add(fail[j],j);
		}
	}
}
int st[N],top;
int match()
{
	int now = 1,i = 0,top = 0;
	while(s[i])
	{
		now = ch[now][s(i)];
		st[++top] = now;
		i++;
	}
	return top;
}
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int main()
{
	int n;
	scanf("%d",&n);
	init();
	for(int i= 1;i<= n;i++)
	{
		scanf("%s",s);
		insert(i);
	}
	build();
	dfs(1);
	Init();
	int q;
	scanf("%d",&q);
	int opt,x;
	while(q--)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%s",s);
			int lth = match();
			sort(st+1,st+lth+1,cmp);
			top = 0;
			for(int i = 1;i<= lth;i++)
				if(st[top]!=st[i])
					st[++top] = st[i];
			lth = top;
			for(int i = 1;i<= lth;i++)
			{
				update(dfn[st[i]],1);
				if(i>1)update(dfn[getlca(st[i-1],st[i])],-1);
			}
		}else
		{
			scanf("%d",&x);
			x=s_p[x];
			printf("%d\n",getans(end[x])-getans(dfn[x]-1));
		}
	}
	return 0;
}
Problem3884

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll quick_pow(ll x,ll y,ll mod)
{
	ll re = 1;
	while(y)
	{
		if(y&1)(re*=x)%=mod;
		(x *= x)%=mod;
		y>>=1;
	}
	return re;
}
ll oula(ll x)
{
	ll phi = x;
	for(ll i = 2;i*i<=x;i++)
		if(x%i==0)
		{
			phi = phi/i*(i-1);
			while(x%i==0)x/=i;
		}
	if(x!=1)phi = phi/x*(x-1);
	return phi;
}
ll calc(ll mod)
{
	if(mod==1)return 0;
	ll ans = 1,cnt = 0,MOD = mod;
	while(mod%2==0)
		ans*=2,cnt++,mod/=2;
	int phi = oula(mod);
	ans = ans*quick_pow(2,((calc(phi)-cnt)%phi+phi)%phi,MOD)%MOD;
	return ans;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int x;
		scanf("%d",&x);
		printf("%lld\n",calc(x));
	}
	return 0;
}
Problem3886

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c[25][1005];
int lth[25];
int f[1<<20];
int find(int no,int x)
{
	int l = 1,r = c[no][0]+1;
	while(l<r)
	{
		int mid= (l+r)>>1;
		if(c[no][mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,l;
	scanf("%d%d",&n,&l);
	int end = 1<<n;
	memset(c,0x3f,sizeof(c));
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&lth[i],&c[i][0]);
		for(int j = 1;j<= c[i][0];j++)
			scanf("%d",&c[i][j]);
	}
	memset(f,-1,sizeof(f));
	f[0] = 0;
	int ans =50;
	for(int i = 0;i<end;i++)
	{
		if(f[i]==-1)continue;
		for(int j = 1;j<= n;j++)
		if(!(i&(1<<(j-1))))
		{
			int tmp = find(j,f[i]);
			if(c[j][tmp]>f[i])tmp--;
			if(tmp>0)f[i|(1<<(j-1))] = max(f[i|(1<<(j-1))],max(f[i],c[j][tmp]+lth[j]));
		}
		if(f[i]>=l)
		{
			int tmp = i,cnt = 0;
			while(tmp){tmp-=tmp&(-tmp);cnt++;}
			ans = min(ans,cnt);
		}
	}
	if(ans!=50)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem3887

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e5+5;
int n,m;
struct E
{
	int next,to;
};
struct G
{
	E e[M];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}
}g,g1,gf;
bool ret[N];
bool vis[N],ins[N];
int dep[N],low[N],stack[N],bel[N],top,dfn,scc,val[N];
void tarjan(int x)
{
	vis[x] = ins[x] = true;
	stack[++top] =x;
	dep[x] = low[x] = ++dfn;
	for(int i = g.head[x];i;i = g.e[i].next)
	{
		int u = g.e[i].to;
		if(!vis[u])
		{tarjan(u);low[x] = min(low[x],low[u]);}
		else if(ins[u])
		{low[x] = min(low[x],dep[u]);}
	}
	if(dep[x]==low[x])
	{
		scc++;
		int tmp;
		do{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = scc;
			val[scc]++;
		}while(tmp!=x);
	}
}
void rebuild()
{
	for(int i = 1;i<= n;i++)
		for(int j = g.head[i];j;j= g.e[j].next)
		{
			int u = g.e[j].to;
			if(bel[i]!=bel[u])
			{
				g1.add(bel[i],bel[u]);
				if(i==1)ret[bel[u]] = true;
				gf.add(bel[u],bel[i]);
			}
		}
}
int dis[2][N];
bool v[N];
queue<int>Q;
void spfa(int s)
{
	memset(dis,-1,sizeof(dis));
	dis[0][s] = val[s];
	Q.push(s);
	v[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]= false;
		for(int i = g1.head[x];i;i = g1.e[i].next)
		{
			int u = g1.e[i].to;
			if(dis[0][x]+val[u]>dis[0][u])
			{
				dis[0][u] = dis[0][x]+val[u];
				if(!v[u])
				{
					Q.push(u);
					v[u] = true;
				}
			}
		}
	}
	Q.push(s);
	v[s] = true;
	dis[1][s] = val[s];
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		v[x] = false;
		for(int i = gf.head[x];i;i=gf.e[i].next)
		{
			int u = gf.e[i].to;
			if(dis[1][x]+val[u]>dis[1][u])
			{
				dis[1][u] = dis[1][x]+val[u];
				if(!v[u])
				{
					Q.push(u);
					v[u] = true;
				}
			}
		}
	}
}
int main()
{
	//freopen("wander.in","r",stdin);
	//freopen("wander.out","w",stdout);
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		g.add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	rebuild();
	spfa(bel[1]);
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = g.head[i];j;j= g.e[j].next)
		{
			int u = g.e[j].to;
			if(bel[i]!=bel[u])
				if(dis[0][bel[u]]!=-1&&dis[1][bel[i]]!=-1)
					ans = max(ans,dis[0][bel[u]]+dis[1][bel[i]]-val[bel[1]]);
		}
	printf("%d\n",ans);
	return 0;
}
Problem3889

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
typedef long long LL;
using namespace std;
const int N = 1005;
LL INF;
int city[N];
bool v[N];
int d2[N],k2[N][N],n;
LL d1[N],k1[N][N];
queue<int>Q;
void spfa(int s)
{
	memset(d1,0x3f,sizeof(d1));
	memset(d2,0x3f,sizeof(d2));
	d1[s] = 0;d2[s] = 0;
	v[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = 1;i<= n;i++)
		{
			if(k1[x][i]==INF)continue;
			if(d1[x]+k1[x][i]<d1[i])
			{
				d1[i] = d1[x]+k1[x][i];
				d2[i] = d2[x]+k2[x][i];
				if(!v[i])Q.push(i),v[i] = true;
			}else if(d1[x]+k1[x][i]>d1[i])continue;
			else if(d2[x]+k2[x][i]<d2[i])
			{
				d2[i] = d2[x]+k2[x][i];
				if(!v[i])Q.push(i),v[i] = true;
			}
		}
	}
}
int main()
{
	memset(k1,0x3f,sizeof(k1));
	memset(k2,0x3f,sizeof(k2));
	INF = k1[0][0];
	int s,t,m;
	scanf("%d%d%d",&s,&t,&m);
	for(int i = 1;i<= m;i++)
	{
		int cost,len;
		scanf("%d%d",&cost,&len);
		for(int j = 1;j<= len;j++)
		{
			scanf("%d",&city[j]);
			n = max(n,city[j]);
		}
		for(int j = 1;j<= len;j++)
			for(int k = j+1;k<= len;k++)
			{
				if(k1[city[j]][city[k]]==cost)
					k2[city[j]][city[k]] = min(k2[city[j]][city[k]],k-j);
				if(k1[city[j]][city[k]]>cost)
				{
					k1[city[j]][city[k]] = cost;
					k2[city[j]][city[k]] = k-j;
				}
			}
	}
	spfa(s);
	if(d1[t]!=INF)printf("%lld %d\n",d1[t],d2[t]);
	else printf("-1 -1\n");
	return 0;
}
Problem3890

#include <stdio.h>
#include <queue>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
struct E
{int next,to,val1,val2;}e[N*N];
int head[N],tot;
int d[N];
void add(int x,int y,int f1,int f2)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val1 = f1;
	e[tot].val2 = f2;
	head[x] = tot;
}
bitset<10005>f[N],g[N];
queue<int>Q;
int main()
{
	int n,m,x,y,u,v;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&v);
		add(x,y,u,v);
		d[y]++;
	}
	for(int i = 1;i<= n;i++)
		if(!d[i])
			Q.push(i);
	f[1] = g[1] = 1;
	while(!Q.empty())
	{
		x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
		{
			f[e[i].to]|=f[x]<<e[i].val1;
			g[e[i].to]|=g[x]<<e[i].val2;
			if(!--d[e[i].to])
				Q.push(e[i].to);
		}
	}
	for(int i = 1;i<= 10000;i++)
		if(f[n][i]&&g[n][i])
		{
			printf("%d\n",i);
			return 0;
		}
	printf("IMPOSSIBLE\n");
	return 0;
}
Problem3894

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 30005;
const int M = 1000005;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	int x;
	while(!Q.empty())
	{
		x = Q.front();Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow!=0)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow!=0&&d[e[i].to]==d[s]+1)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int id,n,m;
inline int getid(int x,int y)
{
	return (x-1)*m+y;
}
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int main()
{
	int sum = 0,x;
	scanf("%d%d",&n,&m);
	id = n*m+1;
	int st = 0,end = id;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			add(0,getid(i,j),x);sum+=x;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),id,x);sum+=x;
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			++id;
			scanf("%d",&x);
			add(0,id,x);sum+=x;
			add(id,getid(i,j),INF);
			for(int k = 0;k<4;k++)
			{
				int tx = i+dx[k],ty = j+dy[k];
				if(tx&&ty&&tx<=n&&ty<=m)add(id,getid(tx,ty),INF);
			}
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			++id;
			scanf("%d",&x);
			add(id,end,x);sum+=x;
			add(getid(i,j),id,INF);
			for(int k = 0;k<4;k++)
			{
				int tx = i+dx[k],ty = j+dy[k];
				if(tx&&ty&&tx<=n&&ty<=m)add(getid(tx,ty),id,INF);
			}
		}
	sum = sum-dinic(st,end);
	printf("%d\n",sum);
	return 0;
}
Problem3924

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct E
{int next,to,val;};
int pos[N],n,q;
namespace Tree
{
	E e[N<<1];
	int head[N],tot,dis[N],dep[N],fa[N],lg2[N<<1];
	int a[N<<1][20],cnt;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].val = f;
	}
	void dfs(int x)
	{
		static int T=0;
		dep[x] = dep[fa[x]]+1;
		a[pos[x] = ++T][0] = dis[x];
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				dis[e[i].to] = dis[x]+e[i].val;
				dfs(e[i].to);
				a[++T][0] = dis[x];
			}
	}
	void init()
	{
		for(int i = 2;i<(N<<1);i++)
			lg2[i] = lg2[i>>1]+1;
		for(int j = 1;j<= 19;j++)
			for(int i = 1;i+(1<<(j-1))<=(n<<1);i++)
				a[i][j] = min(a[i][j-1],a[i+(1<<(j-1))][j-1]);
	}
	int getlca(int x,int y)
	{
		int l = pos[x],r = pos[y];
		if(l>r)swap(l,r);
		int lth = lg2[r-l+1];
		return min(a[l][lth],a[r-(1<<lth)+1][lth]);
	}
	int getdis(int x,int y)
	{
		return dis[x]+dis[y]-2*getlca(x,y);
	}
};
namespace New_Tree
{
	E e[N<<1];
	int head[N],tot,fa[N];
	ll dis_sum1[N],dis_sum2[N],sum1[N],sum2[N],ROOT;
	void add(int x,int y,int z)
	{
		e[++tot].to = y;
		e[tot].val = z;
		e[tot].next = head[x];
		head[x] =tot;
	}
	int root,sum,f[N],size[N];
	bool used[N];
	void get_root(int x,int pre)
	{
		size[x] = 1;
		f[x] =0;
		for(int i = Tree::head[x];i;i=Tree::e[i].next)
			if(Tree::e[i].to!=pre&&!used[Tree::e[i].to])
			{
				get_root(Tree::e[i].to,x);
				size[x]+=size[Tree::e[i].to];
				f[x] = max(f[x],size[Tree::e[i].to]);
			}
		f[x] = max(f[x],sum-size[x]);
		if(f[x]<f[root])root = x;
	}
	void work(int x)
	{
		used[x] = true;
		for(int i = Tree::head[x];i;i=Tree::e[i].next)
		{
			int to = Tree::e[i].to;
			if(used[to])continue;
			sum = size[to],root = 0;
			get_root(to,0);
			fa[root] = x;
			add(x,root,to);
			work(root);
		}
	}
	void update(int x,int y)
	{
		sum1[x]+=y;
		for(int i = x;fa[i];i=fa[i])
		{
			int dis = Tree::getdis(x,fa[i]);
			dis_sum1[fa[i]]+=(ll)dis*y;
			dis_sum2[i]+=(ll)dis*y;
			sum1[fa[i]]+=y;
			sum2[i]+=y;
		}
		return ;
	}
	ll calc(int x)
	{
		ll ans = dis_sum1[x];
		for(int i = x;fa[i];i=fa[i])
		{
			int dis = Tree::getdis(x,fa[i]);
			ans+=dis_sum1[fa[i]]-dis_sum2[i];
			ans+=(sum1[fa[i]]-sum2[i])*dis;
		}
		return ans;
	}
	ll getans(int x)
	{
		ll cst = calc(x);
		for(int i = head[x];i;i=e[i].next)
		{
			ll tmp = calc(e[i].val);
			if(tmp<cst)
				return getans(e[i].to);
		}
		return cst;
	}
};
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		Tree::add(x,y,c);
	}
	Tree::dfs(1);
	Tree::init();
	New_Tree::f[0] = New_Tree::sum = n;
	New_Tree::root = 0;
	New_Tree::get_root(1,0);
	New_Tree::ROOT = New_Tree::root;
	New_Tree::work(New_Tree::root);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&x,&y);
		New_Tree::update(x,y);
		ll ans = New_Tree::getans(New_Tree::ROOT);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem3925

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<10;
typedef long long ll;
double f[50][N],g[50][N];
int sz[N],cnt[N];
ll c[50][50];
int e[11];
int main()
{
	int n,m,u,v;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&u,&v);
		u--,v--;
		e[u]|=1<<v;
		e[v]|=1<<u;
	}
	c[0][0] = 1;
	for(int i = 1;i<50;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<50;j++)
			c[i][j] = c[i-1][j-1]+c[i-1][j];
	}
	for(int s = 1;s<1<<n;s++)
	{
		sz[s] = sz[s>>1]+(s&1);
		if(sz[s]==1)
		{
			g[0][s] = 1;
			continue;
		}
		for(int i = 0;i<n;i++)
			if(s&(1<<i))
				cnt[s]+=sz[s&e[i]];
		cnt[s]/=2;
		int lb = s&(-s);
		for(int k = (s-1)&s;k;k = s&(k-1))
			if(k&lb)
				for(int i = 0;i<=cnt[k];i++)
					for(int j = 0;j<=cnt[s^k];j++)
						f[i+j][s]+=g[i][k]*c[cnt[s^k]][j];
		for(int i = 0;i<=cnt[s];i++)
			g[i][s] = c[cnt[s]][i]-f[i][s];
	}
	double ans = 0;
	int end = (1<<n)-1;
	for(int i = 0;i<= m;i++)
		ans+=(double)f[i][end]/(double)c[cnt[end]][i];
	ans/=(double)(m+1);
	printf("%.6lf\n",ans);
	return 0;
}
Problem3926

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 4e6+5;
struct E
{int next,to;};
E e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int ch[M][10],fa[M],len[M],last,cnt;
int insert(int p,int x)
{
	int np = ++cnt,q,nq;
	last = np,len[np] = len[p]+1;
	for(;p&&!ch[p][x];p = fa[p])ch[p][x] = np;
	if(!p)fa[np] = 1;
	else
	{
		q = ch[p][x];
		if(len[q]==len[p]+1)fa[np] = q;
		else
		{
			fa[nq=++cnt] = fa[q];
			len[nq] = len[p]+1;
			memcpy(ch[nq],ch[q],sizeof(ch[q]));
			fa[np] = fa[q] = nq;
			for(;p&&ch[p][x]==q;p=fa[p])ch[p][x]=nq;
		}
	}
	return last;
}
long long ans;
void solve()
{
	for(int i=1;i<= cnt;i++)
		ans+=len[i]-len[fa[i]];
}
int id[N],val[N],ind[N];
void dfs(int x,int f,int p)
{
	int t = insert(p,val[x]);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x,t);
}
int main()
{
	int n,c,x,y;
	scanf("%d%d",&n,&c);
	for(int i = 1;i<= n;i++)scanf("%d",&val[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
		ind[x]++,ind[y]++;
	}
	id[0] = 1;
	cnt = 1;
	for(int i = 1;i<= n;i++)
		if(ind[i]==1)
			dfs(i,0,1);
	solve();
	printf("%lld\n",ans);
	return 0;
}
Problem3930

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
int d[2*N];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{
	ll n,k,a,b;
	scanf("%lld%lld%lld%lld",&n,&k,&a,&b);
	ll l = a/k,r=b/k;
	if(a%k)l++;
	for(int i = N-5;i>=1;i--)
	{
		ll L = l/i,R = r/i;
		if(l%i)L++;
		if(l<=r)
		{
			d[i]=quick_pow(R-L+1,n%(mod-1));
			d[i]=(d[i]-(R-L+1)+mod)%mod;
			for(int j = i*2;j<N;j+=i)
				d[i]=(d[i]-d[j]+mod)%mod;
		}
	}
	if(l==1)d[1] = (d[1]+1)%mod;
	printf("%d\n",d[1]);
	return 0;
}
Problem3931

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1005;
const int M = 500005;
const ll INF = 1e18;
const int inf = 0x3f3f3f3f;
struct E
{int next,to;ll f;};
ll dis[N];
int d[N];
bool v[N];
queue<int>Q;
struct G
{
	int head[N],tot;
	E e[M];
	void addE(int x,int y,int z)
	{e[++tot].to=y;e[tot].next = head[x];head[x]=tot;e[tot].f=z;}
	void addF(int x,int y,ll f)
	{
		e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;head[x]=tot;
		e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;head[y]=tot;
	}
	void spfa(int s,int n)
	{
		for(int i = 1;i<= n;i++)dis[i]=INF;
		dis[s]=0;v[s]=true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(dis[x]+e[i].f<dis[e[i].to])
				{
					dis[e[i].to]=dis[x]+e[i].f;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to]=true;
					}
				}
		}
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[t]=0;
		Q.push(t);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(d[e[i].to]==-1&&e[i^1].f)
				{
					d[e[i].to] = d[x]+1;
					Q.push(e[i].to);
				}
		}
		return d[s]!=-1;
	}
	ll get_maxflow(int s,int t,ll mf)
	{
		if(s==t)return mf;
		ll last = mf;
		for(int i = head[s];i;i=e[i].next)
			if(d[e[i].to]==d[s]-1&&e[i].f)
			{
				ll tof = get_maxflow(e[i].to,t,min(e[i].f,last));
				if(tof)
				{
					e[i].f-=tof;
					e[i^1].f+=tof;
					if(!(last-=tof))return mf;
				}
			}
		d[s]=-1;
		return mf-last;
	}
	ll dinic(int s,int t)
	{
		ll ans=0,nowflow;
		while(bfs(s,t))
			while((nowflow=get_maxflow(s,t,INF)))
				ans+=nowflow;
		return ans;
	}
}F,G;
int c[N],x[M],y[M],z[M];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&z[i]);
		G.addE(x[i],y[i],z[i]);
		G.addE(y[i],x[i],z[i]);
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	G.spfa(1,n);
	F.tot = 1;
	for(int i = 1;i<= m;i++)
	{
		if(dis[x[i]]+z[i]==dis[y[i]])
			F.addF(x[i]+n,y[i],INF);
		if(dis[y[i]]+z[i]==dis[x[i]])
			F.addF(y[i]+n,x[i],INF);
	}
	for(int i = 1;i<= n;i++)
		F.addF(i,i+n,c[i]);
	ll ans = F.dinic(n+1,n);
	printf("%lld\n",ans);
	return 0;
}
Problem3932

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 4000005;
typedef long long ll;
int ls[M],rs[M],sum[M],ans[M];
int root[N],n,m;
int a[N];
int st[N],ed[N],cnt;
struct P
{int val,id;}T[N];
bool cmpT(P a,P b){return a.val<b.val;}
struct Up
{int pos,val,aa;}ask[N<<1];
int cnt_ask;
bool cmp(Up a,Up b){return a.pos<b.pos;}
int a_T[N];
void init()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&st[i],&ed[i],&a[i]);
		ask[++cnt_ask] = (Up){st[i],1,i};
		ask[++cnt_ask] = (Up){ed[i]+1,-1,i};
		T[i] = (P){a[i],i};
	}
	sort(T+1,T+n+1,cmpT);
	for(int i = 1;i<= n;i++)
		a_T[T[i].id] = i;
	sort(ask+1,ask+cnt_ask+1,cmp);
}
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p]=sum[pre]+val;
		ans[p]=ans[pre]+val*T[l].val;
		return ;
	}
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
	sum[p] = sum[ls[p]]+sum[rs[p]];
	ans[p] = ans[ls[p]]+ans[rs[p]];
}
ll Ans;
void getans(int p,int k)
{
	int l = 1,r = n;
	Ans = 0;
	p = root[p];
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[ls[p]]>=k)
			p = ls[p],r = mid;
		else
			Ans+=ans[ls[p]],k-=sum[ls[p]],p = rs[p],l = mid+1;
	}
	Ans+=ans[p];
	printf("%lld\n",Ans);
}
int main()
{
	init();
	int j=1;
	for(int i = 1;i<= n;i++)
	{
		root[i] = root[i-1];
		while(j<=cnt_ask&&ask[j].pos==i)
		{
			update(root[i],root[i],1,n,a_T[ask[j].aa],ask[j].val);
			j++;
		}
	}
	int x,a,b,c,k;
	Ans=1;
	while(m--)
	{
		scanf("%d%d%d%d",&x,&a,&b,&c);
		k = ((ll)a*Ans+b)%c+1;
		//scanf("%d%d",&x,&k);
		getans(x,k);
	}
	return 0;
}
Problem3940

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 1e5+5;
int ch[N][26],fail[N];
int sum[N],cnt;
char s[N];
void insert()
{
	int now = 0,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)] = ++cnt;
		now = ch[now][s(i)];
		i++;
	}
	sum[now]=i;
}
int q[N],h,t;
void build()
{
	h = 0,t = -1;
	for(int i = 0;i<26;i++)
		if(ch[0][i])
			q[++t]=ch[0][i];
	while(h<=t)
	{
		int x= q[h++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[fail[x]][i];
			if(ch[x][i])
			{
				fail[ch[x][i]] = j;
				q[++t]=ch[x][i];
			}else
				ch[x][i] = j;
		}
	}
}
char str[N],st1[N];
int st2[N],top;
int main()
{
	scanf("%s",str);
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		insert();
	}
	build();
	int now = 0;
	for(int i = 0;str[i];i++)
	{
		st1[++top] = str[i];
		now = ch[now][str[i]-'a'];
		st2[top] = now;
		if(sum[now])
		{
			top-=sum[now];
			now = st2[top];
		}
	}
	for(int i = 1;i<= top;i++)printf("%c",st1[i]);
	return 0;
}
Problem3942

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
char A[N],B[N];
int fail[N],f[N],pos[N];
int main()
{
	scanf("%s",A+1);
	scanf("%s",B+1);
	int lenA = strlen(A+1),lenB = strlen(B+1);
	int j = 0;
	for(int i = 2;i<= lenB;i++)
	{
		while(B[i]!=B[j+1]&&j)
			j = fail[j];
		if(B[i]==B[j+1])j++;
		fail[i] = j;
	}
	for(int i = 1;i<= lenA;i++)
	{
		j = f[pos[pos[0]]];
		while(A[i]!=B[j+1]&&j)
			j = fail[j];
		if(A[i]==B[j+1])j++;
		if(j==lenB)pos[0]-=lenB-1;
		else {f[i] = j;pos[++pos[0]] = i;}
	}
	for(int i = 1;i<= pos[0];i++)
		printf("%c",A[pos[i]]);
	return 0;
}
Problem3944

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int M = 2e6+5;
const int N = 1e5+5;
const int m = 2e6;
bool v[M];
int prime[M],cnt,n;
ll mu[M],phi[M],p[N],q[N];
bool vis[N];
void quick_shai()
{
	phi[1] = mu[1] = 1;
	for(int i = 2;i<M;i++)
	{
		if(!v[i])
		{
			phi[i] = i-1;
			mu[i] = -1;
			prime[++cnt] = i;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<M;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])
			{
				mu[i*prime[j]] = -mu[i];
				phi[i*prime[j]] = phi[i]*(prime[j]-1);
			}else
			{
				mu[i*prime[j]] = 0;
				phi[i*prime[j]] = phi[i]*prime[j];
				break;
			}
		}
	}
	for(int i = 1;i<M;i++)
		phi[i]+=phi[i-1],mu[i]+=mu[i-1];
}
ll getp(int x)
{
	if(x<=m)return phi[x];
	else return p[n/x];
}
ll getq(int x)
{
	if(x<=m)return mu[x];
	else return q[n/x];
}
void solve(int x)
{
	if(x<=m)return ;
	int i,j = 1,t=n/x;
	if(vis[t])return ;
	vis[t] = true;
	p[t] = ((ll)x+1)*x/2;q[t] = 1;
	while(j<x)
	{
		i = j+1;
		j = x/(x/i);
		solve(x/i);
		q[t]-=getq(x/i)*(j-i+1);
		p[t]-=getp(x/i)*(j-i+1);
	}
}
int main()
{
	quick_shai();
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(vis,0,sizeof(vis));
		scanf("%d",&n);
		if(n<=m)printf("%lld %lld\n",phi[n],mu[n]);
		else
		{
			solve(1ll*n);
			printf("%lld %lld\n",p[1],q[1]);
		}
	}
	return 0;
}
Problem3963

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	int d,p,r,g,id;
	ll x,y;
	void read()
	{
		scanf("%d%d%d%d",&d,&p,&r,&g);
		x = g,y = r-p-(ll)d*g-g;
	}
}a[N],t[N];
struct Point
{
	ll x,y;
	Point(ll _x=0,ll _y=0):x(_x),y(_y){}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double operator *(const Point &a,const Point &b)
	{return (double)a.x*b.y-(double)a.y*b.x;}
}ch[N],p[N];
ll f[N];
inline bool cmp1(const data &a,const data &b)
{return a.d<b.d;}
inline bool cmp2(int i,int j)
{return a[i].x==a[j].x?a[i].y+f[a[i].id]<a[j].y+f[a[j].id]:a[i].x<a[j].x;}
inline ll Val(ll k,const Point &p){return k*p.x+p.y;}
void solve(int l,int r)
{
	if(l==r){f[l] = max(f[l-1],f[l]);return ;}
	int mid = (l+r)>>1;
	solve(l,mid);
	int n = 0,m = 0;
	for(int i = l;i<= mid;i++)if(f[a[i].id]>=a[i].p)
		p[++n] = Point(a[i].x,a[i].y+f[a[i].id]);
	for(int i = 1;i<= n;i++)
	{
		while(m>1&&(ch[m]-ch[m-1])*(p[i]-ch[m-1])>=0)m--;
		ch[++m] = p[i];
	}
	int j = 1;
	for(int i = mid+1;i<= r;i++)
	{
		while(j<m&&Val(a[i].d,ch[j+1])>=Val(a[i].d,ch[j]))j++;
		if(j<=m)f[i] = max(f[i],Val(a[i].d,ch[j]));
	}
	solve(mid+1,r);
	int p1 = l,p2 = mid+1;
	for(int i = l;i<=r;i++)
	{
		if(p2>r||(p1<=mid&&cmp2(p1,p2)))t[i]=a[p1++];
		else t[i] = a[p2++];
	}
	for(int i = l;i<= r;i++)a[i]=t[i];
}
int main()
{
	int n,d;
	int cas = 0;
	while(scanf("%d%lld%d",&n,&f[0],&d)!=EOF)
	{
		if(n==0&&f[0]==0&&d==0)break;
		for(int i = 1;i<= n;i++)a[i].read();
		a[++n].d = d+1;
		sort(a+1,a+n+1,cmp1);
		for(int i = 1;i<= n;i++)a[i].id = i,f[i] = 0;
		solve(1,n);
		printf("Case %d: %lld\n",++cas,f[n]);
	}
	return 0;
}
Problem3992

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MOD = 1004535809;
const int M = 16400;
const int G = 3;
int n,m,d,X,S;
int ind[M];
ll quick_pow(ll x,ll y,ll mod)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1,mod);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void NTT(int a[],int len,int type)
{
	static int tmp[M];
	if(len==1)return ;
	for(int i = 0;i<len;i+=2)
		tmp[i>>1] = a[i],tmp[(i+len)>>1]=a[i+1];
	memcpy(a,tmp,sizeof(a[0])*len);
	int *l = a,*r = a+(len>>1);
	NTT(l,len>>1,type);
	NTT(r,len>>1,type);
	ll w = quick_pow(G,(ll)type*(MOD-1)/len%(MOD-1),MOD),wn=1;
	for(int i = 0;i<(len>>1);i++,(wn*=w)%=MOD)
		tmp[i]=(l[i]+wn*r[i]%MOD)%MOD,tmp[i+(len>>1)]=((l[i]-wn*r[i]%MOD)%MOD+MOD)%MOD;
	memcpy(a,tmp,sizeof(a[0])*len);
	return ;
}
struct F
{
	int a[M];
	F(){}
	F(bool x)
	{
		memset(a,0,sizeof(a));
		a[0]=1;
	}
	int& operator[](int x)
	{
		return a[x];
	}
	F& operator*=(const F &s)
	{
		static int b[M];
		memcpy(b,s.a,sizeof(b));
		NTT(a,d,1);
		NTT(b,d,1);
		for(int i = 0;i<d;i++)
			a[i]=(ll)a[i]*b[i]%MOD;
		NTT(a,d,MOD-2);
		for(int i = m-1;i<= (m-2)<<1;i++)
			(a[i-(m-1)]+=a[i])%=MOD,a[i]=0;
		ll inv = quick_pow(d,MOD-2,MOD);
		for(int i=0;i<=m-2;i++)
			a[i]=a[i]*inv%MOD;
		return *this;
	}
}f;
int GPR()
{
	static int s[30];
	int x = m-1;
	for(int i = 2;i*i<=x;i++)
		if(x%i==0)
		{
			s[++s[0]]=i;
			while(x%i==0)x/=i;
		}
	if(x!=1)s[++s[0]]=x;
	for(int g = 2;;g++)
	{
		int j;
		for(j = 1;j<=s[0];j++)
			if(quick_pow(g,(m-1)/s[j],m)==1)
				break;
		if(j==s[0]+1)return g;
	}
}
F Quick_pow(F &a,int y)
{
	F re(true);
	while(y)
	{
		if(y&1)re*=a;
		a*=a,y>>=1;
	}
	return re;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&X,&S);
	for(d=1;d<=m+m;d<<=1);
	int g = GPR();
	for(int i = 0,x=1;i<m-1;i++,(x*=g)%=m)
		ind[x]=i;
	int x;
	for(int i = 1;i<= S;i++)
	{
		scanf("%d",&x);
		if(!x)continue;
		f[ind[x]] = 1;
	}
	F ans = Quick_pow(f,n);
	printf("%d\n",ans[ind[X]]);
	return 0;
}
Problem3995

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
int a[N][2],b[N],n,m;
struct data
{
	int l,r,sum;
	int mx,cnt;
	int lmx,rmx,lv,rv;
	data(){}
	data(int pos)
	{
		int x = b[pos];
		l = r = pos;
		sum = x;
		mx = 0,cnt=1;
		lmx=rmx=lv=rv=x;
	}
	friend data operator+(const data &x,const data &y)
	{
		data res;
		res.l = x.l,res.r = y.r;
		res.mx = max(max(a[x.r][0],a[x.r][1]),max(x.mx,y.mx));
		int max_val = max(max(a[x.r][0],a[x.r][1]),max(x.rmx,y.lmx));
		res.sum = x.sum+y.sum+a[x.r][0]+a[x.r][1]-max_val;
		res.cnt = x.cnt+y.cnt;
		res.lv = x.lv,res.rv = y.rv;
		res.lmx = x.lmx,res.rmx = y.rmx;
		if(x.rv==max_val)
		{
			res.cnt--;
			if(x.cnt==1)
			{
				res.lv = y.lv;
				res.lmx = max(max(x.mx,y.lmx),max(a[x.r][0],a[x.r][1]));
			}
		}else if(y.lv==max_val)
		{
			res.cnt--;
			if(y.cnt==1)
			{
				res.rv = x.rv;
				res.rmx = max(max(y.mx,x.rmx),max(a[x.r][0],a[x.r][1]));
			}
		}
		return res;
	}
}tr[N<<3];
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p] = data(l);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
void update1(int p,int l,int r,int pos)
{
	if(l==r)
	{
		tr[p] = data(l);
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update1(p<<1,l,mid,pos);
	else update1(p<<1|1,mid+1,r,pos);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
void update2(int p,int l,int r,int pos)
{
	int mid = (l+r)>>1;
	if(mid==pos)
	{
		tr[p] = tr[p<<1]+tr[p<<1|1];
		return ;
	}
	if(pos<=mid)
		update2(p<<1,l,mid,pos);
	else update2(p<<1|1,mid+1,r,pos);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
data getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans(p<<1|1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans(p<<1|1,mid+1,r,a,b);
}
void update(int x0,int y0,int x1,int y1,int z)  
{  
    if(y0==y1)//修改了一条竖边  
    {  
        b[y0]=z;  
        update1(1,1,n,y0);  
    }  
    else//修改了一条横边  
    {  
        if(y0>y1) swap(y0,y1);  
        a[y0][x0-1]=z; 
        update2(1,1,n,y0); 
    }  
}  
int main()
{
	scanf("%d%d",&n,&m);
	for(int j = 0;j<2;j++)
		for(int i = 1;i<= n-1;i++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);
	build(1,1,n);
	char opt[3];
	int x0,y0,x1,y1,w;
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='C')
		{
			scanf("%d%d%d%d%d",&x0,&y0,&x1,&y1,&w);
			update(x0,y0,x1,y1,w);
		}else
		{
			scanf("%d%d",&x0,&y0);
			data ans = getans(1,1,n,x0,y0);
			printf("%d\n",ans.sum);
		}
	}
	return 0;
}
Problem3996

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 4e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];e[tot].flow=f;head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];e[tot].flow=0;head[y]=tot;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t]=0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i=head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int main()
{
	int n,x,sum=0;
	scanf("%d",&n);
	int st = 0,end = n*n+n+1,id = n;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
		{
			id++;
			scanf("%d",&x);
			add(i,id,INF),add(j,id,INF);
			add(id,end,x);
			sum+=x;
		}
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		add(st,i,x);
	}
	printf("%d\n",sum-dinic(st,end));

	return 0;
}
Problem4001

#include <stdio.h>
int main()
{
	double x;
	scanf("%lf",&x);
	printf("%.9lf",x*(x+1)/2/(2*x-1));
}
Problem4002

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ll;
const ll mod = 7528443412579576937ll;
ll quick_plus(ll x,ll y)
{
	if(y==0)return 0;
	ll tmp = quick_plus(x,y>>1);
	if(y&1)return ((tmp+tmp)%mod+x)%mod;
	else return (tmp+tmp)%mod;
}
struct Matrix
{
	ll d[2][2];
	Matrix(){memset(d,0,sizeof(d));}
	void operator*=(const Matrix &s)
	{
		Matrix res;
		for(int i = 0;i<2;i++)for(int k = 0;k<2;k++)if(d[i][k])
			for(int j = 0;j<2;j++)
				(res.d[i][j]+=quick_plus(d[i][k],s.d[k][j]))%=mod;
		*this = res;
	}
	friend Matrix quick_pow(Matrix x,ll y)
	{
		Matrix ans;
		for(int i = 0;i<2;i++)ans.d[i][i]=1;
		while(y)
		{
			if(y&1)ans*=x;
			x*=x;
			y>>=1;
		}
		return ans;
	}
}a;
int main()
{
	ll b,d,n;
	scanf("%llu%llu%llu",&b,&d,&n);
	a.d[0][0] = 0;
	a.d[1][0] = 1;
	a.d[0][1] = (d-b*b)/4;
	a.d[1][1] = b;
	Matrix ans = quick_pow(a,n);
	ll Ans = (quick_plus(ans.d[0][0],2)+quick_plus(ans.d[1][0],b))%mod;
	Ans = Ans-(b!=d*d&&(~n&1));
	printf("%llu\n",(Ans+mod)%mod);
	return 0;
}
Problem4003

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
typedef long long ll;
const ll INF = 1e18;
int root[N],fa[N],d[N],a[N],death[N],ans[N];
ll h[N],v[N];
struct Merge_Heap
{
	#define ls son[p][0]
	#define rs son[p][1]
	int son[N][2],cnt;
	int id[N],level[N],exper[N];ll val[N],add[N],mul[N];
	void Push_down(int p)
	{
		if(mul[p]!=1)
		{
			val[p] = val[p]*mul[p];
			mul[ls]*=mul[p],mul[rs]*=mul[p];
			add[ls]*=mul[p],add[rs]*=mul[p];
			mul[p] = 1;
		}
		if(add[p])
		{
			val[p] = val[p]+add[p];
			add[ls]+=add[p],add[rs]+=add[p];
			add[p] = 0;
		}
		if(exper[p])
		{
			level[p]+=exper[p];
			exper[ls]+=exper[p],exper[rs]+=exper[p];
			exper[p] = 0;
		}
	}
	int merge(int x,int y)
	{
		if(!x||!y)return x+y;
		Push_down(x),Push_down(y);
		if(val[x]>val[y])swap(x,y);
		int tmp = rand()&1;
		son[x][tmp] = merge(son[x][tmp],y);
		return x;
	}
	void init(int p,ll _val,int _id)
	{
		++cnt;
		val[cnt] = _val,id[cnt] = _id;
		mul[cnt] = 1,add[cnt] = 0;
		root[p] = merge(root[p],cnt);
	}
	void Fight(int k)
	{
		for(int p = root[k];p;p=root[k])
		{
			Push_down(p);
			if(val[p]>=h[k])return ;
			ans[id[p]] = level[p];
			death[k]++;
			root[k] = merge(ls,rs);
		}
	}
	void Go(int k)
	{
		Push_down(root[k]);
		if(a[k])mul[root[k]]=v[k];
		else add[root[k]]=v[k];
		exper[root[k]]++;
		root[fa[k]] = merge(root[fa[k]],root[k]);
	}
}mh;
int stack[N],top;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lld",&h[i]);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d%lld",&fa[i],&a[i],&v[i]);
		d[fa[i]]++;
	}
	int s;ll c;
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%d",&c,&s);
		mh.init(s,c,i);
	}
	d[0] = 1,h[0] = INF;
	for(int i = 1;i<= n;i++)if(!d[i])stack[++top]=i;
	while(top)
	{
		int x = stack[top];
		top--;
		mh.Fight(x);
		if(x)
		{
			mh.Go(x);
			d[fa[x]]--;
			if(!d[fa[x]])stack[++top]=fa[x];
		}
	}
	for(int i = 1;i<= n;i++)
		printf("%d\n",death[i]);
	for(int i = 1;i<= m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4004

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
typedef long long ll;
const int mod = 1e9+7;
int b[N];
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
struct P
{
	int a[N];
	int val;
	bool operator <(const P &s)const
	{
		return val<s.val;
	}
}p[N];

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&p[i].a[j]);
	for(int i = 1;i<= n;i++)scanf("%d",&p[i].val);
	sort(p+1,p+n+1);
	int ans = 0,ansv = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(p[i].a[j])
			{
				if(!b[j])
				{
					b[j] = i;
					ans++;
					ansv+=p[i].val;
					break;
				}else
				{
					int tmp = (ll)p[i].a[j]*quick_pow(p[b[j]].a[j],mod-2)%mod;
					for(int k = j;k<= m;k++)
						p[i].a[k]=(p[i].a[k]-(ll)p[b[j]].a[k]*tmp%mod+mod)%mod;
				}
			}
	printf("%d %d\n",ans,ansv);
	return 0;
}
Problem4006

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<10;
const int N = 1005;
const int M = 6005;
const int P = 15;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
int head[N],tot,cnt,n,m,p;
void add(int x,int y,int f)
{
    e[++tot].to = y;
    e[tot].next = head[x];
    e[tot].val = f;
    head[x] = tot;
    e[++tot].to = x;
    e[tot].next = head[y];
    e[tot].val = f;
    head[y] = tot;
}
struct Point{int c,d;}po[P];
bool cmp(Point a,Point b){return a.c<b.c;}
int dis[S][N];
int g[S];
int Q[65540];
unsigned short l,r;
bool v[N];
void spfa(int dis[])
{
    while(l!=r)
    {
        int x = Q[l];
        l++;
        v[x] = false;
        for(int i = head[x];i;i = e[i].next)
        {
            if(dis[x]+e[i].val<dis[e[i].to])
            {
                dis[e[i].to] = dis[x]+e[i].val;
                if(!v[e[i].to])
                {
                    v[e[i].to] = true;
                    Q[r++] = e[i].to;
                }
            }
        }
    }
}
int DP()
{
    l = 1,r = 1;
    for(int i = 1;i<1<<cnt;i++)
    {
        //memset(v,0,sizeof(v));
        for(int j = 1;j<= n;j++)
        {
            for(int k = i&(i-1);k;k = (k-1)&i)
                dis[i][j] = min(dis[k][j]+dis[i^k][j],dis[i][j]);
            if(dis[i][j]!=INF){Q[r++] = j;v[j] = true;}
        }
        spfa(dis[i]);
    }
    int ans = INF;
    for(int i = 1;i<= n;i++)
        ans = min(ans,dis[(1<<cnt)-1][i]);
    return ans;
}
int main()
{
    int x,y,z;
    scanf("%d%d%d",&n,&m,&p);
    for(int i = 1;i<= m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
    }
    for(int i = 1;i<= p;i++)
        scanf("%d%d",&po[i].c,&po[i].d);
    int col = 0;
    int true_col[20]={};
    sort(po+1,po+p+1,cmp);
    for(int i=1;i<=p;i++)
    {
        if(i==1||po[i].c!=po[i-1].c)
            ++col;
        true_col[i]=col;
    }
    for(int i=1;i<=p;i++)
        po[i].c = true_col[i];
    memset(g,0x3f,sizeof(g));
    int end = 1<<col;
    for(int i = 0;i<end;i++)
    {
        cnt = 0;
        for(int j = 1;j<= p;j++)
            if(i&(1<<(po[j].c-1)))
                cnt++;
        memset(dis,0x3f,sizeof(dis[0][0])*N*(1<<cnt));
        cnt = 0;
        for(int j = 1;j<= p;j++)
            if(i&(1<<(po[j].c-1)))
                dis[1<<cnt++][po[j].d] = 0;
        g[i] = DP();
    }
    for(int i=1;i<end;i++)
        for(int j=i&(i-1);j;j = (j-1)&i)
            g[i]=min(g[i],g[j]+g[i^j]);
    printf("%d\n",g[(1<<col)-1]);
    return 0;
}
Problem4007

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = (1<<10)+5;
int dp[N][N],w[N][12],f[N][12],n,m;
void dfs(int x,int y,int sta,int cnt)
{
	for(int i = 0;i<= cnt;i++)dp[x][i] = 0;
	if(y==n-1)
	{
		for(int i = 0;i<y;i++)
			if(sta&(1<<i))dp[x][1]+=w[x-(1<<y)][i];
			else dp[x][0]+=f[x-(1<<y)][i];
		return ;
	}
	dfs(x<<1,y+1,sta,cnt>>1),dfs(x<<1|1,y+1,sta,cnt>>1);
	for(int i = 0;i<= cnt>>1;i++)
		for(int j = 0;j<= cnt>>1;j++)
			dp[x][i+j]=max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
	dfs(x<<1,y+1,sta|(1<<y),cnt>>1),dfs(x<<1|1,y+1,sta|(1<<y),cnt>>1);
	for(int i = 0;i<= cnt>>1;i++)
		for(int j = 0;j<= cnt>>1;j++)
			dp[x][i+j]=max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i< 1<<(n-1);i++)
		for(int j = n-2;j>=0;j--)
			scanf("%d",&w[i][j]);
	for(int i = 0;i< 1<<(n-1);i++)
		for(int j = n-2;j>=0;j--)
			scanf("%d",&f[i][j]);
	dfs(1,0,0,1<<(n-1));
	int ans = 0;
	for(int i = 0;i<= m;i++)ans = max(ans,dp[1][i]);
	printf("%d\n",ans);
}
Problem4008

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 220+5;
const int R = 132+5;
double f[N][R],Pow[N][R];
double p[N];
int w[N];
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(f,0,sizeof(f));
		memset(Pow,0,sizeof(Pow));
		int n,r;
		scanf("%d%d",&n,&r);
		for(int i = 1;i<= n;i++)
			scanf("%lf%d",&p[i],&w[i]);
		for(int i = 1;i<= n;i++)
		{
			Pow[i][0] = 1;
			for(int j = 1;j<=r;j++)
				Pow[i][j] = Pow[i][j-1]*(1.0-p[i]);
		}
		f[0][r] = 1;
		double ans = 0;
		for(int i = 0;i<n;i++)
		{
			for(int j = 0;j<=r;j++)
			{
				f[i+1][j] += f[i][j]*Pow[i+1][j];
				if(j-1>=0)
				{
					f[i+1][j-1] += f[i][j]*(1.0-Pow[i+1][j]);
					ans += f[i][j]*(1.0-Pow[i+1][j])*w[i+1];
				}
			}
		}
		printf("%.10f\n",ans);
	}
	return 0;
}
Problem4009

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,fa[N][20];
struct Plate
{int xd,xu,yd,yu,v;}plate[N];
struct Event
{int x,yd,yu,v,id;}event[N];
struct Poi
{int x,y,k,id;}poi[N],tmp1[N],tmp2[N];
bool operator <(Plate a,Plate b){return a.v<b.v;}
bool operator <(Event a,Event b){return a.x==b.x?a.id<b.id:a.x<b.x;}
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int last[N],dfn[N],dep[N],cnt,n,m,q,Cnt;
void dfs(int x,int f)
{
	dfn[x] = ++cnt;
	dep[x] = dep[f]+1;
	fa[x][0] = f;
	for(int i= head[x];i;i=e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
	last[x] = cnt;
}
void init()
{
	for(int j = 1;j<= 18;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 18;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 18;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int jump(int x,int h)
{
	for(int j = 18;j>= 0;j--)
		if(h>=(1<<j))
			x = fa[x][j],h-=(1<<j);
	return x;
}
struct Tree
{
	int val[N];
	void update(int l,int r,int x)
	{
		for(int i = l;i<N;i+=i&(-i))
			val[i]+=x;
		for(int i = r+1;i<N;i+=i&(-i))
			val[i]-=x;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans+=val[i];
		return ans;
	}
}T;
int ans[N],sum[N];
void solve(int l,int r,int st,int ed)
{
	if(ed<st)return ;
	if(l==r)
	{
		for(int i = st;i<= ed;i++)
			ans[poi[i].id] = plate[l].v;
		return ;
	}
	int mid = (l+r)>>1,siz=0;
	for(int i = l;i<= mid;i++)
	{
		event[++siz]=(Event){plate[i].xd,plate[i].yd,plate[i].yu,1,0};
		event[++siz]=(Event){plate[i].xu,plate[i].yd,plate[i].yu,-1,n+1};
	}
	for(int i = st;i<=ed;i++)
		event[++siz]=(Event){poi[i].x,poi[i].y,0,0,i};
	sort(event+1,event+siz+1);
	for(int i = 1;i<= siz;i++)
		if(event[i].id>=st&&event[i].id<=ed)
			sum[event[i].id]=T.getans(event[i].yd);
		else T.update(event[i].yd,event[i].yu,event[i].v);
	int a = 0,b = 0;
	for(int i = st;i<=ed;i++)
		if(sum[i]>=poi[i].k)tmp1[++a] = poi[i];
		else tmp2[++b] = (Poi){poi[i].x,poi[i].y,poi[i].k-sum[i],poi[i].id};
	for(int i = st;i<= st+a-1;i++)poi[i]=tmp1[i-st+1];
	for(int i = st+a;i<= ed;i++)poi[i] = tmp2[i-st-a+1];
	solve(l,mid,st,st+a-1),solve(mid+1,r,st+a,ed);
}
int main()
{
	int x,y,z,lca;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	init();
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		lca = getlca(x,y);
		if(dfn[x]>dfn[y])swap(x,y);
		if(lca!=x)plate[++Cnt] = (Plate){dfn[x],last[x],dfn[y],last[y],z};
		else
		{
			int t = jump(y,dep[y]-dep[x]-1);
			plate[++Cnt]=(Plate){1,dfn[t]-1,dfn[y],last[y],z};
			if(last[t]<n)
				plate[++Cnt]=(Plate){dfn[y],last[y],last[t]+1,n,z};
		}
	}
	sort(plate+1,plate+Cnt+1);
	for(int i =1;i<=q;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(dfn[x]>dfn[y])swap(x,y);
		poi[i]=(Poi){dfn[x],dfn[y],z,i};
	}
	solve(1,Cnt,1,q);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4010

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to;}e[N];
int head[N],tot,deg[N],n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	deg[y]++;
}
int ans[N],top,heap[N],cnt;
void topo()
{
	for(int i = n;i>=1;i--)
		if(!deg[i])
			heap[++cnt] = i;
	while(cnt)
	{
		int x = heap[1];
		ans[++top] = x;
		pop_heap(heap+1,heap+cnt+1);
		cnt--;
		for(int i = head[x];i;i=e[i].next)
			if(!(--deg[e[i].to]))
				heap[++cnt] = e[i].to,push_heap(heap+1,heap+cnt+1);
	}
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 0;
	memset(deg,0,sizeof(deg));
	cnt = top = 0;
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		scanf("%d%d",&n,&m);
		int x,y;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(y,x);
		}
		topo();
		if(top!=n)printf("Impossible!\n");
		else
		{
			for(int i = n;i>= 1;i--)
				printf("%d ",ans[i]);
			printf("\n");
		}
	}
	return 0;
}
Problem4011

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int deg[N],tdeg[N],invdeg[N],n,m,s,t;
ll ans;
void init()
{
	for(int i = 1;i<= n;i++)
		invdeg[i] = quick_pow(deg[i],mod-2);
}
queue<int>Q;
ll f[N];
void topo()
{
	f[t] = ans;
	for(int i = 1;i<= n;i++)
		if(!tdeg[i])
			Q.push(i);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		f[x] = (ll)f[x]*invdeg[x]%mod;
		for(int i = head[x];i;i=e[i].next)
		{
			(f[e[i].to]+=f[x])%=mod;
			if(!(--tdeg[e[i].to]))
				Q.push(e[i].to);
		}
	}
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&s,&t);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		deg[y]++;
		tdeg[y]++;
	}
	deg[t]++;
	ans = 1;
	for(int i = 2;i<= n;i++)
		ans = ans*deg[i]%mod;
	if(t==1)
		printf("%lld\n",ans);
	else
	{
		init();
		topo();
		printf("%lld\n",(ans-f[s]+mod)%mod);
	}
	return 0;
}
Problem4012

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 150005;
typedef long long ll;
typedef vector<pair<int,ll> >P;
const ll INF = 1e18;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
bool ban[N<<1];
void init()
{
	memset(head,0,sizeof(head));
	memset(ban,0,sizeof(ban));
	tot = 1;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
bool used[N];
int size[N],f[N],sum,root;
void get_root(int x,int from)
{
	size[x] = 1;f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to]&&e[i].to!=from)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int a[N],fa[N],dis[N];
P sum1[N];
P sum2[N];
void get_dis(int x,int from,P &s1,P &s2,ll dis)
{
	s1.push_back(pair<int,ll>(a[x],dis));
	s2.push_back(pair<int,ll>(a[x],dis));
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to]&&e[i].to!=from)
			get_dis(e[i].to,x,s1,s2,dis+e[i].val);
}
int work(int x)
{
	used[x] = true;
	sum1[x].push_back(pair<int,ll>(a[x],0));
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			sum=size[e[i].to];
			root = 0;
			P tmp;
			get_dis(e[i].to,x,sum1[x],tmp,e[i].val);
			get_root(e[i].to,0);
			fa[root] = x;sum2[root] = tmp;
			sum2[root].push_back(pair<int,ll>(-1,0));
			sort(sum2[root].begin(),sum2[root].end());
			for(int j = 1;j<sum2[root].size();j++)
				sum2[root][j].second+=sum2[root][j-1].second;
			work(root);
		}
	sum1[x].push_back(pair<int,ll>(-1,0));
    sort(sum1[x].begin(),sum1[x].end());
    for(int j=1;j<sum1[x].size();j++)
        sum1[x][j].second+=sum1[x][j-1].second;
}
int pos[N],T,log_2[N<<1];
ll min_dpt[N<<1][20],dpt[N];
void DFS(int x,int from)
{
	min_dpt[pos[x]=++T][0] = dpt[x];
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=from)
		{
			dpt[e[i].to] = dpt[x]+e[i].val;
			DFS(e[i].to,x);
			min_dpt[++T][0] = dpt[x];
		}
}
void build_lca()
{
	for(int i = 2;i<=T;i++)
		log_2[i] = log_2[i>>1]+1;
	for(int j = 1;j<= log_2[T];j++)
		for(int i = 1;i+(1<<j)-1<=T;i++)
			min_dpt[i][j] = min(min_dpt[i][j-1],min_dpt[i+(1<<(j-1))][j-1]);
}
ll get_lcadpt(int x,int y)
{
	x = pos[x],y = pos[y];
	if(x>y)swap(x,y);
	int l = log_2[y-x+1];
	return min(min_dpt[x][l],min_dpt[y-(1<<l)+1][l]);
}
ll get_distance(int x,int y)
{
	return dpt[x]+dpt[y]-2*get_lcadpt(x,y);
}
ll sumv1,sumv2;int cnt1,cnt2;
int qurey1(const P &s,int x)
{
	int l = 0,r = s.size();
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(s[mid].first<=x)l = mid+1;
		else r = mid;
	}
	l--;
	if(l<0)l = 0;
	return l;
}
int qurey2(const P &s,int x)
{
	int l = 0,r = s.size();
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(s[mid].first<x)l = mid+1;
		else r = mid;
	}
	l--;
	if(l<0)l = 0;
	return l;
}
ll ans;
void qurey(int x,int i,int l,int r)
{
	int r1 = qurey1(sum1[fa[i]],r),l1 = qurey2(sum1[fa[i]],l);
	int r2 = qurey1(sum2[i],r),l2 = qurey2(sum2[i],l);
	ans+=sum1[fa[i]][r1].second-sum1[fa[i]][l1].second-sum2[i][r2].second+sum2[i][l2].second;
	ans+=(ll)(r1-l1-r2+l2)*get_distance(x,fa[i]);
}
void qurey(int x,int l,int r)
{
	ans = 0;
	int L = qurey2(sum1[x],l),R = qurey1(sum1[x],r);
	ans+=sum1[x][R].second-sum1[x][L].second;
	for(int i = x;fa[i];i = fa[i])
		qurey(x,i,l,r);
}
void debug1(int x)
{
	printf("%d\n",sum1[x].size());
	for(int i = 0;i<sum1[x].size();i++)
		printf("%d:%I64d ",sum1[x][i].first,sum1[x][i].second);
	printf("\n");
}
void debug2(int x)
{
	printf("%d\n",sum2[x].size());
	for(int i = 0;i<sum2[x].size();i++)
		printf("%d:%I64d ",sum2[x][i].first,sum2[x][i].second);
	printf("\n");
}
int main()
{
	int n,q,A;
	scanf("%d%d%d",&n,&q,&A);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	DFS(1,0);
	build_lca();
	f[0] = sum = n;
	root = 0;
	get_root(1,0);
	work(root);
	ll last_ans = 0;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&z,&x,&y);
		x = (x+last_ans)%A;
		y = (y+last_ans)%A;
		if(x>y)swap(x,y);
		qurey(z,x,y);
		printf("%lld\n",last_ans = ans);
	}
	return 0;
}
Problem4013

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 405;
struct E
{int next,to;}e[N];
int head[N],tot,deg[N];
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	deg[y]++;
}
int fa[N],f[N][N],g[N],size[N],c[N][N];
bool vis[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
bool dfs(int x,int pre)
{
	vis[x] = true;
	bool flag = false;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre)
	{
		if(vis[e[i].to])return false;
		if(!dfs(e[i].to,x))return false;
		if(flag)
		{
			memset(g,0,sizeof(g));
			for(int j = 1;j<= size[x];j++)
				for(int k = 1;k<= size[e[i].to];k++)
					if(f[x][j]&&f[e[i].to][k])
					for(int I = max(j,k);I<=j+k;I++)
						(g[I]+=(ll)f[x][j]*f[e[i].to][k]%mod*c[j][j+k-I]%mod*c[I][j]%mod)%=mod;
			size[x]+=size[e[i].to];
			for(int I = 1;I<= size[x];I++)
				f[x][I] = g[I];
		}else
		{
			size[x]= size[e[i].to];
			flag = true;
			for(int I = 1;I<= size[x];I++)
				f[x][I] = f[e[i].to][I];
		}	
	}
	if(x)
	{
		size[x]++;
		if(flag)for(int i = size[x];i;i--)f[x][i] = f[x][i-1];
		else f[x][1] = 1;
	}
	return true;
}
void uni(int x,int y)
{
	x = getfa(x),y =getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
int X[N],Y[N];
int main()
{
	int n,m,x,y;
	char opt[3];
	scanf("%d%d",&n,&m);
	c[0][0]=1;
	for(int i = 1;i<= 400;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<= 400;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
	int cnt = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%s%d",&x,opt,&y);
		if(opt[0]=='=')
			uni(x,y);
		else
			X[++cnt] =x,Y[cnt] = y;
	}
	for(int i = 1;i<= cnt;i++)
	{
		x = getfa(X[i]),y = getfa(Y[i]);
		if(x==y){printf("0\n");return 0;}
		add(x,y);
	}
	for(int i=1;i<=n;i++)if(!deg[getfa(i)])add(0,getfa(i));
	if(!dfs(0,-1))return printf("0\n"),0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i&&!vis[i])return printf("0\n"),0;
	int ans = 0;
	for(int i = 1;i<= size[0];i++)ans=(ans+f[0][i])%mod;
	printf("%d\n",ans);
	return 0;
}
Problem4015

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define inf 0x1f1f1f1f
const int N = 210;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void clear()
{
	memset(head,0,sizeof(head));
	tot = 0;
}
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int q[N],fr,ta,fa[N],size[N];
vector <int> grav;
const int mod = 10007;
void Add(int &x,int y)
{
	if((x+=y)>=mod)
		x-=mod;
}
namespace solve1
{
	int f[N][N],g[N],fa[N],size[N];
	void dfs(int x)
	{
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				dfs(e[i].to);
				size[x]+=size[e[i].to];
			}
	}
	void dp(int x)
	{
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
				dp(e[i].to);
		f[x][1] = 1;
		memset(g,0,sizeof(g));
		g[0] = 1;
		for(int j = head[x];j;j=e[j].next)
			if(e[j].to!=fa[x])
				for(int k = size[x]-1;k>=0;k--)
					for(int i = 1;i<= size[e[j].to] && i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
		for(int i = 1;i<size[x];i++)
			f[x][i+1] = g[i];
	}
	void work(int root)
	{
		memset(fa,0,sizeof(fa));
		dfs(root);
		memset(f,0,sizeof(f));
		dp(root);
		int res = 0;
		for(int all = 1;all<= size[root];all++)
		{
			memset(g,0,sizeof(g));
			g[0] = 1;
			for(int j = head[root];j;j=e[j].next)
				for(int k = all-1;k>= 0;k--)
					for(int i = 1;i<=size[e[j].to]&&i*2<all&&i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
			Add(res,g[all-1]);
		}
		printf("%d\n",res);
	}
}

namespace solve2
{
	int f[N][N],g[N],size[N];
	void dp(int x,int fa)
	{
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa)
			{
				dp(e[i].to,x);
				size[x]+=size[e[i].to];
			}
		f[x][1] = 1;
		memset(g,0,sizeof(g));
		g[0] = 1;
		for(int j = head[x];j;j=e[j].next)
			if(e[j].to!=fa)
				for(int k = size[x]-1;k>=0;k--)
					for(int i = 1;i<= size[e[j].to]&&i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
		for(int i = 1;i<size[x];i++)
			f[x][i+1] = g[i];
	}
	void work(int r1,int r2)
	{
		memset(f,0,sizeof(f));
		dp(r1,r2),dp(r2,r1);
		int res = 0;
		for(int i = 1;i<= size[r1]&&i<= size[r2];i++)
			Add(res,f[r1][i]*f[r2][i]%mod);
		printf("%d\n",res);
	}
}
int main()
{
	//freopen("4015.in","r",stdin);
	//freopen("4015.out","w",stdout);
	int cas;
	scanf("%d",&cas);
	int n,a,b;
	for(int Cas = 1;Cas<= cas;Cas++)
	{
		printf("Case %d: ",Cas);
		clear();
		scanf("%d",&n);
		for(int i = 1;i<n;i++)
		{
			scanf("%d%d",&a,&b);
			add(a,b);
		}
		if(n<=2)puts("1");
		else
		{
			fr = 0;
			ta = -1;
			q[++ta] = 1;
			while(fr<=ta)
			{
				int x = q[fr++];
				for(int i = head[x];i;i=e[i].next)
					if(e[i].to!=fa[x])
					{
						fa[e[i].to] = x;
						q[++ta] = e[i].to;
					}
			}
			memset(size,0,sizeof(size));
			for(int i = ta;i>=0;i--)
				size[fa[q[i]]]+=++size[q[i]];
			size[0] = 0;
			grav.clear();
			int Min = inf,now;
			for(int i = 1;i<= n;i++)
			{
				now=n-size[i];
				for(int j = head[i];j;j=e[j].next)
					if(fa[e[j].to]==i)
						now = max(now,size[e[j].to]);
				if(now<Min)
				{
					Min = now;
					grav.clear();
					grav.push_back(i);
				}
				else if(now==Min)
					grav.push_back(i);
			}
			if(grav.size()==1)
				solve1::work(grav[0]);
			else
				solve2::work(grav[0],grav[1]);
		}
	}
	return 0;
}
Problem4016

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 6e4+5;
struct E
{int next,to,val;};
bool v[N],used[N];
int dis[N],f[N],size[N],dep[N],ft[N];
int F[N][2],G[N][2];
int sum,root,n,m,K,ans1,ans2;
struct Gragh
{
	E e[M<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val = f;
		head[x] = tot;
	}
	void spfa(int s)
	{
		queue<int>Q;
		memset(dis,0x3f,sizeof(dis));
		memset(v,0,sizeof(v));
		dis[s] = 0,v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i = e[i].next)
				if(dis[x]+e[i].val<dis[e[i].to])
				{
					dis[e[i].to] = dis[x]+e[i].val;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
		}
	}
	void get_root(int x,int fa)
	{	
		size[x] = 1;f[x] = 0;
		for(int i = head[x];i;i = e[i].next)
			if(!used[e[i].to]&&e[i].to!=fa)
			{
				get_root(e[i].to,x);
				f[x] = max(f[x],size[e[i].to]);
				size[x]+=size[e[i].to];
			}
		f[x] = max(f[x],sum-size[x]);
		if(f[x]<=f[root])root = x;
	}
	void calc(int x)
	{
		queue<int>Q;
		for(int i = 1;i<= K;i++)
			G[i][0] = G[i][1] = F[i][0] = F[i][1] = 0;
		F[0][1] = 1;
		dep[x] = 0,dis[x] = 0;
		for(int i = head[x];i;i = e[i].next)
		{
			if(used[e[i].to])continue;
			dep[e[i].to] = dep[x]+1;dis[e[i].to] = e[i].val;
			ft[e[i].to] = x;
			if(e[i].val>G[dep[e[i].to]][0])
			{
				G[dep[e[i].to]][0] = e[i].val;
				G[dep[e[i].to]][1] = 1;
			}
			else if(e[i].val==G[dep[e[i].to]][0])
				G[dep[e[i].to]][1]++;
			Q.push(e[i].to);
			while(!Q.empty())
			{
				int tp = Q.front();
				Q.pop();
				if(dep[tp]>=K)continue;
				for(int j = head[tp];j;j = e[j].next)
					if(e[j].to!=ft[tp]&&!used[e[j].to])
					{
						ft[e[j].to] = tp;
						dep[e[j].to] = dep[tp]+1;
						dis[e[j].to] = dis[tp]+e[j].val;
						if(dis[e[j].to]>G[dep[e[j].to]][0])
							G[dep[e[j].to]][0] = dis[e[j].to],G[dep[e[j].to]][1] = 1;
						else if(G[dep[e[j].to]][0]==dis[e[j].to])G[dep[e[j].to]][1]++;
						Q.push(e[j].to);
					}
			}
			for(int j = 1;j<= K;j++)
			{
				if(F[K-j][0]+G[j][0]>ans1)
					{ans1 = F[K-j][0]+G[j][0];ans2 = F[K-j][1]*G[j][1];}
				else if(F[K-j][0]+G[j][0]==ans1)
					{ans2+=F[K-j][1]*G[j][1];}
			}
			for(int j = 1;j<= K;j++)
			{
				if(G[j][0]>F[j][0]){F[j][0] = G[j][0],F[j][1] = G[j][1];}
				else if(G[j][0]==F[j][0]){F[j][1]+=G[j][1];}
				G[j][0] = G[j][1] = 0;
			}
		}
	}
	void work(int x)
	{
		calc(x);
		used[x] = true;
		for(int i = head[x];i;i= e[i].next)
			if(!used[e[i].to])
			{
				root = 0;
				sum= size[e[i].to];
				get_root(e[i].to,0);
				if(size[root]>=K)
					work(root);
			}
	}
	void dis_edge()
	{
		for(int i = 1;i<= n;i++)
			for(int j = head[i];j;j = e[j].next)
				if(i<=e[j].to)
					printf("%d %d %d\n",i,e[j].to,e[j].val);
	}
}g,t;
void rebuild(int x)
{
	v[x] = true;
	for(int i = g.head[x];i;i = g.e[i].next)
	{
		int to = g.e[i].to;
		if(!v[to]&&dis[x]+g.e[i].val==dis[to])
		{
			t.add(x,to,g.e[i].val),t.add(to,x,g.e[i].val);
			rebuild(to);
		}
	}
}
struct Edge
{int u,v,w;}edge[M<<1];
bool cmp(const Edge &a,const Edge &b)
{
	if(a.u==b.u)
		return a.v>b.v;
	return a.u<b.u;
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	K--;
	for(int i=1;i<= m;i++)
	{
		scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
		edge[i+m] = edge[i];
		swap(edge[i].u,edge[i].v);
	}
	sort(edge+1,edge+2*m+1,cmp);
	for(int i = 1;i<= 2*m;i++)
		g.add(edge[i].u,edge[i].v,edge[i].w);
	g.spfa(1);
	memset(v,0,sizeof(v));
	rebuild(1);
	//t.dis_edge();
	f[0] = sum= n;
	t.get_root(1,0);
	t.work(root);
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem4016

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 6e4+5;
struct E
{int next,to,val;};
bool v[N],used[N];
int dis[N],f[N],size[N],dep[N],ft[N];
int F[N][2],G[N][2];
int sum,root,n,m,K,ans1,ans2;
struct Gragh
{
    E e[M<<1];
    int head[N],tot;
    void add(int x,int y,int f)
    {
        e[++tot].to = y;
        e[tot].next = head[x];
        e[tot].val = f;
        head[x] = tot;
    }
    void spfa(int s)
    {
        queue<int>Q;
        memset(dis,0x3f,sizeof(dis));
        memset(v,0,sizeof(v));
        dis[s] = 0,v[s] = true;
        Q.push(s);
        while(!Q.empty())
        {
            int x = Q.front();
            Q.pop();
            v[x] = false;
            for(int i = head[x];i;i = e[i].next)
                if(dis[x]+e[i].val<dis[e[i].to])
                {
                    dis[e[i].to] = dis[x]+e[i].val;
                    if(!v[e[i].to])
                    {
                        Q.push(e[i].to);
                        v[e[i].to] = true;
                    }
                }
        }
    }
    void get_root(int x,int fa)
    {   
        size[x] = 1;f[x] = 0;
        for(int i = head[x];i;i = e[i].next)
            if(!used[e[i].to]&&e[i].to!=fa)
            {
                get_root(e[i].to,x);
                f[x] = max(f[x],size[e[i].to]);
                size[x]+=size[e[i].to];
            }
        f[x] = max(f[x],sum-size[x]);
        if(f[x]<=f[root])root = x;
    }
    void calc(int x)
    {
        queue<int>Q;
        for(int i = 0;i<= K;i++)
            G[i][0] = G[i][1] = F[i][0] = F[i][1] = 0;
        F[0][1] = 1;
        dep[x] = 0,dis[x] = 0;
        for(int i = head[x];i;i = e[i].next)
        {
            if(used[e[i].to])continue;
            dep[e[i].to] = dep[x]+1;dis[e[i].to] = e[i].val;
            ft[e[i].to] = x;
            Q.push(e[i].to);
            while(!Q.empty())
            {
                int tp = Q.front();
                Q.pop();
                if(dep[tp]>K)continue;
                if(dis[tp]>G[dep[tp]][0])
                    G[dep[tp]][0] = dis[tp],G[dep[tp]][1] = 0;
                if(G[dep[tp]][0]==dis[tp])G[dep[tp]][1]++;
                for(int j = head[tp];j;j = e[j].next)
                    if(e[j].to!=ft[tp]&&!used[e[j].to])
                    {
                        ft[e[j].to] = tp;
                        dep[e[j].to] = dep[tp]+1;
                        dis[e[j].to] = dis[tp]+e[j].val;
                        Q.push(e[j].to);
                    }
            }
            for(int j = 0;j<= K;j++)
            {
                if(F[K-j][0]+G[j][0]>ans1)
                    {ans1 = F[K-j][0]+G[j][0];ans2 = F[K-j][1]*G[j][1];}
                else if(F[K-j][0]+G[j][0]==ans1)
                    {ans2+=F[K-j][1]*G[j][1];}
            }
            for(int j = 0;j<= K;j++)
            {
                if(G[j][0]>F[j][0]){F[j][0] = G[j][0],F[j][1] = G[j][1];}
                else if(G[j][0]==F[j][0]){F[j][1]+=G[j][1];}
                G[j][0] = G[j][1] = 0;
            }
        }
    }
    void work(int x,int S)
    {
        calc(x);
        used[x] = true;
        for(int i = head[x];i;i= e[i].next)
            if(!used[e[i].to])
            {
                root = 0;
                sum= size[e[i].to];
                if(size[e[i].to]>size[x])size[e[i].to]=S-size[e[i].to];
                if(sum>=K)get_root(e[i].to,0);
                work(root,size[e[i].to]);
            }
    }
    void dis_edge()
    {
        for(int i = 1;i<= n;i++)
            for(int j = head[i];j;j = e[j].next)
                if(i<=e[j].to)
                    printf("%d %d %d\n",i,e[j].to,e[j].val);
    }
}g,t;
void rebuild(int x)
{
    v[x] = true;
    for(int i = g.head[x];i;i = g.e[i].next)
    {
        int to = g.e[i].to;
        if(!v[to]&&dis[x]+g.e[i].val==dis[to])
        {
            t.add(x,to,g.e[i].val),t.add(to,x,g.e[i].val);
            rebuild(to);
        }
    }
}
struct Edge
{int u,v,w;}edge[M<<1];
bool cmp(const Edge &a,const Edge &b)
{
    if(a.u==b.u)
        return a.v>b.v;
    return a.u<b.u;
}
int main()
{
    scanf("%d%d%d",&n,&m,&K);
    K--;
    for(int i=1;i<= m;i++)
    {
        scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
        edge[i+m] = edge[i];
        swap(edge[i].u,edge[i].v);
    }
    sort(edge+1,edge+2*m+1,cmp);
    for(int i = 1;i<= 2*m;i++)
        g.add(edge[i].u,edge[i].v,edge[i].w);
    g.spfa(1);
    memset(v,0,sizeof(v));
    rebuild(1);
    //t.dis_edge();
    f[0] = sum= n;
    t.get_root(1,0);
    t.work(root,sum);
    printf("%d %d\n",ans1,ans2);
    return 0;
}
Problem4025

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Edge
{
	int x,y,st,ed;
	Edge(int _x,int _y,int _s,int _e):x(_x),y(_y),st(_s),ed(_e){}
};
const int N = 100005;
int fa[N],rnk[N],stack[N<<2],a[N],top;
int getfa(int x)
{
	while(fa[x]!=x)x=fa[x];
	return fa[x]=x;
}
int getdis(int x)
{
	int res = 0;
	while(fa[x]!=x&&fa[x])res^=a[x],x=fa[x];
	return res;
}
void uni(int x,int y,int z)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(rnk[x]>rnk[y])swap(x,y);
	if(rnk[x]==rnk[y])
		rnk[y]++,stack[++top] = y;
	fa[x] = y,a[x] = z;stack[++top] = x;
}
void reset(int bot)
{
	while(top>bot)
	{
		if(stack[top]<0)
			rnk[-stack[top]]--;
		else 
			fa[stack[top]] = stack[top],a[stack[top]] = 0;
		top--;
	}
}
void solve(int l,int r,vector<Edge> &e)
{
	int mid = (l+r)>>1,bot = top;
	vector<Edge>L,R;
	for(int i = 0;i<e.size();i++)
	{
		if(e[i].st==l&&e[i].ed==r)
		{
			int _x = getfa(e[i].x),_y = getfa(e[i].y);
			int _z =getdis(e[i].x)^getdis(e[i].y)^1;
			if(_x!=_y)uni(_x,_y,_z);
			else if(_z&1)
			{
				for(int i = l;i<= r;i++)
					printf("No\n");
				reset(bot);
				return ;
			}
		}
		else if(e[i].ed<=mid)L.push_back(e[i]);
		else if(e[i].st>mid)R.push_back(e[i]);
		else
			L.push_back(Edge(e[i].x,e[i].y,e[i].st,mid)),
			R.push_back(Edge(e[i].x,e[i].y,mid+1,e[i].ed));
	}
	if(l==r)printf("Yes\n");
	else 
		solve(l,mid,L),solve(mid+1,r,R);
	reset(bot);
}
int main()
{
	int n,m,T,x,y,s,e;
	scanf("%d%d%d",&n,&m,&T);
	for(int i = 1;i<= n;i++)fa[i]=i;
	vector<Edge>E;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&s,&e);
		s++;
		if(s>e)continue;
		E.push_back(Edge(x,y,s,e));
	}
	solve(1,T,E);
	return 0;
}
Problem4027

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2000005;
int top,c[N],k[N],val[N],n,m,ans;
int stack[N];
bool cmp(int a,int b)
{
	return val[a]<val[b];
}
struct E
{int next,to;}e[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to);
	top = 0;
	for(int i= head[x];i;i = e[i].next)
		stack[++top] = e[i].to;
	sort(stack+1,stack+top+1,cmp);
	for(int i = 1;i<= top;i++)
	{
		if(val[x]+val[stack[i]]-1<=m)
		{
			ans++;
			val[x]+=val[stack[i]]-1;
		}else break;
	}
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&k[i]);
		val[i] = k[i]+c[i];
		for(int j = 1;j<= k[i];j++)
		{
			scanf("%d",&x);
			add(i,x+1);
		}
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}
Problem4028

#include <stdio.h>
#include <math.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 100005;
const int B = 5005;
int g[N],x[N],a[N];
int pos[N],lb[N],rb[N];
int gcd(int a,int b)
{
	if(a==-1)return b;
	if(b==0)return a;
	return gcd(b,a%b);
}
map<ll,int>s[B];
void debug(int b)
{
	printf("Bolck No #%d\n",b);
	map<ll,int>::iterator it;
	for(it = s[b].begin();it!=s[b].end();it++)
		printf("%lld %d\n",it->first,it->second);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int block = sqrt(n);
	for(int i = 1;i<= n;i++)
		pos[i] = (i-1)/block+1;
	int tot = pos[n];
	for(int i = 1;i<= tot;i++)
		lb[i] = (i-1)*block+1,rb[i] = i*block;
	rb[tot] = n;
	for(int i = 1;i<= tot;i++)
	{
		g[lb[i]] = a[lb[i]],x[lb[i]] = a[lb[i]];
		s[i][x[lb[i]]] = lb[i];
		for(int j = lb[i]+1;j<= rb[i];j++)
		{
			g[j] = gcd(g[j-1],a[j]),x[j] = x[j-1]^a[j];
			if(s[i].find(x[j])==s[i].end())s[i][x[j]] = j;
		}
		//debug(i);
	}
	int q,id,nv;
	ll p;
	scanf("%d",&q);
	while(q--)
	{
		char opt[10];
		scanf("%s",opt);
		if(opt[0]=='M')
		{
			scanf("%d%d",&id,&nv);
			id++;
			int Pos = pos[id];
			for(int i = id;i<= rb[Pos];i++)
				if(s[Pos][x[i]]==i)s[Pos].erase(x[i]);
			if(id==lb[Pos])g[id] = x[id] = nv;
			else g[id] = gcd(g[id-1],nv),x[id] = x[id-1]^nv;
			if(s[Pos].find(x[id])==s[Pos].end())s[Pos][x[id]] = id;
			for(int i = id+1;i<= rb[Pos];i++)
			{
				g[i] = gcd(g[i-1],a[i]),x[i] = x[i-1]^a[i];
				if(s[Pos].find(x[i])==s[Pos].end())s[Pos][x[i]] = i;
			}
			a[id] = nv;
			//debug(Pos);
		}
		else
		{
			scanf("%lld",&p);
			int lastgcd = -1;
			int lastxor = 0;
			bool flag = false;
			for(int i = 1;i<= tot&&!flag;i++)
			{
				int tmp_gcd = gcd(lastgcd,g[rb[i]]);
				if(tmp_gcd==lastgcd)
				{
					ll goal = (p/lastgcd)^lastxor;
					if(p%lastgcd)goal = -1;
					if(s[i].find(goal)!=s[i].end())
					{
						printf("%d\n",s[i][goal]-1);
						flag = true;
					}
				}else
				{
					for(int j = lb[i];j<= rb[i];j++)
					{
						ll tg = gcd(lastgcd,g[j]);
						ll tx = lastxor^x[j];
						if(tg*tx==p)
						{
							printf("%d\n",j-1);
							flag = true;break;
						}
					}
				}
				lastgcd = gcd(lastgcd,g[rb[i]]);
				lastxor = lastxor^x[rb[i]];
			}
			if(!flag)printf("no\n");
		}
	}
	return 0;
}
/*
10

1353600 5821200 10752000 1670400 3729600 6844320 12544000 117600 59400 640

10

MODIFY 7 20321280

QUERY 162343680

QUERY 1832232960000

MODIFY 0 92160

QUERY 1234567

QUERY 3989856000

QUERY 833018560

MODIFY 3 8600

MODIFY 5 5306112

QUERY 148900352

6

0

no

2

8

8
*/
Problem4029

#include <set>
#include <map>
#include <ctime>
#include <queue>
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int T,l,r,ans,mn;
int add(int x)
{
    int k=1;
    while(x%10==0)
    {
        k*=10;
        x/=10;
    }
    return k;
}
int cal(int x)
{
    while(x%10==0)
        x/=10;
    int t=x%10,a=0;
    while(x)
    {
        x/=10;
        a++;
    }
    if(t==5)
        return 2*a-1;
    return 2*a;
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&l,&r);
        mn=cal(l);ans=l;
        while(1)
        {
            l+=add(l);
            if(l>r)break;
            int t=cal(l);
            if(t<mn)mn=t,ans=l;
        }
        printf("%d\n",ans);
    }
    return 0;
}
Problem4033

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
typedef long long LL;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,n,K;
LL f[N][N];
int size[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dp(int x,int fa,int val)
{
	size[x]++;
	f[x][0] = f[x][1] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		dp(e[i].to,x,e[i].val);
		size[x]+=size[e[i].to];
		for(int j = min(size[x],K);j>= 0;j--)
			for(int k = 0;k<= j&&k<=size[e[i].to];k++)
				if(j-k>=0&&f[x][j-k]!=-1)f[x][j] = max(f[x][j],f[x][j-k]+f[e[i].to][k]);
	}
	for(int bn = 0;bn<= K&&bn<=size[x];bn++)
	{
		if(f[x][bn]==-1)f[x][bn] = 0;
		f[x][bn] = f[x][bn]+(LL)val*(LL)bn*(K-bn)+(LL)val*(LL)(size[x]-bn)*(n-K-size[x]+bn);
	}
}
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&K);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c),add(y,x,c);
	}
	memset(f,-1,sizeof(f));
	dp(1,0,0);
	printf("%lld\n",f[1][K]);
	return 0;
}
Problem4034

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int w[N],top[N],deep[N],son[N],size[N],fa[N],end[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	deep[x] = dep;
	size[x]++;
	v[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	end[x] = cnt;
}
long long sum[N<<3],f[N<<3];
void push_down(int p,int l,int r)
{
	f[p<<1]+=f[p];
	f[(p<<1)+1]+=f[p];
	int mid = (l+r)>>1;
	sum[p<<1]+=f[p]*(mid-l+1);
	sum[(p<<1)+1]+=f[p]*(r-mid);
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b,long long c)
{
	if(f[p])push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		f[p]+=c;
		sum[p]+=c*(r-l+1);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update((p<<1)+1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
long long getans(int p,int l,int r,int a,int b)
{
	if(f[p])push_down(p,l,r);
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1;
	long long ans = 0;
	if(a<=mid)ans+=getans(p<<1,l,mid,a,b);
	if(b>mid)ans+=getans((p<<1)+1,mid+1,r,a,b);
	return ans;
}
long long qurey(int x,int y)
{
	long long ans = 0;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		ans+=getans(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])
		swap(x,y);
	ans+=getans(1,1,n,w[y],w[x]);
	return ans;
}
int num[N];
int main()
{
	int x,y,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(1,1,n,w[i],w[i],num[i]);
	int opt;
	long long z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)
		{
			scanf("%lld",&z);
			update(1,1,n,w[x],w[x],z);
		}else if(opt==2)
		{
			scanf("%lld",&z);
			update(1,1,n,w[x],end[x],z);
		}else
			printf("%lld\n",qurey(1,x));
	}
	return 0;
}
Problem4036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<20;
const double eps = 1e-8;
double a[N+5];
int f[N+5];
int main()
{
	int n;
	scanf("%d",&n);
	f[0] = ((n+1)&1)?-1:1;
	for(int i = 0;i<(1<<n);i++)
	{
		scanf("%lf",&a[i]);
		if(i>0)f[i] = -f[i-(i&(-i))];
	}
	for(int k = 1;k<(1<<n);k<<=1)
		for(int i = 0;i<(1<<n);i++)
		{
			if(i&k)continue;
			a[i+k]+=a[i];
		}
	bool flag = true;
	for(int i = 0;flag&&i<(1<<n)-1;i++)
		if(a[i]+eps>1)
			flag = false;
	if(!flag)printf("INF\n");
	else
	{
		double ans = 0;
		for(int i = 0;i<(1<<n)-1;i++)
			ans+=f[i]/(1-a[i]);
		printf("%.7lf\n",ans);
	}
	return 0;
}
Problem4055

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 8e3+5;
typedef long double ld;
struct E
{int next,to,b;ld c;};
struct H
{int v,no;}heap[M];
bool cmp(H a,H b)
{
    return a.v>b.v;
}
bool on_tree[M];
int dis[N],ind[N],rei[N],a[N],n,m,cnt;bool v[N];
ld arc[N][N];
ld R[N],tr[N];
queue<int>Q;
struct Gragh
{
	E e[M];
	int head[N],tot;
	void init()
	{
		memset(head,0,sizeof(head));
		tot = 1;
	}
	void add(int x,int y,int b,ld c)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
		e[tot].b = b,e[tot].c = c;
	}
	void spfa(int s)
	{
		cnt = 0;
		memset(dis,0x3f,sizeof(dis));
		memset(v,false,sizeof(v));
		dis[s]=0;
		heap[1].v = 0;heap[1].no = s;
		cnt++;
		push_heap(heap+1,heap+cnt+1,cmp);
		while(cnt)
		{
			int now=heap[1].no;
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			if(v[now])continue;
			v[now]=1;
			for(int i=head[now];i;i=e[i].next)
				if(dis[now]+e[i].b<dis[e[i].to]&&!v[e[i].to])
				{
					dis[e[i].to]=dis[now]+e[i].b;
					heap[++cnt].v = dis[e[i].to];
					heap[cnt].no = e[i].to;
					push_heap(heap+1,heap+cnt+1,cmp);
				}
		}
		for(int i = 1;i<= n;i++)
			for(int j = head[i];j;j=e[j].next)
				if(dis[i]+e[j].b==dis[e[j].to])
					on_tree[j] = true,ind[e[j].to]++,rei[i]++;
	}
	void topo(int s)
	{
		arc[s][s] = 1;
		for(int i = 1;i<= n;i++)
			if(!ind[i])
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(on_tree[i])
				{
					arc[s][e[i].to]+=e[i].c*arc[s][x];
					if(!--ind[e[i].to])
						Q.push(e[i].to);
				}
		}
	}
	void retopo(int s)
	{
		for(int i = 1;i<= n;i++)
		{
			if(!rei[i])
				Q.push(i);
			tr[i] = 0;
		}
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
			if(on_tree[i^1])
			{
				tr[e[i].to]+=e[i].c*tr[x];
				tr[e[i].to]+=e[i].c*a[x]/arc[s][x];
				if(!--rei[e[i].to])
					Q.push(e[i].to);
			}
		}
	}
	void getR(int s)
	{
		for(int i=1;i<= n;i++)
			if(i!=s)
				R[i]+=arc[s][i]*a[s]*tr[i];
	}
}g;
int main()
{
	//freopen("misc.in","r",stdin);
	//freopen("misc.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int u,v,d;ld c;
	g.init();
	for(int i = 1;i<=m;i++)
	{
		scanf("%d%d%d%Lf",&u,&v,&d,&c);
		g.add(u,v,d,c);
		g.add(v,u,d,c);
	}
	for(int i= 1;i<= n;i++)
	{
		memset(ind,0,sizeof(ind));
		memset(rei,0,sizeof(rei));
		memset(on_tree,0,sizeof(on_tree));
		g.spfa(i);
		g.topo(i);
		g.retopo(i);
		g.getR(i);
	}
	for(int i = 1;i<= n;i++)
		printf("%.8Lf\n",R[i]);
	return 0;
}
Problem4071

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
LL sum[N<<3];
int size[N<<3];
struct P{int a,b;}per[N];
int pos[N<<1],cnt,tot,d[N<<1];
bool cmp(const P &x,const P &y)
{
	return (x.a+x.b)<(y.a+y.b);
}
void init()
{
	sort(pos+1,pos+cnt+1);
	int tmp = cnt;cnt = 0;
	pos[0] = -1e9;
	for(int i = 1;i<= tmp;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt] = pos[i];
}
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void push_up(int p)
{
	sum[p] = sum[p<<1]+sum[p<<1|1];
	size[p] = size[p<<1]+size[p<<1|1];
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = size[p] = 0;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void update(int p,int l,int r,int x)
{
	if(l==r)
	{
		sum[p]+=d[l];
		size[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x);
	else update(p<<1|1,mid+1,r,x);
	push_up(p);
}
LL get_sum(int p,int l,int r,int cnt)
{
	if(size[p]<=cnt)return sum[p];
	if(l==r)return (LL)cnt*d[l];
	int mid = (l+r)>>1;
	if(size[p<<1]>=cnt)return get_sum(p<<1,l,mid,cnt);
	else return sum[p<<1]+get_sum(p<<1|1,mid+1,r,cnt-size[p<<1]);
}
LL Ask(LL k)
{
	LL s = get_sum(1,1,cnt,k);
	return sum[1]-(LL)2*s;
}
LL ans[N];
int main()
{
	int k,n;
	scanf("%d%d",&k,&n);
	LL pre = 0;
	char x1[5],x2[5];int x,y;
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d%s%d",x1,&x,x2,&y);
		if(x1[0]==x2[0])pre+=abs(y-x);
		else
		{
			pre++;
			pos[++cnt] = x;pos[++cnt] = y;
			per[++tot].a = x;per[tot].b = y;
		}
	}
	init();
	sort(per+1,per+tot+1,cmp);
	if(cnt)
	{
		n = tot;
		for(int i = 1;i<= n;i++)
			d[find(per[i].a)] = per[i].a,d[find(per[i].b)] = per[i].b;
		build(1,1,cnt);
		for(int i = 1;i<= n;i++)
		{
			update(1,1,cnt,find(per[i].a));
			update(1,1,cnt,find(per[i].b));
			ans[i] = Ask(i);
		}
	}
	if(k==1){printf("%lld\n",ans[n]+pre);return 0;}
	else
	{
		LL Ans = ans[n];
		if(cnt)
		{
			build(1,1,cnt);
			for(int i = n;i>1;i--)
			{
				update(1,1,cnt,find(per[i].a));
				update(1,1,cnt,find(per[i].b));
				Ans = min(Ans,ans[i-1]+Ask(n-i+1));
			}
		}
		printf("%lld\n",Ans+pre);
	}
	return 0;
}
Problem4078

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 405;
const int M = 805;
const int INF = 0x3f3f3f3f;
struct Edge
{int u,v,w;}edge[N*N];
struct E
{int next,to;}e[M*M];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
}
bool cmp(const Edge &a,const Edge &b)
{
	if(a.w==b.w)
	{
		if(a.u==b.u)return a.v>b.v;
		else return a.u>b.u;
	}	
	else return a.w>b.w;
}
int fa[N],d[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	int res = getfa(fa[x]);
	d[x]^=d[fa[x]];
	return fa[x] = res;
}
int a[N][N];
bool ins[N];
int low[N],dfn[N],stack[N],top,dcc,bel[N],cnt;
void tarjan(int x)
{
	stack[++top] =x;
	dfn[x]=low[x]=++cnt;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(low[x]==dfn[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
bool check(int s1,int s2)
{
	for(int i = 1;i<= 2*n;i++)head[i]=low[i]=dfn[i]=bel[i]=ins[i]=0;
	top = dcc = tot = cnt = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
		{
			if(a[i][j]>s1)
			{
				add(i*2-1,j*2);
				add(j*2-1,i*2);
			}if(a[i][j]>s2)
			{
				add(i*2,j*2-1);
				add(j*2,i*2-1);
			}
		}
	for(int i = 1;i<= 2*n;i++)if(!dfn[i])tarjan(i);
	for(int i = 1;i<= n;i++)if(bel[i*2]==bel[i*2-1])return false;
	return true;
}
int getans(int c)
{
	int l = 0,r = c;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(check(c,mid))r = mid-1;
		else l = mid+1;
	}
	return l;
}
int main()
{
	int id = 0;
	scanf("%d",&n);
	if(n<=2){printf("0\n");return 0;}
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
		{
			id++;
			scanf("%d",&a[i][j]);a[j][i]=a[i][j];
			edge[id]=(Edge){i,j,a[i][j]};
		}
	for(int i = 1;i<= n;i++)fa[i]=i,d[i]=0;
	sort(edge+1,edge+id+1,cmp);
	int ans = INF;
	for(int i = 1;i<= id;i++)
	{
		int u = edge[i].u,v = edge[i].v,w = edge[i].w;
		int x = getfa(u),y = getfa(v);
		if(x!=y)
		{
			ans = min(ans,w+getans(w));
			d[x] = d[u]^d[v]^1;
			fa[x] = y;
		}else if(d[u]==d[v])
		{
			ans=min(ans,w+getans(w));
			break;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem4098

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int mod = 1e9+7;
char s[N][N];
int f[2][N][N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	f[0][1][n] = 1;
	for(int i = 1;i<=n;i++)
	{
		int now = i&1,pre = (i-1)&1;
		memset(f[now],0,sizeof(f[now]));
		for(int x1 = 1;x1<= i;x1++)
		{
			int y1 = i-x1+1;
			for(int x2 = n;x2>=n-i;x2--)
			{
				int y2 = n-(i-(n-x2))+1;
				if(s[x1][y1]==s[x2][y2])
					f[now][x1][x2] = ((f[pre][x1][x2]+f[pre][x1-1][x2])%mod+(f[pre][x1][x2+1]+f[pre][x1-1][x2+1])%mod)%mod;
			}
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		(ans+=f[n&1][i][i])%=mod;
	printf("%d\n",ans);
	return 0;
}
Problem4100

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL v[7][7];
int main()
{
	int n,x;
	char tmp[3];
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%s%d",tmp,&x);
		if(tmp[0]=='B')v[0][(x%7+7)%7]++;
		else if(tmp[0]=='E')v[1][(x%7+7)%7]++;
		else if(tmp[0]=='S')v[2][(x%7+7)%7]++;
		else if(tmp[0]=='I')v[3][(x%7+7)%7]++;
		else if(tmp[0]=='G')v[4][(x%7+7)%7]++;
		else if(tmp[0]=='O')v[5][(x%7+7)%7]++;
		else v[6][(x%7+7)%7]++;
	}
	LL ans = 0;
	for(int B = 0;B<7;B++)
	for(int E = 0;E<7;E++)
	for(int S = 0;S<7;S++)
	for(int I = 0;I<7;I++)
	for(int G = 0;G<7;G++)
	for(int O = 0;O<7;O++)
	for(int M = 0;M<7;M++)
	{
		if((B+E+S+S+I+E)*(G+O+E+S)*(M+O+O)%7==0)
			ans += v[0][B]*v[1][E]*v[2][S]*v[3][I]*v[4][G]*v[5][O]*v[6][M];
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4101

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct G
{int s,p;}g[N];
bool cmp(G a,G b)
{
	return a.p<b.p;
}
int n,b;
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(g[mid].p<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&b);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&g[i].s,&g[i].p);
	sort(g+1,g+n+1,cmp);
	int l = find(b)-1;
	int r = l+1;
	int ans = 0x3f3f3f3f;
	for(int i = l;i>=1;i--)
	{
		while(r<=n&&g[r].p-g[i].p<=g[i].s)
		{
			ans = min(ans,g[r].p-g[i].p-g[r].s);
			r++;
		}
	}
	r = l+1;
	for(int i = r;i<=n;i++)
	{
		while(l&&g[i].p-g[l].p<=g[i].s)
		{
			ans = min(ans,g[i].p-g[l].p-g[l].s);
			l--;
		}
	}
	if(ans!=0x3f3f3f3f)printf("%d\n",max(ans,0));
	else printf("-1\n");
	return 0;
}
Problem4102

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 20005;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
queue<int>Q;
int dis[N][N];
void bfs(int s)
{
	memset(dis[s],-1,sizeof(dis[s]));
	Q.push(s);
	dis[s][s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(dis[s][e[i].to]==-1)
			{
				dis[s][e[i].to] = dis[s][x]+1;
				Q.push(e[i].to);
			}
	}
	return ;
}
struct P
{int no,val;}p[N];
bool cmp(P a,P b)
{
	return a.val>b.val;
}
int f[N];
int main()
{
	int n,en;
	scanf("%d%d",&n,&en);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&p[i].val);
		p[i].no = i;
		int d,x;
		scanf("%d",&d);
		for(int j = 1;j<= d;j++)
		{
			scanf("%d",&x);
			add(i,x);
		}
	}
	for(int i = 1;i<= n;i++)
	{
		bfs(i);
		for(int j = 1;j<= n;j++)
			dis[i][j]*=en;
		dis[0][i] = 0;
	}
	sort(p+1,p+n+1,cmp);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<i;j++)
			if(dis[p[j].no][p[i].no]>=0)
				f[i] = max(f[i],f[j]-dis[p[j].no][p[i].no]+p[i].val);
	int ans =0;
	for(int i = 1;i<= n;i++)
		ans = max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4103

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 3e5+5;
const int W = M*35;
int n,m,cnt,U,D,L,R,k;
int a[N],b[M];
int ch[W][2],sum[W],root[M];
struct data{int x,y;}q[N];
void insert(int x,int &y,int num,int dep)
{
	y = ++cnt;
	sum[y] = sum[x]+1;
	ch[y][0]=ch[x][0],ch[y][1]=ch[x][1];
	if(dep<0)return ;
	int t = num&(1<<dep);t = t>>dep;
	insert(ch[x][t],ch[y][t],num,dep-1);
}
int solve(int k,int dep)
{
	if(dep==-1)return 0;
	int tmp = 0,t;
	for(int i = U;i<= D;i++)
	{
		t = a[i]&(1<<dep);t = t>>dep;
		tmp+=sum[ch[q[i].y][t^1]]-sum[ch[q[i].x][t^1]];
	}
	if(tmp>=k)
	{
		for(int i = U;i<=D;i++)
		{
			t = a[i]&(1<<dep);t = t>>dep;
			q[i].x = ch[q[i].x][t^1];
			q[i].y = ch[q[i].y][t^1];
		}
		return solve(k,dep-1)+(1<<dep);
	}else
	{
		for(int i = U;i<=D;i++)
		{
			t = a[i]&(1<<dep);t = t>>dep;
			q[i].x = ch[q[i].x][t];
			q[i].y = ch[q[i].y][t];
		}
		return solve(k-tmp,dep-1);
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&b[i]);
	for(int i = 1;i<= m;i++)insert(root[i-1],root[i],b[i],30);
	int Q;
	scanf("%d",&Q);
	for(int i = 1;i<= Q;i++)
	{
		scanf("%d%d%d%d%d",&U,&D,&L,&R,&k);
		for(int i = U;i<= D;i++)
			q[i].x = root[L-1],q[i].y = root[R];
		printf("%d\n",solve(k,30));
	}
	return 0;
}
Problem4140

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 500010;
int n,opt,top,num;
int l[40],r1[40],r2[40];
bool t;
double A,B,C,sum;
inline double sqr(double x){return x*x;}
struct Point
{
	double x,y;
}ins[N],newq[N],q1[N],q2[N];
inline bool cmp1(const Point &a,const Point &b)   
{return a.x==b.x?a.y>b.y:a.x<b.x;}
inline bool cmp2(const Point &a,const Point &b)   
{return a.x==b.x?a.y<b.y:a.x<b.x;}
void rebuild() 
{
	while (num&&top-l[num]==l[num]-l[num-1])    
		num--;
	l[++num]=top;
	int L=l[num-1]+1,R=L-1,cnt=0;
	for (int i=L;i<=top;i++)    
		newq[++cnt]=ins[i];
	sort(newq+1,newq+cnt+1,cmp1);
	for (int i=1;i<=cnt;i++)
	{
		while (R>L&&(q1[R].y-q1[R-1].y)*(newq[i].x-q1[R].x)<=(newq[i].y-q1[R].y)*(q1[R].x-q1[R-1].x))   
			R--;
		q1[++R]=newq[i];
	}
	r1[num]=R;
	R=L-1;
	sort(newq+1,newq+cnt+1,cmp2);
	for (int i=1;i<=cnt;i++)
	{
		while (R>L&&(q2[R].y-q2[R-1].y)*(newq[i].x-q2[R].x)>=(newq[i].y-q2[R].y)*(q2[R].x-q2[R-1].x))   
			R--;
		q2[++R]=newq[i];
	}
	r2[num]=R;
}
inline double calc(Point x) 
{return A*x.x+B*x.y;}
bool query1(int l,int r)
{
	int mid1,mid2,len;double s1,s2;
	while (l<=r)
	{
		len=(r-l)/3;
		mid1=l+len;
		mid2=r-len;
		s1=calc(q1[mid1]);
		s2=calc(q1[mid2]);
		if (s1<s2)  
			{if (s1<C)  return t=1;r=mid2-1;}
		else    
			{if (s2<C)  return t=1;l=mid1+1;}
	}
	return 0;
}
bool query2(int l,int r)
{
	int mid1,mid2,len;double s1,s2;
	while (l<=r)
	{
		len=(r-l)/3;
		mid1=l+len;
		mid2=r-len;
		s1=calc(q2[mid1]);
		s2=calc(q2[mid2]);
		if (s1<s2)  
			{if (s1<C)  return t=1;r=mid2-1;}
		else    
			{if (s2<C)  return t=1;l=mid1+1;}
	}
	return 0;
}
inline void Query()
{
	t=0;
	for (int i=1;i<=num;i++)
	{
		if (B<0)    
			query1(l[i-1]+1,r1[i]); 
		else    
			query2(l[i-1]+1,r2[i]);
		if (t)  return;
	}
}
int main()
{
	scanf("%d",&n);
	while (n--)
	{
		scanf("%d%lf%lf",&opt,&A,&B);A+=sum,B+=sum;
		if  (opt==0)    
			ins[++top].x=A,ins[top].y=B,rebuild();
		else    
		{
			if (!top)   
				{puts("No");continue;}
			C=sqr(A)+sqr(B);
			A*=2;B*=2;
			Query();
			puts(t?"No":"Yes");
			if (!t) sum++;
		}
	}
}
Problem4145

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<16;
const int INF = 0x3f3f3f3f;
int d[105],c[105][20];
int f[105][N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&d[i]);
		for(int j = 1;j<= m;j++)
			scanf("%d",&c[i][j]);
	}
	memset(f,0x3f,sizeof(f));
	f[0][0] = 0;
	for(int i = 1;i<= n;i++)
	{
		for(int sta = 0;sta<1<<m;sta++)
			f[i][sta] = f[i-1][sta]+d[i];
		for(int sta = 0;sta<1<<m;sta++)
		{
			if(f[i][sta]==INF)continue;
			for(int k = 0;k<m;k++)
			{
				if(sta&(1<<k))continue;
				f[i][sta|(1<<k)] = min(f[i][sta|(1<<k)],f[i][sta]+c[i][k+1]);
			}
		}
		for(int sta = 0;sta<1<<m;sta++)
			f[i][sta] = min(f[i-1][sta],f[i][sta]);
	}
	printf("%d\n",f[n][(1<<m)-1]);
	return 0;
}
Problem4147

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int gcd(int a,int b)
{
	if(!b)return a;
	else return gcd(b,a%b);
}
bool calc(int n,int p,int q)
{
	return n%p<q&&n%p%(p-q)==0;
}
int main()
{
	int cas;
	int p,q,n;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d%d",&p,&q,&n);
		int d = gcd(p,q);
		if(n%d){puts("R");continue;}
		p/=d,q/=d,n/=d;
		if(p==q)puts("E");
		else if(p>q)
		{
			if(n<p)puts("P");
			else puts(calc(n,p,q)?"E":"P");
		}else
		{
			if(n<p)
			{
				if(n+p<q)puts("E");
				else puts(calc(n+p,q,p)?"P":"E");
			}
			else puts("E");
		}
	}
}
Problem4173

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 998244353;
ll oula(ll x)
{
	ll ans = x;
	for(ll i = 2;i*i<= x;i++)
	{
		if(x%i==0)ans = ans/i*(i-1);
		while(x%i==0)x/=i;
	}
	if(x!=1)ans = ans/x*(x-1);
	return ans%mod;
}
int main()
{
	ll n,m;
	scanf("%lld%lld",&n,&m);
	printf("%lld\n",(n%mod)*(m%mod)%mod*oula(n)%mod*oula(m)%mod);
	return 0;
}
Problem4174

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int mod = 998244353;
typedef long long ll;
int mu[N],prime[N],cnt,sum[N];
bool v[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
		{
			prime[++cnt] =i;
			mu[i] = mod-1;
		}
		for(int j = 1;j<=cnt&&prime[j]*i<N;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]]=(mod-mu[i])%mod;
			else
			{
				mu[i*prime[j]]=0;
				break;
			}
		}
	}
}
ll getsum(ll n)
{
	return (n*(n+1)>>1)%mod;
}
int main()
{
	int n,m,x;
	scanf("%d%d%d",&n,&m,&x);
	quick_mu();
	ll ans = 0;
	ans=((getsum(n)*getsum(m)-n*getsum(m)-m*getsum(n))%mod+mod)%mod;
	if(n>m)swap(n,m);
	for(int i = 1;i<= n;i++)
	{
		ll tmp = i+x/i*i*2;
		for(int j = 1;j*i<=n;j++)
			(ans+=tmp*mu[j]%mod*(n/i/j)%mod*(m/i/j)%mod)%=mod;
	}
	ans = ans*((mod+1)>>1)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4176

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
const int mod = 1e9+7;
int n,S;
int mu[N],prime[N/10],cnt,sum2[N];
bool v[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<=S;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<=S;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])
				mu[prime[j]*i] = -mu[i];
			else {mu[prime[j]*i]=0;break;}
		}
	}
}
int Get_Sum(int n)
{
	int i,ans=0,last;
	for(i=1;i<=n;i=last+1)
	{
		last = n/(n/i);
		(ans+=(ll)(last-i+1)*(n/i)%mod)%=mod;
	}
	return ans;
}
int get_sum(int x)
{
	if(x<=S)return mu[x];
	else return sum2[n/x];
}
void init()
{
	quick_mu();
	for(int i = 2;i<=S;i++)
		mu[i]+=mu[i-1];
	int i,j,last;
	for(i=1;n/i>S;i++);
	for(j=i;j;j--)
	{
		int n = ::n/j;
		sum2[j] = 1;
		for(i=2;i<=n;i=last+1)
		{
			last = n/(n/i);
			(sum2[j]-=(ll)(last-i+1)*get_sum(n/i)%mod)%=mod;
		}
	}
}
int main()
{
	int i,last,ans =0;
	scanf("%d",&n);
	S = ceil(pow(n,0.75)-1e-7)+1e-7;
	init();
	for(i=1;i<=n;i=last+1)
	{
		last = n/(n/i);
		ll tmp = Get_Sum(n/i);
		(ans+=(get_sum(last)-get_sum(i-1))*tmp%mod*tmp%mod)%=mod;
	}
	printf("%d\n",(ans+mod)%mod);
	return 0;
}
Problem4180

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
const ll INF = 1ll<<62;
ll n;
char s[N];
struct Matrix
{
	ll d[4][4];
	Matrix()
	{
		memset(d,0,sizeof(d));
	}
	Matrix(bool flag)
	{
		memset(d,0,sizeof(d));
		for(int i = 0;i<4;i++)d[i][i]=1;
	}
	void operator *=(const Matrix &s)
	{
		Matrix res;
		for(int i = 0;i<4;i++)for(int j  =0;j<4;j++)
		{
			res.d[i][j] = INF;
			for(int k = 0;k<4;k++)
				res.d[i][j] = min(res.d[i][j],d[i][k]+s.d[k][j]);
		}
		*this = res;
	}
	friend Matrix quick_pow(Matrix s,ll d)
	{
		Matrix res(true);
		while(d)
		{
			if(d&1)res*=s;
			s*=s;
			d>>=1;
		}
		return res;
	}
};
struct SAM
{
	int trs[N][4],fa[N],len[N];
	int cnt,last;
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p,newp,q,newq;
		p = last,newp = ++cnt;
		last = newp,len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)fa[newp] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[newp] = q;
			else
			{
				newq = ++cnt;
				fa[newq] = fa[q];
				len[newq] = len[p]+1;
				memcpy(trs[newq],trs[q],sizeof(trs[q]));
				fa[newp] = fa[q] = newq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = newq;
			}
		}
	}
	ll mn[N][4];
	bool vis[N];
	void dfs(int x)
	{
		vis[x] = true;
		for(int i = 0;i<4;i++)
		{
			if(!vis[trs[x][i]])dfs(trs[x][i]);
			if(trs[x][i])mn[x][i] = INF;
			else mn[x][i]=1;
		}
		for(int i = 0;i<4;i++)if(trs[x][i])
			for(int j = 0;j<4;j++)
				mn[x][j] = min(mn[x][j],mn[trs[x][i]][j]+1);
	}	
}sam;
Matrix go;
bool check(ll x)
{
	Matrix ans = quick_pow(go,x);
	for(int i= 0;i<4;i++)
		for(int j = 0;j<4;j++)
			if(ans.d[i][j]+1<=n)return true;
	return false;
}
int main()
{
	scanf("%lld",&n);
	scanf("%s",s+1);
	sam.init();
	sam.vis[0] = true;
	for(int i = 1;s[i];i++)
		sam.insert(s[i]-'A');
	sam.dfs(1);
	for(int i = 0;i<4;i++)
		for(int j = 0;j<4;j++)
			go.d[i][j] = sam.mn[sam.trs[1][i]][j];
	ll l = 0,r = n+1,ans=0;
	while(l<=r)
	{
		ll mid = (l+r)>>1;
		if(check(mid))l=mid+1;
		else r = mid-1,ans = mid;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4195

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int fa[N<<1];
int idx[N<<1],cnt;
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
void init()
{
	for(int i = 1;i<= cnt;i++)fa[i]=i;
}
struct seg
{
	int x,y,o;
}a[N];
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(idx[mid]<=x)l=mid+1;
		else r = mid;
	}
	return l-1;
}
int main()
{
	int cas;
	int n;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d",&n);
		cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].o);
			idx[++cnt]=a[i].x,idx[++cnt]=a[i].y;
		}
		sort(idx+1,idx+cnt+1);
		int tmp = cnt;cnt = 0;
		for(int i = 1;i<= tmp;i++)
			if(i==1||idx[i]!=idx[i-1])
				idx[++cnt] = idx[i];
		init();
		for(int i = 1;i<= n;i++)
			if(a[i].o)uni(find(a[i].x),find(a[i].y));
		bool flag = true;
		for(int i = 1;i<= n&&flag;i++)
			if(a[i].o==0)
			{
				if(getfa(find(a[i].x))==getfa(find(a[i].y)))
					flag = false;
			}
		if(flag)puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem4196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,cnt;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int top[N],deep[N],fa[N],w[N],size[N],son[N],t[N];
int sum[N<<2],f[N<<2],n;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x]!=n)dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	t[x] = cnt;
}
void push_down(int p,int l,int r)
{
	int mid = (l+r)>>1;
	sum[p] = (r-l+1)*f[p];
	f[p<<1] = f[p];
	sum[p<<1] = f[p]*(mid-l+1);
	f[(p<<1)+1] = f[p];
	sum[(p<<1)+1] = f[p]*(r-mid);
	f[p] = -1;
}
void update(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){f[p] =c;sum[p] = (r-l+1)*f[p];return ;}
	if(f[p]!=-1)push_down(p,l,r);
	int mid = (l+r)>>1;
	if(a<= mid)
		update(p<<1,l,mid,a,b,c);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
int getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	if(f[p]!=-1)push_down(p,l,r);
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans((p<<1)+1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans((p<<1)+1,mid+1,r,a,b);
}
int t_ans;
void get_update(int x,int y,int c,int opt)
{
	while(top[x]!=top[y])
	{
		if(deep[x]<deep[y])swap(x,y);
		if(opt==1)update(1,1,n,w[top[x]],w[x],c);
		else t_ans+=getans(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)update(1,1,n,w[y],w[x],c);
	else t_ans+=getans(1,1,n,w[y],w[x]);
}
int main()
{
	memset(f,-1,sizeof(f));
	int x;
	scanf("%d",&n);
	for(int i = 0;i< n;i++)
		son[i] = n;
	for(int i = 1;i< n;i++)
		{scanf("%d",&x);add(x,i);}
	dfs1(0,1);
	dfs2(0,0);
	char j[20];
	int q,tmp1,tmp2;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d",j,&x);
		if(j[0]=='i')
		{
			t_ans = 0;
			get_update(0,x,0,0);
			tmp1 = t_ans;
			get_update(0,x,1,1);
			t_ans = 0;
			get_update(0,x,0,0);
			printf("%d\n",t_ans-tmp1);
		}else
		{
			tmp1= getans(1,1,n,w[x],t[x]);
			update(1,1,n,w[x],t[x],0);
			tmp2 = getans(1,1,n,w[x],t[x]);
			printf("%d\n",tmp1-tmp2);
		}
	}
	return 0;
}
Problem4197

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int S = 1<<8;
int prime[N],cnt;
bool vis[N];
void quick_prime()
{
	for(int i = 2;i<=500;i++)
	{
		if(!vis[i])
			prime[cnt++] = i;
		for(int j = 0;j<cnt&&i*prime[j]<=500;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
struct Num
{
	int l,p,i;
	bool operator <(const Num &s)const
	{
		return p<s.p;
	}
}num[N];
int f[S][S],dp[S][S][2];
void calc(int x)
{
	int tmp = x;
	for(int i = 0;i<8;i++)
		if(tmp%prime[i]==0)
		{
			num[x].l|=1<<i;
			while(tmp%prime[i]==0)tmp/=prime[i];
		}
	num[x].p = tmp;
}
int main()
{
	int n,mod;
	quick_prime();
	scanf("%d%d",&n,&mod);
	for(int i = 2;i<= n;i++)
		calc(i);
	sort(num+2,num+n+1);
	f[0][0] = 1;
	int end = (1<<8)-1,i,j,k;
	for(i = 2;i<= n;i++)
	{
		if(i==2||num[i].p==1||num[i-1].p!=num[i].p)
			for(j = end;j>=0;j--)
				for(k = end;k>=0;k--)
					dp[j][k][0]=dp[j][k][1]=f[j][k];
		for(j = end;j>=0;j--)
			for(k = end;k>=0;k--)
			{
				if((j&num[i].l)==0)
					(dp[j][k|num[i].l][1]+=dp[j][k][1])%=mod;
				if((k&num[i].l)==0)
					(dp[j|num[i].l][k][0]+=dp[j][k][0])%=mod;
			}
		if(i==n||num[i].p==1||num[i].p!=num[i+1].p)
			for(j = end;j>=0;j--)
				for(k = end;k>=0;k--)
				{
					f[j][k] = dp[j][k][0]+dp[j][k][1]-f[j][k];
					f[j][k] = (f[j][k]%mod+mod)%mod;
				}
	}
	int ans = 0;
	for(j = 0;j<=end;j++)
		for(k = 0;k<=end;k++)
			if((j&k)==0)(ans+=f[j][k])%=mod;
	printf("%d\n",ans);
	return 0;
}
Problem4198

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
struct Heap
{
	ll w;int l;
	Heap(){}
	Heap(ll _w,int _l):w(_w),l(_l)
	{}
	bool operator <(const Heap &s)const
	{
		if(w!=s.w)return s.w<w;
		else return s.l<l;
	}
};
priority_queue<Heap>heap;
int n,k,nn;
ll ans = 0;
int main()
{
	scanf("%d%d",&n,&k);
	nn = n;ll x;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&x);
		heap.push(Heap(x,1));
	}
	if((n-1)%(k-1))nn+=(k-1)-(n-1)%(k-1);
	for(int i = n+1;i<= nn;i++)
		heap.push(Heap(0,1));
	while(nn>1)
	{
		ll s1 = 0;int s2 = 0;
		for(int i = 1;i<= k;i++)
		{
			Heap x = heap.top();
			heap.pop();
			s1+=x.w;s2=max(s2,x.l);
		}
		ans+=s1,nn-=(k-1);
		heap.push(Heap(s1,s2+1));
	}
	printf("%lld\n%d\n",ans,heap.top().l-1);
	return 0;
}
Problem4199

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
typedef long long ll;
const int INF = 2e9;
char s[N];
int fa[N],mx[N],mn[N],cnt[N];
int sa[N],c[N],v[N],nv[N],q[N],h[N],rk[N];
ll ans,tot;
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i=0;i<lim;i++)c[i]=0;
	for(i=0;i<len;i++)c[v[i]=s[i]-'a']++;
	for(i=1;i<lim;i++)c[i]+=c[i-1];
	for(i=len-1;i>=0;i--)sa[--c[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)c[i]=0;
		for(i=0;i<len;i++)c[v[q[i]]]++;
		for(i=1;i<lim;i++)c[i]+=c[i-1];
		for(i=len-1;i>=0;i--)sa[--c[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rk[i])
		{
			int j = 0;
			if(i)j = max(0,h[rk[i-1]]-1);
			while(i+j<len&&sa[rk[i]-1]+j<len&&s[i+j]==s[sa[rk[i]-1]+j])j++;
			h[rk[i]]=j;
		}
}
int a[N];
void init(int len)
{
	for(int i = 0;i< len;i++)
		fa[i]=i,mx[i]=mn[i]=a[sa[i]],cnt[i]=1;
}
vector<int>Q[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(x>y)swap(x,y);
	ll tmp = max(1ll*mx[x]*mx[y],1ll*mn[x]*mn[y]);
	if(tmp>ans||!tot)ans = tmp;
	tot+=1ll*cnt[x]*cnt[y];
	fa[y] = x;
	mx[x] = max(mx[x],mx[y]),mn[x]=min(mn[x],mn[y]);
	cnt[x]+=cnt[y];
}
ll Ans[N][2];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s);
	for(int i = 0;i<n;i++)scanf("%d",&a[i]);
	build_sa(n,26);
	build_rank(n);
	build_height(n);
	init(n);
	for(int i = 1;i<=n;i++)
		Q[h[i]].push_back(i);
	for(int i = n-1;i>=0;i--)
	{
		for(int j = 0;j<Q[i].size();j++)
			uni(Q[i][j],Q[i][j]-1);
		Ans[i][0] = tot,Ans[i][1] = ans;
	}
	for(int i = 0;i<n;i++)
		printf("%lld %lld\n",Ans[i][0],Ans[i][1]);
	return 0;
}
Problem4199

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
typedef long long ll;
int sa[N],cnt[N],val[N],nv[N],q[N],h[N],rnk[N];
char s[N];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int lim,int len)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]-'a']++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;
		
		for(i =0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]]=q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		if(lim==len)return ;
		for(i = 0;i<len;i++)val[i] = nv[i];
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])
				j++;
			h[rnk[i]]=j;
		}
}
int fa[N],size[N],n;
ll mx[N],mn[N],a[N];
ll tot,ans;
ll Ans[N][2];
void init()
{
	for(int i = 0;i<n;i++)
		fa[i]=i,mx[i]=mn[i]=a[sa[i]],size[i]=1;
}
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(x>y)swap(x,y);
	ll tmp = max(mx[x]*mx[y],mn[x]*mn[y]);
	if(tmp>ans||!tot)ans = tmp;
	tot+=(ll)size[x]*size[y];
	fa[y] = x;
	mx[x] = max(mx[x],mx[y]),mn[x] =min(mn[x],mn[y]);
	size[x] = size[x]+size[y];
}
vector<int>Q[N];
int main()
{
	scanf("%d",&n);scanf("%s",s);
	for(int i = 0;i<n;i++)scanf("%lld",&a[i]);
	build_sa(26,n);
	build_rank(n);
	build_height(n);
	init();
	for(int i = 1;i<=n;i++)
		Q[h[i]].push_back(i);
	for(int i = n-1;i>= 0;i--)
	{
		for(int j = 0;j<Q[i].size();j++)
			uni(Q[i][j],Q[i][j]-1);
		Ans[i][0]=tot,Ans[i][1] = ans;
	}
	for(int i = 0;i<n;i++)
		printf("%lld %lld\n",Ans[i][0],Ans[i][1]);
	return 0;
}
Problem4200

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+10;
const int S = 5e4+3,T = 5e4+4,SS = 5e4+1,TT = 5e4+2;
const int M = 5e5+5;
const int INF = 0x3f3f3f3f;
struct P
{
	int x,y,id;
}p[N];
inline bool cmp1(const P &a,const P &b)
{return a.x+a.y==b.x+b.y?a.y<b.y:a.x+a.y<b.x+b.y;}
inline bool cmp2(const P &a,const P &b)
{return a.x-a.y==b.x-b.y?a.y<b.y:a.x-a.y<b.x-b.y;}
inline bool cmp3(const P &a,const P &b)
{return a.x==b.x?a.y<b.y:a.x<b.x;}
inline bool cmp4(const P &a,const P &b)
{return a.y==b.y?a.x<b.x:a.y<b.y;}
int s[N],t1[N],t2[N],t3[N],f[N],ff[N],l[N],r[N],lf[N],rf[N],a[N],an;
vector<int>v,t[N];
namespace Max_Flow
{
	queue<int>Q;
	struct E
	{int next,to,f;}e[M];
	int head[N],_head[N],tot,d[N];
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f=f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f=0;
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[s] = 0;Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f&&d[e[i].to]==-1)
				{
					d[e[i].to] = d[x]+1;
					Q.push(e[i].to);
				}
		}
		memcpy(_head,head,sizeof(head));
		return d[t]!=-1;
	}
	int get_mxf(int s,int t,int mx)
	{
		if(s==t)return mx;
		int last = mx;
		for(int &i = _head[s];i;i=e[i].next)
			if(e[i].f&&d[e[i].to]==d[s]+1)
			{
				int tof = get_mxf(e[i].to,t,min(last,e[i].f));
				if(tof)
				{
					e[i].f-=tof;e[i^1].f+=tof;
					if(!(last-=tof))return mx;
				}
			}
		d[s] = -1;
		return mx-last;
	}
	int dinic(int s,int t)
	{
		int ans = 0;
		while(bfs(s,t))
			ans+=get_mxf(s,t,INF);
		return ans;
	}
}
void update(int x,int y)
{
	if(ff[y]+1>f[x])f[x]=ff[y]+1,t[x].clear();
	if(ff[y]+1==f[x])t[x].push_back(y);
}
void getans(int x)
{
	a[++an] = x;
	int i,j,u=1;
	if(f[x]==ff[x])
	{
		u = 0;
		if(p[x].id)getans(t[x][0]);
	}
	for(i=l[x];u&&i<x;i++)if(f[i]+x-l[x]==ff[x])
	{
		u=0;
        for(j=x;--j>i;)a[++an]=j;
        for(j=l[x];j<=i;++j)a[++an]=j;
        if(p[i].id)getans(t[i][0]);
	}
	for(i=r[i];u&&i>x;--i)if(f[i]+r[x]-x==ff[x])
	{
        u=0;
        for(j=x;++j<i;)a[++an]=j;
        for(j=r[x];j>=i;--j)a[++an]=j;
        if(p[i].id)getans(t[i][0]);
	}
}
int d[N],u[N],c[N];
void Insert(int x,int y)
{
	Max_Flow::add(x,y,INF);
	c[x]++,c[y]--;
}
void dfs(int x)
{
    if(d[x])return;
    int i,j;d[x]=1;
    if(f[x]==ff[x]&&!u[x])
    	for(u[x]=1,i=0;i<t[x].size();++i)
    		Insert(t[x][i],x),dfs(t[x][i]);
    for(i=l[x];i<x;++i)
    	if(f[i]+x-l[x]==ff[x]&&!u[i])
    		for(u[i]=1,j=0;j<t[i].size();++j)
    			Insert(t[i][j],i),dfs(t[i][j]);
    for(i=r[x];i>x;--i)
    	if(f[i]+r[x]-x==ff[x]&&!u[i])
    		for(u[i]=1,j=0;j<t[i].size();++j)
    			Insert(t[i][j],i),dfs(t[i][j]);
}
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		p[i].id = i;
	}
	sort(p,p+n+1,cmp1);
	for(int i = 0;i<n;i++)if(p[i].x+p[i].y==p[i+1].x+p[i+1].y)t1[p[i].id]=p[i+1].id;
	sort(p,p+n+1,cmp2);
	for(int i = 0;i<n;i++)if(p[i].x-p[i].y==p[i+1].x-p[i+1].y)t2[p[i].id]=p[i+1].id;
	sort(p,p+n+1,cmp3);
	for(int i = 0;i<n;i++)if(p[i].x==p[i+1].x)t3[p[i].id] = p[i+1].id;
	sort(p,p+n+1,cmp4);for(int i = 0;i<= n;i++)s[p[i].id] = i;
	memset(f,0xef,sizeof(f));
	f[s[0]] = 0;
	for(int i = 0;i<= n;i=r[i]+1)
	{
		for(l[i]=r[i]=i;r[i]<n&&p[r[i]].y==p[r[i]+1].y;++r[i]);
		for(int j = l[i];++j<=r[i];)
			l[j]=l[i],r[j]=r[i];
		lf[l[i]] = -INF;
		for(int j = l[i];++j<=r[i];)lf[j] = max(lf[j-1],f[j-1]);
		rf[r[i]] = -INF;
		for(int j = r[i];--j>=l[i];)rf[j] = max(rf[j+1],f[j+1]);
		for(int j = l[i];j<=r[i];j++)
		{
			ff[j] = max(f[j],max(lf[j]+j-l[i],rf[j]+r[i]-j));
			if(t1[p[j].id])update(s[t1[p[j].id]],j);
			if(t2[p[j].id])update(s[t2[p[j].id]],j);
			if(t3[p[j].id])update(s[t3[p[j].id]],j);
			if(ff[j]>ans)ans=ff[j],v.clear();
			if(ff[j]==ans)v.push_back(j);
		}
	}
	Max_Flow::tot = 1;
	printf("%d\n",ans);
	getans(v[0]);
	for(int i = an;--i;)
		printf("%d ",p[a[i]].id);
	printf("\n");
	for(int i = 0;i<v.size();i++)dfs(v[i]);
	for(int i = 0;i<= n;i++)
	{
		if(c[i]<0)Max_Flow::add(S,i,-c[i]);
		if(c[i]>0)Max_Flow::add(i,T,c[i]);
		Max_Flow::add(SS,i,INF),Max_Flow::add(i,TT,INF);
	}
	Max_Flow::dinic(S,T);
	Max_Flow::add(TT,SS,INF);
	printf("%d\n",Max_Flow::dinic(S,T));
	return 0;
}
Problem4205

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 7e4+5;
const int M = 4e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],_head[N],tot = 1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	for(int i = s;i<= t;i++)d[i]=-1;
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	if(d[s]==-1)return false;
	memcpy(_head,head,sizeof(head));
	return true;
}
int get_mxf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last=mf;
	for(int i = _head[s];i;i=e[i].next)
	{
		_head[s] = i;
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	}
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
const int P = 205;
bool vis[P];
int prime[P],cnt;
vector<int>fac[P];
int id[50][50];
void quick_prime()
{
	for(int i = 2;i<=200;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<=200;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = prime[i];j<=200;j+=prime[i])
			fac[j].push_back(i);
	}
}
struct Card
{int a,b,c;}c0[30005],c1[30005];
int S,T;
int n1,n2;
void build(int no,int tp)
{
	int a,b,c;
	if(tp)a = c1[no].a,b = c1[no].b,c = c1[no].c;
	else a = c0[no].a,b = c0[no].b,c = c0[no].c;
	for(int i = 0;i<fac[a].size();i++)
		for(int j = 0;j<fac[b].size();j++)
			if(tp)add(id[fac[a][i]][fac[b][j]]+n1+n2,n1+no,1);
			else add(no,id[fac[a][i]][fac[b][j]]+n1+n2,1);
	for(int i = 0;i<fac[a].size();i++)
		for(int j = 0;j<fac[c].size();j++)
			if(tp)add(id[fac[a][i]][fac[c][j]]+cnt*cnt+n1+n2,n1+no,1);
			else add(no,id[fac[a][i]][fac[c][j]]+cnt*cnt+n1+n2,1);
	for(int i = 0;i<fac[b].size();i++)
		for(int j = 0;j<fac[c].size();j++)
			if(tp)add(id[fac[b][i]][fac[c][j]]+cnt*cnt*2+n1+n2,n1+no,1);
			else add(no,id[fac[b][i]][fac[c][j]]+cnt*cnt*2+n1+n2,1);
}
int main()
{
	scanf("%d%d",&n1,&n2);
	quick_prime();
	int Id = 0;
	for(int i = 1;i<= cnt;i++)
		for(int j = 1;j<= cnt;j++)
			id[i][j] = ++Id;
	S = 0,T = n1+n2+3*Id+1;
	for(int i = 1;i<= n1;i++)
		scanf("%d%d%d",&c0[i].a,&c0[i].b,&c0[i].c);
	for(int i = 1;i<= n2;i++)
		scanf("%d%d%d",&c1[i].a,&c1[i].b,&c1[i].c);
	for(int i = 1;i<= n1;i++)
		add(S,i,1),build(i,0);
	for(int i = 1;i<= n2;i++)
		add(i+n1,T,1),build(i,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem4206

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const double PI = acos(-1.0);
const double INF = 1e18;
double R,x,y,len,ang1,ang2;
double stack[N];
int top;
struct Point
{
	double x,y;
	bool flag;
	bool operator <(const Point &s)const
	{
		if(flag==s.flag)
		{
			if(x==s.x)return y<s.y;
			return x<s.x;
		}
		return flag<s.flag;
	}
}p[N];
double getdis(double x,double y)
{
	return sqrt(x*x+y*y);
}
int Find(double x)
{
	int l = 0,r = top,ans = 0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(stack[mid]>=x)ans = mid,r = mid-1;
		else l = mid+1;
	}
	return ans;
}
int main()
{
	int n;
	scanf("%d%lf",&n,&R);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf",&p[i].x,&p[i].y);
		if(getdis(p[i].x,p[i].y)<R)
		{
			p[i].flag = true;
			continue;
		}
		ang1 = atan2(p[i].y,p[i].x),ang2 = acos(R/getdis(p[i].x,p[i].y));
		p[i].x = ang1-ang2;p[i].y = ang1+ang2;
		if(p[i].y>PI)p[i].y-=PI*2,swap(p[i].x,p[i].y);
		if(p[i].x<-PI)p[i].x+=PI*2,swap(p[i].x,p[i].y);
	}
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i++)
		if(p[i].flag)
			{n = i-1;break;}
	stack[0] = -INF;
	int ans = 0;
	for(int i = 1;i<= n;i++)
	{
		stack[top=1]=p[i].y;
		for(int j = i+1;j<= n;j++)
		{
			if(p[j].x>p[i].y)break;
			if(p[j].y>stack[top])
				stack[++top] = p[j].y;
			else
			{
				int tmp = Find(p[j].y);
				if(tmp!=1)stack[tmp]=p[j].y;
			}
		}
		ans = max(ans,top);
	}
	printf("%d\n",ans);
	return 0;
}
Problem4212

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Lth = 2000005;
const int N = 2005;
char s[Lth],s1[Lth],s2[Lth];
struct STR{int bg,ed;}str[N];
int trie[Lth][26],Max[Lth],Min[Lth],root[Lth],tot;
struct Trie
{
	int ch[Lth][26],sum[Lth],cnt;
	int insert(int id,int pre)
	{
		int tmp,y;
		tmp = y = ++cnt;
		for(int i = str[id].ed;i>=str[id].bg;i--)
		{
			for(int j = 0;j<26;j++)ch[y][j]=ch[pre][j];
			sum[y] = sum[pre]+1;
			int p = s[i]-'a';
			pre = ch[pre][p];
			ch[y][p] = ++cnt;
			y = ch[y][p];
		}
		sum[y] = sum[pre]+1;
		return tmp;
	}
	int getans(int L,int R,int lth)
	{
		for(int i = lth;i>=1;i--)
		{
			//fprintf(stderr, "%d %d\n",L,R);
			L = ch[L][s2[i]-'a'],R = ch[R][s2[i]-'a'];
		}
		return sum[R]-sum[L];
	}
}tr;
bool cmp(const STR &a,const STR &b)
{
	int p1 = a.bg,p2 = b.bg;
	while(p1<=a.ed&&p2<=b.ed)
	{
		if(s[p1]<s[p2])return true;
		else if(s[p1]>s[p2])return false;
		p1++,p2++;
	}
	if (p1<=a.ed) return 0;
	else if (p2<=b.ed) return 1;
	else return 0;
}
char tmp[Lth];
int main()
{
	//freopen("x.in","r",stdin);
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",tmp+1);
		str[i].bg = str[i-1].ed+1;
		str[i].ed = str[i].bg+strlen(tmp+1)-1;
		for(int j = str[i].bg;j<=str[i].ed;j++)s[j]=tmp[j-str[i].bg+1];
	}
	sort(str+1,str+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		int now = 0;
		for(int j = str[i].bg;j<= str[i].ed;j++)
		{
			int p = s[j]-'a';
			if(!trie[now][p])trie[now][p] = ++tot;
			now = trie[now][p];
			if(Min[now]==0)Min[now] = i;
			Max[now] = max(Max[now],i);
		}
	}
	for(int i = 1;i<= n;i++)
		root[i] = tr.insert(i,root[i-1]);
	int ans = 0;
	int m;
	scanf("%d",&m);
	while(m--)
	{
		scanf("%s",s1+1);int lth1 = strlen(s1+1);
		scanf("%s",s2+1);int lth2 = strlen(s2+1);
		for(int i = 1;i<= lth1;i++)s1[i] = (s1[i]-'a'+ans)%26+'a';
		for(int i = 1;i<= lth2;i++)s2[i] = (s2[i]-'a'+ans)%26+'a';
		int now = 0,l = -1,r = -1;
		for(int i = 1;i<= lth1;i++)
		{
			int p = s1[i]-'a';
			if(!trie[now][p])break;
			now = trie[now][p];
			if(i==lth1){l=Min[now],r=Max[now];}
		}
		if(l==-1&&r==-1){ans = 0;printf("%d\n",ans);continue;}
		ans = tr.getans(root[l-1],root[r],lth2);
		printf("%d\n",ans);
	}
	return 0;
}
Problem4227

#include <stdio.h>
#include <queue>
#include <vector>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3e5+5;
const int M = 8e5+5;
struct E{int next,to,val;};
struct Edge{int x,y,f;}a[M];
ll dis[N];
bool vis[N];
queue<int>Q;
E e[M];
int head[N],tot,deg[N],n,m,id[N],cnt;
void add(int x,int y,int f=0)
{e[++tot].to=y;e[tot].next=head[x];e[tot].val=f;head[x]=tot;deg[y]++;}
void spfa(int s)
{
	memset(dis,0x3f,sizeof(dis));
	dis[s] = 0;vis[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].val)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(!vis[e[i].to])
				{
					vis[e[i].to]=true;
					Q.push(e[i].to);
				}
			}
	}
}
int dep[N],fa[N][18],size[N],sum[M];
void rebuild()
{
	memset(head,0,sizeof(head));
	memset(deg,0,sizeof(deg));
	tot = 0;cnt = n;
	for(int i = 1;i<= n;i++)size[i]=dis[i]<dis[0];
	for(int i = 1;i<= m;i++)
	{
		if(dis[a[i].x]+a[i].f==dis[a[i].y])
			id[++cnt]=i,add(a[i].x,cnt),add(cnt,a[i].y);
		if(dis[a[i].y]+a[i].f==dis[a[i].x])
			id[++cnt]=i,add(a[i].y,cnt),add(cnt,a[i].x);
	}
	for(int i = 1;i<= cnt;i++)
		if(!deg[i])
			add(cnt+1,i);
	cnt++;
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
vector<int>E[N];
void dfs(int x)
{
	for(int i = 0;i<E[x].size();i++)
	{
		dfs(E[x][i]);
		size[x]+=size[E[x][i]];
	}
	sum[id[x]]=size[x];
}
ll ans[N];
int main()
{
	int s;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].f);
		add(a[i].x,a[i].y,a[i].f),add(a[i].y,a[i].x,a[i].f);
	}
	scanf("%d",&s);
	spfa(s);
	rebuild();
	Q.push(cnt);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		if(fa[x][0])E[fa[x][0]].push_back(x);
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<18;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
		for(int i = head[x];i;i=e[i].next)
		{
			if(!fa[e[i].to][0])fa[e[i].to][0]=x;
			else fa[e[i].to][0]=getlca(fa[e[i].to][0],x);
			if(!--deg[e[i].to])Q.push(e[i].to);
		}	
	}
	dfs(cnt);
	for(int i = 1;i<= m;i++)
		ans[a[i].x]+=sum[i],ans[a[i].y]+=sum[i];
	for(int i = 1;i<= n;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem4237

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 2e9;
struct P
{
	int x,y;
}a[N],q1[N],q2[N];
bool cmpy(const P &a,const P &b)
{
	return a.y>b.y;
}
bool cmpx(const P &a,const P &b)
{
	return a.x<b.x;
}
long long ans;
int find(int x,int lim)
{
	int l = 1,r = lim;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(q1[mid].y<=x)r = mid-1;
		else l = mid+1;
	}
	return r;
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)return ;
	CDQ(l,mid);
	sort(a+l,a+mid+1,cmpy);
	sort(a+mid+1,a+r+1,cmpy);
	int top1 = 0,top2 = 0,p = mid+1;
	q1[0].y = q2[0].y = INF;
	int ll,rr;
	for(int i = l;i<=mid;i++)
	{
		while(p<=r&&a[p].y>a[i].y)
		{
			while(top1&&a[p].x<q1[top1].x)
				top1--;
			q1[++top1] = a[p];
			p++;
		}
		while(top2&&a[i].x>q2[top2].x)
			top2--;
		q2[++top2] = a[i];
		ll = find(q2[top2-1].y,top1)+1;
		rr = find(q2[top2].y,top1);
		if(ll<=rr)
			ans+=rr-ll+1;
	}
	sort(a+l,a+mid+1,cmpx);
	sort(a+mid+1,a+r+1,cmpx);
	CDQ(mid+1,r);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<= n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmpx);
	CDQ(1,n);
	printf("%lld\n",ans);
	return 0;
}
Problem4238

#include<stdio.h>
#include<string.h>
#include<algorithm>
#define N 110000
#define M 210000
using namespace std;
int next[M<<1],to[M<<1],head[N],tot=1;
int deep[N],fa[N],good[N],bad[N],gc,bc;
bool vis[N];
void add(int x,int y)
{
  to[++tot]=y;
  next[tot]=head[x];
  head[x]=tot;
}
void dfs(int x,int pre)
{
  deep[x]=deep[fa[x]]+1,vis[x]=1;
  int i;
  for(i=head[x];i;i=next[i])
  {
    if((i^1)==pre)  continue;
    if(!vis[to[i]])
    {
      fa[to[i]]=x;
      dfs(to[i],i);
      good[x]+=good[to[i]];
      bad[x]+=bad[to[i]];
    }
    else
    {
      if(deep[to[i]]>deep[x]) continue;
      if(deep[x]-deep[to[i]]&1)
        good[x]++,good[to[i]]--,gc++;
      else
        bad[x]++,bad[to[i]]--,bc++;
    }
  }
}
int main()
{
  int n,m,i,j,k,x,y,ans;
  scanf("%d%d",&n,&m);
  for(i=1;i<=m;i++)
  {
    scanf("%d%d",&x,&y);
    add(x,y),add(y,x);
  }
  for(i=1;i<=n;i++)
  {
    if(!vis[i])
      dfs(i,0);
  }
  for(i=1,ans=0;i<=n;i++)
  {
    if(fa[i]&&bad[i]==bc&&!good[i])
      ans++;
  }
  if(bc==1)
    ans++;
  printf("%d\n",ans);
  return 0;
}
Problem4243

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 2e5+5;
struct E
{int next,to;}e[M<<1];
int head1[N],head2[N],tot;
void add1(int x,int y){e[++tot].to=y;e[tot].next=head1[x];head1[x]=tot;}
void add2(int x,int y){e[++tot].to=y;e[tot].next=head2[x];head2[x]=tot;}
int fa[N],size[N],outd[N];
bool bo[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(size[x]<size[y])swap(x,y);
	fa[y] = x;size[x]+=size[y];
}
queue<int>Q;
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add1(x,y),add2(y,x),outd[x]++;
	}
	for(int i = 1;i<= n;i++)fa[i]=i,size[i]=1;
	for(int i = 1;i<= n;i++)
	{
		for(int id = head1[i];id;id=e[id].next)bo[e[id].to]=true;
		for(int id = head2[i];id;id=e[id].next)
			if(bo[e[id].to])merge(i,e[id].to);
		for(int id = head1[i];id;id=e[id].next)bo[e[id].to]=false;
	}
	for(int i = 1;i<= n;i++)
	{
		int y = 0;
		for(int id = head1[i];id;id=e[id].next)
			if(y)merge(y,e[id].to);
			else y = e[id].to;
	}
	memset(bo,true,sizeof(bo));
	for(int i = 1;i<= n;i++)
		if(size[getfa(i)]>1)Q.push(i),bo[i]=false;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head1[x];i;i=e[i].next)
		{
			merge(x,e[i].to);
			if(bo[e[i].to]){bo[e[i].to]=false;Q.push(e[i].to);}
		}
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
		if(getfa(i)==i)
		{
			if(size[i]>1)ans+=(long long)size[i]*(size[i]-1);
			else ans+=outd[i];
		}
	printf("%lld\n",ans);
	return 0;
}
Problem4246

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define fir first
#define sec second
typedef long long ll;
const double eps = 1e-10;
const int N = 3005;
const double PI = 3.1415926535897323;
int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	if(x>0)return 1;else return -1;
}
struct Point
{
	int x,y;
	Point(int _x=0,int _y=0):x(_x),y(_y){}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double arctan2(const Point &p)
	{
		double ang = atan2(p.y,p.x);
		if(ang<=0)return ang+PI;
		else return ang;
	}
}O;
pair<Point,int>point[N],stack[N];
int top;
ll ans;
void calc(int c)
{
	static pair<double,int>b[N];
	bool v[N];
	static pair<Point,int>_stack[N];
	int cnt[2][3]={};
	for(int i = 1;i<= top;i++)
		b[i] = make_pair(arctan2(stack[i].fir-O),i);
	sort(b+1,b+top+1);
	for(int i = 1;i<= top;i++)
		_stack[i]=stack[b[i].sec];
	memcpy(stack+1,_stack+1,sizeof(stack[0])*top);
	for(int i = 1;i<= top;i++)
	{
		if(stack[i].fir.y<O.y||stack[i].fir.y==O.y&&stack[i].fir.x>O.x)
			cnt[v[i]=false][stack[i].sec]++;
		else 
			cnt[v[i]=true][stack[i].sec]++;
	}
	int cnt0,cnt1;
	for(int i = 1;i<= top;i++)
	{
		cnt[v[i]][stack[i].sec]--;
		cnt0 = (c==0?1:cnt[0][0])*(c==1?1:cnt[0][1])*(c==2?1:cnt[0][2]);
		int C = stack[i].sec;
		cnt1 = (C==0?1:cnt[1][0])*(C==1?1:cnt[1][1])*(C==2?1:cnt[1][2]);
		//cnt0/=cnt[0][c],cnt1/=cnt[1][stack[i].sec];
		ans+=(ll)cnt0*cnt1;
		cnt0 = (c==0?1:cnt[1][0])*(c==1?1:cnt[1][1])*(c==2?1:cnt[1][2]);
		cnt1 = (C==0?1:cnt[0][0])*(C==1?1:cnt[0][1])*(C==2?1:cnt[0][2]);
		//cnt0/=cnt[1][c],cnt1/=cnt[0][stack[i].sec];
		ans+=(ll)cnt0*cnt1;
		cnt[v[i]^1][stack[i].sec]++;
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&point[i].fir.x,&point[i].fir.y,&point[i].sec);
	for(int i = 1;i<= n;i++)
	{
		top = 0;
		for(int j = 1;j<= n;j++)
			if(i!=j)
				stack[++top]=point[j];
		O = point[i].fir;
		calc(point[i].sec);
	}
	printf("%lld\n",ans>>2);
	return 0;
}
Problem4260

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e5+5;
const int M = 35*N;
struct Trie
{
	int ch[M][2],sum[M];
	int cnt;
	int insert(int x,int num)
	{
		int tmp,y;
		tmp=y=++cnt;
		for(int i = 30;i>=0;i--)
		{
			int t = num&(1<<i);t = t>>i;
			ch[y][0]=ch[x][0],ch[y][1]=ch[x][1];
			x = ch[x][t];
			y = ch[y][t]=++cnt;
			sum[y] = sum[x]+1;
		}
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 30;i>= 0;i--)
		{
			int t = val&(1<<i);t=t>>i;
			if(sum[ch[r][t^1]]-sum[ch[l][t^1]]>0)
				l=ch[l][t^1],r=ch[r][t^1],ans+=(1<<i);
			else l = ch[l][t],r=ch[r][t];
		}
		return ans;
	} 
}trie;
int z[N],y[N],a[N],root[N];
int main()
{
	int n;
	scanf("%d",&n);
	n++;
	a[1] = 0;
	for(int i = 2;i<= n;i++)
	{
		scanf("%d",&a[i]);
		a[i] = a[i-1]^a[i];
	}
	for(int i = 1;i<= n;i++)
		root[i] = trie.insert(root[i-1],a[i]);
	for(int i = 2;i<=n;i++)
	{
		z[i] = trie.getans(root[0],root[i],a[i]);
		y[i] = trie.getans(root[i-1],root[n],a[i]);
	}
	for(int i = 1;i<= n;i++)z[i] = max(z[i],z[i-1]);
	for(int i = n;i>= 1;i--)y[i] = max(y[i],y[i+1]);
	int ans = 0;
	for(int i = 2;i<=n;i++)
		ans = max(ans,z[i]+y[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4276

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<iostream>
#define maxn 30010
#define maxm 200010
#define inf 1000000000

using namespace std;

struct yts
{
	int l,r,num;
}a[20010];

int head[maxn],to[maxm],c[maxm],len[maxm],next[maxm],p[maxm],fr[maxn],dis[maxn],q[maxn];
bool vis[maxn];
int n,m,s,t,num,ans,cnt;

void addedge(int x,int y,int z,int w)
{
	num++;to[num]=y;c[num]=z;len[num]=w;p[num]=x;next[num]=head[x];head[x]=num;
	num++;to[num]=x;c[num]=0;len[num]=-w;p[num]=y;next[num]=head[y];head[y]=num;
}

void build(int i,int l,int r)
{
	a[i].l=l;a[i].r=r;a[i].num=++cnt;
	if (l==r)
	{
		addedge(a[i].num,t,1,0);
		return;
	}
	int mid=(l+r)/2;
	build(i*2,l,mid);build(i*2+1,mid+1,r);
	addedge(a[i].num,a[i*2].num,inf,0);
	addedge(a[i].num,a[i*2+1].num,inf,0);
}

void query(int i,int l,int r,int x)
{
	if (l<=a[i].l && a[i].r<=r)
	{
		addedge(x,a[i].num,1,0);
		return;
	}
	int mid=(a[i].l+a[i].r)/2;
	if (l<=mid) query(i*2,l,r,x);
	if (mid<r) query(i*2+1,l,r,x);
} 

bool spfa()
{
	for (int i=s;i<=t;i++) dis[i]=-inf;
	int l=0,r=1;
	q[1]=s;dis[s]=0;vis[s]=1;
	while (l!=r)
	{
		l++;if (l==maxn) l=0;
		int x=q[l];
		for (int p=head[x];p;p=next[p])
		  if (c[p] && dis[x]+len[p]>dis[to[p]])
		  {
		  	dis[to[p]]=dis[x]+len[p];
		  	fr[to[p]]=p;
		  	if (!vis[to[p]])
		  	{
		  		r++;if (r==maxn) r=0;
		  		q[r]=to[p];vis[to[p]]=1;
		  	}
		  }
		vis[x]=0;
	}
	if (dis[t]==-inf) return 0; else return 1;
}

void mcf()
{
	int x=inf;
	for (int i=fr[t];i;i=fr[p[i]]) x=min(x,c[i]);
	for (int i=fr[t];i;i=fr[p[i]]) ans+=x*len[i],c[i]-=x,c[i^1]+=x;
}

void costflow()
{
	while (spfa()) mcf();
}

int main()
{
	scanf("%d",&n);
	num=1;s=0,t=30000;
	build(1,1,5000);
	for (int i=1;i<=n;i++)
	{
		int l,r,x;
		scanf("%d%d%d",&l,&r,&x);
		r--;
		addedge(s,++cnt,1,x);
		query(1,l,r,cnt);
	}
	costflow();
	printf("%d\n",ans);
	return 0;
}
Problem4291

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int a[N];
int main()
{
	int n;
	ll ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),ans+=a[i];
	sort(a+1,a+n+1);
	if(n==1)
	{
		if(a[1]%2==1)printf("NIESTETY\n");
		else printf("%d\n",a[1]);
	}
	else
	{
		if(ans%2==0)printf("%lld\n",ans);
		else
		{
			for(int i = 1;i<= n;i++)
				if(a[i]%2==1)
					{ans-=a[i];break;}
			printf("%lld\n",ans);
		}
	}
	return 0;
}
Problem4292

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
bool check(ll ans,int num)
{
	int tmp = 0;
	while(ans)
	{
		int k = ans%10;
		ans/=10;
		tmp +=k*k;
	}
	return tmp==num;
}
int main()
{
	ll k,a,b,ans=0;
	scanf("%lld%lld%lld",&k,&a,&b);
	for(int i = max(a/k-2,0ll);i<= min(b/k+2,1458ll);i++)
		if(check(k*i,i)&&k*i<=b&&k*i>=a)
			ans++;
	printf("%lld\n",ans);
	return 0;
}
Problem4293

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
struct Seg
{
	ll sum,v,lazy,del;
	Seg(){lazy = -1;}
}t[N<<2];
ll a[N],sum[N];
inline int id(int l,int r){return (l+r)|(l!=r);}
void add_day(int l,int r,ll d)
{
	t[id(l,r)].v += d*a[r];
	t[id(l,r)].sum += (sum[r]-sum[l-1])*d;
	t[id(l,r)].del+=d;
}
void push_down(int l,int r)
{
	int mid = (l+r)>>1;
	int p = id(l,r);
	if(t[p].lazy!=-1)
	{
		int lf = id(l,mid),rt = id(mid+1,r);
		t[lf].lazy=t[rt].lazy=t[p].lazy;
		t[lf].v=t[rt].v=t[p].lazy;
		t[lf].sum=(ll)(mid-l+1)*t[p].lazy,t[rt].sum=(ll)(r-mid)*t[p].lazy;
		t[lf].del=t[rt].del=0;
		t[p].lazy=-1;
	}
	if(t[p].del)
	{
		add_day(l,mid,t[p].del);
		add_day(mid+1,r,t[p].del);
		t[p].del=0;
	}
}
void push_up(int l,int r)
{
	int mid = (l+r)>>1;
	t[id(l,r)].sum= t[id(l,mid)].sum+t[id(mid+1,r)].sum;
	t[id(l,r)].v = t[id(mid+1,r)].v;
}
int L;
int Find(int l,int r,ll x)
{
	if(l==r)return l;
	int mid = (l+r)>>1;
	push_down(l,r);
	if(t[id(l,mid)].v>=x)return Find(l,mid,x);
	else return Find(mid+1,r,x);
}
ll Update(int l, int r,ll b) 
{
    if(r<L) return 0;
    int mid = (l+r)>>1,p = id(l,r); 
	ll ans = 0;
    if(L<=l) 
	{ 
		ans = t[p].sum; 
		t[p].del = 0; 
		t[p].sum = (ll)(r-l+1)*b; 
		t[p].v = b; 
		t[p].lazy = b; 
		return ans; 
	}
	push_down(l,r);
	ans = Update(l,mid,b)+Update(mid+1,r,b);
    push_up(l,r);
    return ans;
}
int main()
{
	int n,m;
	ll last = 0,d,b;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	for(int i = 1;i<= n;i++)sum[i] = sum[i-1]+a[i];
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld",&d,&b);
		ll dt = d-last;last = d;
		add_day(1,n,dt);
		if(t[id(1,n)].v<b){printf("0\n");continue;}
		L = Find(1,n,b);
		printf("%lld\n",Update(1,n,b)-b*(n-L+1));
	}
	return 0;
}
Problem4294

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll base = 6000000000000000000ull;
const int N = 20;
ll quick_plus(ll x,ll y,ll mod)
{
	ll ans = 0;
	while(y)
	{
		if(y&1)(ans+=x)%=mod;
		x = (x+x)%mod;
		y>>=1;
	}
	return ans;
}
void getfib(ll n,ll &x,ll &y,ll mod)
{
	if(!n){x=0,y=1;return ;}
	else if(n==1){x=y=1;return ;}
	if(n&1){getfib(n-1,y,x,mod);y=(x+y)%mod;return;}
	ll a,b;
	getfib(n>>1,a,b,mod);
	x = (quick_plus(a,b,mod)+quick_plus(a,b>a?b-a:b-a+mod,mod))%mod;
	y = (quick_plus(a,a,mod)+quick_plus(b,b,mod))%mod;
}
ll Pow[N],b[N];
char s[N];
bool flag;
ll ans;
void dfs(int n,ll now,ll mod)
{
	if(flag)return ;
	ll x,y;
	getfib(now,x,y,Pow[n]);
	if(x!=b[n])return ;
	if(n==1){flag = true;ans = base+now;return ;}
	for(int i = 0;i<10;i++)
		dfs(n-1,(now+mod*i)%(mod*10),mod*10);
}
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	for(int i = n;i;i--)
	{
		if(i==n)Pow[i]=1;
		else Pow[i]=Pow[i+1]*10;
		b[i]=b[i+1]+Pow[i]*(s[i]-'0');
	}
	for(int i = 1;i<= n;i++)Pow[i]*=10;
	for(int i = 0;i<60;i++)
		dfs(n,i,60);
	if(flag)printf("%llu\n",ans);
	else printf("NIE\n");
	return 0;
}
Problem4295

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define ll long long
#define inf 2000000000000000000ll
#define eps 1e-10
#define md
#define N 5000010
using namespace std;
const int D=2000000;
struct QQ { int dt,id;} q[N];
int a[N],b[N],r[N],sum[N],mn[N],T[N];
char st[N];
bool vis[N];
ll lun[N],ed[N],win[N],last[N];
int main()
{
	int n,m;
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&a[i]);
	scanf("%d",&m); scanf("%s",st);
	for (int i=0;i<m;i++) b[i]=st[i]=='W'?1:-1;
	for (int i=0;i<m;i++)
		if (!vis[i])
		{
		int x=i,tot=0;
		while (!vis[x])
		{
			vis[x]=1; r[++tot]=x; sum[tot]=sum[tot-1]+b[x];
			x=(x+n)%m;
		}
		for (int j=1;j<=tot;j++)
		{
			r[j+tot]=r[tot];
			sum[j+tot]=sum[j+tot-1]+b[r[j]];
		}
		int h=1,w=0;
		for (int j=1;j<=tot;j++)
		{
			while (h<=w&&q[w].dt>=sum[j]) w--;
			q[++w].id=j; q[w].dt=sum[j];
		}
		for (int j=1;j<=tot;j++)
		{
			while (h<=w&&q[h].id<j) h++;
			mn[j]=-(q[h].dt-sum[j-1]);
			win[j]=sum[j+tot-1]-sum[j-1];
			while (h<=w&&q[w].dt>=sum[j+tot]) w--;
			q[++w].id=j+tot; q[w].dt=sum[j+tot];
		}
		for (int j=D-(tot<<1);j<=D+(tot<<1);j++) last[j]=inf;
		for (int j=(tot<<1);j>tot;j--)
			last[sum[j]+D]=j;
		for (int j=tot;j;j--)
		{
			x=r[j]; T[x]=tot;
			last[sum[j]+D]=j;
			while (x<n)
			{
				if (win[j]>=0&&a[x]>mn[j]) lun[x]=inf;
				else
				{
					if (a[x]<=mn[j]) lun[x]=0;
					else lun[x]=(a[x]-mn[j]-1)/(-win[j])+1;
					ed[x]=a[x]+lun[x]*win[j];
					ed[x]=last[-ed[x]+sum[j-1]+D]-(j-1);
				}
				x+=m;
			}
		}
	}
	ll ans=inf;
	for (int i=0;i<n;i++)
	{
		if (lun[i]==inf) continue;
		ans=min(ans,(lun[i]*T[i]+ed[i]-1)*n+i+1);
	}
	if (ans==inf) printf("-1\n");
		else printf("%lld\n",ans);
	return 0;
}
Problem4296

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int fa[N],size[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,d[N];
int n,m,D;
bool v[N];
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;d[x]++;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;d[y]++;
}
queue<int>Q;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
	size[y]=size[x]+size[y];
	size[x] = 0;
}
int main()
{
	int x,y;
	scanf("%d%d%d",&n,&m,&D);
	for(int i = 1;i<= n;i++)size[fa[i]=i]=1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]<D)
			Q.push(i),v[i]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(!v[e[i].to])
			{
				d[e[i].to]--;
				if(d[e[i].to]<D)Q.push(e[i].to),v[e[i].to]=true;
			}
	}
	for(int i = 1;i<= n;i++)
		if(!v[i])
			for(int j = head[i];j;j=e[j].next)
				if(!v[e[j].to])
					uni(i,e[j].to);
	int maxi = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i]&&getfa(i)==i)
			if(size[i]>size[maxi])
				maxi = i;
	if(maxi==0)printf("NIE\n");
	else
	{
		printf("%d\n",size[maxi]);
		for(int i = 1;i<= n;i++)
			if(!v[i]&&getfa(i)==maxi)
				printf("%d ",i);
	}
	return 0;
}
Problem4297

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
int l[N],r[N],del[N],a[N<<1],c,n,m;
ll s,now,ans,tmp;
struct E
{int next,to;};
struct Gragh
{
	E e[N<<1];
	int head[N],tot,d[N],f[N];
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
		d[y]++;
		f[y] = x;
	}
}g,G;
void dfs(int x)
{
	if(!G.head[x])return ;
	for(int i = G.head[x];i;i=G.e[i].next)
		dfs(G.e[i].to);
	tmp = 1ll<<60;
	c = m = s = 0;
	for(int j = 0,i = G.head[x];i;i=G.e[i].next)
	{
		int to = G.e[i].to;
		a[m++]=l[to];
		a[m++]=r[to];
		c--;
		s+=l[to];
	}
	std::sort(a,a+m);
	for(int i = 0;i<m;i++)
	{
		c++;
		s-=a[i];
		now=s+1ll*a[i]*c;
		if(now<tmp)
			l[x]=a[i],tmp = now;
		if(now==tmp)
			r[x]=a[i];
	}
	ans+=tmp;
}
int q[N],h,t,ed;
int main()
{
	int o,u;
	scanf("%d%d",&n,&m);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&o,&u);
		g.add(o,u),g.add(u,o);
	}
	for(int i = 1;i<= m;i++)
		scanf("%d",&l[i]),r[i]=l[i];
	if(n==m)
	{
		for(int i = 1;i<= n;i++)
			for(int j = g.head[i];j;j=g.e[j].next)
			{
				int to = g.e[j].to;
				ans+=abs(l[i]-l[to]);
			}
		printf("%lld\n",ans>>1);
		return 0;
	}
	h = 1,t = 0;
	for(int i = 1;i<= m;i++)
		del[q[++t]=i]=1;
	int x=0;
	while(h<=t)
	{
		for(int i = h;i<= t;i++)
			for(int j = g.head[q[i]];j;j=g.e[j].next)
				if(!del[g.e[j].to])
				{
					int to = g.e[j].to;
					G.add(to,q[i]);
				}
		x = t;
		for(int i = h;i<= x;i++)
			for(int j = g.head[q[i]];j;j=g.e[j].next)
				if(!del[g.e[j].to])
				{
					int to = g.e[j].to;
					if((--g.d[to])<=1)
						del[q[++t]=to]=1;
				}
		h = x+1;
	}
	for(int i = 1;i<= n;i++)
		if(!G.f[i])
			G.add(0,i);
	dfs(0);
	printf("%lld\n",ans);
	return 0;
}
Problem4298

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int base = 60383;
const int mod = 793999;
const int T = 205;
const int N = 5005;
const int M = 1000005;
struct HASH
{int next,cnt;ull to;}Hash[M];
int hd[mod+5],Cnt;
ull pow[T],hash[N];
int id[T][N],size[T][N],ans;
void Insert(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans+=(Hash[i].cnt<<1)+1;
			Hash[i].cnt++;
			return ;
		}
	ans++;
	Hash[++Cnt].to = x;Hash[Cnt].next = hd[p];hd[p] = Cnt;
	Hash[Cnt].cnt = 1;
}
void Delete(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans-=(Hash[i].cnt<<1)-1;
			--Hash[i].cnt;
			return ;
		}
}
struct E
{int next,to;}e[M<<1];
int head[T][N],tot;
void add(int d,int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[d][x];
	head[d][x] = tot;
}
void dfs(int d,int x,int pre,int fa)
{
	Delete(hash[x]);
	hash[x]-=pow[d]*id[d][x];
	id[d][x] = fa;
	hash[x]+=pow[d]*id[d][x];
	Insert(hash[x]);
	for(int i = head[d][x];i;i=e[i].next)if(e[i].to!=pre)
		dfs(d,e[i].to,x,fa);
}
void uni(int d,int x,int y)
{
	if(id[d][x]==id[d][y])return ;
	if(size[d][id[d][x]]<size[d][id[d][y]])swap(x,y);
	size[d][id[d][x]]+=size[d][id[d][y]];
	add(d,x,y),add(d,y,x);
	dfs(d,y,x,id[d][x]);
}
int main()
{
	int d,n,m;
	scanf("%d%d%d",&d,&n,&m);
	pow[0]=1;
	for(int i = 1;i<= d;i++)pow[i]=pow[i-1]*base;
	for(int i = 1;i<= d;i++)
		for(int j = 1;j<= n;j++)
			id[i][j]=j,size[i][j]=1,hash[j]+=pow[i]*j;
	for(int j = 1;j<=n;j++)Insert(hash[j]);
	int a,b,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&k);
		uni(k,a,b);
		printf("%d\n",ans);
	}
}
Problem4298

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int base = 60383;
const int mod = 1747969;
const int T = 205;
const int N = 5005;
const int M = 1000005;
struct HASH
{int next,cnt;ull to;}Hash[M];
int hd[mod+5],Cnt;
ull pow[T],hash[N];
int id[T][N],size[T][N],ans;
void Insert(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans+=(Hash[i].cnt<<1)+1;
			Hash[i].cnt++;
			return ;
		}
	ans++;
	Hash[++Cnt].to = x;Hash[Cnt].next = hd[p];hd[p] = Cnt;
	Hash[Cnt].cnt = 1;
}
void Delete(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans-=(Hash[i].cnt<<1)-1;
			--Hash[i].cnt;
			return ;
		}
}
struct E
{int next,to;}e[M<<1];
int head[T][N],tot;
void add(int d,int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[d][x];
	head[d][x] = tot;
}
void dfs(int d,int x,int pre,int fa)
{
	Delete(hash[x]);
	hash[x]-=pow[d]*id[d][x];
	id[d][x] = fa;
	hash[x]+=pow[d]*id[d][x];
	Insert(hash[x]);
	for(int i = head[d][x];i;i=e[i].next)if(e[i].to!=pre)
		dfs(d,e[i].to,x,fa);
}
void uni(int d,int x,int y)
{
	if(id[d][x]==id[d][y])return ;
	if(size[d][id[d][x]]<size[d][id[d][y]])swap(x,y);
	size[d][id[d][x]]+=size[d][id[d][y]];
	add(d,x,y),add(d,y,x);
	dfs(d,y,x,id[d][x]);
}
int main()
{
	int d,n,m;
	scanf("%d%d%d",&d,&n,&m);
	pow[0]=1;
	for(int i = 1;i<= d;i++)pow[i]=pow[i-1]*base;
	for(int i = 1;i<= d;i++)
		for(int j = 1;j<= n;j++)
			id[i][j]=j,size[i][j]=1,hash[j]+=pow[i]*j;
	for(int j = 1;j<=n;j++)Insert(hash[j]);
	int a,b,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&k);
		uni(k,a,b);
		printf("%d\n",ans);
	}
}
Problem4305

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 3e5+5;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int fac[N],inv[N];
void init()
{
	fac[0] = inv[0] = 1;
	for(int i = 1;i<N;i++)fac[i]=(ll)fac[i-1]*i%mod;
	inv[N-1] = quick_pow(fac[N-1],mod-2);
	for(int i = N-2;i>= 1;i--)inv[i] = (ll)inv[i+1]*(i+1)%mod;
}
int a[N],cnt[N],ans[N];
int C(int n,int m)
{
	if(m>n)return 0;
	return (ll)fac[n]*inv[n-m]%mod*inv[m]%mod;
}
int main()
{
	int n,m,k;
	init();
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),cnt[a[i]]++;
	for(int i = 1;i<= m;i++)
		for(int j = i+i;j<= m;j+=i)
			cnt[i]+=cnt[j];
	for(int i = 1;i<= m;i++)
		if(cnt[i]>=n-k)
			ans[i] = (ll)C(cnt[i],n-k)*quick_pow(m/i-1,cnt[i]-n+k)%mod*quick_pow(m/i,n-cnt[i])%mod;
	for(int i = m;i>= 1;i--)
		for(int j = i+i;j<= m;j+=i)
			(ans[i]+=mod-ans[j])%=mod;
	for(int i = 1;i< m;i++)printf("%d ",ans[i]);
	printf("%d\n",ans[m]);
	return 0;
}
Problem4316

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 6e4+5;
const int INF = 0x3f3f3f3f;
int f[M<<1][2];
namespace Cactus
{
	struct E
	{int next,to;}e[M<<1];
	int head[N],tot=1,n;
	int dfn[N],low[N],Dfn,stk[N],top;
}
namespace R_S_Tree
{
	struct E
	{int next,to;}e[M<<2];
	int head[N<<1],tot=1,n;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dp(int x,int fa)
	{
		f[x][1]=1;
		if(x<=Cactus::n)
		{
			for(int i = head[x];i;i=e[i].next)
				if(e[i].to!=fa)
				{
					dp(e[i].to,x);
					if(e[i].to>Cactus::n)continue;
					f[x][0]+=max(f[e[i].to][0],f[e[i].to][1]);
					f[x][1]+=f[e[i].to][0];
				}
		}else
		{
			static int g[M<<1][2];
			int top = 0;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].to!=fa)
					dp(e[i].to,x);
			for(int i = head[x];i;i=e[i].next)
			{
				g[++top][0] = f[e[i].to][0];
				g[top][1] = f[e[i].to][1];
			}
			for(int i = top-1;i>=1;i--)
			{
				g[i][0]+=max(g[i+1][0],g[i+1][1]);
				g[i][1]+=g[i+1][0];
			}
			f[fa][0] = g[1][0];
			for(int i = 1;i<top;i++)
			{
				g[i][0]-=max(g[i+1][0],g[i+1][1]);
				g[i][1]-=g[i+1][0];
			}
			g[top][1] = -INF;
			for(int i = top-1;i>=1;i--)
			{
				g[i][0]+=max(g[i+1][0],g[i+1][1]);
				g[i][1]+=g[i+1][0];
			}
			f[fa][1] = g[1][1];
		}
	}
}
namespace Cactus
{
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dfs(int x,int pre)
	{
		stk[++top] = x;
		dfn[x] = low[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)if(i!=(pre^1))
		{
			if(!dfn[e[i].to])
			{
				dfs(e[i].to,i);
				low[x] =min(low[x],low[e[i].to]);
				if(low[e[i].to]>=dfn[x])
				{
					int tmp;
					R_S_Tree::n++;
					do
					{
						tmp = stk[top--];
						R_S_Tree::add(tmp,R_S_Tree::n);
					}while(tmp!=e[i].to);
					R_S_Tree::add(x,R_S_Tree::n);
				}
			}else low[x] = min(low[x],dfn[e[i].to]);
		}
	}
};
int main()
{
	int m;
	scanf("%d%d",&Cactus::n,&m);
	R_S_Tree::n = Cactus::n;
	int x,y;
	while(m--)
	{
		scanf("%d%d",&x,&y);
		Cactus::add(x,y);
	}
	Cactus::top = 0,Cactus::Dfn = 0;
	Cactus::dfs(1,0);
	R_S_Tree::dp(1,0);
	printf("%d\n",max(f[1][0],f[1][1]));
	return 0;
}
Problem4318

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100000+5;
double f[N],l1[N],l2[N];
double p[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf",&p[i]);
	for(int i = 1;i<= n;i++)
	{
		l1[i] = p[i]*(l1[i-1]+1);
		l2[i] = p[i]*(l2[i-1]+2*l1[i-1]+1);
		f[i] = p[i]*(f[i-1]+3.0*l2[i-1]+3.0*l1[i-1]+1)+(1-p[i])*f[i-1];
	}
	printf("%.1f",f[n]);
	return 0;
}
Problem4320

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int X = 300005;
const int N = 100005;
struct A{int opt,num;}ask[N];
int ans[N],modn[605],fa[X];
bool v[X];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
int main()
{
	int n;
	char x[2];
	scanf("%d",&n);
	memset(ans,-1,sizeof(ans));
	memset(modn,0x3f,sizeof(modn));
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",x,&ask[i].num);
		if(x[0]=='A')
		{
			for(int j = 1;j<= 600;j++)
				modn[j] = min(modn[j],ask[i].num%j);
			ask[i].opt = 1;
			v[ask[i].num] = true;
		}
		else 
		{
			if(ask[i].num<=600)ans[i] = modn[ask[i].num];
			ask[i].opt = 2;
		}
	}
	for(int i = 1;i<=X-5;i++)
		if(!v[i])
			fa[i] =i+1;
	for(int i = n;i>= 1;i--)
	{
		if(ask[i].opt==1)fa[ask[i].num] = ask[i].num+1;
		else if(ask[i].num>600)
		{
			int tmp = 0x3f3f3f3f;
			for(int j = 0;j<= X-5;j+=ask[i].num)
			{
				int tt = getfa(max(1,j));
				if(tt<=X-5)tmp = min(tmp,tt%ask[i].num);
			}
			ans[i] = tmp;
		}
	}
	for(int i = 1;i<= n;i++)
		if(ans[i]!=-1)
			printf("%d\n",ans[i]);
	return 0;
}
Problem4346

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 1e9;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][3][3],g[N][3],p[N][3],q[N][3],c[3][3];
void dp(int x,int fa)
{
	p[x][1] = 1,p[x][2] = 2;
	memset(g[x],0x3f,sizeof(g[x]));
	memset(f[x],0x3f,sizeof(f[x]));
	f[x][0][0] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			int y = e[i].to;
			dp(y,x);
			int tmp = min(min(p[y][1],p[y][2]),q[y][1]);
			for(int j = 0;j<3;j++)
				tmp = min(tmp,g[y][j]);
			p[x][1]+=tmp,p[x][2]+=min(tmp,q[y][2]);
			memset(c,0x3f,sizeof(c));
			for(int j = 0;j<3;j++)
				for(int k = 0;k<3;k++)
					if(f[x][j][k]<INF)
					{
						tmp = f[x][j][k];
						for (int l=1; l<3; l++) c[min(2,j+l)][k]=min(c[min(2,j+l)][k],tmp+p[y][l]);  
                   		for (int l=0; l<3; l++) c[j][max(k,2-l)]=min(c[j][max(k,2-l)],tmp+g[y][l]);  
					}
			memcpy(f[x],c,sizeof(c));
		}
	for (int i=0; i<3; i++)  
        for (int j=0; j<=i; j++) g[x][i]=min(g[x][i],f[x][i][j]);  
    q[x][1]=min(f[x][0][1],f[x][1][2]);  
    q[x][2]=f[x][0][2];  
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
    for (int i=1; i<n; i++){  
    	scanf("%d%d",&x,&y); 
        add(x,y);
    }  
    dp(1,0); 
    int ans=min(p[1][1],p[1][2]);  
    for (int i=0; i<3; i++) ans=min(ans,g[1][i]);  
    printf("%d\n",ans);  
	return 0;
}
Problem4348

#include <stdio.h>
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define N 1005
int n,m,i,j,x,y,l,r,f[N][N],ans,t,q[10005][3],cnt;bool a[N][N];char ch[N];
struct P {int x,y,l,r,s;}s[N*N];
inline void up(int b) {if(ans<b)ans=b;}
inline void add(int x,int y,int z) 
{
	if(x&&x==y)return;
	q[++cnt][0]=x,q[cnt][1]=y,q[cnt][2]=z;
}
int main() 
{
	scanf("%d",&n);
	gets(ch);
	if(n==1){printf("1",ans);return 0;}
	for(int i = 1;i<= n;i++)
		for(gets(ch+1),j=1;j<=n;j++)
			if(ch[j]=='B')a[i][j]=1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(a[i][j]&&!f[i][j]) 
			{
				for(x=i;a[x][j];x++);
				for(y=j;a[i][y];y++);
				s[++m].x=i,s[m].y=--x,s[m].l=j,s[m].r=--y;
				up(s[m].s=(x-i+1)*(y-j+1));
				for(int I = i;I<= x;I++)
					for(int J = j;J<=y;J++)
						f[I][J]=m;
			}
	if(ans==n*n){printf("%d",ans);return 0;}
	for(i=n;~i;i--)
		for(j=n;~j;j--)
			f[i+1][j+1]=f[i][j];
	for(i=1;i<=m;i++)
		s[i].x++,s[i].y++,s[i].l++,s[i].r++;
	n+=2;
	ans=2;
	rep(i,1,m) 
	{
		x=s[i].x,y=s[i].y,l=s[i].l,r=s[i].r,cnt=0;
		if(x>2)rep(j,l,r) 
		{
			if(f[x-2][j])add(f[x-2][j],0,0);
			else 
			{
				t=s[i].s+2+s[f[x-2][j-1]].s+s[f[x-2][j+1]].s;
				if(f[x-2][j-1]!=f[x-1][j-1])t+=s[f[x-1][j-1]].s;
				if(f[x-2][j+1]!=f[x-1][j+1])t+=s[f[x-1][j+1]].s;
				if(x>3)t+=s[f[x-3][j]].s;
				up(t);
			}
		}
		if(y+2<=n)rep(j,l,r) 
		{
			if(f[y+2][j])add(f[y+2][j],0,0);
			else 
			{
				t=s[i].s+2+s[f[y+2][j-1]].s+s[f[y+2][j+1]].s;
				if(f[y+2][j-1]!=f[y+1][j-1])t+=s[f[y+1][j-1]].s;
				if(f[y+2][j+1]!=f[y+1][j+1])t+=s[f[y+1][j+1]].s;
				if(y+3<=n)t+=s[f[y+3][j]].s;
				up(t);
			}
		}
		if(l>2)rep(j,x,y) 
		{
			if(f[j][l-2])add(f[j][l-2],0,0);
			else 
			{
				t=s[i].s+2+s[f[j-1][l-2]].s+s[f[j+1][l-2]].s;
				if(f[j-1][l-2]!=f[j-1][l-1])t+=s[f[j-1][l-1]].s;
				if(f[j+1][l-2]!=f[j+1][l-1])t+=s[f[j+1][l-1]].s;
				if(l>3)t+=s[f[j][l-3]].s;
				up(t);
			}
		}
		if(r+2<=n)rep(j,x,y) 
		{
			if(f[j][r+2])add(f[j][r+2],0,0);
			else 
			{
				t=s[i].s+2+s[f[j-1][r+2]].s+s[f[j+1][r+2]].s;
				if(f[j-1][r+2]!=f[j-1][r+1])t+=s[f[j-1][r+1]].s;
				if(f[j+1][r+2]!=f[j+1][r+1])t+=s[f[j+1][r+1]].s;
				if(r+3<=n)t+=s[f[j][r+3]].s;
				up(t);
			}
		}
		if(f[x-1][l-1]) 
		{
			if(x>2)add(f[x-1][l-1],f[x-2][l],0);
			if(l>2)add(f[x-1][l-1],f[x][l-2],0);
		}
		if(f[y+1][l-1]) 
		{
			if(y+2<=n)add(f[y+1][l-1],f[y+2][l],0);
			if(l>2)add(f[y+1][l-1],f[y][l-2],0);
		}
		if(f[x-1][r+1]) 
		{
			if(x>2)add(f[x-1][r+1],f[x-2][r],0);
			if(r+2<=n)add(f[x-1][r+1],f[x][r+2],0);
		}
		if(f[y+1][r+1]) 
		{
			if(y+2<=n)add(f[y+1][r+1],f[y+2][r],0);
			if(r+2<=n)add(f[y+1][r+1],f[y][r+2],0);
		}
		if(x==y) 
		{
			if(l>2)add(f[x][l-2],f[x-1][l-1],f[x+1][l-1]);
			if(r+2<=n)add(f[x][r+2],f[x-1][r+1],f[x+1][r+1]);
		}
		if(l==r) 
		{
			if(x>2)add(f[x-2][l],f[x-1][l-1],f[x-1][l+1]);
			if(y+2<=n)add(f[y+2][l],f[y+1][l-1],f[y+1][l+1]);
		}
		up(s[i].s+2);
		rep(j,1,cnt) 
		{
			up(s[i].s+2+s[q[j][0]].s+s[q[j][1]].s+s[q[j][2]].s);
			rep(k,j+1,cnt) 
			{
				t=s[i].s+2+s[q[j][0]].s+s[q[j][1]].s+s[q[j][2]].s+s[q[k][0]].s+s[q[k][1]].s+s[q[k][2]].s;
				if(q[k][0]==q[j][0]||q[k][0]==q[j][1]||q[k][0]==q[j][2])t-=s[q[k][0]].s;
				if(q[k][1]==q[j][0]||q[k][1]==q[j][1]||q[k][1]==q[j][2])t-=s[q[k][1]].s;
				if(q[k][2]==q[j][0]||q[k][2]==q[j][1]||q[k][2]==q[j][2])t-=s[q[k][2]].s;
				up(t);
			}
		}
		if(x>1&&l>1&&!f[x-1][l-1]) 
		{
			t=s[i].s+2+s[f[x-2][l-1]].s+s[f[x-1][l-2]].s;
			if(x==y&&l==r) 
			{
				if(f[x-1][l-2]!=f[x][l-2])up(t+s[f[x][l-2]].s+s[f[x+1][l-1]].s);else up(t+s[f[x+1][l-1]].s);
				if(f[x-2][l-1]!=f[x-2][l])up(t+s[f[x-2][l]].s+s[f[x-1][l+1]].s);else up(t+s[f[x-1][l+1]].s);
			}else 
			{
				if(f[x-1][l-2]!=f[x][l-2])up(t+s[f[x][l-2]].s);
				if(f[x-2][l-1]!=f[x-2][l])up(t+s[f[x-2][l]].s);
			}
		}
		if(x>1&&r<n&&!f[x-1][r+1]) 
		{
			t=s[i].s+2+s[f[x-2][r+1]].s+s[f[x-1][r+2]].s;
			if(x==y&&l==r) 
			{
				if(f[x-1][r+2]!=f[x][r+2])up(t+s[f[x][r+2]].s+s[f[x+1][l+1]].s);else up(t+s[f[x+1][l+1]].s);
				if(f[x-2][r+1]!=f[x-2][r])up(t+s[f[x-2][r]].s+s[f[x-1][l-1]].s);else up(t+s[f[x-1][l-1]].s);
			}else 
			{
				if(f[x-1][r+2]!=f[x][r+2])up(t+s[f[x][r+2]].s);
				if(f[x-2][r+1]!=f[x-2][r])up(t+s[f[x-2][r]].s);
			}
		}
		if(y<n&&l>1&&!f[y+1][l-1]) 
		{
			t=s[i].s+2+s[f[y+2][l-1]].s+s[f[y+1][l-2]].s;
			if(x==y&&l==r) 
			{
				if(f[y+1][l-2]!=f[y][l-2])up(t+s[f[y][l-2]].s+s[f[x-1][l-1]].s);else up(t+s[f[x-1][l-1]].s);
				if(f[y+2][l-1]!=f[y+2][l])up(t+s[f[y+2][l]].s+s[f[x+1][l+1]].s);else up(t+s[f[x+1][l+1]].s);
			}else 
			{
				if(f[y+1][l-2]!=f[y][l-2])up(t+s[f[y][l-2]].s);
				if(f[y+2][l-1]!=f[y+2][l])up(t+s[f[y+2][l]].s);
			}
		}
		if(y<n&&r<n&&!f[y+1][r+1]) 
		{
			t=s[i].s+2+s[f[y+2][r+1]].s+s[f[y+1][r+2]].s;
			if(x==y&&l==r) 
			{
				if(f[y+1][r+2]!=f[y][r+2])up(t+s[f[y][r+2]].s+s[f[x-1][l+1]].s);else up(t+s[f[x-1][l+1]].s);
				if(f[y+2][r+1]!=f[y+2][r])up(t+s[f[y+2][r]].s+s[f[x+1][l-1]].s);else up(t+s[f[x+1][l-1]].s);
			}else 
			{
				if(f[y+1][r+2]!=f[y][r+2])up(t+s[f[y][r+2]].s);
				if(f[y+2][r+1]!=f[y+2][r])up(t+s[f[y+2][r]].s);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
Problem4349

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2505;
const int INF = 0x3f3f3f3f;
const double eps = 1e-7;
struct E
{int u,v;double val;}e[M];
int p[N],num[N],pre[N],vis[N],mark[N];
double c[N],in[N];
double work(int root,int n,int m)
{
	double ans = 0;
	while(true)
	{
		for(int i = 1;i<= n;i++)in[i] = INF;
		for(int i = 1;i<= m;i++)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].val<in[v])
			{
				in[v] = e[i].val;
				pre[v] = u;
			}
		}
		for(int i = 1;i<= n;i++)
		{
			if(i==root)continue;
			if(fabs(in[i]-INF)<eps)return -1;
		}
		memset(mark,-1,sizeof(mark));
		memset(vis,-1,sizeof(vis));
		in[root] = 0;int cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			ans+=in[i];
			int v=i;
			while(v!=root&&mark[v]==-1&&vis[v]!=i)
			{
				vis[v] = i;
				v = pre[v];
			}
			if(v!=root&&mark[v]==-1)
			{
				++cnt;
				for(int u = pre[v];u!=v;u = pre[u])
					mark[u] = cnt;
				mark[v] = cnt;
			}
		}
		if(cnt==0)break;
		for(int i = 1;i<= n;i++)
			if(mark[i]==-1)mark[i]=++cnt;
		for(int i = 1;i<=m;i++)
		{
			int u = e[i].u,v = e[i].v;
			e[i].u = mark[u],e[i].v = mark[v];
			if(e[i].u!=e[i].v)
				e[i].val-=in[v];
		}
		n=cnt,root = mark[root];
	}
	return ans;
}
int main()
{
	int n,m=0;
	scanf("%d",&n);
	int tmp = n;n = 1;
	double x;int t;
	for(int i = 1;i<= tmp;i++)
	{
		scanf("%lf%d",&x,&t);
		if(t)
		{
			p[i]=++n;
			e[++m] = (E){1,n,x};
			c[n] = x;num[n] = t;
		}
	}
	int a,b,k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%lf",&a,&b,&x);
		if(p[a]&&p[b])
		{
			e[++m] = (E){p[a],p[b],x};
			c[p[b]] = min(c[p[b]],x);
		}
	}
	double ans = work(1,n,m);
	for(int i = 2;i<= n;i++)
		if(num[i]>1)ans+=c[i]*(num[i]-1);
	printf("%.2f\n",ans);
	return 0;
}
Problem4377

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 1e6+5;
int n,a,b,p,m,cnt;
struct S
{int l,r;}seg[M<<2];
char s[M];
void add(int l,int r)
{
	if(l<=r){seg[++cnt].l = l;seg[cnt].r = r;}
	else 
	{
		seg[++cnt].l = l;seg[cnt].r = n-1;
		seg[++cnt].l = 0;seg[cnt].r = r;
	}
}
bool cmp(S a,S b)
{
	return a.l<b.l;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&a,&b,&p,&m);
	scanf("%s",s);
	int now = 0;
	for(int i = 0;i<m;i++,now = (now+a)%n)
	{
		if(s[i]=='0')add((p-now+n)%n,(n-1-now+n)%n);
		else add((n-now)%n,(p-1-now+n)%n);
	}
	for(int i=1,c=(b-a+n)%n;i<m;i++,c=(c-a+n)%n)
        add(c,c);
    sort(seg+1,seg+cnt+1,cmp);
    int end = -1,ans = 0;
    for(int i = 1;i<= cnt;i++)
    {
    	if(seg[i].l>end)
    	{
    		ans+=seg[i].l-end-1;
    		end = seg[i].r;
    	}
    	end = max(seg[i].r,end);
    }
    printf("%d\n",ans+n-1-end);
	return 0;
}
Problem4378

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
int a[N],num[N],cnt;
LL cn[N],cs[N];
struct opt
{int kind;LL x,y;}Opt[N];
int Find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(num[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void update(int pos,int xn,int xs)
{
	for(int i = pos;i<N;i+=i&(-i))
		cn[i]+=xn,cs[i]+=xs;
	return ;
}
LL getn(int pos)
{
	LL ans = 0;
	for(int i = pos;i>0;i-=i&(-i))
		ans+=cn[i];
	return ans;
}
LL gets(int pos)
{
	LL ans = 0;
	for(int i = pos;i>0;i-=i&(-i))
		ans+=cs[i];
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	char o[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",o);
		if(o[0]=='U')
			Opt[i].kind = 1;
		else
			Opt[i].kind = 2;
		scanf("%lld%lld",&Opt[i].x,&Opt[i].y);
		num[++cnt] = Opt[i].y;
	}
	memset(a,-1,sizeof(a));
	sort(num+1,num+cnt+1);
	for(int i = 1;i<= m;i++)
	{
		if(Opt[i].kind==1)
		{
			int tmp = a[Opt[i].x];
			if(tmp!=-1)update(Find(tmp),-1,-tmp);
			update(Find(Opt[i].y),1,Opt[i].y);
			a[Opt[i].x] = Opt[i].y;
		}else
		{
			LL tmp = getn(cnt)-getn(Find(Opt[i].y)-1);
			if(tmp>=Opt[i].x)printf("TAK\n");
			else if(gets(Find(Opt[i].y)-1)>=(Opt[i].x-tmp)*Opt[i].y)printf("TAK\n");
			else printf("NIE\n");
		}
	}
	return 0;
}
Problem4379

#include<iostream>
#include<cstdio>
#include<cstring>
#include <cctype>
#define N 1000010
using namespace std;
int to[N],nxt[N],pre[N],cnt;
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
void ae(int ff,int tt)
{
	cnt++;
	to[cnt]=tt;
	nxt[cnt]=pre[ff];
	pre[ff]=cnt;
}
int fa[N],d1[N],fir[N],sec[N],thr[N];
int fd[N],sd[N];
void dfs(int x)
{
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==fa[x]) continue;
		fa[j]=x;
		dfs(j);
		thr[x]=max(fir[j]+1,thr[x]);
		if(thr[x]>sec[x]) swap(thr[x],sec[x]);
		if(sec[x]>fir[x]) swap(sec[x],fir[x]);
		d1[x]=max(d1[x],d1[j]);
		sd[x]=max(d1[j],sd[x]);
		if(sd[x]>fd[x]) swap(sd[x],fd[x]);
	}
	d1[x]=max(d1[x],fir[x]+sec[x]);
}
int minn=707185547,x4,y4;
int maxn,x5,y5;
int cal(int x,int y)
{
	if(x>y) swap(x,y);
	int yy=y;
	x=x/2+x%2;y=y/2+y%2;
	return max(x+y+1,yy);
}
void solve(int x,int d2,int lg)
{
//	cout<<d1[x]<<' '<<x<<' '<<d2<<' '<<lg<<endl;
	int t,tmp;
	if(x!=1)
	{
		t=cal(d1[x],d2);
	//	cout<<fa[x]<<' '<<x<<' '<<d1[x]<<' '<<d2<<endl;
		if(t<minn) minn=t,x4=fa[x],y4=x;
		if(d1[x]+d2+1>maxn) maxn=d1[x]+d2+1,x5=fa[x],y5=x;
	}
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==fa[x]) continue;
		t=fir[x];tmp=fd[x];
		if(tmp==d1[j]) tmp=sd[x];
		if(t==fir[j]+1)
		{
			t=sec[x];
			tmp=max(tmp,sec[x]+max(thr[x],lg));
		}
		else if(sec[x]==fir[j]+1) tmp=max(tmp,fir[x]+max(thr[x],lg));
		else tmp=max(tmp,fir[x]+max(sec[x],lg));
		t=max(lg,t);tmp=max(tmp,d2);
		solve(j,tmp,t+1);
	}
}
int t[5],T,ma;
bool del[N];
void dfs1(int x,int ff,int dd)
{
	int i,j;
	if(dd>ma) ma=dd,t[T]=x;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==ff||del[i]) continue;
		dfs1(j,x,dd+1);
	}
}
int ans[3],TT;
bool getans(int x,int ff,int dd)
{
	if(x==t[T])
	{
		if(ma==0) ans[TT]=x;
		return true;
	}
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==ff||del[i]) continue;
		if(getans(j,x,dd+1))
		{
			if(dd==ma/2) ans[TT]=x;
			return true;
		}
	}
	return false;
}
void findmin(int x,int y)
{
	int i;
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=true;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=true;
	ma=-1;T=1;
	dfs1(x,y,0);
	ma=-1;T=2;
	dfs1(t[1],0,0);
	TT=1;
	getans(t[1],0,0);
	ma=-1;T=3;
	dfs1(y,x,0);
	ma=-1;T=4;
	dfs1(t[3],0,0);
	TT=2;
	getans(t[3],0,0);
	printf("%d %d %d %d %d\n",minn,x,y,ans[1],ans[2]);
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=false;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=false;
}
void findmax(int x,int y)
{
	int i;
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=true;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=true;
	ma=-1;T=1;
	dfs1(x,y,0);
	ma=-1;T=2;
	dfs1(t[1],0,0);
	ma=-1;T=3;
	dfs1(y,x,0);
	ma=-1;T=4;
	dfs1(t[3],0,0);
	printf("%d %d %d %d %d",maxn,x,y,t[1],t[3]);
}
int main()
{
	int n,m;
	n = read();
	int i,j,x,y;
	for(i=1;i<n;i++)
	{
		x = read();y = read();
		ae(x,y);ae(y,x);
	}
	dfs(1);
	solve(1,0,0);
	findmin(x4,y4);
	findmax(x5,y5);
}
Problem4380

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 52;
const int M = 4002;
const int INF = 500000;
int L[M],R[M],c[M],stack[M],pos[N][N][M],val[N][N][M];
LL f[N][N][M],sum[N][N][M];
int pid[N];
void printans(int l,int r,int t)
{
	if(l>r)return ;
	int tmp = val[l][r][t];
	printans(l,pos[l][r][t]-1,tmp);
	printf("%d ",pid[tmp]);
	printans(pos[l][r][t]+1,r,tmp);
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&L[i],&R[i],&c[i]);
		pid[i] = c[i];
	}
	sort(pid+1,pid+m+1);
	for(int lth = 1;lth<=n;lth++)
	{
		for(int l = 1;l+lth-1<= n;l++)
		{
			int r = l+lth-1;
			for(int k = l;k<= r;k++)
			{
				int top = 0;
				for(int t = 1;t<= m;t++)
					if(L[t]>=l&&R[t]<=r&&k>=L[t]&&k<=R[t])
						stack[++top] = c[t];
				sort(stack+1,stack+top+1);
				int head = 1;
				for(int t = 1;t<= m;t++)
				{
					while(head<=top&&stack[head]<pid[t])head++;
					LL tmp = sum[l][k-1][t]+sum[k+1][r][t]+(LL)(top-head+1)*pid[t];
					if(tmp>=f[l][r][t])
					{
						f[l][r][t] = tmp;
						pos[l][r][t] = k;
					}
				}
			}
			for(int k = m;k>=1;k--)
			{
				val[l][r][k] = k;
				if(f[l][r][k]<sum[l][r][k+1])
				{
					val[l][r][k] = val[l][r][k+1];
					pos[l][r][k] = pos[l][r][k+1];
				}
				sum[l][r][k] = max(sum[l][r][k+1],f[l][r][k]);
			}
		}
	}
	printf("%lld\n",sum[1][n][1]);
	printans(1,n,1);
	return 0;
}
Problem4381

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N],size[N],son[N],top[N],id[N],pos[N],dep[N],sum[N][155],a[N];
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x]++;
	dep[x] = dep[f]+1;
	int p = fa[x];
	for(int i =1;i<= 150&&p;p = fa[p],i++)sum[x][i] = sum[p][i]+a[x];
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=f)
		{
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
int cnt;
void dfs2(int x,int tp)
{
	top[x] = tp;
	id[++cnt] = x;
	pos[x] = cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=son[x]&&e[i].to!=fa[x])
			dfs2(e[i].to,e[i].to);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
int find(int x,int y)
{
	while(dep[x]-dep[top[x]]<y)
	{
		y-=dep[x]-dep[top[x]]+1;
		x = fa[top[x]];
	}
	return id[pos[x]-y];
}
int ask(int x,int y,int z)
{
	int ans = 0;
	if(z<=150)return sum[x][z]-sum[y][z]+a[y];
	while(top[x]!=top[y])
	{
		int i;
		for(i = pos[x];i>=pos[top[x]];i-=z)ans+=a[id[i]];
		x = find(x,pos[x]-i);
	}
	for(int i = pos[x];i>=pos[y];i-=z)ans+=a[id[i]];
	return ans;
}
int solve(int x,int y,int z)
{
	int ans = 0,lca = getlca(x,y);
	int lth = dep[x]+dep[y]-2*dep[lca];
	if(lth%z)ans+=a[y];
	y = find(y,lth%z);
	int t1 = find(x,(dep[x]-dep[lca])/z*z);
	if(dep[y]<=dep[lca])return ans+ask(x,t1,z);
	int t2 = find(y,(dep[y]-dep[lca])/z*z);
	if(t1==t2)ans-=a[t1];
	return ans+ask(x,t1,z)+ask(y,t2,z);
}
int b[N],c[N];
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs1(1,0);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	for(int i = 1;i< n;i++)
	{
		scanf("%d",&x);
		printf("%d\n",solve(b[i],b[i+1],x));
	}
	return 0;
}
Problem4382

#include <stdio.h>
#include <map>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
typedef unsigned long long ull;
const int N = 1000005;
const LL seed = 131133;
map<ull,int>id;
LL cnt;
ull pw[N],val[N],sum[N];
int pre[N],next[N],a[N];
bool vis[N];
int stack[N],top,n,k,ans,tot;
int calc(int x,int y)
{
	int t = y-x;
	return abs(t-n+t);
}
int main()
{
	scanf("%d%d",&n,&k);
	pw[0] = 1;
	for(int i = 1;i<= n;i++)pw[i] = pw[i-1]*seed;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		if(pre[a[i]])
		{
			val[pre[a[i]]]+=pw[++tot];
			val[i]-=pw[tot];
		}
		pre[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
		sum[i] = sum[i-1]+val[i];
	for(int i = 1;i<= n;i++)
	{
		if(id.count(sum[i]))
			next[id[sum[i]]] = i;
		id[sum[i]] = i;
	}
	ans = n;
	for(int i = 1;i<= n;i++)
		if(!vis[i])
		{
			top = 0;
			for(int j = i;j;j = next[j])
				stack[++top] = j,vis[j] = true;
			cnt+=(LL)top*(top-1)>>1;
			int k = 1;
			for(int j = 1;j<= top;j++)
			{
				while(k<j&&calc(stack[k],stack[j])>calc(stack[k+1],stack[j]))k++;
				ans = min(ans,calc(stack[k],stack[j]));
			}
		}
	printf("%lld %d",cnt,ans);
	return 0;
}
Problem4383

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Ed = 2e6+5;
const int N = 6e5+5;
const int INF = 1e9;
struct E
{int next,to,val;}e[Ed];
int ls[N],rs[N],L[N],R[N];
int sit[N];
int head[N],tot,cnt,ind[N],c[N],d[N],ans[N];
bool done[N];
void add(int x,int y,int f)
{
	ind[y]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int build(int l,int r)
{
	cnt++;
	L[cnt] = l,R[cnt] = r;
	int p = cnt;
	if(l==r)
	{
		sit[l] = cnt;
		return p;
	}
	int mid = (l+r)>>1;
	ls[p] = build(l,mid);
	add(p,ls[p],0);
	rs[p] = build(mid+1,r);
	add(p,rs[p],0);
	return p;
}
void update(int p,int a,int b,int c)
{
	if(L[p]>=a&&R[p]<=b)
	{
		add(c,p,0);return ;
	}
	int mid = (L[p]+R[p])>>1;
	if(a<=mid)update(ls[p],a,b,c);
	if(b>mid)update(rs[p],a,b,c);
	return ;
}
void dfs(int x)
{
	done[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		ans[e[i].to] = min(ans[e[i].to],ans[x]-e[i].val);
		ind[e[i].to]--;
		if(!ind[e[i].to])dfs(e[i].to);
	}
}
int main()
{
	int n,s,m;
	scanf("%d%d%d",&n,&s,&m);
	build(1,n);
	for(int i = 1;i<= cnt;i++)ans[i] = INF;
	int tmp = cnt;
	for(int i = 1;i<= s;i++)
	{
		scanf("%d%d",&c[i],&d[i]);
		ans[sit[c[i]]] = d[i];
	}
	int left,right,k;
	int y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&left,&right,&k);
		y = left;
		cnt++;
		for(int i = 1;i<= k;i++)
		{
			int x;
			scanf("%d",&x);
			add(sit[x],cnt,1);
			if(x>y)update(1,y,x-1,cnt);
			y = x+1;
		}
		if(right>=y)update(1,y,right,cnt);
	}
	for(int i = tmp+1;i<= cnt;i++)ans[i] = INF;
	dfs(1);
	for(int i = 1;i<= n;i++)
		if(!done[sit[i]]||ans[sit[i]]<1)
			{printf("NIE\n");return 0;}
	for(int i = 1;i<= s;i++)
		if(ans[sit[c[i]]]!=d[i])
			{printf("NIE\n");return 0;}
	printf("TAK\n");
	for(int i = 1;i< n;i++)
		printf("%d ",ans[sit[i]]);
	printf("%d\n",ans[sit[n]]);
	return 0;
}
Problem4385

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 2e6+5;
LL sum[N];
int a[N];
int line[N],L,R;
int main()
{
	int n,d;
	LL p;
	scanf("%d%lld%d",&n,&p,&d);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum[i] = sum[i-1]+a[i];
	}
	int i = 0,ans = 0;
	L = 0,R = -1;
	for(int j = d;j<= n;j++)
	{
		while(L<=R&&sum[j]-sum[j-d]>sum[line[R]]-sum[line[R]-d])R--;
		line[++R] = j;
		while(sum[j]-sum[i]-sum[line[L]]+sum[line[L]-d]>p)
		{
			i++;
			if(line[L]-d<i)L++;
		}
		ans = max(ans,j-i);
	}
	printf("%d\n",ans);
	return 0;
}
Problem4386

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 41;
int n,m,cnt;
LL K,mx;
struct Martix
{
	LL a[N*3][N*3];
	Martix()
	{
		memset(a,0,sizeof(a));
	}
	Martix operator*(const Martix &S)const
	{
		Martix ans;
		int i,j,k;
		for (i=0; i<=cnt; i++)
			for (j=0; j<=cnt; j++)
				if (S.a[i][j]<0 || a[i][j]<0)
				{
					ans.a[0][0]=-1; return ans;
				}
		for (i=0; i<=cnt; i++)
			for (j=0; j<=cnt; j++) 
				if (S.a[i][j])
				for (k=0; k<=cnt; k++) 
					if(a[j][k]){
					if (S.a[i][j]>K/a[j][k]){
						ans.a[0][0]=-1; return ans;
					}
					ans.a[i][k]+=S.a[i][j]*a[j][k];
					if (ans.a[i][k]>K){
						ans.a[0][0]=-1; return ans;
					}
				}
		return ans;
	}
};
Martix quick[65],b,c;
int id[N][3],st[N*3];
bool check()
{
	if (b.a[0][0]<0) return 0; 
	LL tmp=0;
	for (int i=1; i<=cnt; i++) 
		if (b.a[0][i] && st[i])
		{
			if(b.a[0][i]>K/st[i]) return 0;
			tmp+=b.a[0][i]*st[i];
			if (tmp>=K) return 0;
		}
	return 1;
}
int main()
{
	int x,y,C;
	scanf("%d%d%lld",&n,&m,&K);
	mx = K*3;
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<3;j++)
			id[i][j] = ++cnt;
	Martix A;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 0;j<2;j++)
			A.a[id[i][j]][id[i][j+1]]++;
		A.a[0][id[i][0]] = 1;
	}
	A.a[0][0] = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&C);
		A.a[id[x][C-1]][id[y][0]]++;
		st[id[x][C-1]]++;
	}
	int len = 0;
	while((LL)1<<len<=mx)len++;
	len--;
	quick[0] = A;
	for(int i = 1;i<= len;i++)
		quick[i] = quick[i-1]*quick[i-1];
	c.a[0][0] = 1;
	LL ans = 0;
	for(int i = len;i>=0;i--)
	{
		b = quick[i]*c;
		if(check())
		{
			ans|=((LL)1<<i);
			memcpy(c.a[0],b.a[0],sizeof(b.a[0]));
		}
	}
	ans++; 
	printf("%lld\n",(ans<=mx)?ans:-1);
	return 0;
}
Problem4398

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e5+5;
const int N = 4e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;};
struct p
{
	int v,no;
}heap[N<<2];
bool cmp(p a,p b)
{
	return a.v>b.v;
}
int dist[N],pre[N],cnt;
bool v[N];
struct G
{
	E e[M<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val  = f;
		head[x] = tot;
	}
	void spfa()
	{
		dist[1]=0;
		heap[1].v = 0;heap[1].no = 1;
		cnt++;
		push_heap(heap+1,heap+cnt+1,cmp);
		while(cnt)
		{
			int now=heap[1].no;
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			if(v[now])continue;
			v[now]=1;
			for(int i=head[now];i;i=e[i].next)
				if(dist[now]+e[i].val<dist[e[i].to]&&!v[e[i].to])
				{
					dist[e[i].to]=dist[now]+e[i].val;
					if(now==1)pre[e[i].to]=e[i].to;
					else pre[e[i].to]=pre[now];
					heap[++cnt].v = dist[e[i].to];
					heap[cnt].no = e[i].to;
					push_heap(heap+1,heap+cnt+1,cmp);
				}
		}
	}
}g1,g2;
int main()
{
	int n,m,x,y,u,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		g1.add(x,y,u);
		g1.add(y,x,w);
	}
	memset(dist,0x3f,sizeof(dist));
	g1.spfa();
	int end = n+1;
	for(int i = g1.head[1];i;i = g1.e[i].next)
	{
		if(pre[g1.e[i].to]!=g1.e[i].to)
			g2.add(1,g1.e[i].to,g1.e[i].val);
		//else g2.add(1,g1.e[i].to,dist[g1.e[i].to]);
	}
	for(int i = 2;i<= n;i++)
	{
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			if(g1.e[j].to==1)
			{
				if(pre[i]!=i)
					g2.add(1,end,dist[i]+g1.e[j].val);
				else g2.add(i,end,g1.e[j].val);
			}else
			{
				if(pre[g1.e[j].to]!=pre[i])
					g2.add(1,g1.e[j].to,dist[i]+g1.e[j].val);
				else g2.add(i,g1.e[j].to,g1.e[j].val);
			}
		}
	}
	memset(dist,0x3f,sizeof(dist));
	memset(v,0,sizeof(v));
	g2.spfa();
	if(dist[end]==INF)printf("-1\n");
	else printf("%d\n",dist[end]);
	return 0;
}
Problem4412

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
int c[N<<1];
int q[N],l,r;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&c[i]);
		c[i+n] = c[i];
	}
	int last = 0,sum = 0,st = 0,beg = 0;
	for(int i = 1;i<= 2*n;i++)
	{
		if(last<0)
			last = 0,beg = i;
		last+=c[i]-1;
		if(last>sum)
			sum = last,st = beg;
	}
	LL ans = 0;
	r = -1;
	for(int i = st;i<st+n;i++)
	{
		while(c[i]--)
			q[++r] = i;
		ans+=(LL)(i-q[l])*(i-q[l]);
		l++;
	}
	printf("%lld",ans);
	return 0;
}
Problem4422

#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
const int X=1000001,Y=1000000,N=2000005;
struct FEN{
    int xl,xr,y,i;
    bool flag;
    bool operator < (const FEN &o)const{
        return y!=o.y?y>o.y:xl<o.xl;
    }
} fen[N<<1];

struct FLO{
    int x,y;
    bool operator < (const FLO &o)const{
        return y>o.y;
    }
} flo[N];
struct CS{
    int x,y,i;
    bool operator < (const CS &o)const{
        return y>o.y;
    }
} cow[N];
struct SS{
    int nm;
    bool cov,cut;
} tr[X<<2];
int ans[N],fs[N];;
char * cp=(char *)malloc(20000000);
inline void in(int &x){
    for (;*cp<'0'||*cp>'9';cp++);
    for (x=0;*cp>='0'&&*cp<='9';cp++)
        x=x*10+*cp-'0';
}
inline void pushup(int x){
    tr[x].nm=tr[x<<1].nm+tr[x<<1|1].nm;
    tr[x].cut=tr[x<<1].cut|tr[x<<1|1].cut;
}
inline void paint(int x){
    tr[x].cov=1;
    tr[x].nm=0;
}
inline void pushdown(int x){
    if(tr[x].cov){
        paint(x<<1),paint(x<<1|1);
        tr[x].cov=0;
    }
}
void add(int x,int l,int r,int pur,int val){
    tr[x].nm+=val;
    if (l==r) return; 
    int mid=(l+r)>>1;
    pushdown(x);
    if(pur<=mid)
        add(x<<1,l,mid,pur,val);
    else 
        add(x<<1|1,mid+1,r,pur,val);
    pushup(x);
}
void cov(int x,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        paint(x);
        return;
    }
    pushdown(x);
    int mid=(l+r)>>1;
    if(L<=mid)cov(x<<1,l,mid,L,R);
    if(R>mid)cov(x<<1|1,mid+1,r,L,R);
    pushup(x);
}
int query(int x,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)
    {
        return tr[x].nm;
    }
    int mid=(l+r)>>1,ans=0;
    pushdown(x);
    if(L<=mid)ans+=query(x<<1,l,mid,L,R);
    if(R>mid)ans+=query(x<<1|1,mid+1,r,L,R);
    return ans;
}
void update(int x,int l,int r,int pur)
{
    if(l==r)
    {
        tr[x].cut^=1;
        return; 
    }
    int mid=l+r>>1;
    pushdown(x);
    if(pur<=mid)
        update(x<<1,l,mid,pur);
    else 
        update(x<<1|1,mid+1,r,pur);
    pushup(x);
}
int next(int x,int l,int r,int L)
{
    if(l>=L)
    {
        if(tr[x].cut)
        {
            while(l!=r)
                if(tr[x<<1].cut)
                    x<<=1,r=l+r>>1;
                else 
                    x=x<<1|1,l=(l+r>>1)+1;
            return l;
        }
        else return 0;
    }
    int tmp,mid=(l+r)>>1;
    pushdown(x);
    if(L<=mid&&(tmp=next(x<<1,l,mid,L)))
        return tmp;
    else 
        return next(x<<1|1,mid+1,r,L);
}
int main()
{
	//freopen("tt.in","r",stdin);
    fread(cp,1,20000000,stdin);
    int f,m,n,x1,y1,x2,y2;
    in(f);
    for(int i=f;i--;)
    {
        in(x1),in(y1),in(x2),in(y2);
        fen[i<<1]=(FEN){x1,x2,y1-1,i,0};
        fen[i<<1|1]=(FEN){x1,x2,y2,i,1};
    }
    sort(fen,fen+(f<<1));
    in(m);
    for(int i=m;i--;)
        in(flo[i].x),in(flo[i].y);
    sort(flo,flo+m);
    in(n);
    for(int i=0;i<n;++i)
    {
        in(cow[i].x),in(cow[i].y);
        cow[i].i=i;
    }
    sort(cow,cow+n);
    f=m=n=0;
    update(1,1,Y,Y);
    int sum,cut;
    for(int i=Y;i;--i)
    {
        for(;fen[f].y==i;++f)
            if(fen[f].flag==0)
            {
                cov(1,1,Y,fen[f].xl,fen[f].xr);
                if(fen[f].xl!=1)
                    add(1,1,Y,fen[f].xl-1,-fs[fen[f].i]);
                if(fen[f].xl!=1)
                    update(1,1,Y,fen[f].xl-1);
                if(fen[f].xr!=Y)
                    update(1,1,Y,fen[f].xr);
            }else
            {
                cut=next(1,1,Y,fen[f].xr);
                sum=query(1,1,Y,fen[f].xl,fen[f].xr);
                fs[fen[f].i]=query(1,1,Y,fen[f].xr+1,cut);
                cov(1,1,Y,fen[f].xl,fen[f].xr);
                if(fen[f].xl>1)
                    add(1,1,Y,fen[f].xl-1,sum+fs[fen[f].i]);
                if(fen[f].xl!=1)
                    update(1,1,Y,fen[f].xl-1);
                if(fen[f].xr!=Y)
                    update(1,1,Y,fen[f].xr);
            }
        for(;flo[m].y==i;++m)
            add(1,1,Y,flo[m].x,1);
        for(;cow[n].y==i;++n)
        {
            cut=next(1,1,Y,cow[n].x);
            ans[cow[n].i]=query(1,1,Y,cow[n].x,cut);
        }
    }
    for(int i=0;i<n;++i)
        printf("%d\n",ans[i]);
    return 0;
}
Problem4425

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int n,m,ans;
struct stuff
{int l,r;}s[N];
inline bool cmp(const stuff &a,const stuff &b){return a.l<b.l;}
struct pro
{
	int x;
	bool operator <(const pro &a)const{return x>a.x;}
};
priority_queue<pro>heap;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&s[i].l,&s[i].r),s[i].r+=s[i].l;
	sort(s+1,s+n+1,cmp);
	heap.push((pro){s[1].r+m});
	for(int i = 2;i<= n;i++)
	{
		while(!heap.empty()&&heap.top().x<s[i].l)heap.pop();
		int t = heap.top().x;
		if(t-m<=s[i].l&&s[i].l<=t)ans++,heap.pop();
		heap.push((pro){s[i].r+m});
	}
	printf("%d\n",ans);
	return 0;
}
Problem4426

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 210;
const int INF = 0x3f3f3f3f;
struct data
{
	int l,r;
	data(){}
	data(int _l,int _r):l(_l),r(_r){}
}s[N],q[2][N];
int cnt[2],ans = -INF;
bool cmp1(const data &a,const data &b)
{return a.l<b.l;}
bool cmp2(const data &a,const data &b)
{return a.r-a.l+1>b.r-b.l+1;}
int f[N][N],sum[N];
void solve(int now,int l,int r,int dl,int dr)
{
	int mid = (l+r)>>1,dmid = dl,maxn = ans;
	for(int i = min(dr,mid-1);i>=dl;i--)
	{
		if(q[0][i+1].r<=q[0][mid].l)break;
		int tmp = f[now-1][i]+q[0][i+1].r-q[0][mid].l;
		if(tmp>=maxn)maxn = tmp,dmid = i;
	}
	f[now][mid] = maxn;
	if(l<mid)solve(now,l,mid-1,dl,dmid);
	if(r>mid)solve(now,mid+1,r,dmid,dr);
}
int main()
{
	int n,p;
	scanf("%d%d",&n,&p);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&s[i].l,&s[i].r);
	for(int i = 1;i<= n;i++)
	{
		int flag = 0;
		for(int j = 1;j<= n;j++)
			if(s[i].l<=s[j].l&&s[i].r>=s[j].r&&(s[i].l!=s[j].l||s[i].r!=s[j].r||i<j))
				flag = 1;
		q[flag][++cnt[flag]] = s[i];
	}
	sort(q[0]+1,q[0]+cnt[0]+1,cmp1);
	for(int i = 1;i<= cnt[0];i++)f[0][i]=-INF;
	for(int i = 1;i<= p;i++)f[i][0] = -INF;
	for(int i = 1;i<= p;i++)solve(i,1,cnt[0],0,cnt[0]);
	sort(q[1]+1,q[1]+cnt[1]+1,cmp2);
	for(int i = 1;i<= cnt[1];i++)sum[i] = sum[i-1]+q[1][i].r-q[1][i].l;
	for(int i = 1;i<= p;i++)
		if((p-i)<=cnt[1]&&f[i][cnt[0]]>=0)
			ans = max(ans,f[i][cnt[0]]+sum[p-i]);
	printf("%d\n",ans);
	return 0;
}
Problem4427

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-9;
const int N = 1005;
inline int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	return x>0?1:-1;
}
inline int sqr(int x)
{
	return x*x;
}
struct Point
{
	double x,y;
	Point(){}
	Point(double _x,double _y):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double operator *(const Point &a,const Point &b)
	{return a.x*b.y-a.y*b.x;}
	friend bool operator !=(const Point &a,const Point &b)
	{return a.x!=b.x||a.y!=b.y;}
	friend bool operator ==(const Point &a,const Point &b)
	{return a.x==b.x&&a.y==b.y;} 
}poi[N];
struct Line
{
	Point a,b;
	Line(){}
	Line(const Point &_a,const Point &_b):a(_a),b(_b){}
}line[N];
struct E
{int next,to;}e[N*N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool Inter(const Line &l1,const Line &l2)
{
	return dcmp((l1.b-l1.a)*(l2.a-l1.a))*dcmp((l1.b-l1.a)*(l2.b-l1.a))<0
			&& dcmp((l2.b-l2.a)*(l1.a-l2.a))*dcmp((l2.b-l2.a)*(l1.b-l2.a))<0;
}
int col[N];
queue<int>Q;
int main()
{
	int n,m,x,y,id;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		poi[i] = Point(x,y);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&id,&x,&y);
		line[i].a = poi[id];
		line[i].b = Point(x,y);
	}
	for(int i = 1;i<= m;i++)
		for(int j = i+1;j<= m;j++)
			if((Inter(line[i],line[j])||line[i].b==line[j].b)&&
				line[i].a!=line[j].a&&line[i].a!=line[j].b&&line[i].b!=line[j].a)
					add(i,j),add(j,i);
	for(int i = 1;i<= m;i++)
	{
		if(col[i])continue;
		col[i] = 1;
		Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int j = head[x];j;j=e[j].next)
			{
				if(col[e[j].to])
				{
					if(col[e[j].to]==col[x])
					{
						printf("impossible\n");
						return 0;
					}
				}else
				{
					col[e[j].to] = col[x]==1?2:1;
					Q.push(e[j].to);
				}
			}
		}
	}
	printf("possible\n");
	return 0;
}
Problem4432

#include <stdio.h>
#include <math.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int mx = 3e5;
int Tim,n,m,top,tp;
int cnt[N][4];
char s[N];
struct seg;
struct edge;
vector<edge*>now[N][4];
struct edge
{
	seg *pre,*nxt;
	inline void solve();
	inline void merge();
}List[N<<1];
struct seg
{
	int l,r,flag,h0,t0;
	edge *pre,*nxt;
	inline int calc()
	{return h0+cnt[Tim][flag]-cnt[t0][flag];}
	inline bool checka()
	{return pre&&pre->pre->calc()>calc();}
	inline bool checkb()
	{return nxt&&nxt->nxt->calc()>calc();}
	inline void update()
	{flag = checka()|(checkb()<<1);}
}list[N<<1],*last,*first;
inline void edge::solve()
{
	int delta = abs(pre->calc()-nxt->calc()),flag = pre->flag^nxt->flag;
	if(delta && flag && delta+cnt[Tim][flag]<=mx)
		now[delta+cnt[Tim][flag]][flag].push_back(this);
}
inline void edge::merge()
{
	if(!(pre&&nxt))return ;
	int h = pre->calc();
	if(nxt->calc()!=h)return ;
	seg* ret = pre;
	ret->l = pre->l,ret->r = nxt->r,ret->h0 = h,ret->t0 = Tim;
	ret->pre = pre->pre,ret->nxt = nxt->nxt,ret->update();
	if(ret->pre)ret->pre->nxt = ret;
	if(ret->nxt)ret->nxt->pre = ret;
	if(ret->pre)ret->pre->solve();
	if(ret->nxt)ret->nxt->solve();
	pre = NULL,nxt = NULL;
}

int main()
{
	int h;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&h);
		if(last && last->h0==h)
			{last->r=i;continue;}
		++top;
		list[top].l = list[top].r = i;list[top].h0 = h,list[top].t0 = 0;
		if(last)
		{
			++tp;
			List[tp].pre = last,List[tp].nxt = &list[top];
			last->nxt = &List[tp];list[top].pre = &List[tp],last->update();
		}else first = &list[top];
		last = &list[top];
	}
	last->update();
	for(seg *i = first;i->nxt;i=i->nxt->nxt)
		i->nxt->solve();
	scanf("%s",s+1);
	for(Tim = 1;Tim<=m;Tim++)
	{
		cnt[Tim][1]=cnt[Tim-1][1]+(s[Tim]=='A'),cnt[Tim][2]=cnt[Tim-1][2]+(s[Tim]=='B');
		cnt[Tim][3]=cnt[Tim-1][3]+1;
		for(int f = 1;f<= 3;f++)
		{
			int sz = now[cnt[Tim][f]][f].size();
			for(int i = 0;i<sz;i++)now[cnt[Tim][f]][f][i]->merge();
		}
	}
	Tim = m;
	for (seg* i=first;i;i=i->nxt?i->nxt->nxt:NULL)
   	    for (int j=i->l;j<=i->r;++j)
        {
            if (j>1) putchar(' ');
            printf("%d",i->calc());
        }
    putchar('\n');
	return 0;
}
Problem4435

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
const int M = 9005;
const int INF = 0x3f3f3f3f;
typedef unsigned long long ull;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f;
}
int d[N],n,m;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(s);
	d[s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]+1)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
bool vis[N];
int a[N],b[N];
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!vis[e[i].to])
			dfs(e[i].to);
}
void reset()
{
	for(int i = 2;i<=tot;i+=2)
		e[i].f=e[i^1].f=(e[i].f+e[i^1].f)>>1;
}
ull BASE = 1,hash[4][N];
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(vis,0,sizeof(vis));
	dfs(s);
	BASE *= 131;
	for(int i = 1;i<= n;i++)
		if(~d[i])
			hash[tmp][i]+=BASE;
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(vis[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i]=i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,1);
	}
	solve(1,n);
	int Ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			for(int k = 0;k<= 3;k++)if(hash[k][i]!=hash[k][j])
			{
				Ans+=k;
				break;
			}
	printf("%d\n",Ans);
	return 0;
}
Problem4436

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
int nxt[N];
bool ins[N],vis[N];
int head[N],tot,ind[N];
queue<int>Q;
void getans(int x,int c)
{
	vis[x] = true;
	ins[x] = c;
	if(!vis[nxt[x]])getans(nxt[x],c^1);
}
int main()
{
	int n,x;
	scanf("%d",&n);
	n<<=1;
	for(int i = 1;i<= n;i++)
		scanf("%d",&nxt[i]),ind[nxt[i]]++;
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i),vis[i]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		ins[x] = true;
		int y = nxt[x];
		if(vis[y])continue;
		vis[y] = true;
		int z = nxt[y];
		if(!--ind[z])
		{
			Q.push(z);
			vis[z] = true;
		}
	}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			getans(i,1);
	for(int i = 1;i<= n;i++)
		if(ins[i])printf("%d ",i);
	return 0;
}
Problem4437

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
const int M=2000000;
const int P=(1<<24)-1;
char map[105][105];
struct E
{int x,y,next;}e[M+5];
int head[P+1],tot,n,m;
void add(int x,int y)
{
	int p = ++tot;
	e[p].x = x;
	e[p].y = y;
	e[p].next = head[((x<<9)^y)&P];
	head[((x<<9)^y)&P] = p;
}
bool ask(int x,int y)
{
	for(int i = head[((x<<9)^y)&P];i;i=e[i].next)
		if(x==e[i].x&&y==e[i].y)
			return true;
	return false;
}
int _dx[]={0,0,1,-1};
int _dy[]={1,-1,0,0};
int l,r,Qx[M],Qy[M];
const int lim = 10000;
int cnt;
void bfs()
{
	l=r=-1;Qx[++r]=0,Qy[r]=0;
	add(0,0);
	int x,y,sx,sy;
	while(l<r&&cnt<lim)
	{
		x = Qx[++l],y = Qy[l];
		for(int d = 0;d<4;d++)
		{
			sx = x+_dx[d],sy = y+_dy[d];
			if(!ask(sx,sy)&&map[(sx%n+n)%n][(sy%m+m)%m]=='.')
			{
				Qx[++r] = sx,Qy[r] = sy;
				add(sx,sy);
				if(sx%n==0&&sy%m==0)cnt++;
				if(r==M-1)return ;
			}
		}
	}
}
inline ll Abs(ll x){return x>0?x:-x;}
int flag;
ll dx,dy;
void getans(int x,int y)
{
	if(cnt<lim&&r<M-1){printf("%s\n",ask(x,y)?"yes":"no");return ;}
	if(flag){printf("%s\n",ask((x%n+n)%n,(y%m+m)%m)?"yes":"no");return ;}
	int L = -1e9,R = 1e9;
	while(L+5<R)
	{
		int m1 = (L+L+R)/3,m2 = (L+R+R)/3;
		ll f1 = Abs(dx*m1+x)+Abs(dy*m1+y);
		ll f2 = Abs(dx*m2+x)+Abs(dy*m2+y);
		if(f1<f2)R = m2;
		else L = m1;
	}
	int k = L;
	for(int i = L;i<= R;i++)
		if(Abs(dx*k+x)+Abs(dy*k+y)>=Abs(dx*i+x)+Abs(dy*i+y))
		{
			if (ask(x+dx*i,y+dy*i)) return void(printf("yes\n"));
			k=i;
		}
	printf("no\n");
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i< n;i++)
		scanf("%s",map[i]);
	bfs();
	if(cnt>=lim||r==M-1)
	{
		if(ask(n,0)&&ask(0,m))
			flag = 1;
		else
		{
			dx = 1ll<<40,dy = 1ll<<40;
			for (int i=1;i<=r;i++)
				if (Qx[i]%n==0 && Qy[i]%m==0)
					if (Qx[i]+Qy[i]<dx+dy)
						dx=Qx[i],dy=Qy[i];
		}
	}
	int Q,x,y;
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%d%d",&x,&y);
		getans(x,y);
	}
	return 0;
}
Problem4444

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int INF = 1e9;
const int N = 400020;
struct yts { int x,t,ne;} e[N];
struct PP { int l,r,id;} p[N];
int head[N],dep[N],st[N],ans[N],w;
int m,num;
 
bool cmp(PP a,PP b) { return a.l<b.l;}
void put(int x,int y)
{
	num++; e[num].x=x; e[num].t=y;
	e[num].ne=head[x]; head[x]=num;
}
 
void dfs(int x,int h)
{
	st[++w]=x;
	if (p[x].id!=-1)
	{
		while (h<w&&p[st[h+1]].r>=p[x].l+m) h++;
		ans[p[x].id]=dep[x]-dep[st[h]]+1;
	}
	for (int i=head[x];i;i=e[i].ne)
	{
		int y=e[i].t;
		dep[y]=dep[x]+1;
		dfs(y,h);
	}
	w--;
}
 
int main()
{
	int n;
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		if (r<l) r+=m;
		p[i]=(PP){l,r,i}; p[i+n]=(PP){l+m,r+m,-1};
	}
	n<<=1;
	sort(p+1,p+n+1,cmp);
	int now=1;
	for (int i=1;i<n;i++)
	{
		while (now<n&&p[now+1].l<=p[i].r) now++;
		put(now,i);
	}
	n>>=1;
	dep[2*n]=1; dfs(2*n,1);
	for (int i=1;i<=n;i++) printf("%d ",ans[i]);
	printf("\n");
	return 0;
}
Problem4445

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
const double eps = 1e-10;
int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	if(x>0)return 1;else return -1;
}
struct Point
{
	double x,y;
	Point(double _x=0,double _y=0):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend Point operator *(const Point &a,const double &k)
	{return Point(a.x*k,a.y*k);}
	friend double operator *(const Point &a,const Point &b)
	{return a.x*b.x+a.y*b.y;}
	friend double operator ^(const Point &a,const Point &b)
	{return a.x*b.y-a.y*b.x;}

};
struct Line
{
	Point p,v;
	double ang;
	Line(){}
	Line(Point _p,Point _v):p(_p),v(_v)
	{ang = atan2(v.y,v.x);}
	bool operator <(const Line &s)const
	{return ang<s.ang;}
};
bool on_left(const Line &l,const Point &p)
{return dcmp(l.v^(p-l.p))>0;}
Point Get_intersection(const Line &l1,const Line &l2)
{
	double x = ((l2.p-l1.p)^l2.v)/(l1.v^l2.v);
	return l1.p+l1.v*x;
}
double pans;
Line l[N],q[N];
Point t[N],p[N];
void Get_Half_Plane_Intersection(int n)
{
	sort(l+1,l+n+1);
	int hd = 1,tl = 0;
	q[++tl]=l[1];
	for(int i = 2;i<= n;i++)
	{
		while(hd<tl&& !on_left(l[i],p[tl-1]))tl--;
		while(hd<tl&& !on_left(l[i],p[hd]))hd++;
		q[++tl]=l[i];
		if(dcmp(q[tl].v^q[tl-1].v)==0)
		{
			tl--;
			if(hd<tl && !on_left(l[i],p[tl-1]))q[tl]=l[i];
		}
		if(hd<tl)p[tl-1] = Get_intersection(q[tl],q[tl-1]);
	}
	while(hd<tl && !on_left(q[hd],p[tl-1]))tl--;
	if(tl-hd<=1)
	{
		printf("0.0000");
		return ;
	}
	p[tl] = Get_intersection(q[tl],q[hd]);
	double ans = 0;
	for(int i = hd+1;i< tl;i++)
		ans+=((p[i]-p[hd])^(p[i+1]-p[hd]));
	ans = ans*0.5;
	printf("%.4f\n",ans/pans);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf",&t[i].x,&t[i].y);
	t[n+1]=t[1];
	for(int i = 2;i<n;i++)
		pans+=((t[i]-t[1])^(t[i+1]-t[1]));
	pans*=0.5;
	int cnt = 0;
	double x1 = t[1].x,y1 = t[1].y;
	double x2 = t[2].x,y2 = t[2].y;
	for(int i = 2;i<= n;i++)
	{
		double x3 = t[i].x,y3 = t[i].y;
		double x4 = t[i+1].x,y4 = t[i+1].y;
		double a = y1+y4-y2-y3;
		double b = x2+x3-x1-x4;
		double c = (t[1]^t[2])+(t[i+1]^t[i]);
		Point p,v;
		if(dcmp(b)!=0)p=Point(0,-c/b);  
        else p=Point(-c/a,0);  
       	v=Point(-b,a);
       	l[++cnt]=Line(p,v);
	}
	for(int i = 1;i<= n;i++)l[++cnt]=Line(t[i],t[i+1]-t[i]);
	Get_Half_Plane_Intersection(cnt);
	return 0;
}
Problem4446

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
ll f[N][20],g[N][20],A[N],B[N],dep[N],dis[N];
int ls[N],rs[N],fa[N];
void dp(int x)
{
	if(!ls[x]&&!rs[x])
	{
		for(int y = 2;y<=dep[x];y++)
		{
			int lca = x>>(dep[x]-y+1),z = x>>(dep[x]-y)^1;
			f[x][y]=(dis[x]+dis[z]-2*dis[lca])*A[z];
		}
	}else if(ls[x]&&!rs[x])
	{
		dp(ls[x]);
		for(int y = 2;y<= dep[x];y++)
			f[x][y]=A[ls[x]]*B[ls[x]]+f[ls[x]][y];
	}else
	{
		dp(ls[x]),dp(rs[x]);
		for(int y = 2;y<= dep[x];y++)
			f[x][y]=min(A[ls[x]]*B[ls[x]]+f[ls[x]][dep[x]+1]+f[rs[x]][y],
						A[rs[x]]*B[rs[x]]+f[rs[x]][dep[x]+1]+f[ls[x]][y]);
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
		scanf("%lld",&A[i]);
	dep[1]=1;
	for(int i = 2;i<= n;i++)
	{
		scanf("%lld",&B[i]);
		fa[i]=i>>1;
		dep[i]=dep[fa[i]]+1;
		dis[i]=dis[fa[i]]+B[i];
		if(ls[fa[i]])rs[fa[i]]=i;
		else ls[fa[i]]=i;
	}
	dp(1);
	for(int x = n;x>=1;x--)
		for(int y = 0;y<=dep[x];y++)
		{
			if(!rs[x])
			{
				if(!ls[x])
				{
					if(!y)g[x][y]=0;
					else
					{
						int z=x>>(dep[x]-y);
						g[x][y]=(dis[x]-dis[z])*A[z];
					}
				}else
					g[x][y]=A[ls[x]]*B[ls[x]]+g[ls[x]][y];
			}else
			{
				g[x][y]=min(A[ls[x]]*B[ls[x]]+f[ls[x]][dep[x]+1]+g[rs[x]][y],
							A[rs[x]]*B[rs[x]]+f[rs[x]][dep[x]+1]+g[ls[x]][y]);
			}
		}
	ll ans = g[1][0];
	for(int i = 2;i<= n;i++)
	{
		int x = i;ll sum = g[x][dep[x]-1];
		while(x!=1)
		{
			if((x^1)>n)
				sum+=A[x>>2]*B[x>>1];
			else 
				sum+=A[x^1]*B[x^1]+g[x^1][dep[x>>1]-1];
			x=x>>1;
		}
		ans = min(ans,sum);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4447

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
int n,m,s,t,a[N];
char opt[N];
struct Seg
{
	int x,y,z,s1,s2,t1,t2;
	void init(int i)
	{
		x = y = i;z = 1;
		s1 = t1 = i?-1:0;
		s2 = t2 = -1;
	}
	friend Seg operator +(const Seg &a,const Seg &b)
	{
		Seg res={a.x,b.y,a.z+b.z};
		int j = (a.y||b.x)?-1:0;
		if(b.s1==j)res.s1=a.s1,res.s2=a.s2;
		else 
			res.s1 = b.s1+a.z,res.s2=(b.s2!=j)?b.s2+a.z:a.s1;
		if(a.t1==j)res.t1=b.t1,res.t2=b.t2;
		else
			res.t1 = a.t1+b.z,res.t2=(a.t2!=j)?a.t2+b.z:b.t1;
		return res;
	}
}tr[N<<3];
int cal(int i)
{
	int s = i%n,t=(s+n-1)%n;
	if(opt[s]=='+')return (a[s]+a[t])%10;
	else return a[s]*a[t]%10;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].init(cal(l));
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p]=tr[p<<1]+tr[p<<1|1];
}
void update(int p,int l,int r,int pos,int val)
{
	if(l==r)
	{
		tr[p].init(val);
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,val);
	else update(p<<1|1,mid+1,r,pos,val);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
Seg getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans(p<<1|1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans(p<<1|1,mid+1,r,a,b);
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i<n;i++)
		scanf("%d %c",&a[i],&opt[i]);
	build(1,0,2*n-1);
	int s,t;
	while(m--)
	{
		scanf("%d%d",&s,&t);
		if(s==1)
		{
			scanf("%d %c",&a[t],&opt[t]);
			update(1,0,2*n-1,t,cal(t));
			update(1,0,2*n-1,t+n,cal(t));
			update(1,0,2*n-1,t+1,cal(t+1));
			if(t!=n-1)
				update(1,0,2*n-1,t+n+1,cal(t+1));
		}else
		{
			update(1,0,2*n-1,t,a[t]);
			Seg a=getans(1,0,2*n-1,t,t+(n-1)/2);
			Seg b=getans(1,0,2*n-1,t+(n+1)/2,t+n-1);
			if(~b.t1&&(a.x||b.t1))++b.t1;
            if(~b.t2&&(a.x||b.t2))++b.t2;
            printf("%d\n",a.y||b.x?max(a.s1,b.t1):max(max(a.s2,b.t2),min(a.s1,b.t1)));
            update(1,0,2*n-1,t,cal(t));
		}
	}
	return 0;
}
Problem4448

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],size[N],son[N],top[N],fa[N],dfn[N],seq[N],Dfn,cnt;
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x]=e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x]=tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=son[x]&&e[i].to!=fa[x])
			dfs2(e[i].to,e[i].to);
}
struct Ask
{
	int x,y,c;
	int dat;
}ask[N];
int root[N],sum[N*100],TOT,ls[N*100],rs[N*100],val[N];
int mx = 2e5;
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++TOT;
	sum[p]=sum[pre]+1;
	if(l==r)return ;
	ls[p]=ls[pre],rs[p]=rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
int getans(int p1,int p2,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p2]-sum[p1];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p1],ls[p2],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p1],rs[p2],mid+1,r,a,b);
	return ans;
}
int lth;
int getans(int x,int y,int c)
{
	int ans = 0;
	lth = dep[x]+dep[y];
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=getans(root[dfn[top[x]]-1],root[dfn[x]],0,mx,c,mx);
		x = fa[top[x]];
	}
	if(dep[y]<dep[x])swap(x,y);
	ans+=getans(root[dfn[x]-1],root[dfn[y]],0,mx,c,mx);
	lth-=dep[x]+dep[fa[x]];
	return ans;
}
int main()
{
	int n,m,rot;
	int k,x,y,c;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(!x)rot=i;
		else add(x,i);
	}
	dfs1(rot);
	dfs2(rot,rot);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&k,&x);
		if(k==1)
		{
			scanf("%d%d",&y,&c);
			cnt++;
			ask[cnt].x=x,ask[cnt].y=y,ask[cnt].c=c;ask[cnt].dat=i;
		}else
			val[x] = m-i;
	}
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],0,mx,val[seq[i]]);
	for(int i = 1;i<= cnt;i++)
	{
		int ans2 = getans(ask[i].x,ask[i].y,ask[i].c+m-ask[i].dat+1);
		int ans1 = lth;
		printf("%d %d\n",ans1,ans2);
	}
	return 0;
}
Problem4451

#include <bits/stdc++.h>

const int N = 400005;
const int mod = 1000003;
typedef long long ll;
int toA[N],toB[N];
int ny[N],jc[N];
int n,a,b,c,w;
int pow(int x,int y)
{
	int ans = 1;
	while (y)
	{
		if (y & 1)
			ans = (ll) ans * x % mod;
		x = (ll) x * x % mod;
		y >>= 1;
	}
	return ans;
}

void getJc()
{
	jc[0] = ny[0] = 1;
	for (int i = 1; i <= N - 5; i++)
	{
		jc[i] = (ll) jc[i - 1] * i % mod;
		ny[i] = pow(jc[i],mod - 2);
	}
}

int getW(int x1,int y1)
{
	return (ll)jc[x1 + y1] % mod * ny[x1] % mod * ny[y1] % mod * toB[x1] % mod * toA[y1] % mod;
}

int main()
{
	getJc();
	scanf("%d%d%d%d",&n,&a,&b,&c);
	int ans=0;
	toA[0]=toB[0]=1;
	for (int i = 1; i <= n; i++)
		toA[i] = (ll)toA[i - 1] * a % mod, toB[i] = (ll)toB[i - 1] * b % mod;
	for (int i = 1; i <= n; i++)
	{
		scanf("%d",&w);
		int x = n - i,y = n - 1;
		if (i > 1)
			ans = (ans + (ll)toB[x] * toA[y] % mod * jc[x + y - 1] % mod * ny[x] % mod * ny[y - 1] % mod * w % mod) % mod;
	}
	for (int i = 1; i <= n; i++)
	{
		scanf("%d",&w);
		int x = n - 1, y = n - i;
		if (i > 1)
			ans = (ans + (ll)toB[x] * toA[y] % mod * jc[x + y - 1] % mod * ny[x - 1] % mod * ny[y] % mod * w % mod) % mod;
	}
	n--;
	int now = 1, w = (a + b) % mod;
	ans = (ans + c) % mod;
	for (int i = 1; i < n; i++)
	{
		now = (ll)now * w % mod;
		ans = (ans + (ll)now * c % mod) % mod;
	}
	int x1 = 0, y1 = n-1, x2 = n-1, y2 = 0;
	for (int i = 1; i < n; i++)
	{
		int w1 = getW(x1,y1);
		int w2 = getW(x2,y2);
		now = (now - (ll)w1 + mod) % mod;
		now = (now - (ll)w2 + mod) % mod;
		now = (ll)now * w % mod;
		now = (now + (ll)w1 * b % mod) % mod;
		now = (now + (ll)w2 * a % mod) % mod;
		ans = (ans + (ll)now * c % mod) % mod;
		x1++;
		y2++;
	}
	printf("%d\n",ans);
}
Problem4452

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int fa[N],size[N],deg[N],size2[N],num0,num2,numc;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x] = getfa(fa[x]);
}
void del(int x)
{
	if(deg[x]==0)num0--;
	if(deg[x]==2)num2--,size2[getfa(x)]--;
}
void add(int x)
{
	if(deg[x]==0)num0++;
	if(deg[x]==2)num2++,size2[getfa(x)]++;
}
void delc(int x){if(size[x]==size2[x])numc--;}
void addc(int x){if(size[x]==size2[x])numc++;}
void merge(int u,int v)
{
	int x = getfa(u),y = getfa(v);
	if(x^y)
	{
		delc(x),delc(y),del(u),del(v);
		deg[u]++,deg[v]++;
		add(u),add(v);
		fa[x] = y,size[y]+=size[x],size2[y]+=size2[x];
		addc(y);
	}else
	{
		delc(x),del(u),del(v);
		deg[u]++,deg[v]++;
		add(u),add(v),addc(x);
	}
}
int a[N],idx[N],ans1[N],ans2[N];
bool cmp(int x,int y)
{
	return a[x]>a[y];
}
struct E
{
	int x,y,w;
	bool operator <(const E &s)const
	{
		return w>s.w;
	}
}e[N];
int main()
{
	int n,m,q;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w);
	sort(e+1,e+m+1);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)scanf("%d",&a[i]),idx[i]=i;
	sort(idx+1,idx+q+1,cmp);
	for(int i = 1;i<= n;i++)
		deg[i]=0,fa[i]=i,size[i]=1,size2[i]=0;
	num0 = n;
	int pnt = 1;
	int curm = 0;
	for(int i = 1;i<= q;i++)
	{
		while(pnt<=m&&e[pnt].w>=a[idx[i]])
			merge(e[pnt].x,e[pnt].y),pnt++,curm++;
		ans1[idx[i]] = n-num0-num2+numc;
		ans2[idx[i]] = curm-num2+numc;
	}
	for(int i = 1;i<= q;i++)
		printf("%d %d\n",ans1[i],ans2[i]);
	return 0;
}
Problem4453

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
char s[N];
int len;
namespace SA
{
	int sa[N],val[N],nv[N],h[N],rnk[N],cnt[N],q[N];
	bool is_same(int a,int b,int hl,int len)
	{
		return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
	}
	void build_sa(int lim,int len)
	{
		int i,j,k;
		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]] = i;
		for(int d = 1;;d++)
		{
			int hl = 1<<(d-1);
			int id = 0;
			for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
			for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

			for(i = 0;i<lim;i++)cnt[i] = 0;
			for(i = 0;i<len;i++)cnt[val[q[i]]]++;
			for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
			for(i = len-1;i>= 0;i--)sa[--cnt[val[q[i]]]] = q[i];

			lim = 0;
			for(i = 0;i<len;lim++)
			{
				for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
				for(k = i,i = j+1;k<=j;k++)nv[sa[k]] = lim;
			}
			for(i = 0;i<len;i++)val[i] = nv[i];
			if(lim==len)break;
		}
	}
	void build_rank(int len)
	{
		for(int i = 0;i<len;i++)
			rnk[sa[i]] = i;
	}
	void build_height(int len)
	{
		for(int i = 0;i<len;i++)
			if(rnk[i])
			{
				int j = 0;
				if(i)j = max(h[rnk[i-1]]-1,0);
				while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])
					j++;
				h[rnk[i]] = j;
			}
	}
	int st[N][20];
	int lg2[N];
	void build_st(int len)
	{
		for(int i = 2;i<N;i++)
			lg2[i] = lg2[i>>1]+1;
		for(int i = 0;i<len;i++)
			st[i][0] = h[i];
		for(int j = 1;j<= 18;j++)
			for(int i = 0;i+(1<<(j-1))<=len;i++)
				st[i][j] = min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
	}
	int lcp(int i,int j)
	{
		i = rnk[i],j = rnk[j];
		if(i>j)swap(i,j);
		i++;
		int lth = lg2[j-i+1];
		return min(st[i][lth],st[j-(1<<lth)+1][lth]);
	}
}
struct E{int next,to,id;};
struct List
{
	E e[N];
	int h[N],tot;
	void insert(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = h[x];
		h[x] = tot;
	}
}g,list;
struct Q
{int next,to,id;}q[N];
int head[N],tot;
void addq(int x,int y,int id)
{
	q[++tot].to = y;
	q[tot].next = head[x];
	q[tot].id = id;
	head[x] = tot;
}
int vis[N];
set<int>S;
void dfs(int x)
{
	vis[x] = 1;
	S.erase(x);
	for(int i = g.h[x];i;i=g.e[i].next)
	{
		int to = g.e[i].to;
		if(vis[to])continue;
		dfs(to);
	}
}
int stack[N],top,ans[N];
void solve()
{
	for(int r = 0;r< len;r++)
	{
		S.insert(r);
		while(top)
		{
			int lth = SA::lcp(r,stack[top]);
			if(s[r+lth]<s[stack[top]+lth])break;
			list.insert(r+lth,stack[top]);
			g.insert(r,stack[top]);
			top--;
		}
		stack[++top] = r;
		for(int i = list.h[r];i;i=list.e[i].next)
		{
			int to = list.e[i].to;
			if(!vis[to])dfs(to);
		}
		for(int i = head[r];i;i=q[i].next)
			ans[q[i].id] = *S.lower_bound(q[i].to);
	}
}
int main()
{
	scanf("%s",s);
	len = strlen(s);
	SA::build_sa(255,len);
	SA::build_rank(len);
	SA::build_height(len);
	SA::build_st(len);
	int q,l,r;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&l,&r);
		l--,r--;
		addq(r,l,i);
	}
	solve();
	for(int i = 1;i<= q;i++)printf("%d\n",ans[i]+1);
	return 0;
}
Problem4455

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 20;
int mp[N][N],fa[N],n,m;
bool islf[N];
ll f[N][N];
struct E
{int next,to;}e[N*N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int p[N],q[N];
void dfs(int s)
{
	q[1] = s;
	int l = 1,r = 1;
	while(l<=r)
	{
		int x = q[l++];
		islf[x] = true;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				islf[x] = false;
				q[++r] = e[i].to;
			}
	}
}
int get_point(int x)
{
	int j = 0,cnt = 0;
	while(x)
	{
		j++;
		if(x&1)p[++cnt] = j;
		x>>=1;
	}
	return cnt;
}
void dp(int cnt)
{
	for(int i = n;i>= 1;i--)
	{
		int x = q[i];
		if(islf[x])continue;
		for(int j = 1;j<= cnt;j++)
		{
			for(int o = head[x];o;o=e[o].next)
			{
				ll num = 0;int to = e[o].to;
				if(fa[to]!=x)continue;
				for(int k = 1;k<= cnt;k++)
					if(mp[p[j]][p[k]])
						num+=f[to][k];
				f[x][j]*=num;
			}
		}
	}
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)mp[i][i]=1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		mp[x][y] = mp[y][x] = 1;
	}
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1);
	ll ans = 0;int tmp = n%2;
	for(int i = 0;i<(1<<n);i++)
	{
		int cnt = get_point(i);
		int flag = (cnt%2==tmp)?1:-1;
		ll tans = 0;
		for(int j = 1;j<= n;j++)
			for(int k =1;k<= cnt;k++)
				f[j][k] = 1;
		dp(cnt);
		for(int j = 1;j<= cnt;j++)tans+=f[1][j];
		ans+=(ll)flag*tans;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4456

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
struct Ask
{
	int id;
	int x1,y1,x2,y2;
	Ask(){}
}a[M],b[M];
int head[M],tot;
int n,m;
inline int getid(int i,int j)
{
	return i*m-m+j;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool cmp(const int &a,const int &b)
{
	return a>b;
}
int d[M],id[M],cnt,ans[M],q[M];
void goup(int x)
{
	int y=q[x],t=d[y];
	for (; x>1 && t<d[q[x>>1]]; x>>=1)
	{
		q[x]=q[x>>1]; id[q[x]]=x;
	}
	q[x]=y; id[y]=x;
}
void godown(int x)
{
	int y=x<<1,z=q[x],t=d[z];
	if (y<cnt && d[q[y|1]]<d[q[y]]) y|=1;
	while (y<=cnt && d[q[y]]<t)
	{
		q[x]=q[y]; id[q[x]]=x;
		x=y; y<<=1; if (y<cnt && d[q[y|1]]<d[q[y]]) y|=1;
	}
	q[x]=z; id[z]=x;
}
void dijk(int s,int x1,int y1,int x2,int y2)
{
	register int i,j;
	d[s] = 0,id[s] =1,cnt=0;
	q[++cnt] =s;
	for(i = x1;i<= x2;i++)
		for(j = y1;j<= y2;j++)
			if(getid(i,j)!=s)
			{
				int no = getid(i,j);
				q[++cnt] = no;
				d[no] = INF;id[no] = cnt;
			}
	while(cnt)
	{
		int x=q[1];
		q[1]=q[cnt--];
		id[q[1]]=1;
		godown(1);
		for(i = head[x];i;i=e[i].next)
		{
			int to = e[i].to,u = (to-1)/m+1,v = (to-1)%m+1;
			if(u<=x2&&u>=x1&&v<=y2&&v>=y1&&d[x]+e[i].val<d[to])
				{d[to]=d[x]+e[i].val;goup(id[to]);}
		}
	}
}
/*queue<int>Q;
bool vis[M];
void dijk(int s,int x1,int y1,int x2,int y2)
{
	for(int i = x1;i<=x2;i++)
		for(int j = y1;j<= y2;j++)
			d[getid(i,j)] = INF;
	Q.push(s);d[s] = 0;vis[s] =true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] =false;
		for(int i = head[x];i;i=e[i].next)
		{
			int no = e[i].to;
			int u = (no-1)/m+1,v = (no-1)%m+1;
			if(u<=x2&&u>=x1&&v<=y2&&v>=y1&&d[no]>d[x]+e[i].val)
			{
				d[no] =d[x]+e[i].val;
				if(!vis[no])
					Q.push(no);
			}
		}
	}
}*/
void solve(int x1,int y1,int x2,int y2,int l,int r)
{
	int i,j,k;
	int mid;
	if(l>r)return ;
	if(x2-x1>y2-y1)
	{
		mid = (x1+x2)>>1;
		for(i = y1;i<= y2;i++)
		{
			dijk(getid(mid,i),x1,y1,x2,y2);
			for(j = l;j<= r;j++)
				ans[a[j].id] = min(ans[a[j].id],d[getid(a[j].x1,a[j].y1)]+d[getid(a[j].x2,a[j].y2)]);
		}
		j = l-1,k = r+1;
		for(i = l;i<= r;i++)
			if(a[i].x1<mid&&a[i].x2<mid)b[++j]=a[i];
			else if(a[i].x1>mid&&a[i].x2>mid)b[--k]=a[i];
		for(i = l;i<= j;i++)a[i]=b[i];solve(x1,y1,mid-1,y2,l,j);
		for(i = r;i>= k;i--)a[i]=b[i];solve(mid+1,y1,x2,y2,k,r);
	}else
	{
		mid = (y1+y2)>>1;
		for(i = x1;i<= x2;i++)
		{
			dijk(getid(i,mid),x1,y1,x2,y2);
			for(j = l;j<= r;j++)
				ans[a[j].id] = min(ans[a[j].id],d[getid(a[j].x1,a[j].y1)]+d[getid(a[j].x2,a[j].y2)]);
		}
		j = l-1,k = r+1;
		for(i = l;i<= r;i++)
			if(a[i].y1<mid&&a[i].y2<mid)b[++j]=a[i];
			else if(a[i].y1>mid&&a[i].y2>mid)b[--k]=a[i];
		for(i = l;i<= j;i++)a[i]=b[i];solve(x1,y1,x2,mid-1,l,j);
		for(i = r;i>= k;i--)a[i]=b[i];solve(x1,mid+1,x2,y2,k,r);
	}
}
int main()
{
	//freopen("ex_tourist3.in","r",stdin);
	memset(ans,0x3f,sizeof(ans));
	int q,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),getid(i,j+1),x);
			add(getid(i,j+1),getid(i,j),x);
		}
	for(int i = 1;i< n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),getid(i+1,j),x);
			add(getid(i+1,j),getid(i,j),x);
		}
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d%d",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
		a[i].id = i;
	}
	solve(1,1,n,m,1,q);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4472

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct data
{
	int val,x;
	data(){}
	data(int val,int x):val(val),x(x){}
	bool operator <(const data &a)const
	{
		return val>a.val;
	}
}stack[N];
int f[N],n;
bool can[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,top,lim[N],val[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	top = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			stack[++top] = data(f[e[i].to],e[i].to);
	sort(stack+1,stack+top+1);
	int i;
	for(i = 1;i<= top;i++)
	{
		if(stack[i].val<0||i==lim[x])break;
		f[x]+=stack[i].val;
		if(can[stack[i].x])can[x] = true;
		if(stack[i].val==0)can[x] = true;
	}
	if(i<lim[x]&&i<=top&&i!=0&&stack[i].val==stack[i-1].val)
		can[x] = true;
	f[x]+=val[x];
}
int main()
{
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
		scanf("%d",&val[i]);
	for(int i = 2;i<= n;i++)
		scanf("%d",&lim[i]);
	lim[1] = 10*n;
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	printf("%d\n",f[1]);
	if(!can[1])printf("solution is unique\n");
	else printf("solution is not unique\n");
	return 0;
}
Problem4484

#include <stdio.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 1e5+5;
bitset<N>bit[N];
struct E
{int next,to;}e[M];
struct data
{
	int en,v;
	bool operator <(const data &a)const
	{
		return v>a.v;
	}
}a[N];
int head[N],tot,d[N],n,m,len[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	d[y]++;
}
int q[N],s,t,ans=0;
void getans()
{
	s = 1,t = 0;
	for(int i = 1;i<= n;i++)
		if(!d[i])
			q[++t] = i;
	while(s<=t)
	{
		int x = q[s++];
		for(int i = head[x];i;i=e[i].next)
			if(!(--d[e[i].to]))
				q[++t] = e[i].to;
	}
	int num;
	for(int i = t;i>= 1;i--)
	{
		int x = q[i];
		bit[x][x] = 1,num = 0,len[x] = 1;
		for(int j = head[x];j;j=e[j].next)
		{
			a[++num] = (data){e[j].to,len[e[j].to]};
			len[x] = max(len[x],len[e[j].to]+1);
		}
		sort(a+1,a+num+1);
		for(int j = 1;j<= num;j++)
		{
			int y = a[j].en;
			if(bit[x][y])ans++;
			bit[x]|=bit[y];
		}
	}	
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	getans();
	printf("%d\n",ans);
	return 0;
}
Problem4485

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot = 1,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].f = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].f = f;head[y] = tot;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
inline int getid(int x,int y)
{
	return (x-1)*m+y;
}
int main()
{
	int d,sum = 0;
	scanf("%d%d",&n,&m);
	int S = 0,T = n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&d);
			if(d>0)add(S,getid(i,j),d),sum+=d;
			else add(getid(i,j),T,-d),sum+=-d;
		}
	for(int i = 1;i<n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&d);
			add(getid(i,j),getid(i+1,j),d);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<m;j++)
		{
			scanf("%d",&d);
			add(getid(i,j),getid(i,j+1),d);
		}
	printf("%d\n",sum-dinic(S,T));
	return 0;
}
Problem4487

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 405;
int c[N][N];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void init()
{
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
}
int main()
{
	int n,m,p;
	ll ans = 0;
	init();
	scanf("%d%d%d",&n,&m,&p);
	for(int i = 0;i<= n;i++)
		for(int k = 0;k<= p;k++)
		{
			ans+=(ll)c[n][i]*c[p][k]%mod*((n+m+p-i-k)%2?-1:1)*quick_pow(1-quick_pow(k+1,i),m)%mod;
			ans=(ans%mod+mod)%mod;
		}
	printf("%lld\n",ans);
	return 0;
}
Problem4488

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	ll num;int pos;
	bool operator <(const data &a)const
	{
		if(num==a.num)return pos<a.pos;
		return num<a.num;
	}
};
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	else return gcd(y,x%y);
}
data tmp,f[2][N];
ll a[N];
int main()
{
	int n;
	ll ans = 0;
	scanf("%d",&n);
	int now = 1,pre = 0;
	int cntn = 0,cntp = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&a[i]);
		for(int j = 1;j <= cntp;j++)
			f[pre][j].num = gcd(f[pre][j].num,a[i]);
		tmp.num = a[i];
		tmp.pos = i;
		cntp++;
		f[pre][cntp] = tmp;
		sort(f[pre]+1,f[pre]+cntp+1);
		cntn = 0;
		for(int j = 1;j<= cntp;j++)
			if(f[pre][j].num!=f[pre][j-1].num)
				f[now][++cntn] = f[pre][j];
		for(int j = 1;j<= cntn;j++)
			ans = max(ans,f[now][j].num*(i-f[now][j].pos+1));
		swap(now,pre);
		cntp = cntn;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4503

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
const double pi = 3.14159265358979323;
#define N 300005
using namespace std;

struct cpx{ double r,i; }a[N],b[N],c[N]; int n1,n2,m,f[N],g[N],pos[N];
char s1[N],s2[N];
cpx operator +(cpx x,cpx y){ x.r+=y.r; x.i+=y.i; return x; }
cpx operator -(cpx x,cpx y){ x.r-=y.r; x.i-=y.i; return x; }
cpx operator *(cpx x,cpx y){
	cpx t; t.r=x.r*y.r-x.i*y.i; t.i=x.r*y.i+x.i*y.r; return t;
}
void dft(cpx *a,int flag){
	int i,j,k; cpx w,wn,u,v;
	if (flag>0) for (i=0; i<m; i++) a[i].i=0;
	for (k=1; k<m; k<<=1){
		wn.r=cos(pi*flag/k); wn.i=sin(pi*flag/k);
		for (i=0; i<m; i+=(k<<1)){
			w.r=1; w.i=0;
			for (j=i; j<i+k; j++){
				u=a[j]; v=a[j+k]*w;
				a[j]=u+v; a[j+k]=u-v; w=w*wn;
			}
		}
	}
	if (flag<0) for (i=0; i<m; i++) a[i].r/=m;
}
int main(){
	scanf("%s%s",s1+1,s2+1); int i,j,k,cnt=0;
	n1=strlen(s1+1); n2=strlen(s2+1);
	for (i=1; i<=n1; i++) f[i]=s1[i]-'a'+1;
	for (i=1; i<=n2; i++) g[n2-i+1]=(s2[i]=='?')?0:s2[i]-'a'+1;
	m=n1+n2+1;
	for (i=1; i<m; i<<=1) cnt++; m=i;
	for (i=0; i<m; i++)
		for (k=i,j=1; j<=cnt; j++,k>>=1) pos[i]=pos[i]<<1|(k&1);
	for (i=0; i<m; i++){ a[pos[i]].r=f[i]*f[i]; b[pos[i]].r=g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=a[i]*b[i];
	for (i=0; i<m; i++){ a[pos[i]].r=1;  b[pos[i]].r=g[i]*g[i]*g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=c[pos[i]]+a[i]*b[i];
	for (i=0; i<m; i++){ a[pos[i]].r=f[i]*2; b[pos[i]].r=g[i]*g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=c[pos[i]]-a[i]*b[i];
	dft(c,-1); cnt=0;/*
	for(int i = 0;i<m;i++)
		printf("%.2f ",c[i].r);*/
	for (i=1; i<=n1-n2+1; i++) if (c[i+n2].r<0.5) f[++cnt]=i;
	printf("%d\n",cnt);
	for (i=1; i<=cnt; i++) printf("%d\n",f[i]-1);
	return 0;
}
Problem4511

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int pre[7];
int main()
{
	int sum = 0;
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		(sum+=x)%=7;
		if(pre[sum])ans = max(ans,i-pre[sum]);
		else pre[sum] = i;
	}
	printf("%d\n",ans);
	return 0;
}
Problem4512

#include <stdio.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2050;
bitset<N>r[N],u[N],v[N];
char s[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	int x =1024,y = 1024,ans = 0;
	for(int i = 1;i<= n;i++)
	{
		v[x][y] = true;
		if(s[i]=='E')
		{
			x++;
			if(!r[x-1][y]&&v[x][y])
				ans++;
			r[x-1][y] = true;
		}else if(s[i]=='W')
		{
			x--;
			if(!r[x][y]&&v[x][y])
				ans++;
			r[x][y] = true;
		}else if(s[i]=='N')
		{
			y--;
			if(!u[x][y]&&v[x][y])
				ans++;
			u[x][y] = true;
		}else
		{
			y++;
			if(!u[x][y-1]&&v[x][y])
				ans++;
			u[x][y-1] = true;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem4513

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll pow2[64];
ll f[100][2][2][2],g[100][2][2][2];
ll mod;
void work()
{
	ll N,M,K;
	scanf("%lld%lld%lld%lld",&N,&M,&K,&mod);
	N--,M--;
	ll ans = 0;
	memset(f,0,sizeof(f));
	memset(g,0,sizeof(g));
	f[0][1][1][1] = 1;
	for(int i=0;i<=63;i++)
		for(int a=0;a<2;a++)
		for(int b=0;b<2;b++)
		for(int c=0;c<2;c++)
			if(f[i][a][b][c])
			{
				int p = ((N&pow2[63-i])==0)?0:1;
				int q = ((M&pow2[63-i])==0)?0:1;
				int t = ((K&pow2[63-i])==0)?0:1;
				for(int x = 0;x<2;x++)
				{
					if(a&&x>p)continue;
					for(int y = 0;y<2;y++)
					{
						if(b&&y>q)continue;
						int z = x^y;
						if(c&&z<t)continue;
						int A = (a&&x==p);
						int B = (b&&y==q);
						int C = (c&&z==t);
						(f[i+1][A][B][C]+=f[i][a][b][c])%=mod;
						g[i+1][A][B][C]=(g[i+1][A][B][C]+g[i][a][b][c]+((z==0)?0:pow2[63-i]%mod)*f[i][a][b][c]%mod)%mod;
					}
				}
			}
	K%=mod;
	for(int a=0;a<2;a++)
		for(int b=0;b<2;b++)
			for(int c=0;c<2;c++)
		    	ans=(ans+g[64][a][b][c]-K*f[64][a][b][c]%mod+mod)%mod;
	printf("%lld\n",ans);
}
int main()
{
	pow2[0] = 1;
	for(int i = 1;i<64;i++)
		pow2[i] = pow2[i-1]*2;
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem4514

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll INF = 1e18;
const int N = 305;
const int M = N*N+10*N;
const int maxX = 1e5+5;
int prime[maxX],cnt;
bool vis[maxX];
struct E
{
	int next,to,from;
	ll c,f;
}e[M];
int head[N],tot = 1,from[N];
void add(int x,int y,ll f,ll c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;e[tot].c = c;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;e[tot].c = -c;
	e[tot].from = y,e[tot-1].from = x;
}
queue<int>Q;
bool v[N];
ll dis[N],rl[N];
void spfa(int S,int T)
{
	for(int i = S;i<= T;i++)dis[i] = -INF;
	Q.push(S);
	dis[S] = 0,vis[S] = true;
	rl[S] = INF;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[x]+e[i].c>dis[e[i].to])
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				rl[e[i].to] = min(rl[x],e[i].f);
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
}
void init()
{
	for(int i = 2;i<maxX;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<maxX;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int a[N],b[N],c[N],f[N];
int main()
{
	init();
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		ll tmp = a[i];
		for(int j = 1;(ll)prime[j]*prime[j]<=(ll)tmp;j++)
			while(tmp%prime[j]==0)f[i]++,tmp/=prime[j];
		if(tmp!=1&&tmp!=-1)f[i]++;
	}
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
	for(int i = 1;i<= n;i++)
		if(f[i]&1)
			for(int j = 1;j<= n;j++)
				if(f[j]==f[i]-1&&a[i]%a[j]==0||f[j]==f[i]+1&&a[j]%a[i]==0)
					add(i,j,INF,(ll)c[i]*c[j]);
	int S = 0,T = n+1;
	for(int i = 1;i<= n;i++)
		if(f[i]&1)
			add(S,i,b[i],0);
		else add(i,T,b[i],0);
	ll now = 0,ans = 0;
	ll tmp = 0;
	while(true)
	{
		spfa(S,T);
		if(dis[T]==-INF||now+dis[T]<0)break;
		if(dis[T]>=0)tmp = rl[T];
		else tmp = min(rl[T],now/(-dis[T]));
		ans+=tmp;
		now+=dis[T]*tmp;
		for(int i = from[T];i;i=from[e[i].from])
			e[i].f-=tmp,e[i^1].f+=tmp;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4515

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long ll;
const ll INF = 123456789123456789ll;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
int dep[N],top[N],size[N],son[N],fa[N],n,m;
ll dis[N];
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dis[e[i].to] = dis[x]+e[i].val;
			dfs1(e[i].to);
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
			size[x]+=size[e[i].to];
		}
}
int dfn[N],seq[N],Dfn;
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct Seg
{ll a,b,mn;}tr[N<<2];
void build(int p,int l,int r)
{
	tr[p].a=0,tr[p].b=INF,tr[p].mn = INF;
	if(l==r)return;
	int mid = (l+r)>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
}
ll calc(ll a,ll b,ll x)
{
	return a*dis[seq[x]]+b;
}
void Update(int p,int l,int r,ll a,ll b)
{
	ll xl = calc(tr[p].a,tr[p].b,l);
	ll xr = calc(tr[p].a,tr[p].b,r);
	ll yl = calc(a,b,l),yr = calc(a,b,r);
	if(xl<=yl&&xr<=yr)return ;
	if(xl>=yl&&xr>=yr){tr[p].a=a,tr[p].b=b;return ;}
	int mid = (l+r)>>1;
	ll xm = calc(tr[p].a,tr[p].b,mid);
	ll ym = calc(a,b,mid);
	if(xm>=ym)
	{
		swap(a,tr[p].a),swap(b,tr[p].b);
		swap(xl,yl),swap(xr,yr),swap(xm,ym);
	}
	if(xl>=yl)Update(p<<1,l,mid,a,b);
	else Update(p<<1|1,mid+1,r,a,b);
}
void update(int p,int l,int r,int a,int b,ll A,ll B)
{
	tr[p].mn = min(tr[p].mn,min(calc(A,B,a),calc(A,B,b)));
	if(l>=a&&r<=b){Update(p,l,r,A,B);return ;}
	int mid = (l+r)>>1;
	if(b<=mid)update(p<<1,l,mid,a,b,A,B);
	else if(a >mid)update(p<<1|1,mid+1,r,a,b,A,B);
	else update(p<<1,l,mid,a,mid,A,B),update(p<<1|1,mid+1,r,mid+1,b,A,B);
}
ll ans;
void getans(int p,int l,int r,int a,int b)
{
	ans = min(ans,min(calc(tr[p].a,tr[p].b,a),calc(tr[p].a,tr[p].b,b)));
	if(l>=a&&r<=b){ans = min(ans,tr[p].mn);return ;}
	int mid = (l+r)>>1;
	if(b<=mid)getans(p<<1,l,mid,a,b);
	else if(a >mid)getans(p<<1|1,mid+1,r,a,b);
	else getans(p<<1,l,mid,a,mid),getans(p<<1|1,mid+1,r,mid+1,b);
	return ;
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
void update(int f,int x,ll a,ll b)
{
	while(top[x]!=top[f])
	{
		update(1,1,n,dfn[top[x]],dfn[x],a,b);
		x = fa[top[x]];
	}
	update(1,1,n,dfn[f],dfn[x],a,b);
}
void getans(int f,int x)
{
	while(top[x]!=top[f])
	{
		getans(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	getans(1,1,n,dfn[f],dfn[x]);
}
int main()
{
	int x,y;
	ll z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%lld",&x,&y,&z);
		add(x,y,z);
	}
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	int opt;
	while(m--)
	{
		scanf("%d%d%d",&opt,&x,&y);
		if(opt==1)
		{
			ll a,b;
			scanf("%lld%lld",&a,&b);
			int lca = getlca(x,y);
			update(lca,x,-a,a*dis[x]+b);
			update(lca,y,a,a*(dis[x]-dis[lca]*2)+b);
		}else
		{
			int lca = getlca(x,y);
			ans = INF;
			getans(lca,x);
			getans(lca,y);
			printf("%lld\n",ans);
		}
	}
	return 0;
}
Problem4516

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct SAM
{
	map<int,int>trs[N];
	int fa[N],len[N];
	int cnt,last;
	long long ans;
	void init(){cnt = last = 1,ans = 0;}
	void insert(int x)
	{
		int p = last,newp = ++cnt,q,newq;
		last = newp,len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)fa[newp] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[newp] = q;
			else
			{
				fa[newq=++cnt]=fa[q];
				len[newq] = len[p]+1;
				trs[newq] = trs[q];
				fa[newp] = fa[q] = newq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=newq;
			}
		}
		ans+=len[newp]-len[fa[newp]];
	}
}sam;
int d[N];
int main()
{
	int n;
	scanf("%d",&n);
	sam.init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&d[i]);
		sam.insert(d[i]);
		printf("%lld\n",sam.ans);
	}
	return 0;
}
Problem4519

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 900;
const int M = 9000;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M<<1];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f=f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f=f;
}
int d[N],n;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t]=0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(mx,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
bool vis[N];
int ans[N][N],a[N],b[N];
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!vis[e[i].to])
			dfs(e[i].to);
}
void reset()
{
	for(int i = 2;i<= tot;i+=2)
		e[i].f=e[i^1].f=(e[i].f+e[i^1].f)>>1;
}
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(vis,0,sizeof(vis));
	dfs(s);
	for(int i = 1;i<= n;i++)
		if(vis[i])
			for(int j = 1;j<= n;j++)
				if(!vis[j])
					ans[i][j]=ans[j][i]=min(ans[i][j],tmp);
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(vis[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)
		a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
int q[N*N],cnt;
int main()
{
	memset(ans,0x3f,sizeof(ans));
	int m,u,v,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	for(int i = 1;i<= n;i++)a[i]=i;
	solve(1,n);
	cnt = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			q[++cnt]=ans[i][j];
	sort(q+1,q+cnt+1);
	cnt = unique(q+1,q+cnt+1)-q-1;
	printf("%d\n",cnt);
	return 0;
}
Problem4521

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;

ll f[20][2][10][10][4][2];
ll pow10[20];
int sta(int a,int b)
{
	return ((a==8||b==8)<<1)|((a==4||b==4));
}
ll dp(ll x)
{
	if(x<pow10[10])return 0;
	int s[20]={};
	int cnt = 0;
	while(x){s[11-cnt]=x%10;x/=10;cnt++;}
	memset(f,0,sizeof(f));
	int ap = sta(s[1],s[2]),fg = 0;
	f[2][0][s[1]][s[2]][ap][0]=1;
	for(int i = 1;i<= s[1];i++)
		for(int j = 0;j<= 9;j++)
		{
			if(i==s[1]&&j>=s[2])continue;
			f[2][1][i][j][sta(i,j)][0]=1;
		}
	for(int i = 3;i<= 11;i++)
	{
		ap|=sta(s[i],s[i]),fg|=(s[i]==s[i-1]&&s[i-1]==s[i-2]);
		if(ap!=3)f[i][0][s[i-1]][s[i]][ap][fg] = 1;
		for(int j = 0;j<= 9;j++)
		for(int k = 0;k<= 9;k++)
		for(int a = 0;a<= 2;a++)
			for(int b = 0;b<= 9;b++)
			{	
				int t1 = a|sta(b,b),t2 = j==k&&k==b;
				if(t1==3)continue;
				f[i][1][k][b][t1][1]+=(b<s[i])*f[i-1][0][j][k][a][1]+f[i-1][1][j][k][a][1];
				f[i][1][k][b][t1][t2]+=(b<s[i])*f[i-1][0][j][k][a][0]+f[i-1][1][j][k][a][0];
			}
	}
	ll ans = 0;
	for(int i = 0;i<= 9;i++)for(int j = 0;j<= 9;j++)
	for(int a = 0;a<= 2;a++)for(int b = 0;b<= 1;b++)
		ans+=f[11][b][i][j][a][1];
	return ans;
}

int main()
{
	ll l,r;
	scanf("%lld%lld",&l,&r);
	pow10[0]=1;
	for(int i = 1;i<= 11;i++)pow10[i]=pow10[i-1]*10;
	printf("%lld\n",dp(r)-dp(l-1));
	return 0;
}
Problem4522

#include<cstdio>
#include<algorithm>
#include<cmath>
#define fo(i,a,b) for(i=a;i<=b;i++)
using namespace std;
typedef long long ll;
ll e,d,n,nn,r,c,a,xx,yy,t,p,q,mod;
void gcd(ll a,ll b)
{
    if (!b)
    {
        xx=1;
        yy=0;
        t=a;
    }
    else
    {
        gcd(b,a%b);
        swap(xx,yy);
        yy-=xx*(a/b);
    }
}
ll getny(ll x,ll y)
{
    gcd(x,y);
    xx=(xx%y+y)%y;
    return xx;
}
int rand() 
{
    static int rand_seed=1542071823;
    rand_seed+=rand_seed<<1|1;
    return rand_seed;
}
ll quick_plus(ll x,ll y)
{
    if (!y) return 0;
    ll t=quick_plus(x,y/2);
    t=(t+t)%mod;
    if (y%2) t=(t+x)%mod;
    return t;
}
ll quick_pow(ll x,ll y)
{
    if (!y) return 1;
    ll t=quick_pow(x,y/2);
    t=quick_plus(t,t);
    if (y%2) t=quick_plus(t,x);
    return t;
}
ll f(ll x)
{
    return (quick_plus(x,x)+a)%mod;
}
ll pollard_rho(ll n)
{
    ll r1,r2,p;
    while (1)
    {
        a=rand()%100;
        r1=r2=2;
        do{
            r1=f(r1);
            r2=f(f(r2));
            gcd(abs(r2-r1),n);
            p=t;
            if (p>1) return p;
        }while (r1!=r2);
    }
}
int main()
{
    scanf("%lld%lld%lld",&e,&n,&c);
    mod=n;
    p=pollard_rho(n);
    q=n/p;
    r=(p-1)*(q-1);
    d=getny(e,r);
    nn=quick_pow(c,d);
    printf("%lld %lld\n",d,nn);
}
Problem4522

#include<cstdio>
#include<algorithm>
#include<cmath>
#define fo(i,a,b) for(i=a;i<=b;i++)
using namespace std;
typedef long long ll;
ll e,d,n,nn,r,c,a,xx,yy,t,p,q,mod;
void gcd(ll a,ll b)
{
    if (!b)
    {
        xx=1;
        yy=0;
        t=a;
    }
    else
    {
        gcd(b,a%b);
        swap(xx,yy);
        yy-=xx*(a/b);
    }
}
ll getny(ll x,ll y)
{
    gcd(x,y);
    xx=(xx%y+y)%y;
    return xx;
}
int rand() 
{
    static int rand_seed=1e9+7;
    rand_seed+=rand_seed<<1|1;
    return rand_seed;
}
ll quick_plus(ll x,ll y)
{
    if (!y) return 0;
    ll t=quick_plus(x,y/2);
    t=(t+t)%mod;
    if (y%2) t=(t+x)%mod;
    return t;
}
ll quick_pow(ll x,ll y)
{
    if (!y) return 1;
    ll t=quick_pow(x,y/2);
    t=quick_plus(t,t);
    if (y%2) t=quick_plus(t,x);
    return t;
}
ll f(ll x)
{
    return (quick_plus(x,x)+a)%mod;
}
ll pollard_rho(ll n)
{
    ll r1,r2,p;
    while (1)
    {
        a=rand()%100;
        r1=r2=2;
        do{
            r1=f(r1);
            r2=f(f(r2));
            gcd(abs(r2-r1),n);
            p=t;
            if (p>1) return p;
        }while (r1!=r2);
    }
}
int main()
{
    scanf("%lld%lld%lld",&e,&n,&c);
    mod=n;
    p=pollard_rho(n);
    q=n/p;
    r=(p-1)*(q-1);
    d=getny(e,r);
    nn=quick_pow(c,d);
    printf("%lld %lld\n",d,nn);
}
Problem4524

#include <stdio.h>
#include <set>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 18000000+5;
struct Heap
{
	int ls,rs;
	int dis;ll key,mul;
}tr[N];
int tot;
ll n;int E;
ll quick_pow(ll x,ll y)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res=res*x;
		x = x*x;
		y>>=1;
	}
	return res;
}
int newnode(int x)
{
	if(!x)return 0;
	int t = ++tot;
	tr[t] = tr[x];
	return t;
}
int multi(int x,ll y)
{
	int t = newnode(x);
	tr[t].mul*=y,tr[t].key*=y;
	return t;
}
void Push_down(int x)
{
	if(tr[x].mul>1)
	{
		tr[x].ls = multi(tr[x].ls,tr[x].mul);
		tr[x].rs = multi(tr[x].rs,tr[x].mul);
		tr[x].mul = 1;
	}
}
int merge(int x,int y)
{
	if(!x)return newnode(y);
	if(!y)return newnode(x);
	Push_down(x),Push_down(y);
	if(tr[x].key<tr[y].key)swap(x,y);
	int t = newnode(x);
	tr[t].rs = merge(tr[x].rs,y);
	if(tr[tr[t].rs].dis>tr[tr[t].ls].dis)
		swap(tr[t].ls,tr[t].rs);
	tr[t].dis = tr[tr[t].rs].dis+1;
	return t;
}
int pop(int x)
{
	Push_down(x);
	return merge(tr[x].ls,tr[x].rs);
}
struct Int
{
	int id;
	Int(int _id):id(_id){}
	bool operator <(const Int &s)const
	{
		return tr[id].key>tr[s.id].key||tr[id].key==tr[s.id].key&&id<s.id;
	}
};
multiset<Int>ans;
int prime[200],cnt;
bool vis[200];
int f[200][100],g[200][200];
void get_prime()
{
	for(int i = 2;i<= 127&&i<= n;i++)
	{
		if(!vis[i])prime[++cnt]=i;
		for(int j = 1;j<=cnt&&i*prime[j]<=127;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	scanf("%lld%d",&n,&E);
	get_prime();
	f[0][0]=g[0][0]=1;
	tr[1].dis = tr[1].key = tr[1].mul = tot = 1;
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = 1;j<= (int)floor(log(n)/log(prime[i]));j++)
		{
			for(int k = 1;k<= j;k++)
			{
				int t = multi(g[i-1][j-k],quick_pow(prime[i],k));
				f[i][j] =merge(f[i][j],t);
			}
			ans.insert(Int(f[i][j]));
			g[i][j] = merge(g[i-1][j],f[i][j]);
		}
		g[i][0]=g[i-1][0];
	}
	E--;
	while(E--)
	{
		int t = (*ans.begin()).id;
		ans.erase(ans.begin());
		ans.insert(Int(merge(tr[t].ls,tr[t].rs)));
	}
	printf("%lld\n",tr[(*ans.begin()).id].key);
	return 0;
}
Problem4525

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int pos[N],n,k;
bool check(int x)
{
	int last = 1,ans = 0;
	for(int i= 1;i<= n;i++)
		if(pos[i]-pos[last]>x)
			ans++,last = i;
	ans++;
	return ans<=k;
}
int main()
{		
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&pos[i]);
	sort(pos+1,pos+n+1);
	int l = 0,r = pos[n]+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(2*mid))r = mid;
		else l = mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem4530

#include <bits/stdc++.h>
#define N 100005
typedef long long ll;
using namespace std;
int n,q,ans,tot,num;
struct Link_Cut_Tree
{
    int c[N][2],fa[N],size1[N],size2[N],q[N],top;
    bool rev[N];
    inline void pushup(int x)
    {
        int l=c[x][0],r=c[x][1];
        size1[x]=size1[l]+size1[r]+size2[x];
    }
    inline bool isroot(int x)
    {return c[fa[x]][1]!=x&&c[fa[x]][0]!=x;}
    inline void pushdown(int x)
    {
        int l=c[x][0],r=c[x][1];
        if(rev[x])
        {
            rev[l]^=1;rev[r]^=1;rev[x]^=1;
            swap(c[x][0],c[x][1]);
        }
    }
    inline void rotate(int x)
    {
        int y=fa[x],z=fa[y],l,r;
        if(c[y][0]==x)l=0;else l=1;r=l^1;
        if(!isroot(y)){if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
        fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
        c[y][l]=c[x][r];c[x][r]=y;
        pushup(y);pushup(x);
    }
    inline void splay(int x)
    {
        top=1;q[top]=x;
        for(int i=x;!isroot(i);i=fa[i])q[++top]=fa[i];
        for(int i=top;i;i--)pushdown(q[i]);
        while(!isroot(x))
        {
            int y=fa[x],z=fa[y];
            if(!isroot(y))
            {
                if((c[z][0]==y)^(c[y][0]==x))rotate(x);
                else rotate(y);
            }
            rotate(x);
        }
        pushup(x);
    }
    void access(int x)
    {
        for(int t=0;x;t=x,x=fa[x])
        {
            splay(x);size2[x]+=size1[c[x][1]];
            c[x][1]=t;size2[x]-=size1[t];pushup(x);
        }
    }
    void makeroot(int x){access(x);splay(x);rev[x]^=1;}
    int find(int x){access(x);splay(x);while(c[x][0])x=c[x][0];return x;}
    void split(int x,int y){makeroot(x);access(y);splay(y);}
    void link(int x,int y)
    {
        makeroot(x);makeroot(y);fa[x]=y;size2[y]+=size1[x];
        pushup(y);
    }
    void cut(int x,int y){split(x,y);if(c[y][0]==x)c[y][0]=0,fa[x]=0;}
    void init(int n)
    {
        for(int i=1;i<=n;i++)size1[i]=size2[i]=1;
    }
}T;
int main()
{
    scanf("%d%d",&n,&q);
    T.init(n);char s[10];
    while(q--)
    {
        scanf("%s",s);
        int x,y;
        scanf("%d%d",&x,&y);
        if(s[0]=='A')T.link(x,y);
        else
        {
            T.makeroot(x);T.access(y);T.splay(x);
            printf("%lld\n",(ll)((T.size2[y])*(T.size1[x]-T.size2[y])));
        }
    }
    return 0;
}
Problem4537

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 1e5+5;
const int Q = 5e4+5;
struct E
{
	int x,y,a,b,id;
	void read(int no)
	{
		scanf("%d%d%d%d",&x,&y,&a,&b);
		id = no;
	}
	bool operator <(const E &s)const
	{
		if(a==s.a)return b<s.b;
		return a<s.a;
	}
}e[M],ask[Q],tmp[Q];
struct Opt
{
	int x,y,fa,mxa,mxb,sz;
}opt[Q];
bool cmp(const E &x,const E &y)
{
	if(x.b==y.b)return x.a<y.a;
	return x.b<y.b;
}
int tot,top;
int fa[N],size[N],mxa[Q],mxb[Q],ans[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return getfa(fa[x]);
}
void merge(int x,int y,int a,int b)
{
	x = getfa(x),y = getfa(y);
	if(size[x]>size[y])swap(x,y);
	opt[++tot].x = x,opt[tot].mxa = mxa[y],opt[tot].mxb = mxb[y];
	opt[tot].y = y,opt[tot].fa = fa[x],opt[tot].sz = size[y];
	if(x==y)
	{
		mxa[x] = max(mxa[x],a);
		mxb[x] = max(mxb[x],b);
		return ;
	}
	fa[x] = y,size[y]+=size[x];
	mxa[y] = max(mxa[y],max(mxa[x],a));
	mxb[y] = max(mxb[y],max(mxb[x],b));
}
void go_back()
{
	while(tot)
	{
		fa[opt[tot].x] = opt[tot].fa;
		mxa[opt[tot].y] = opt[tot].mxa;
		mxb[opt[tot].y] = opt[tot].mxb;
		size[opt[tot].y] = opt[tot].sz;
		tot--;
	}
}
int main()
{
	int n,m,q;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		e[i].read(i);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
		ask[i].read(i);
	sort(e+1,e+m+1);
	sort(ask+1,ask+q+1,cmp);
	int block = sqrt(m);
	for(int i = 1;i<= m;i+=block)
	{
		top = 0;
		for(int j = 1;j<= q;j++)
			if(ask[j].a>=e[i].a&&(i+block>m||ask[j].a<e[i+block].a))
				tmp[++top] = ask[j];
		sort(e+1,e+i,cmp);
		for(int j = 1;j<= n;j++)fa[j]=j,size[j]=1,mxa[j]=mxb[j]=-1;
		for(int j = 1,k = 1;j<= top;j++)
		{
			for(;k<i&&e[k].b<=tmp[j].b;k++)
				merge(e[k].x,e[k].y,e[k].a,e[k].b);
			tot = 0;
			for(int l = i;l<i+block&&l<=m;l++)
				if(e[l].a<=tmp[j].a&&e[l].b<=tmp[j].b)
					merge(e[l].x,e[l].y,e[l].a,e[l].b);
			int x = getfa(tmp[j].x),y = getfa(tmp[j].y);
			ans[tmp[j].id] = x==y&&mxa[x]==tmp[j].a&&mxb[x]==tmp[j].b;
			go_back();
		}
	}
	for(int i = 1;i<= q;i++)
		if(ans[i])printf("Yes\n");
		else printf("No\n");
	return 0;
}
Problem4538

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,m;

struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;
}
int son[N],size[N],dfn[N],top[N],Dfn,fa[N],dep[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] =dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>=size[son[x]])son[x]=e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}

struct Heap
{
	priority_queue<int>a,b;
	void del(int val){b.push(val);}
	void push(int val){a.push(val);}
	int top()
	{
		while(!b.empty()&&a.top()==b.top()) a.pop(),b.pop();
        if(a.empty()) return -1;
        return a.top();
	}
}t[270005];
void update(int p,int l,int r,int a,int b,int val,bool flag)
{
	if(a>b)return ;
	if(l>=a&&r<=b)
	{
		if(!flag)t[p].push(val);
		else t[p].del(val);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,val,flag);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,val,flag);
}
int getans(int p,int l,int r,int pos)
{
	if(l==r)
		return t[p].top();
	int mid = (l+r)>>1;
	if(pos<=mid)return max(t[p].top(),getans(p<<1,l,mid,pos));
	else return max(t[p].top(),getans(p<<1|1,mid+1,r,pos));
}

vector<pair<int,int> >stack;
void Update(int x,int y,int val,bool flag)
{
	stack.clear();
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		stack.push_back(make_pair(dfn[top[x]],dfn[x]));
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	stack.push_back(make_pair(dfn[y],dfn[x]));
	sort(stack.begin(),stack.end());
	x = 1;
	int sz = stack.size();
	for(int i = 0;i<sz;i++)
	{
		update(1,1,n,x,stack[i].first-1,val,flag);
		x = stack[i].second+1;
	}
	update(1,1,n,x,n,val,flag);
	return ;
}

int X[N<<1],Y[N<<1],Z[N<<1];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&X[0],&Y[0]);
		add(X[0],Y[0]);
	}
	int root = rand()%n+1;
	dfs1(root);
	dfs2(root,root);
	int tp;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&tp);
		if(tp==0)
		{
			scanf("%d%d%d",&X[i],&Y[i],&Z[i]);
			Update(X[i],Y[i],Z[i],(bool)tp);
		}else if(tp==1)
		{
			scanf("%d",&X[i]);
			Update(X[X[i]],Y[X[i]],Z[X[i]],(bool)tp);
		}else
		{
			scanf("%d",&X[i]);
			printf("%d\n",getans(1,1,n,dfn[X[i]]));
		}
	}
	return 0;
}
Problem4539

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int maxn = 2e5+5;
const int M = 2e6+5;
ll N;
int idx,n,m,q,root[maxn],from[maxn];
namespace seg
{
	int sz[M],ls[M],rs[M],root[maxn],tot;
	void Insert(int &p,int pre,int l,int r,int v)
	{
		p = ++tot;
		sz[p] = sz[pre]+1;
		if(l==r)return ;
		int mid = (l+r)>>1;
		ls[p] = ls[pre],rs[p] = rs[pre];
		if(v<=mid)Insert(ls[p],ls[pre],l,mid,v);
		else Insert(rs[p],rs[pre],mid+1,r,v);
	}
	void insert(int idx,int x)
	{
		Insert(root[idx],root[idx-1],1,n,x);
	}
	int calc(int x,int y,int k)
	{
		x = root[x-1],y = root[y];
		int l= 1,r = n;
		while(l<r)
		{
			int mid = (l+r)>>1;
			if(sz[ls[y]]-sz[ls[x]]>=k)r=mid,y = ls[y],x = ls[x];
			else k-=sz[ls[y]]-sz[ls[x]],l=mid+1,y = rs[y],x = rs[x];
		}
		return l;
	}
}
int size[maxn],dfn[maxn],last[maxn];
struct Gragh
{
	struct E
	{int next,to;ll val;}e[maxn<<1];
	int head[maxn],tot;
	void add(int x,int y,ll f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
	}
	int dep[maxn],fa[maxn][18],Dfn;
	ll dis[maxn];
	void dfs1(int x)
	{
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<= 17;i++)
			fa[x][i] = fa[fa[x][i-1]][i-1];
		for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa[x][0])
		{
			dis[e[i].to] = dis[x]+e[i].val;
			fa[e[i].to][0] = x;
			dfs1(e[i].to);
		}
	}
	void dfs2(int x)
	{
		dfn[x] = ++Dfn;
		seg::insert(Dfn,x);
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x][0])
			{
				dfs2(e[i].to);
				size[x] += size[e[i].to];
			}
		last[x] = Dfn;
	}
	int go_up(int x,int d)
	{
		for(int i = 17;i>= 0;i--)
			if((d>>i)&1)x=fa[x][i];
		return x;
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i =17;i>= 0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 17;i>= 0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	ll getdis(int x,int y)
	{
		return dis[x]+dis[y]-dis[getlca(x,y)]*2;
	}
	int find(int x,int v)
	{
		return go_up(x,dep[x]-dep[v]-1);
	}
}G[2];
ll list[maxn];
int getpos(ll x)
{
	return lower_bound(list+1,list+idx+1,x)-list;
}
int main()
{
	ll x,y;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		G[0].add(x,y,1);
	}
	G[0].dfs1(1);
	G[0].dfs2(1);
	N = n,idx = 1;
	root[1] = 1;
	list[1] = N;
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld",&x,&y);
		int t = getpos(y),r=root[t],yy=seg::calc(dfn[r],last[r],y-list[t-1]);
		G[1].add(t,idx+1,G[0].dis[yy]-G[0].dis[r]+1);
		N+=size[x],root[++idx] = x,list[idx] = N,from[idx] = yy;
	}
	G[1].dfs1(1);
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld%lld",&x,&y);
		int tx = getpos(x),rx = root[tx],xx = seg::calc(dfn[rx],last[rx],x-list[tx-1]);
		int ty = getpos(y),ry = root[ty],yy = seg::calc(dfn[ry],last[ry],y-list[ty-1]);
		int lca = G[1].getlca(tx,ty);
		ll ans = G[0].dis[xx]+G[0].dis[yy]-G[0].dis[rx]-G[0].dis[ry]+G[1].getdis(tx,ty);
		if(tx==ty)
		{
			printf("%lld\n",G[0].getdis(xx,yy));
		}else if(tx==lca)
		{
			int fry = from[G[1].find(ty,lca)];
			printf("%lld\n",ans-(G[0].dis[xx]+G[0].dis[fry]-G[0].getdis(xx,fry)-2*G[0].dis[rx]));
		}else if(ty==lca)
		{
			int frx = from[G[1].find(tx,lca)];
			printf("%lld\n",ans-(G[0].dis[yy]+G[0].dis[frx]-G[0].getdis(yy,frx)-2*G[0].dis[ry]));
		}else
		{
			int frx = from[G[1].find(tx,lca)];
			int fry = from[G[1].find(ty,lca)];
			printf("%lld\n",ans-(G[0].dis[frx]+G[0].dis[fry]-G[0].getdis(frx,fry)-2*G[0].dis[root[lca]]));
		}
	}
	return 0;
}
Problem4540

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
int a[N],lg2[N];
int st[N][18],n,q;
int Min(int x,int y)
{
	return a[x]<a[y]?x:y;
}
void build_st()
{
	for(int i = 2;i<= n;i++)
		lg2[i] = lg2[i>>1]+1;
	for(int i = 1;i<= n;i++)
		st[i][0] = i;
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<=n;i++)
		{
			st[i][j] = st[i][j-1];
			if(i+(1<<(j-1))<=n)
				st[i][j] = Min(st[i][j],st[i+(1<<(j-1))][j-1]);
		}
}
int Ask(int l,int r)
{
	if(l>r)swap(l,r);
	int lth = lg2[r-l+1];
	return Min(st[l][lth],st[r-(1<<lth)+1][lth]);
}

ll left[N],right[N];
int stack[N],top;
void init()
{
	stack[top=0]=0;
	for(int i = 1;i<= n;i++)
	{
		while(top&&a[stack[top]]>=a[i])top--;
		right[i] = right[stack[top]]+(ll)a[i]*(i-stack[top]);
		stack[++top] = i;
	}
	stack[top=0]=n+1;
	for(int i = n;i;i--)
	{
		while(top&&a[stack[top]]>=a[i])top--;
		left[i] = left[stack[top]]+(ll)a[i]*(stack[top]-i);
		stack[++top] = i;
	}
}
ll getleft(int l,int r)
{
	int t = Ask(l,r);
	return (ll)a[t]*(r-t+1)+left[l]-left[t];
}
ll getright(int l,int r)
{
	int t = Ask(l,r);
	return (ll)a[t]*(t-l+1)+right[r]-right[t];
}

struct Ask
{
	int l,r,lpos,id;
	bool operator <(const Ask &s)const
	{
		if(lpos==s.lpos)return r<s.r;
		return lpos<s.lpos;
	}
}ask[N];
ll ans;
ll Ans[N];
void solve()
{
	int l = 1,r = 0;
	for(int i = 1;i<= q;i++)
	{
		while(r<ask[i].r)ans+=getright(l,++r);
		while(r>ask[i].r)ans-=getright(l,r--);
		while(l<ask[i].l)ans-=getleft(l++,r);
		while(l>ask[i].l)ans+=getleft(--l,r);
		Ans[ask[i].id] = ans;
	}
}

int main()
{
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	build_st();
	init();
	int block = sqrt(q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].lpos = (ask[i].l-1)/block+1;
		ask[i].id = i;
	}
	sort(ask+1,ask+q+1);
	solve();
	for(int i = 1;i<= q;i++)
		printf("%lld\n",Ans[i]);
	return 0;
}
Problem4541

#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <math.h>
#include <vector>
using namespace std;
const int N=200010;
typedef long long ll;
struct point
{
    int x,y;
    friend ll operator *(const point &a,const point &b)
    {
        return (ll)a.x*b.y-(ll)b.x*a.y;
    }
    friend point operator -(const point &a,const point &b)
    {
        point tmp;
        tmp.x=a.x-b.x; tmp.y=a.y-b.y;
        return tmp;
    }
}p[N];
struct edge
{
    int u,v,id;
    double ang;
    edge(){}
    edge(int a,int b,int k)
    {
        u=a; v=b; id=k;
        ang=atan2((double)p[b].y-p[a].y,(double)p[b].x-p[a].x);
    }
    friend bool operator <(const edge &a,const edge &b)
    {
        return a.ang<b.ang;
    }
}e[6*N];
vector<edge> E[N],TE[N*2];
int Nex[N*6],v[N*6],cnt=1,num,rt;
int vi[N*2],fa[N*2],flag[N*6];
int n,m,k,x,y,rec,q[N];
ll ans1,ans2,P,S[N*2],S1[N*2];

int Find(int x,const edge &a)
{
    int mid,l=0,r=E[x].size();
    while(r-l>1)
    {
        mid=(l+r)>>1;
        if(a<E[x][mid]) r=mid;
        else l=mid;
    }
    return l;
}
ll gcd(ll a,ll b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}
void solve()
{
    int now,tmp,st; ll s;
    for(int i=2;i<=cnt;i++)
    if(!v[i])
    {
        s=0; now=i; v[i]=++num; st=e[i].u;
        while(1)
        {
            tmp=Nex[now]; v[tmp]=num;
            if(e[tmp].v==st) break;
            s+=(p[e[tmp].u]-p[st])*(p[e[tmp].v]-p[st]);
            now=tmp;
        }
        S[num]=s;
        if(s<=0) rt=num;
    }
    for(int i=2;i<=cnt;i++) 
    TE[v[i]].push_back(edge(v[i],v[i^1],i));
}
void dfs(int x)
{
    vi[x]=1; S1[x]=S[x]*S[x]; S[x]*=2;
    for(int i=0;i<(int)TE[x].size();i++)
    if(!vi[TE[x][i].v])
    {
        fa[TE[x][i].v]=x;
        flag[TE[x][i].id]=1;
        flag[TE[x][i].id^1]=1;
        dfs(TE[x][i].v);
        S[x]+=S[TE[x][i].v];
        S1[x]+=S1[TE[x][i].v];
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++) scanf("%d%d",&p[i].x,&p[i].y);
    for(int i=1;i<=m;i++) 
    {
        scanf("%d%d",&x,&y);
        ++cnt; e[cnt]=edge(x,y,cnt);
        E[x].push_back(e[cnt]);
        ++cnt; e[cnt]=edge(y,x,cnt);
        E[y].push_back(e[cnt]);
    }
    for(int i=1;i<=n;i++) sort(E[i].begin(),E[i].end());
    for(int i=2;i<=cnt;i++)
    {
        Nex[i]=Find(e[i].v,e[i^1])-1;
        if(Nex[i]<0) Nex[i]=E[e[i].v].size()-1;
        Nex[i]=E[e[i].v][Nex[i]].id;
    }
    solve(); dfs(rt);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&q[0]);q[0]=(q[0]+P)%n+1;
        for(int j=1;j<=q[0];j++) scanf("%d",&q[j]),q[j]=(q[j]+P)%n+1;
        ans1=ans2=0; q[++q[0]]=q[1];
        for(int j=1;j<q[0];j++)
        {
            x=q[j]; y=q[j+1];
            int tmp=Find(x,edge(x,y,0));
            tmp=E[x][tmp].id;
            if(!flag[tmp]) continue;
            if(v[tmp]==fa[v[tmp^1]]) ans1+=S[v[tmp^1]],ans2+=S1[v[tmp^1]];
            else ans1-=S[v[tmp]],ans2-=S1[v[tmp]];
        }
        if(ans1<0) ans1=-ans1,ans2=-ans2;
        ll d=gcd(ans1,ans2); ans1/=d; ans2/=d;
        printf("%lld %lld\n",P=ans2,ans1);
    }
    return 0;
}
Problem4542

#include <stdio.h>
#include <math.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
struct Ask
{
	int l,r,lpos,id;
	bool operator <(const Ask &s)const
	{
		if(lpos==s.lpos)return r<s.r;
		return lpos<s.lpos;
	}
}ask[N];
ll s[N],cd[N],ba[N],Ans[N];
char str[N];
map<ll,ll>tt;
int main()
{
	ll p;
	int n,m;
	scanf("%lld",&p);
	scanf("%s",str+1);
	scanf("%d",&m);
	n = strlen(str+1);
	if(p!=2&&p!=5)
	{
		ll pow10 = 1;
		for(int i = n;i;i--)
		{
			pow10 = pow10*10%p;
			s[i] = (s[i+1]+(ll)(str[i]-'0')*pow10%p)%p;
			cd[i] = s[i];
		}
		sort(cd+1,cd+n+1);
		for(int i= 1;i<= n+1;i++)
			tt[cd[i]]=i;
		for(int i = 1;i<= n+1;i++)
			s[i] = tt[s[i]];
		int block = sqrt(n);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&ask[i].l,&ask[i].r);
			ask[i].r++;
			ask[i].lpos = ask[i].l/block;
			ask[i].id = i;
		}
		sort(ask+1,ask+m+1);
		ll ans = 0;
		int l = 1,r = 0;
		for(int i = 1;i<= m;i++)
		{
			while(r<ask[i].r)ans+=ba[s[++r]]++;
			while(r>ask[i].r)ans-=--ba[s[r--]];
			while(l<ask[i].l)ans-=--ba[s[l++]];
			while(l>ask[i].l)ans+=ba[s[--l]]++;
			Ans[ask[i].id] = ans;
		}
		for(int i = 1;i<= m;i++)
			printf("%lld\n",Ans[i]);
	}else
	{
		for(int i = 1;i<= n;i++)
		{
			if(!((str[i]-'0')%p))
				ba[i] = ba[i-1]+1,cd[i] = cd[i-1]+i;
			else ba[i] = ba[i-1],cd[i] = cd[i-1];
		}
		for(int i = 1;i<= m;i++)
		{
			int l,r;
			scanf("%d%d",&l,&r);
			printf("%lld\n",cd[r]-cd[l-1]-(ba[r]-ba[l-1])*(l-1));
		}
	}
	return 0;
}
Problem4551

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int mx[N<<2],lazy[N<<2],dep[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,in[N],out[N],Dfn;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	in[x] = ++Dfn;
	dep[x] = dep[fa]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	out[x] = Dfn;
}
inline int merge(int x,int y)
{
	return dep[x]>dep[y]?x:y;
}
inline void Push_down(int p)
{
	if(!lazy[p])return ;
	mx[p<<1] = merge(mx[p<<1],lazy[p]),mx[p<<1|1] = merge(mx[p<<1|1],lazy[p]);
	lazy[p<<1] = merge(lazy[p<<1],lazy[p]),lazy[p<<1|1] = merge(lazy[p<<1|1],lazy[p]);
	lazy[p] = 0;
}
void build(int p,int l,int r)
{
	lazy[p] = 0;
	if(l==r){mx[p]=1;return ;}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);build(p<<1|1,mid+1,r);
	mx[p] = merge(mx[p<<1],mx[p<<1|1]);
}
void update(int p,int l,int r,int a,int b,int id)
{
	if(l>=a&&r<=b)
	{
		mx[p] = merge(mx[p],id);lazy[p] = merge(lazy[p],id);
		return ;
	}
	Push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,id);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,id);
	mx[p] = merge(mx[p<<1],mx[p<<1|1]);
}
int getans(int p,int l,int r,int pos)
{
	if(l==r)return mx[p];
	Push_down(p);
	int mid = (l+r)>>1;
	if(pos<=mid)return getans(p<<1,l,mid,pos);
	else return getans(p<<1|1,mid+1,r,pos);
}
int main()
{
	//freopen("x.in","r",stdin);
	int n,q,x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	build(1,1,n);
	char opt[3];
	while(q--)
	{
		scanf("%s%d",opt,&x);
		if(opt[0]=='Q')printf("%d\n",getans(1,1,n,in[x]));
		else update(1,1,n,in[x],out[x],x);
	}
	return 0;
}
Problem4552

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int sum[N<<2],cov[N<<2];
int a[N];
int MID;
void build(int p,int l,int r)
{
	cov[p] = -1;
	if(l==r)
	{
		sum[p] = a[l]>=MID;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
inline void Push_down(int p,int l,int r)
{
	if(cov[p]==-1)return ;
	int mid = (l+r)>>1;
	if(cov[p]==1)
	{
		sum[p<<1] = mid-l+1;sum[p<<1|1] = r-mid;
		cov[p<<1] = cov[p],cov[p<<1|1] = cov[p];
	}else
	{
		sum[p<<1] = sum[p<<1|1] = cov[p<<1] = cov[p<<1|1] = 0;
	}
	cov[p] = -1;
}
void Update(int p,int l,int r,int a,int b,int v)
{
	if(a>b)return ;
	if(l>=a&&r<=b)
	{
		sum[p] = (r-l+1)*v;
		cov[p] = v;
		return ;
	}
	Push_down(p,l,r);
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,v);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,v);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int Getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	Push_down(p,l,r);
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getsum(p<<1,l,mid,a,b);
	if(b >mid)ans+=Getsum(p<<1|1,mid+1,r,a,b);
	return ans;
}
int opt[N],l[N],r[N];
int n,m,q;
bool check(int mid)
{
	MID = mid;
	build(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		int tmp = Getsum(1,1,n,l[i],r[i]);
		int lth = r[i]-l[i]+1;
		if(!opt[i])
		{
			Update(1,1,n,l[i],l[i]+lth-tmp-1,0);
			Update(1,1,n,l[i]+lth-tmp,r[i],1);
		}else
		{
			Update(1,1,n,l[i],l[i]+tmp-1,1);
			Update(1,1,n,l[i]+tmp,r[i],0);
		}
	}
	return Getsum(1,1,n,q,q)==1;
}
int main()
{
	//freopen("x.in","r",stdin);
	//freopen("x.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&opt[i],&l[i],&r[i]);
	scanf("%d",&q);
	int L = 1,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(check(mid))L = mid+1;
		else R = mid;
	}
	printf("%d\n",L-1);
	return 0;
}
Problem4553

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int MX = 1e5;
const int N = 1e5+5;
const int M = 1e7+5;
int rot[N],ls[M],rs[M],mx[M],tot,f[N],a[N];
void update(int &p,int l,int r,int pos,int val)
{
	if(!p)p = ++tot;
	mx[p] = max(mx[p],val);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],l,mid,pos,val);
	else update(rs[p],mid+1,r,pos,val);
}
int getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(ls[p],l,mid,a,b);
	else if(a>mid)return getans(rs[p],mid+1,r,a,b);
	else return max(getans(ls[p],l,mid,a,b),getans(rs[p],mid+1,r,a,b));
}
void Update(int x,int y)
{
	for(int i = x;i<=MX;i+=i&(-i))
		update(rot[i],1,MX,a[y],f[y]);
}
int Getans(int x,int y)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))
		ans = max(ans,getans(rot[i],1,MX,1,y));
	return ans;
}
int Mx[N],Mn[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),Mx[i]=Mn[i]=a[i];
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		Mx[x] = max(Mx[x],y);Mn[x] = min(Mn[x],y); 
	}
	//for(int i = 1;i<= n;i++)f[i] = 1;
	for(int i = 1;i<= n;i++)
	{
		f[i] = Getans(a[i],Mn[i])+1;
		Update(Mx[i],i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)ans = max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4554

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6005;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[N*10];
int head[N],tot=1;
int d[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
bool bfs(int s,int t)
{
	for(int i = s;i<=t;i++)d[i]=-1;
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int n,m;
char s[55][55];
inline int id(int x,int y)
{
	return (x-1)*m+y;
}
int bl1[N],bl2[N];
int main()
{
	int cnt1=1,cnt2=1;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= m;j++)
			if(s[i][j]=='#')cnt1++;
			else bl1[id(i,j)] = cnt1;
		cnt1++;
	}
	for(int j = 1;j<= m;j++)
	{
		for(int i = 1;i<= n;i++)
			if(s[i][j]=='#')cnt2++;
			else bl2[id(i,j)]=cnt2;
		cnt2++;
	}
	int S =0,T = cnt1+cnt2+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(s[i][j]=='*')add(bl1[id(i,j)],bl2[id(i,j)]+cnt1,1);
	for(int i = 1;i<= cnt1;i++)add(S,i,1);
	for(int i = 1;i<= cnt2;i++)add(i+cnt1,T,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem4555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 261244*2;
const int mod = 998244353;
int quick_pow(int x,int y)
{
    int res = 1;
    while(y)
    {
        if(y&1)res = (ll)res*x%mod;
        x = (ll)x*x%mod;
        y>>=1;
    }
    return res;
}
void NTT(int *a,int len,int type)
{
	//for(int i = 0;i<len;i++)printf("%d ",a[i]);
	//printf("\n");
    int t = 0;
    for(int i = 0;i<len;i++)
    {
        if(t<i)swap(a[t],a[i]);
        for(int j = len>>1;(t^=j)<j;j>>=1);
    }
    for(int i = 2;i<= len;i<<=1)
    {
        int wn = quick_pow(3,(mod-1)/i);
        for(int j = 0;j<len;j+=i)
        {
            int w = 1,tmp;
            for(int k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
            {
                tmp = (ll)a[j+k+(i>>1)]*w%mod;
                a[j+k+(i>>1)] = (a[j+k]-tmp)%mod;
                a[j+k] = (a[j+k]+tmp)%mod;
            }
        }
    }
    if(type==-1)
    {
        for(int i = 1;i<len>>1;i++)swap(a[i],a[len-i]);
        int Inv = quick_pow(len,mod-2);
        for(int i = 0;i<len;i++)
            a[i] = (ll)a[i]*Inv%mod;
    }
	//for(int i = 0;i<len;i++)printf("%d ",a[i]);
	//printf("\n");
}
void conv(int *a,int *b,int *c,int len)
{
    NTT(a,len,1),NTT(b,len,1);
    for(int i = 0;i<len;i++)c[i]=(ll)a[i]*b[i]%mod;
    NTT(c,len,-1);
}
int fac[N],env[N],a[N],b[N],c[N];
int main()
{
    int n,len=1;
    scanf("%d",&n);
    for(;len<=2*n;len<<=1);
    fac[0] = 1;
    for(int i = 1;i<= n;i++)fac[i]=(ll)fac[i-1]*i%mod;
    env[n] = quick_pow(fac[n],mod-2);
    for(int i = n-1;i>=0;i--)env[i] = (ll)env[i+1]*(i+1)%mod;
    for(int i = 0;i<= n;i++)a[i]=i%2?-env[i]:env[i];
    b[0]=1,b[1]=n+1;
    for(int i = 2;i<= n;i++)b[i]=(ll)(quick_pow(i,n+1)-1)*quick_pow(i-1,mod-2)%mod*env[i]%mod;
    conv(a,b,c,len);
    int j = 1,ans=0;
    for(int i = 0;i<=n;i++)
    {
        if(i)j=(ll)j*i%mod;
        ans=(ans+(ll)quick_pow(2,i)*fac[i]%mod*c[i]%mod)%mod;
        ans = (ans+mod)%mod;
    }
    printf("%d\n",(ans%mod+mod)%mod);
    return 0;
}
Problem4556

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 5e6+5;
int ls[M],rs[M],sum[M];
int rot[N],Cnt,n,m;
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++Cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
int getans(int L,int R,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[R]-sum[L];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[L],ls[R],l,mid,a,b);
	if(b >mid)ans+=getans(rs[L],rs[R],mid+1,r,a,b);
	return ans;
}
int sa[N],cnt[N],val[N],rnk[N],h[N],q[N],nv[N];
char s[N];
inline bool is_same(int a,int b,int hl,int len)
{return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[val[i]]] = i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[i]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]] = q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i=j+1;k<=j;k++)nv[sa[k]] = lim;
		}
		if(lim==len)break;
		for(i = 0;i<len;i++)val[i]=nv[i];
	}
}
void build_rank(int len)
{for(int i = 0;i<=len;i++)rnk[sa[i]]=i;}
int mn[N][18];
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]] = j;
		}
}
int lg2[N];
void build_st(int len)
{
	for(int i = 2;i<= len;i++)lg2[i] = lg2[i>>1]+1;
	for(int i = 0;i<=len;i++)mn[i][0] = h[i];
	for(int j = 1;j<= 18;j++)
		for(int i = 0;i+(1<<j)-1<= len;i++)
			mn[i][j] = min(mn[i][j-1],mn[i+(1<<(j-1))][j-1]);
}
int main()
{
	//freopen("x.in","r",stdin);
	scanf("%d%d",&n,&m);
	scanf("%s",s);
	int a,b,c,d;
	build_sa(n+1,256);
	build_rank(n);build_height(n);
	build_st(n);
	for(int i = 1;i<= n;i++)
		update(rot[i],rot[i-1],1,n,sa[i]+1);
	while(m--)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		int l = 1,r = min(d-c+1,b-a+1),ans=0,mid;
		while(l<=r)
		{
			mid = (l+r)>>1;
			int lp = rnk[c-1],rp = lp;
			for(int k = lg2[n];k>=0;k--)
			{
				if(lp>=(1<<k) && mn[lp-(1<<k)+1][k]>=mid)lp-=(1<<k);
				if(rp<=n-(1<<k) && mn[rp+1][k]>=mid)rp+=(1<<k);
			}
			if(getans(rot[lp-1],rot[rp],1,n,a,b-mid+1)>0)ans = mid,l=mid+1;
			else r = mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem4557

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,d,m;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][25],g[N][25];
int w[N];bool need[N];
void dfs(int x,int fa)
{
	f[x][0] = g[x][0] = need[x]?w[x]:0;
	for(int i = 1;i<= d;i++)g[x][i]=w[x];
	g[x][d+1] = INF; 
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			for(int j = 0;j<= d;j++)
				g[x][j] = min(g[x][j]+f[e[i].to][j],g[e[i].to][j+1]+f[x][j+1]);
			for(int j = d;j>=0;j--)g[x][j] = min(g[x][j+1],g[x][j]);
			f[x][0]=g[x][0];
			for(int j = 1;j<=d;j++)f[x][j]+=f[e[i].to][j-1];
			for(int j = 1;j<=d;j++)f[x][j] = min(f[x][j-1],f[x][j]);
		}
}
int main()
{
	scanf("%d%d",&n,&d);
	for(int i = 1;i<= n;i++)
		scanf("%d",&w[i]);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		int x;
		scanf("%d",&x);
		need[x] = true;
	}
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	printf("%d\n",f[1][0]);
	return 0;
}
Problem4558

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int mod = 1e8+7;
typedef long long ll;
const int N = 2005;
const int MOD = 1880213;
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
}p[N];
int n,m,k;
bool inmap(const Point &s)
{
	return s.x<=n&&s.x>=0&&s.y<=m&&s.y>=0;
}
struct Hash
{
	int head[MOD],tot;
	int nxt[N],x[N],y[N];
	void add(int a,int b)
	{
		int tmp = ((ll)a*37+b)%MOD;
		++tot;
		nxt[tot] = head[tmp];
		x[tot] = a,y[tot] = b;
		head[tmp] = tot;
	}
	bool check(int a,int b)
	{
		int tmp = ((ll)a*37+b)%MOD;
		for(int i = head[tmp];i;i=nxt[i])
			if(x[i]==a&&y[i]==b)
				return true;
		return false;
	}
}hash;
ll calc(ll x,ll y)
{
	return (x+y)*(y-x+1)>>1;
}
ll Calc(ll x,ll y,ll z)
{
	if(!x || !y || z<2)return 0;
	z = min(z,x+y);
	x = min(x,z-1),y = min(y,z-1);
	ll sum = 0;
	sum = (sum+(ll)(z-y)*y%mod)%mod;
	sum = (sum+calc(z-x,y-1))%mod;
	return sum;
}
ll t1=0,t2=0,t3=0,t4=0;
void calc(const Point &p3,const Point &p4)
{
	if(inmap(p3)&&inmap(p4))
	{
		int tmp = hash.check(p3.x,p3.y)+hash.check(p4.x,p4.y);
		t2++;
		t3+=tmp;
		if(tmp>1)t4++;
	}
}
void Calc(const Point &p1,const Point &p2)
{
	int dx = p2.x-p1.x,dy = p2.y-p1.y;
	calc(Point(p1.x+dy,p1.y-dx),Point(p2.x+dy,p2.y-dx));
	calc(Point(p1.x-dy,p1.y+dx),Point(p2.x-dy,p2.y+dx));
	if(abs(dx+dy)&1)return ;
	dy = (dx+dy)>>1;
	dx-=dy;
	calc(Point(p1.x+dx,p1.y+dy),Point(p2.x-dx,p2.y-dy));
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		hash.add(p[i].x,p[i].y);
	}
	ll ans = 0;
	for(int i = 1;i<= n&&i<= m;i++)
		ans = (ans+(ll)i*(n-i+1)%mod*(m-i+1)%mod)%mod;
	for(int i = 1;i<= k;i++)
	{
		(t1+=Calc(p[i].x,n-p[i].x,p[i].y))%=mod;
		(t1+=Calc(p[i].x,n-p[i].x,m-p[i].y))%=mod;
		(t1+=Calc(p[i].y,m-p[i].y,p[i].x))%=mod;
		(t1+=Calc(p[i].y,m-p[i].y,n-p[i].x))%=mod;
		t1 = t1+min(p[i].x,p[i].y)+min(n-p[i].x,p[i].y)+min(p[i].x,m-p[i].y)+min(n-p[i].x,m-p[i].y);
		t1 = t1%mod;
		for(int j = 1;j<i;j++)
			Calc(p[i],p[j]);
	}
	ans = ((((ans-t1+mod)%mod+t2)%mod-t3/3)%mod+mod+t4/6)%mod;
	ans = (ans+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4559

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 105;
const int mod = 1e9+7;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int fac[N*N],env[N*N],Pow[N];
void init()
{
	fac[0] = env[0] = 1;
	for(int i = 1;i<= 10000;i++)
		fac[i] = (ll)fac[i-1]*i%mod;
	env[10000] = quick_pow(fac[10000],mod-2);
	for(int i = 9999;i>=1;i--)
		env[i] = (ll)env[i+1]*(i+1)%mod;
}
ll C(int n,int m)
{
	if(m>n)return 0;
	return (ll)fac[n]*env[m]%mod*env[n-m]%mod;
}
int f[N],g[N],rnk[N],s[N];
int n,m,k;
int main()
{
	init();
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)scanf("%d",&s[i]);
	int mxrnk=0;
	for(int i = 1;i<= m;i++)scanf("%d",&rnk[i]),mxrnk=max(mxrnk,rnk[i]);
	for(int i = n-mxrnk;i>= k;i--)
	{
		f[i] = C(n-1,i);
		for(int j = 1;j<= m;j++)
			f[i] = (ll)f[i]*C(n-i-1,rnk[j]-1)%mod;
		for(int j = i+1;j<= n-mxrnk;j++)
			f[i] = (f[i]-(ll)f[j]*C(j,i)%mod+mod)%mod;
	}
	int ans = 1;
	for(int i = 1;i<= m;i++)
	{
		g[0] = s[i];
		Pow[0] = 1;
		for(int j = 1;j<= n;j++)
		{
			Pow[j] = (ll)Pow[j-1]*s[i]%mod;
			g[j] = quick_pow(s[i]+1,j+1)-1;
			for(int k = 1;k<= j;k++)
				(g[j]+=mod-C(j+1,k+1)*g[j-k]%mod)%=mod;
			g[j]=(ll)g[j]*quick_pow(C(j+1,1),mod-2)%mod;
		}
		int now = 0;
		for(int j = 0,k = 1;j<rnk[i];j++,k = -k)
			now = (now+(ll)(mod+k)*C(rnk[i]-1,j)%mod*g[n-rnk[i]+j]%mod*Pow[rnk[i]-j-1]%mod)%mod;
		ans = (ll)ans*now%mod;
	}
	printf("%lld\n",(ll)ans*f[k]%mod);
	return 0;
}
Problem4561

#include <stdio.h>
#include <math.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
ll sqr(ll x){return x*x;}
struct Cir
{
	ll x,y,r;
}c[N];
ll T;
struct data
{
	ll num,x,o;
	data(){}
	data(ll _num,ll _x,ll _o):num(_num),x(_x),o(_o){}
	bool operator <(const data &s)const
	{
		double xx = c[num].y+o*sqrt(sqr(c[num].r)-sqr(T-c[num].x));
		double yy = c[s.num].y+s.o*sqrt(sqr(c[s.num].r)-sqr(T-c[s.num].x));
		if(xx!=yy)return xx<yy;
		return o<s.o;
	}
}poi[N<<1];
bool cmp(const data &a,const data &b)
{
	return a.x<b.x;
}
set<data>S;
ll f[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld%lld",&c[i].x,&c[i].y,&c[i].r);
		poi[(i<<1)-1] = data(i,c[i].x-c[i].r,1);
		poi[i<<1] = data(i,c[i].x+c[i].r,-1);
	}
	sort(poi+1,poi+2*n+1,cmp);
	set<data>::iterator it;
	for(int i = 1;i<= 2*n;i++)
	{
		T = poi[i].x;
		if(poi[i].o==1)
		{
			it = S.upper_bound(data(poi[i].num,0,-1));
			if(it==S.end())f[poi[i].num] = 1;
			else
			{
				if((*it).o==1)f[poi[i].num] = -f[(*it).num];
				else f[poi[i].num] = f[(*it).num];
			}
			S.insert(data(poi[i].num,0,-1));
			S.insert(data(poi[i].num,0,1));
		}else
		{
			S.erase(data(poi[i].num,0,-1));
			S.erase(data(poi[i].num,0,1));
		}
	}
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans = ans+f[i]*sqr(c[i].r);
	printf("%lld\n",ans);
	return 0;
}
Problem4563

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int B = 2000;
const int mod = 10000;
struct BigNum
{
	int d[B],len;
	BigNum(){memset(d,0,sizeof(d));len = 1;}
	BigNum(int x)
	{
		memset(d,0,sizeof(d));
		len = 1;
		while(x)d[len] = x%mod,x/=mod,len++;
		len--;
	}
	void print()
	{
		printf("%d",d[len]);
		for(int i = len-1;i;i--)
			printf("%04d",d[i]);
	}
	void operator +=(const BigNum &s)
	{
		len = max(len,s.len);
		for(int i = 1;i<=len;i++)
		{
			d[i] = d[i]+s.d[i];
			if(d[i]>=mod)
				d[i+1]++,d[i]%=mod;
		}
		if(d[len+1])len++;
	}
	friend BigNum operator +(const BigNum &a,const BigNum &b)
	{
		BigNum res = a;res+=b;
		return res;
	}
	void operator *=(const int &s)
	{
		int num = 0;
		for(int i = 1;i<= len;i++)
		{
			num = num+d[i]*s;
			d[i] = num%mod;
			num/=mod;
		}
		if(num)d[++len] = num;
	}
}f[205];
int main()
{
	f[0] = BigNum(1);f[1] = BigNum(0);
	int n;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
		f[i] = f[i-1]+f[i-2],f[i]*=(i-1);
	f[n].print();
	return 0;
}
Problem4564

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 3e5+5;
const int Asiz = 1005;
const int Siz = 300;
const int maxA = 1e6+5;
int cnt[maxA],bcnt[Asiz][2];
struct E
{int next,to;}e[M];
int head[N],tot=1,A[N],a[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dfn[N],DFN[N],low[N],seq[N],Dfn,size[N];
void dfs(int x,int pre)
{
	DFN[x] = low[x] = ++Dfn;
	seq[Dfn] = x;
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!DFN[e[i].to])
		{
			dfs(e[i].to,i);
			low[x] = min(low[e[i].to],low[x]);
		}else 
			low[x] = min(low[e[i].to],DFN[x]);
	}
}
void dfs2(int x,int pre)
{
	size[x] = 1;
	dfn[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!dfn[e[i].to]&&low[e[i].to]>=DFN[x])
		{
			dfs2(e[i].to,i);
			if(low[e[i].to]>DFN[x])
				size[x]+=size[e[i].to];
		}
	}
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!dfn[e[i].to]&&low[e[i].to]<DFN[x])
			dfs2(e[i].to,i);
	}
	if(low[x]!=DFN[x])
		size[seq[low[x]]]+=size[x];
}
struct Ask
{
	int l,r,pl;
	int o,p,id;
	bool operator <(const Ask &s)const
	{
		return pl<s.pl||pl==s.pl&&r<s.r;
	}
}ask[N];
int ans[N];
void Delete(int x)
{
	int tx = (a[x]-1)/Asiz+1;
	bcnt[tx][cnt[a[x]]&1]--;
	cnt[a[x]]--;
	if(cnt[a[x]])
		bcnt[tx][cnt[a[x]]&1]++;
}
void Insert(int x)
{
	int tx = (a[x]-1)/Asiz+1;
	if(cnt[a[x]])
		bcnt[tx][cnt[a[x]]&1]--;
	cnt[a[x]]++;
	bcnt[tx][cnt[a[x]]&1]++;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&A[i]);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	Dfn = 0;
	dfs2(1,0);
	for(int i = 1;i<= n;i++)a[dfn[i]]=A[i];
	int q;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].o,&ask[i].l,&ask[i].p);
		ask[i].r = dfn[ask[i].l]+size[ask[i].l]-1;
		ask[i].l = dfn[ask[i].l];
		ask[i].pl = ask[i].l/Siz;
		ask[i].id = i;
	}
	sort(ask+1,ask+q+1);
	int L = 1,R = 0;
	for(int i = 1;i<= q;i++)
	{
		while(L<ask[i].l)Delete(L),L++;
		while(L>ask[i].l)L--,Insert(L);
		while(R<ask[i].r)R++,Insert(R);
		while(R>ask[i].r)Delete(R),R--;
		x=(ask[i].p-1)/Asiz+1;
		for(int j = 1;j< x;j++)
			ans[ask[i].id]+=bcnt[j][ask[i].o];
		for(int j = (x-1)*Asiz+1;j<= ask[i].p;j++)
			if(cnt[j]&&(cnt[j]&1)==ask[i].o)
				ans[ask[i].id]++;
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4565

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<8;
const int N = 305;
ll f[N][N][S];
ll inf;
int val[S],c[S];
char s[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	for(int i = 0;i<1<<k;i++)scanf("%d%d",&c[i],&val[i]);
	memset(f,0xef,sizeof(f));inf = f[0][0][0];
	for(int i = 1;i<= n;i++)f[i][i][s[i]-'0'] = 0;
	for(int lth = 2;lth<= n;lth++)
	{
		for(int i = 1;i+lth-1<=n;i++)
		{
			int j = i+lth-1;
			int len = j-i;ll now,t;
			while(len>=k)len-=k-1;
			for(int m = j;m>i;m-=k-1)
				for(int S = 0;S<(1<<len);S++)
					if(f[i][m-1][S]!=inf)
					{
						if(f[m][j][0]!=inf)f[i][j][S<<1] = max(f[i][j][S<<1],f[i][m-1][S]+f[m][j][0]);
						if(f[m][j][1]!=inf)f[i][j][S<<1|1] = max(f[i][j][S<<1|1],f[i][m-1][S]+f[m][j][1]);
					}
			if(len==k-1)
			{
				ll g[2];
				g[0] = g[1] = inf;
				for(int S = 0;S<1<<k;S++)
					if(f[i][j][S]!=inf)
						g[c[S]]=max(g[c[S]],f[i][j][S]+val[S]);
				memcpy(f[i][j],g,sizeof(g));
			}
		}
	}
	ll ans = 0;
	for(int i = 0;i<1<<k;i++)
		ans = max(ans,f[1][n][i]);
	printf("%lld\n",ans);
	return 0;
}
Problem4566

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 4e5+5;
char s1[N>>1],s2[N>>1],s[N];
int sa[N],rnk[N],val[N],nv[N],q[N],cnt[N],h[N],a[N];
inline bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]] = i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>= 0;i--)sa[--cnt[val[q[i]]]] = q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i=j+1;k<= j;k++)nv[sa[k]] = lim;
		}
		if(lim==len)return ;
		for(i = 0;i<len;i++)val[i] = nv[i];
	}
}
void build_height(int len)
{
	for(int i = 0;i< len;i++)rnk[sa[i]]=i;
	for(int i = 0;i< len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]] = j;
		}
}
inline bool cmp(int a,int b){return h[a]>h[b];}
int fa[N];
ll st[N],en[N];
long long ans;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x] = getfa(fa[x]);
}
void calc(int x)
{
	if(!x)return ;
	int r1 = getfa(x),r2 = getfa(x-1);
	ans+=(ll)(st[r1]*en[r2]+st[r2]*en[r1])*h[x];
	st[r1]+=st[r2],en[r1]+=en[r2],fa[r2] = r1;
}

int main()
{
	scanf("%s",s1);
	int l1 = strlen(s1);
	scanf("%s",s2);
	int l2 = strlen(s2);
	for(int i = 0;i<l1;i++)
		s[i] = s1[i];
	s[l1] = 'z'+1;
	for(int i = 0;i<l2;i++)s[i+l1+1]=s2[i];
	int len = l1+l2+1;
	build_sa(len,256);
	build_height(len);
	for(int i = 0;i<len;i++)a[i]=fa[i]=i,st[i]=(sa[i]<l1),en[i] = 1-st[i];
	sort(a,a+len,cmp);
	for(int i = 0;i<len;i++)calc(a[i]);
	printf("%lld\n",ans);
	return 0;
}
Problem4568

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 20005;
struct Seg
{
	ll p[61];
	Seg(){memset(p,0,sizeof(p));}
	void init()
	{
		memset(p,0,sizeof(p));
	}
}tr[N<<2];
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,Q;
ll val[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],top[N],size[N],son[N],dfn[N],Dfn,seq[N],fa[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	seq[++Dfn] = x;
	dfn[x] = Dfn;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void insert(Seg &a,ll x)
{
	for(int i = 60;i>=0;i--)
		if((x>>i)&1)
		{
			if(!a.p[i]){a.p[i] = x;break;}
			else x^=a.p[i];
		}
}
void merge(Seg &a,Seg &b,Seg &c)
{
	for(int i = 0;i<= 60;i++)a.p[i]=b.p[i];
	for(int i = 60;i>=0;i--)if(c.p[i])insert(a,c.p[i]);
}
ll getans(const Seg &ans)
{
	ll Ans = 0;
	for(int i = 60;i>=0;i--)if((Ans^ans.p[i])>Ans)Ans = Ans^ans.p[i];
	return Ans;
}
void Build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].init();
		insert(tr[p],val[seq[l]]);
		return ;
	}
	int mid = (l+r)>>1;
	Build(p<<1,l,mid);
	Build(p<<1|1,mid+1,r);
	merge(tr[p],tr[p<<1],tr[p<<1|1]);
}
Seg ret;
void Getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		{merge(ret,ret,tr[p]);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Getans(p<<1,l,mid,a,b);
	if(b >mid)Getans(p<<1|1,mid+1,r,a,b);
}
ll Getans(int x,int y)
{
	ret.init();
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		Getans(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	Getans(1,1,n,dfn[y],dfn[x]);
	return getans(ret);
}
int main()
{
	scanf("%d%d",&n,&Q);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&val[i]);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	Build(1,1,n);
	while(Q--)
	{
		scanf("%d%d",&x,&y);
		printf("%lld\n",Getans(x,y));
	}
	return 0;
}
Problem4569

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int mod = 1e9+7;
int fa[N*20],id[N][20],idx[N*20][2];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[y] = x;
}
int pow2[20];
int main()
{
	pow2[0] = 1;
	for(int i = 1;i<= 18;i++)pow2[i]=pow2[i-1]*2;
	int n,cnt = 0,m;
	scanf("%d",&n);
	if(n==1){printf("10\n");return 0;}
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<=18;j++)
			id[i][j]=++cnt,idx[cnt][0]=i,idx[cnt][1]=j;
	scanf("%d",&m);
	int l1,r1,l2,r2;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
		for(int j = 18;j>= 0;j--)
		{
			if(l1+pow2[j]-1<=r1)
			{
				merge(id[l1][j],id[l2][j]);
				l1+=pow2[j],l2+=pow2[j];
			}
		}
	}
	for(int j = 18;j>= 1;j--)
	{
		for(int i = 1;i<= n;i++)
		{
			int k = getfa(id[i][j]);
			int s = idx[k][0];int t = idx[k][1];
			merge(id[s][t-1],id[i][j-1]);
			merge(id[s+pow2[t-1]][t-1],id[i+pow2[j-1]][j-1]);
		}
	}
	int tot = 0;
	for(int i = 1;i<= n;i++)
		if(getfa(id[i][0])==id[i][0])tot++;
	long long ans = 9;
	for(int i = 1;i< tot;i++)ans = ans*10%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4570

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const double eps = 1e-8;
const double INF = 1e20;
typedef long long ll;
struct P
{
	double x,y;
	P(double _x=0,double _y=0):x(_x),y(_y){}
	bool operator <(const P &s)const
	{
		if(x==s.x)return y>s.y;
		return x<s.x;
	}
	friend P operator -(const P &a,const P &b)
	{
		return P(a.x-b.x,a.y-b.y);
	}
	friend double operator *(const P &a,const P &b)
	{
		return a.x*b.y-a.y*b.x;
	}
}p[N],stack[N];
int top;
double slope(const P &a,const P &b)
{
	if(fabs(a.x-b.x)<eps)return -INF;
	else return (b.y-a.y)/(b.x-a.x);
}
double slope(const P &a)
{
	return -sqrt(a.y/a.x);
}
double calc(const P &a,double k)
{
	if(k>-eps)return INF;
	else return a.x+a.y-a.x*k-a.y/k;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf",&p[i].x,&p[i].y);
	sort(p+1,p+n+1);
	stack[++top] = p[1];
	for(int i = 2;i<= n;i++)
	{
		while(top>1&&(p[i]-stack[top])*(stack[top]-stack[top-1])<-eps)
			top--;
		stack[++top] = p[i];
	}
	double ans;
	if(top==1)ans = calc(stack[1],slope(stack[1]));
	else
	{
		double sp,sp1,sp2;
		ans = INF;
		sp2 = slope(stack[1],stack[2]),sp = slope(stack[1]);
		if(sp+eps>sp2)ans = min(ans,calc(stack[1],sp));
		for(int i = 2;i<top;i++)
		{
			sp1 = slope(stack[i-1],stack[i]);
			sp2 = slope(stack[i],stack[i+1]);
			sp = slope(stack[i]);
			ans = min(ans,calc(stack[i],sp1));
			if(sp1+eps>sp&&sp+eps>sp2)ans = min(ans,calc(stack[i],sp));
		}
		sp1 = slope(stack[top-1],stack[top]),sp = slope(stack[top]);
		ans = min(ans,calc(stack[top],sp1));
		if(sp1+eps>sp)ans = min(ans,calc(stack[top],sp));
	}
	printf("%.4f\n",ans);
	return 0;
}
Problem4571

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
int root[N],size[N*100],ls[N*100],rs[N*100],cnt,a[N];
void Update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	size[p] = size[pre]+1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Update(ls[p],ls[pre],l,mid,pos);
	else Update(rs[p],rs[pre],mid+1,r,pos);
}
int Getans(int L,int R,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return size[R]-size[L];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getans(ls[L],ls[R],l,mid,a,b);
	if(b >mid)ans+=Getans(rs[L],rs[R],mid+1,r,a,b);
	return ans;
}
int L,R,D;
int mx = (1<<19)-1;
int getans(int l,int r,int x,int y)
{
	if(l==r)
		return x^l;
	int mid = (l+r)>>1;
	D--;
	if(x&(1<<D))
	{
		if(Getans(L,R,0,mx,max(0,l-y),max(0,mid-y)))
			return getans(l,mid,x,y);
		else 
			return getans(mid+1,r,x,y);
	}
	else
	{
		if(Getans(L,R,0,mx,max(0,mid+1-y),max(0,r-y)))
			return getans(mid+1,r,x,y);
		else 
			return getans(l,mid,x,y);
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		Update(root[i],root[i-1],0,mx,a[i]);
	int x,y,l,r;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&l,&r);
		D = 19;
		L = root[l-1],R = root[r];
		printf("%d\n",getans(0,mx,x,y));
	}
	return 0;
}
Problem4573

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 4e5+5;
struct List
{int next,to,opt;}e[M];
struct data
{
	int t,ca,x,y,z,ans;
	bool operator <(const data &s)const
	{return t<s.t;}
}ask[N],zlt;
int head[N],TOT;
void add(int x,int y,int o)
{e[++TOT].to=y;e[TOT].next=head[x];e[TOT].opt=o;head[x]=TOT;}
int fa[M],ch[M][2],size[M],sum[M],val[M],pp[M],sta[M],tot,top;
int lt[N],rt[N],gs[N],b[M],n,m;
bool rev[M];
inline int pd(int x)
{return ch[fa[x]][1]==x;}
inline void Push_up(int p)
{sum[p]=sum[ch[p][0]]+val[p]+sum[ch[p][1]];}
void rotate(int x)
{
	int y = fa[x];
	int d = ch[y][1]==x;
	fa[x] = fa[y];
	if(fa[y])ch[fa[y]][pd(y)] = x;
	ch[y][d]=ch[x][d^1];
	if(ch[x][d^1])fa[ch[x][d^1]] = y;
	ch[x][d^1] = y;
	fa[y] = x;
	Push_up(y);Push_up(x);
	if(pp[y])pp[x]=pp[y],pp[y]=0;
}
void Push_down(int p)
{
	if(rev[p])
	{
		if(ch[p][0])rev[ch[p][0]]^=1;
		if(ch[p][1])rev[ch[p][1]]^=1;
		swap(ch[p][0],ch[p][1]);
		rev[p] = false;
	}
}
void relax(int x,int y)
{
	top = 0;
	while(x!=y)
	{
		sta[++top] = x;
		x = fa[x];
	}
	while(top)
	{
		x = sta[top--];
		Push_down(x);
	}
}
void splay(int x,int y)
{
	relax(x,y);
	while(fa[x]!=y)
	{
		if(fa[fa[x]]!=y)
		{
			if(pd(x)==pd(fa[x]))rotate(fa[x]);
			else rotate(x);
		}
		rotate(x);
	}
}
int access(int x)
{
	int y,z,p = x;
	splay(x,0);
	z = ch[x][1];
	ch[x][1] = 0;
	if(z)
	{
		fa[z] = 0;
		pp[z] = x;
	}
	Push_up(x);
	while(pp[x])
	{
		p = y = pp[x];
		splay(y,0);
		z = ch[y][1];
		if(z)
		{
			fa[z] = 0;
			pp[z] = y;
		}
		ch[y][1] = x;
		fa[x] = y;pp[x] = 0;
		Push_up(y);
		splay(x,0);
	}
	return p;
}
void make_root(int x)
{
	access(x);
	splay(x,0);
	rev[x]^=1;
}
void Link(int x,int y)
{
	make_root(y);
	splay(y,0);
	pp[y] = x;
}
void Cut(int x)
{
	make_root(1);
	access(x);
	splay(x,0);
	int y = ch[x][0];
	ch[x][0] = 0;
	if(y)
	{
		fa[y] = pp[y] = 0;
	}
	Push_up(x);
}
void Insert1(int x)
{
	int j = b[ask[x].y-1],k = b[ask[x].y];
	Cut(k);
	Link(k,ask[x].x);
}
void Delete1(int x)
{
	int j = b[ask[x].y-1],k = b[ask[x].y];
	Cut(k);
	Link(k,j);
}
void Insert0(int x)
{
	int j = gs[ask[x].x];
	val[ask[x].x] = 1;
	Push_up(ask[x].x);
	Link(ask[x].x,b[j]);
}
void Delete0(int x)
{
	Cut(ask[x].x);
}

int main()
{
	int l,r,x,y,ans;
	scanf("%d%d",&n,&m);
	tot = top = 1;
	lt[1] = 1,rt[1] = n;
	for(int i = 1;i<= m;i++)
	{
		ask[i].t = i;
		scanf("%d",&ask[i].ca);
		if(ask[i].ca==0)
		{
			scanf("%d%d",&l,&r);
			add(l,i,1),add(r+1,i,-1);
			ask[i].x=++tot;
			lt[tot]=l,rt[tot]=r;
			gs[tot] = top;
		}else if(ask[i].ca==1)
		{
			scanf("%d%d%d",&l,&r,&ask[i].x);
			l = max(l,lt[ask[i].x]),r = min(r,rt[ask[i].x]);
			if(l<=r)
			{
				add(l,i,1),add(r+1,i,-1);
				ask[i].y=++top;
			}
		}else
		{
			scanf("%d%d%d",&ask[i].z,&ask[i].x,&ask[i].y);
			l = ask[i].z;
			add(l,i,1);
		}
	}
	zlt.t=0;
    zlt.ca=1;
    zlt.x=1;
    zlt.y=1;
    ask[0]=zlt;
    for(int i = 1;i<= top;i++)b[i]=++tot;
    val[1] = 1;
	Push_up(1);
	pp[b[1]] = 1;
	for(int i = 2;i<= top;i++)pp[b[i]]=b[i-1];
	for(int i = 1;i<= n;i++)
	{
		for(int t = head[i];t;t=e[t].next)
		{
			if(ask[e[t].to].ca==0)
				{if(e[t].opt==1)Insert0(e[t].to);else Delete0(e[t].to);}
			else if(ask[e[t].to].ca==1)
				{if(e[t].opt==1)Insert1(e[t].to);else Delete1(e[t].to);}
		}
		for(int t = head[i];t;t=e[t].next)
		{
			if(ask[e[t].to].ca==2)
			{
				x = ask[e[t].to].x,y = ask[e[t].to].y;
				if(x==y){ask[e[t].to].ans = 0;continue;}
				make_root(1);
                access(x);
                splay(x,0);
                ans=sum[x];
                x=access(y);
                splay(y,0);
                ans+=sum[y];
                access(x);
                splay(x,0);
                ans-=sum[x]*2;
                ask[e[t].to].ans=ans;
			}
		}
	}
	for(int i = 1;i<= m;i++)
		if(ask[i].ca==2)printf("%d\n",ask[i].ans);
	return 0;
}
Problem4574

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 405;
const int mod = 1e9+7;
int dp[2][N][N],ans[N][N],A[N][N];
int a[N],idx[N],y[N],num[N];
int n,Q;
void solve(int l,int r,int pos)
{
	int i,j;
	for(i = l;i<= r;i++)
		for(j = l;j<= r;j++)
			dp[0][i][j]=dp[1][i][j]=0;
	int now = 1,pre = 0;
	ll k1;
	dp[0][l][r] = 1;
	for(int t = 1;t<= Q;t++)
	{
		for(i = l;i<= r;i++)
		{
			k1 = 0;
			for(j = r;j>= i;j--)
				dp[now][i][j] = k1%mod,k1 += 1ll*dp[pre][i][j]*(n-j);
		}
		for(j = l;j<= r;j++)
		{
			k1 = 0;
			for(i = l;i<= j;i++)
				dp[now][i][j]= (dp[now][i][j]+k1)%mod,k1 += 1ll*dp[pre][i][j]*(i-1);
		}
		for(j = l;j<= r;j++)
			for(i = l;i<= j;i++)
				dp[now][i][j]=(dp[now][i][j]+1ll*dp[pre][i][j]*A[i][j])%mod;
		pre^=1,now^=1;
	}
	for(i = l;i<= r;i++)
	{
		k1 = 0;
		for(j = r;j>= i;j--)
		{
			k1 += dp[pre][i][j];
			ans[j][y[pos]] = (ans[j][y[pos]]+k1)%mod;
		}
	}
}
bool cmp(int x,int y)
{
	return a[x]<a[y];
}
int main()
{
	scanf("%d%d",&n,&Q);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)idx[i]=i;
	sort(idx+1,idx+n+1,cmp);
	for(int i = 1;i<= n;i++)y[idx[i]]=i;
	for(int i = 1;i<= n;i++)num[i] = (i*(i+1))>>1;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)A[i][j] = num[i-1]+num[j-i+1]+num[n-j];
	int l,r,Ans;
	for(int i = 1;i<= n;i++)
	{
		l = i,r = i;
		while(l&&a[l]<=a[i])l--;
		while(r<=n&&a[r]<=a[i])r++;
		solve(l+1,r-1,i);
	}
	int i,j,k;
	for(i = 1;i<= n;i++)
	{
		Ans = 0;
		for(j = 1;j<= n;j++)
		{
			if(!ans[i][j])continue;
			for(k = 1;k<j;k++)
				ans[i][j] = (ans[i][j]-ans[i][k]+mod)%mod;
			Ans = (Ans+1ll*a[idx[j]]*ans[i][j])%mod;
		}
		printf("%d",Ans);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem4576

#include <stdio.h>
#include <cctype>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 262145;
int f[60][N];
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
int main()
{
	int n,x,ans = 0;
	n=read();
	for(int i = 1;i<= n;i++){x=read();f[x][i] = i+1;}
	for(int i= 2;i<= 58;i++)
		for(int j = 1;j<= n;j++)
		{
			if(!f[i][j])f[i][j] = f[i-1][f[i-1][j]];
			if(f[i][j])ans = i;
		}
	printf("%d",ans);
	return 0;
}
Problem4578

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 5e4+5;
const int INF = 0x3f3f3f3f;
int pmx[N],hmx[N],pmn[N],hmn[N],n;
struct Pos
{int x,y;}pos[N];
bool cmp1(Pos a,Pos b){return a.x<b.x;}
bool cmp2(Pos a,Pos b){return a.y<b.y;}
void init1()
{
	pmn[0] = INF,hmn[n+1] = INF;
	for(int i = 1;i<= n;i++)
	{
		pmx[i] = max(pmx[i-1],pos[i].x);
		pmn[i] = min(pmn[i-1],pos[i].x);
	}for(int i = n;i>= 1;i--)
	{
		hmx[i] = max(hmx[i+1],pos[i].x);
		hmn[i] = min(hmn[i+1],pos[i].x);
	}
}
void init2()
{
	pmn[0] = INF,hmn[n+1] = INF;
	for(int i = 1;i<= n;i++)
	{
		pmx[i] = max(pmx[i-1],pos[i].y);
		pmn[i] = min(pmn[i-1],pos[i].y);
	}for(int i = n;i>= 1;i--)
	{
		hmx[i] = max(hmx[i+1],pos[i].y);
		hmn[i] = min(hmn[i+1],pos[i].y);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&pos[i].x,&pos[i].y);
	sort(pos+1,pos+n+1,cmp1);
	init2();
	LL ans = 1e18+5;
	for(int i = 1;i< n;i++)
	{
		LL tmp = (LL)(pos[i].x-pos[1].x)*(pmx[i]-pmn[i]);
		tmp+=(LL)(pos[n].x-pos[i+1].x)*(hmx[i+1]-hmn[i+1]);
		ans = min(ans,tmp);
	}
	sort(pos+1,pos+n+1,cmp2);
	init1();
	for(int i = 1;i< n;i++)
	{
		LL tmp = (LL)(pos[i].y-pos[1].y)*(pmx[i]-pmn[i]);
		tmp+=(LL)(pos[n].y-pos[i+1].y)*(hmx[i+1]-hmn[i+1]);
		ans = min(ans,tmp);
	}
	printf("%lld\n",(LL)(pos[n].y-pos[1].y)*(hmx[1]-hmn[1])-ans);
	return 0;
}
Problem4579

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 400005;
struct E
{int next,to;}e[N];
int head[N],tot,fa[N],ask[N],size[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool ans[N],used[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(size[x]>size[y])
		fa[y] = x;
	else fa[x] = y; 
	size[x] = size[y] = size[x]+size[y];
}
int cnt = 0;
void solve(int x)
{
	for(int i = head[x];i;i = e[i].next)
		if(used[e[i].to])
			uni(e[i].to,x);
	used[x] = true;
	cnt++;
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)size[fa[i] = i] = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&ask[i]);
	for(int i = n;i>=1;i--)
	{
		solve(ask[i]);
		if(size[getfa(ask[i])]==cnt)ans[i] =true;
		else ans[i] = false;
	}
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
Problem4580

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int num[250];
int f[250][250];
int uni(int l,int r)
{
	if(f[l][r]!=0)return f[l][r];
	for(int i = l;i<r;i++)
		if(uni(l,i)==uni(i+1,r))
			f[l][r] = max(f[l][i]+1,f[l][r]);
	if(f[l][r]==0)f[l][r] = -1;
	return f[l][r];
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&num[i]);
		f[i][i] = num[i];
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)
			ans = max(ans,uni(i,j));
	printf("%d\n",ans);
	return 0;
}
Problem4581

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
int maxx[5],maxy[5],minx[5],miny[5];
int x[N],y[N];
int main()
{
	int n;
	scanf("%d",&n);
	memset(minx,0x3f,sizeof(minx));
	memset(miny,0x3f,sizeof(miny));
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
		maxx[4] = max(maxx[4],x[i]);
		for(int j = 4;j>1;j--)
			if(maxx[j]>maxx[j-1])swap(maxx[j],maxx[j-1]);
		minx[4] = min(minx[4],x[i]);
		for(int j = 4;j>1;j--)
			if(minx[j]<minx[j-1])swap(minx[j],minx[j-1]);
		maxy[4] = max(maxy[4],y[i]);
		for(int j = 4;j>1;j--)
			if(maxy[j]>maxy[j-1])swap(maxy[j],maxy[j-1]);
		miny[4] = min(miny[4],y[i]);
		for(int j = 4;j>1;j--)
			if(miny[j]<miny[j-1])swap(miny[j],miny[j-1]);
	}
	int ans = (1<<30)-1+(1<<30);
	for(int x1 = 1;x1<=4;x1++)
	for(int x2 = 1;x2<=4;x2++)
		if(minx[x1]<maxx[x2])
		for(int y1 = 1;y1<=4;y1++)
		for(int y2 = 1;y2<=4;y2++)
		if(miny[y1]<maxy[y2])
		{
			int cnt = 0;
			for(int i = 1;i<= n;i++)
				if(x[i]>=minx[x1]&&x[i]<=maxx[x2]&&y[i]>=miny[y1]&&y[i]<=maxy[y2])
					cnt++;
			if(cnt>=n-3)
				ans = min(ans,(maxx[x2]-minx[x1])*(maxy[y2]-miny[y1]));
		}
	printf("%d\n",ans);
	return 0;
}
Problem4582

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int ans[N<<1],num[N<<1];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	sort(num+1,num+n+1);
	int j = 0;
	for(int i = 1;i<=n;i++)
	{
		while(num[j]-num[i]<=k&&j<=n)j++;
		ans[i] = j-i;
	}
	int Tans = 0;
	for(int i = n;i>=1;i--)
	{
		Tans = max(Tans,ans[i]+ans[i+ans[i]]);
		ans[i] = max(ans[i],ans[i+1]);
	}
	printf("%d\n",Tans);
	return 0;
}
Problem4590

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
int opt[N],n;
int check(LL l)
{
	LL now = 0;int cnt = 0;
	for(int i = 1;i<= n;i++)
	{
		now+=opt[i];
		if(now<0)now = 0;
		if(now>=l){cnt++;now = 0;}
	}
	return cnt;
}
int main()
{
	int k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&opt[i]);
	LL l = 1,r = 1e15,lans = 0,rans = 0;
	while(l<r)
	{
		LL mid = (l+r)>>1;
		if(check(mid)>k)l = mid+1;
		else r = mid;
	}
	lans = l;
	l = 1;r = 1e15;
	while(l<r)
	{
		LL mid = (l+r)>>1;
		if(check(mid)>=k)l = mid+1;
		else r = mid;
	}
	rans = l-1;
	if(check(lans)!=k||check(rans)!=k||lans<=0||rans<=0)printf("-1\n");
	else printf("%lld %lld\n",lans,rans);
	return 0;
}
Problem4592

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std; 
#define maxn 200005 
  
struct Seg  
{  
    int l,r;  
    int lmx,rmx,ans,size,tag;  
}t[maxn<<2];  
  
int n,T;  
  
inline void add(int i,int x)  
{  
    t[i].tag=x;  
    if (x==1) t[i].lmx=t[i].rmx=t[i].ans=t[i].size=0;  
    else t[i].lmx=t[i].rmx=t[i].ans=t[i].size=t[i].r-t[i].l+1;  
}  
  
inline void release(int i) 
{
    if (t[i].tag==-1) return;  
    add(i*2,t[i].tag);add(i*2+1,t[i].tag);  
    t[i].tag=-1;  
}  
  
Seg merge(Seg x,Seg y)  
{  
    Seg ans;  
    ans.l=x.l;ans.r=y.r;  
    ans.size=x.size+y.size;  
    if (x.size==x.r-x.l+1) ans.lmx=x.size+y.lmx; else ans.lmx=x.lmx;  
    if (y.size==y.r-y.l+1) ans.rmx=y.size+x.rmx; else ans.rmx=y.rmx;  
    ans.ans=max(x.rmx+y.lmx,max(x.ans,y.ans));  
    ans.tag=-1;  
    return ans;  
}  
  
void build(int i,int l,int r)  
{  
    t[i].l=l;t[i].r=r;t[i].lmx=t[i].rmx=t[i].ans=t[i].size=0;t[i].tag=-1;  
    if (l==r) return;  
    int mid=(t[i].l+t[i].r)/2;  
    build(i*2,l,mid);build(i*2+1,mid+1,r);  
}  
  
void modify(int i,int l,int r,int d)  
{  
    if (l<=t[i].l && t[i].r<=r) {add(i,d);return;}  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (l<=mid) modify(i*2,l,r,d);  
    if (mid<r) modify(i*2+1,l,r,d);  
    t[i]=merge(t[i*2],t[i*2+1]);  
}  
  
int Query(int i,int l,int r)  
{  
    if (l<=t[i].l && t[i].r<=r) return t[i].size;  
    release(i);  
    int mid=(t[i].l+t[i].r)/2,ans=0;  
    if (l<=mid) ans+=Query(i*2,l,r);  
    if (mid<r) ans+=Query(i*2+1,l,r);  
    return ans;  
}  
  
void change(int i,int l,int r,int x)  
{  
    if (!x) return;  
    if (l<=t[i].l && t[i].r<=r && t[i].size<=x) {add(i,1);return;}  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (l<=mid)  
    {  
        int num=Query(i*2,l,r);  
        if (x>num) {modify(i*2,l,r,1);if (mid<r) change(i*2+1,l,r,x-num);}  
        else change(i*2,l,r,x);  
    }  
    else change(i*2+1,l,r,x);   
    t[i]=merge(t[i*2],t[i*2+1]);  
}  
  
Seg query(int i,int l,int r)  
{  
    if (l<=t[i].l && t[i].r<=r) return t[i];  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (r<=mid) return query(i*2,l,r);  
    else if (l>mid) return query(i*2+1,l,r);  
    else return merge(query(i*2,l,r),query(i*2+1,l,r));  
}  
  
int main()  
{  
    scanf("%d%d",&n,&T);  
    build(1,1,n);  
    while (T--)  
    {  
        int op,l1,l2,r1,r2;  
        scanf("%d%d%d",&op,&l1,&r1);  
        if (op==0) modify(1,l1,r1,0);  
        else if (op==1)  
        {  
            scanf("%d%d",&l2,&r2);  
            int num=r1-l1+1-Query(1,l1,r1);  
            modify(1,l1,r1,0);  
            change(1,l2,r2,num);  
        }  
        else   
        {  
            Seg ans=query(1,l1,r1);  
            printf("%d\n",ans.ans);  
        }  
    }  
    return 0;  
}  
Problem4593

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <ctime>
using namespace std;
struct node {int to;int next;};node bian[200005];
int first[100005],size,f[100005],h[100005],g[1000010];
int father[100005],d[100005],c[100005],n,a,b,maxc;
void inser(int x,int y) {
	size ++;
	bian[size].to = y;
	bian[size].next = first[x];
	first[x] = size;
}
void dfs(int x,int Anc) {
	father[x] = Anc;
	int _d1 = d[x],_d2 = d[x] - c[father[x]],ret = 0;
	for(int u = first[x];u;u = bian[u].next)
	{
		if(bian[u].to == Anc) continue;
		dfs(bian[u].to,x);
		if(f[bian[u].to] == h[bian[u].to])
		{
			_d1 -= c[bian[u].to];
			_d2 -= c[bian[u].to];
			ret += f[bian[u].to];
		}
		else ret += h[bian[u].to];
	}
	f[x] = ret + max(_d1,0);
	h[x] = ret + max(_d2,0);
}
void bfs(int x,int Anc) {
	father[x] = Anc;
	int _d1 = d[x],_d2 = d[x] - c[father[x]],ret = 0;
	for(int u = first[x];u;u = bian[u].next)
	{
		if(bian[u].to == Anc) continue;
		bfs(bian[u].to,x);
		if(f[bian[u].to] - h[bian[u].to] < c[bian[u].to])
		{
			_d1 -= c[bian[u].to];
			_d2 -= c[bian[u].to];
			ret += f[bian[u].to];
		}
		else ret += h[bian[u].to];
	}
	if(_d1 < 0) 
	{
		int _n = 0;g[0] = 0;
		for(int u = first[x];u;u = bian[u].next)
		{
			if(bian[u].to == Anc) continue;
			if(f[bian[u].to] - h[bian[u].to] >= c[bian[u].to]) continue;
			for(int i = _n + 1;i <= _n + c[bian[u].to];i ++)
				g[i] = 0;
			_n = _n + c[bian[u].to];
			int C = c[bian[u].to],D = f[bian[u].to] - h[bian[u].to];
			for(int i = 0;i + C <= _n;i ++)
				g[i + C] = ((g[i + C] > g[i] + D) ? g[i + C] : g[i] + D);
		}
		f[x] = ret;
		for(int i = 1;i <= _n;i ++)
			f[x] = min(f[x],max(0,_d1 + i) + ret - g[i]);
		//f[x] = ret - g[_n];
	}
	else f[x] = ret + max(_d1,0);
	if(_d2 < 0) 
	{
		int _n = 0;g[0] = 0;
		for(int u = first[x];u;u = bian[u].next)
		{
			if(bian[u].to == Anc) continue;
			if(f[bian[u].to] - h[bian[u].to] >= c[bian[u].to]) continue;
			for(int i = _n + 1;i <= _n + c[bian[u].to];i ++)
				g[i] = 0;
			_n = _n + c[bian[u].to];
			int C = c[bian[u].to],D = f[bian[u].to] - h[bian[u].to];
			for(int i = 0;i + C <= _n;i ++)
				g[i + C] = ((g[i + C] > g[i] + D) ? g[i + C] : g[i] + D);
		}
		h[x] = ret;
		for(int i = 1;i <= _n;i ++)
			h[x] = min(h[x],max(0,_d1 + i) + ret - g[i]);	
	}
	else h[x] = ret + max(_d2,0);
}
int main() {
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)
		scanf("%d",&d[i]);
	for(int i = 1;i <= n;i ++)
		scanf("%d",&c[i]),maxc = max(maxc,c[i]);
	for(int i = 2;i <= n;i ++)
	{
		scanf("%d%d",&a,&b);
		inser(a,b);
		inser(b,a);
	}
	if(maxc <= 1) dfs(1,0); else bfs(1,0);
	printf("%d",f[1]);
}
Problem4594

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int pre[N],fi[N],n,m;
struct E
{
	int x,y;
	E(int _x=0,int _y=0):x(_x),y(_y){}
	bool operator <(const E &s)const
	{
		if(x!=s.x)return x<s.x;
		return y<s.y;
	}
}e[N];
bool check(int x,int l,int r)
{
	if(x<=0)return false;
	for(int i = l+x;i<= r;i++)
	{
		if((i-l)%x!=pre[i]-l)return false;
		if(e[fi[i]].x==i&&e[fi[i]].y<l+x&&fi[i]<=m)return false;
	}
	return true;
}
bool judge(int l,int r)
{
	if(l==r)return true;
	int x=0;
	for(int i = l;i<= r;i++)
	{
		if(pre[i]>=l)continue;
		for(;fi[i]<=m&&e[fi[i]].x==i&&e[fi[i]].y<l;fi[i]++);
		if(fi[i]<=m&&e[fi[i]].x==i){pre[i]=e[fi[i]].y;++fi[i];}
	}
	pre[l] = l;
	for(int i = r;i>l;i--)
		if(pre[i]==l&&r-l+1>=(pre[i-1]-l+1)*2)
			{x = pre[i-1]-l+1;break;}
	if(!check(x,l,r)&&(r-pre[r])*2>=r-l+1&&pre[r]>=l)x = r-pre[r];
	if(check(x,l,r)&&judge(l,l+x-1)&&judge(l+x,r))return true;
	return false;
}
int main()
{
	int cas,x,y;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		bool flag = false;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			if(x<y)swap(x,y);
			e[i] = E(x,y);
			if(x==y)flag = true;
		}
		if(flag){puts("NO");continue;}
		sort(e+1,e+m+1);
		for(int i = 0;i<n;i++)pre[i] = -1;
		int j = 1;
		for(int i = 0;i< n;i++)
		{
			fi[i] = j;
			for(;e[j].x==i&&j<=m;j++);
		}
		if(judge(0,n-1))puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem4596

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 20;
const int M = 1005;
ll d[N][N];
int m[N];
int v1[N][N*N],v2[N][N*N];
int n;ll ans;
ll Gauss()
{
	ll res = 1,f = 1;
	for(int i = 1;i<n;i++)
		for(int j = 1;j<n;j++)
			(d[i][j]+=mod)%=mod;
	for(int i = 1;i<n;i++)
	{
		for(int j = i+1;j<n;j++)
		{
			ll A = d[i][i],B = d[j][i];
			while(B)
			{
				ll C = A/B;
				A%=B;
				swap(A,B);
				for(int k = i;k<n;k++)
					d[i][k] = (d[i][k]-C*d[j][k]%mod+mod)%mod;
				for(int k = i;k<n;k++)
					swap(d[i][k],d[j][k]);
				f = -f;
			}
		}
		if(!d[i][i])return 0;
		res = res*d[i][i]%mod;
	}
	return (mod+f*res)%mod;
}
int main()
{
	scanf("%d",&n);
	for(int i = 0;i< n-1;i++)
	{
		scanf("%d",&m[i]);
		for(int j = 1;j<= m[i];j++)
			scanf("%d%d",&v1[i][j],&v2[i][j]);
	}
	for(int sta = 1;sta<1<<(n-1);sta++)
	{
		memset(d,0,sizeof(d));
		int cnt = 0;
		for(int i = 0;i< n-1;i++)
			if(sta&(1<<i))
			{
				cnt++;
				for(int k = 1;k<= m[i];k++)
					d[v1[i][k]][v2[i][k]]--,  
                    d[v2[i][k]][v1[i][k]]--,  
                    d[v1[i][k]][v1[i][k]]++,  
                    d[v2[i][k]][v2[i][k]]++; 
			}
		if((n-cnt)&1)(ans+=Gauss())%=mod;
		else (ans+=mod-Gauss())%=mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4597

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int N = 1e5+5;
typedef long long ll;
int n,T;
ll tr[N<<2],lazy[N<<2];
ll sum[N],a[N],inv[10005];
ll quick_pow(ll x,ll y)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
void Push_down(int p,int l,int r)
{
	if(l==r||lazy[p]==1)return ;
	tr[p<<1] = tr[p<<1]*lazy[p]%mod;lazy[p<<1] = lazy[p<<1]*lazy[p]%mod;
	tr[p<<1|1] = tr[p<<1|1]*lazy[p]%mod;lazy[p<<1|1] = lazy[p<<1|1]*lazy[p]%mod;
	lazy[p] = 1;
}
void build(int p,int l,int r)
{
	lazy[p] = 1;
	if(l==r)
	{
		if(l!=n)tr[p] = 2ll*quick_pow(3,n-l-1)%mod*sum[l]%mod;
		else tr[p] = sum[n];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p] = (tr[p<<1]+tr[p<<1|1])%mod;
}
void Update(int p,int l,int r,int a,int b,int x)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		tr[p]=tr[p]*x%mod;
		lazy[p]=lazy[p]*x%mod;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,x);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,x);
	tr[p] = (tr[p<<1]+tr[p<<1|1])%mod;
}

int main()
{
	for(int i = 1;i<= 10000;i++)inv[i]=quick_pow(i,mod-2);
	scanf("%d%d",&n,&T);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	sum[0]=1;
	for(int i = 1;i<= n;i++)sum[i]=sum[i-1]*a[i]%mod;
	build(1,1,n);
	while(T--)
	{
		int pos;ll x;
		scanf("%d%lld",&pos,&x);
		Update(1,1,n,pos,n,inv[a[pos]]*x%mod);
		a[pos] = x;
		printf("%lld\n",tr[1]);
	}
	return 0;
}
Problem4598

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef unsigned long long ull;
typedef long long ll;
const int sed = 37;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],f[N],sum,maxd,root,n,m;
bool used[N];
void get_root(int x,int fa,int dep)
{
	maxd = max(maxd,dep);
	size[x] = 1,f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
		{
			get_root(e[i].to,x,dep+1);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int cntz[N],cntd[N],tcz[N],tcd[N],mod[N],val[N];
ull hz[N],hd[N];
void dfs(int x,int fa,ull hash,int dep)
{
	hash = hash*sed+val[x];
	if(hash==hz[dep])cntz[mod[dep]]++;
	if(hash==hd[dep])cntd[mod[dep]]++;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			dfs(e[i].to,x,hash,dep+1);
}
ll ans;
void work(int x)
{
	root = 0;
	sum = size[x];
	maxd = 0;
	get_root(x,0,1);
	if(sum<m||2*maxd<m)return ;
	x = root;
	used[x] = true;
	memset(tcz,0,sizeof(int)*(m+1));
	memset(tcd,0,sizeof(int)*(m+1));
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
		{
			memset(cntz,0,sizeof(int)*(m+1));
			memset(cntd,0,sizeof(int)*(m+1));
			dfs(e[i].to,x,val[x],2);
			cntz[m] = cntz[0],cntd[m] = cntd[0];
			cntz[m+1] = cntz[1],cntd[m+1] = cntd[1];
			ans+=cntz[0]+cntd[0];
			for(int x = 0;x<m;x++)
			{
				ans+=(ll)cntz[m-x+1]*tcd[x];
				ans+=(ll)cntd[m-x+1]*tcz[x];
			}
			for(int x = 0;x<m;x++)
				tcz[x]+=cntz[x],tcd[x]+=cntd[x];
		}
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
			work(e[i].to);
}
char P[N],s[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		tot = 0;
		memset(head,0,sizeof(head));
		ans = 0;
		memset(used,0,sizeof(used));
		scanf("%d%d",&n,&m);
		scanf("%s",s+1);
		for(int i = 1;i<= n;i++)
			val[i] = s[i]-'A'+1;
		int x,y;
		for(int i = 1;i< n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
		}
		scanf("%s",P+1);
		ull pp = 1;
		for(int i = 1,j = 1,k = m;i<= n;i++,pp = pp*sed)
		{
			mod[i] = i%m;
			hz[i] = (P[j]-'A'+1)*pp+hz[i-1];
			hd[i] = (P[k]-'A'+1)*pp+hd[i-1];
			j++;if(j==m+1)j=1;
			k--;if(k==0)k=m;
		}
		f[0] = size[1] = n;
		if(m>1)work(1);
		else 
		{
			for(int i = 1;i<= n;i++)ans+=(val[i]==P[1]-'A'+1);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4600

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
bool vis[N];
int sg[25][25];
void init(int n,int maxQ)
{
	int tmp,x = 0,y = 0;
	tmp = n;while(tmp>=2)x++,tmp/=2;
	tmp = n;while(tmp>=3)y++,tmp/=3;
	for(int i = 0;i<= x;i++)
		for(int j = 0;j<= y;j++)
		{
			memset(vis,0,sizeof(vis));
			for(int p = 1;p<= i;p++)
				for(int q = 1;q*p<=i&&q<=maxQ;q++)
				{
					tmp = -1;
					for(int k = 1;k<= q;k++)
						if(tmp==-1)tmp = sg[i-k*p][j];
						else tmp = tmp^sg[i-p*k][j];
					if(tmp!=-1)vis[tmp] = true;
				}
			for(int p = 1;p<= j;p++)
				for(int q = 1;q*p<=j&&q<=maxQ;q++)
				{
					tmp = -1;
					for(int k = 1;k<= q;k++)
						if(tmp==-1)tmp = sg[i][j-p*k];
						else tmp = tmp^sg[i][j-p*k];
					if(tmp!=-1)vis[tmp] = true;
				}
			for(int k=0;;k++)
				if(!vis[k])
					{sg[i][j] =k;break;}
		}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n,maxQ;
		scanf("%d%d",&n,&maxQ);
		init(n,maxQ);
		int ans = 0;
		int s;
		for(int i = 1;i<= n;i++)
		{
			scanf("%d",&s);
			if(!s)
			{
				int x,y,tmp;
				x = y = 0;
				tmp = i;while(tmp%2==0)x++,tmp/=2;
				tmp = i;while(tmp%3==0)y++,tmp/=3;
				ans = ans^sg[x][y];
			}
		}
		if(!ans)printf("lose\n");
		else printf("win\n");
	}
	return 0;
}
Problem4603

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
const double pi = 3.14159265358979323;
struct Point
{
	double x,y,z;
	Point(){}
	Point(double _x,double _y,double _z):x(_x),y(_y),z(_z){}
	friend Point operator +(const Point &a,const Point &b)
	{
		return Point(a.x+b.x,a.y+b.y,a.z+b.z);
	}
	friend Point operator -(const Point &a,const Point &b)
	{
		return Point(a.x-b.x,a.y-b.y,a.z-b.z);
	}
	friend Point operator *(const Point &a,double b)
	{
		return Point(a.x*b,a.y*b,a.z*b);
	}
	friend Point operator /(const Point &a,double b)
	{
		return Point(a.x/b,a.y/b,a.z/b);
	} 
	friend double operator &(const Point &a,const Point &b)
	{
		return a.x*b.x+a.y*b.y+a.z*b.z;
	}
	friend Point operator |(const Point &a,const Point &b)
	{
		return Point(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);
	}
	friend double getdis(const Point &a)
	{
		return sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
	}
}poi[N],centre;
struct Shape
{
	int num;
	Point vec[N];
}sur[N];
int n,f;
double getV(Point p,Point a,Point b,Point c)
{
	a = a-p,b = b-p,c = c-p;
	double ans = (a|b)&c;
	ans = ans/6.0;
	return fabs(ans);
}
Point getC(const Point &p,const Point &a,const Point &b,const Point &c)
{
	Point C;
	C = p+a+b+c;
	return C/4.0;
}
void getcentre()
{
	double sumv = 0;
	Point t = Point(0,0,0);
	for(int i = 1;i<= f;i++)
	{
		int num = sur[i].num;
		for(int j = 1;j<= num-2;j++)
		{
			double v = getV(centre,sur[i].vec[0],sur[i].vec[j],sur[i].vec[j+1]);
			Point c = getC(centre,sur[i].vec[0],sur[i].vec[j],sur[i].vec[j+1]);
			c = c*v,sumv+=v,t = t+c;
		}
	}
	centre = t/sumv;
}
double getAngle(Point p,Point x,Point y,Point z)
{
	x = x-p,y = y-p,z = z-p;
	x = x/getdis(x),y = y/getdis(x),z = z/getdis(x);
	Point a = x|y,b = x|z;
	double ans = (a&b)/getdis(a)/getdis(b);
	return acos(ans);
}
double getS(const Shape &x,const Point &y)
{
	double ans = -(x.num-2)*pi;
	for(int i = 0;i<x.num;i++)
		ans+=getAngle(y,x.vec[i],x.vec[(i+1)%x.num],x.vec[(i-1+x.num)%x.num]);
	return ans;
}
int main()
{
	int x;
	scanf("%d%d",&n,&f);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf%lf",&poi[i].x,&poi[i].y,&poi[i].z);
	for(int i = 1;i<= f;i++)
	{
		scanf("%d",&sur[i].num);
		for(int j = 0;j<sur[i].num;j++)
			scanf("%d",&x),sur[i].vec[j]=poi[x];
	}
	centre = Point(0,0,0);
	for(int i = 1;i<= n;i++)
		centre = centre+poi[i];
	centre = centre/(double)n;
	getcentre();
	for(int i = 1;i<= f;i++)
	{
		double ans = getS(sur[i],centre);
		ans /= 4.0*pi;
		printf("%.7lf\n",ans);
	}
	return 0;
}
Problem4605

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 4e6+5;
const double alpha = 0.81;
const int INF = 1e9+1;
struct P
{
	int mn[2],mx[2],d[2],l,r,sz;
	int& operator[](int x){return d[x];}
	P(int x,int y){l = r = 0;d[0] = x,d[1] = y;}
	P(){l=r=0;}
};
int D,pt[N];
int dcnt,tot;
namespace KD_tree
{
	P t[M];
	bool cmp(int a,int b)
	{
	return t[a][D]<t[b][D];
	}
	void update(int k)
	{
		P &l = t[t[k].l],&r = t[t[k].r];
		for(int i = 0;i<2;i++)
			t[k].mn[i] = t[k].mx[i] = t[k][i];
		for(int i = 0;i<2;i++)
		{
			if(t[k].l)t[k].mn[i] = min(t[k].mn[i],l.mn[i]);t[k].mx[i] = max(t[k].mx[i],l.mx[i]);
			if(t[k].r)t[k].mn[i] = min(t[k].mn[i],r.mn[i]);t[k].mx[i] = max(t[k].mx[i],r.mx[i]);
		}
		t[k].sz = l.sz+r.sz+1;
	}
	int NewPoint(int x,int y)
	{
		++dcnt;
		t[dcnt][0] = x;t[dcnt][1]= y;
		update(dcnt);
		return dcnt;
	}
	bool ned_rebuild(int k)
	{
		return max(t[t[k].l].sz,t[t[k].r].sz)>t[k].sz*alpha;
	}
	int query(int p,int x0,int y0,int x1,int y1)
	{
		if(!p||t[p].mn[0]>x1||t[p].mx[0]<x0||t[p].mn[1]>y1||t[p].mx[1]<y0)return 0;
		if(t[p].mn[0]>=x0&&t[p].mx[0]<=x1&&t[p].mn[1]>=y0&&t[p].mx[1]<=y1)return t[p].sz;
		int ans = 0;
		if(t[p][0]>=x0&&t[p][0]<=x1&&t[p][1]>=y0&&t[p][1]<=y1)ans++;
		return ans+query(t[p].l,x0,y0,x1,y1)+query(t[p].r,x0,y0,x1,y1);
	}
	int tmpx,tmpd,tmpf;
	void Insert(int &x,int now,const P &p)
	{
		if(!x){x = NewPoint(p.d[0],p.d[1]);return ;}
		if(p.d[now]>t[x][now])Insert(t[x].l,now^1,p);
		else Insert(t[x].r,now^1,p);
		update(x);
		if(ned_rebuild(x))tmpx = x,tmpd = now,tmpf = 0;
		else if(tmpx==t[x].l||tmpx==t[x].r)tmpf = x;
	}
	void travel(int &x)
	{
		if(!x)return ;
		pt[++tot] = x;
		travel(t[x].l),travel(t[x].r);
	}
	int build(int l,int r,int now)
	{
		if(l>r)return 0;
		int mid = (l+r)>>1,x;
		D = now;
		nth_element(pt+l,pt+mid,pt+r+1,cmp);
		x = pt[mid];
		t[x].l = build(l,mid-1,now^1);
		t[x].r = build(mid+1,r,now^1);
		update(x);
		return x;
	}
	void Insert(int &x,const P &p)
	{
		tmpx = tmpf = 0;
		Insert(x,0,p);
		if(!tmpx)return ;
		tot = 0,travel(tmpx);
		if(!tmpf){x = build(1,tot,tmpd);return ;}
		if(tmpx == t[tmpf].l)t[tmpf].l=build(1,tot,tmpd);
		else t[tmpf].r=build(1,tot,tmpd);
	}
}
struct Node
{int ls,rs,rt;}ti[M];
int ncnt,root;
void Insert(int &x,const P &p,int pos,int L = 1,int R = INF)
{
	if(!x)x = ++ncnt;
	KD_tree::Insert(ti[x].rt,p);
	if(L==R)return ;
	int mid = (L+R)>>1;
	if(pos<=mid)Insert(ti[x].ls,p,pos,L,mid);
	else Insert(ti[x].rs,p,pos,mid+1,R);
}
int query(int &x,int &x0,int &y0,int &x1,int &y1,int k,int L=1,int R=INF)
{
	if(L==R)return L;
	int rcnt = KD_tree::query(ti[ti[x].rs].rt,x0,y0,x1,y1);
	int mid = (L+R)>>1;
	if(k<=rcnt)return query(ti[x].rs,x0,y0,x1,y1,k,mid+1,R);
	else return query(ti[x].ls,x0,y0,x1,y1,k-rcnt,L,mid);
}
int n,q,ans;
int main()
{
	scanf("%d%d",&n,&q);
	int x0,y0,x1,y1,opt,k,tmp;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&x0,&y0,&k);
			x0 = x0^ans,y0 = y0^ans,k = k^ans;
			P p = P(x0,y0);
			Insert(root,p,k);
		}else
		{
			scanf("%d%d%d%d%d",&x0,&y0,&x1,&y1,&k);
			x0 = x0^ans,y0 = y0^ans,x1 = x1^ans,y1 = y1^ans,k = k^ans;
			tmp = KD_tree::query(ti[root].rt,x0,y0,x1,y1);
			if(tmp<k){printf("NAIVE!ORZzyz.\n");ans = 0;}
			else printf("%d\n",ans = query(root,x0,y0,x1,y1,k));
		}
	}
	return 0;
}
Problem4607

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e6+5;
const int M = 30;
int f[30][1<<13][3];
int cnt[M][M],deg[M],w[M][M],fa[M],d[M],g[M],id[M],n,c,m;
bool vis[M],del[M];
char a[N],b[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void Up(int &a,int b){a=a<b?a:b;}
int Cnt(int x)
{
	int cnt = 0;
	while(x)cnt++,x-=x&(-x);
	return cnt;
}
int main()
{
	scanf("%d%d",&n,&c);
	scanf("%s",a);scanf("%s",b);
	for(int i = 0;i<n;i++)
		cnt[a[i]-'a'][b[i]-'a']++,deg[a[i]-'a']++;
	for(int i = 0;i<26;i++)
		for(int j = 0;j<26;j++)
		{
			w[i][j] = deg[i]-cnt[i][j];
			if(i!=j)w[i][j]+=c;
		}
	for(int i = 0;i<26;i++)fa[i]=i,id[i]=-1;
	for(int i = 0;i<26;i++)
	{
		int k = 0;
		for(int j=0;j<26;j++)
			if(w[i][j]<w[i][k])k=j;
		d[g[i]=k]++;
		if(getfa(i)!=getfa(k))fa[fa[i]]=fa[k];
	}
	int ans = 0;
	for(int i = 0;i<26;i++)
		if(!del[getfa(i)])
		{
			del[fa[i]]=vis[i]=true;
			int j;
			for(j = g[i];!vis[j];j=g[j])vis[j]=true;
			if(g[j]==j)continue;id[j]=m;
			for(int k = g[j];k!=j;k=g[k])id[k]=m;
			m++;
		}
	if(!m)
	{
		for(int i = 0;i<26;i++)ans+=w[i][g[i]];
		printf("%d\n",ans);
		return 0;
	}
	int flag = 1;
	for(int i = 0;i<26;i++)
		if(d[i]!=1)flag = 0;
	for(int i = 0;i<= 26;i++)
		for(int S = 0;S < 1<<m;S++)
			for(int j = 0;j<2;j++)
				f[i][S][j]=INF;
	f[0][0][0]=0;
	for(int i = 0;i<26;i++)
		for(int S = 0;S< 1<<m;S++)
			for(int j = 0;j<2;j++)
				if(f[i][S][j]<INF)
				{
					for(int k = 0;k<26;k++)
					{
						int sta = S;
						if(~id[i] && k!=g[i])sta|=1<<id[i];
						if(~id[k] && (k!=g[i] || id[i]!=id[k] ))sta|=1<<id[k];
						Up(f[i+1][sta][j||k!=g[i]],f[i][S][j]+w[i][k]);
					}
				}
	ans = INF;
	for(int S = 0;S<1<<m;S++)
		for(int j = flag;j<2;j++)
			if(f[26][S][j]<INF)
				Up(ans,f[26][S][j]+(m-Cnt(S))*c);
	printf("%d\n",ans);
	return 0;
}
Problem4613

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#define fir first
#define sec second
using namespace std;
typedef long long ll;
typedef pair<ll,int> pil;
const int N = 1e6+5;
const ll INF = 1e18;
priority_queue<pil, vector<pil> , greater<pil> >Q;
struct E
{int next,to,val;}e[N];
int head[N],tot,cnt;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];
	head[x] = tot;e[tot].val = f;
}
int n,m,fa[N],a[N],deg[N],ans[N];
ll dis[N],f[N];
void dfs(int x,int pre)
{
	f[x] = x<=n?0:INF;
	for(int i = head[x];i;i=e[i].next)
	{
		fa[e[i].to] = x;
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to,i);
		if(f[e[i].to]<f[x])f[x] = f[e[i].to];
		deg[x]++;
	}
	f[x]+=e[pre].val;
}
char name[N>>1][15];
bool cmp(int a,int b)
{return dis[a]<dis[b];}
void Push(int x)
{
	if(x==n+1)return ;
	if(--deg[x])return ;
	cnt++;
	Q.push(pil(f[x],x));
}
int main()
{
	int x,d;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",name[i]+1);
		scanf("%d%d",&x,&d);
		add(x+n+1,i,d);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&d);
		add(x+n+1,i+n+1,d);
	}
	dfs(n+1,0);
	f[n+1] = INF;
	for(int i = 1;i<= n;i++)a[i]=i;
	sort(a+1,a+n+1,cmp);
	cnt = n;
	for(int i = 1;i<= n;i++)Q.push(pil(f[i],i));
	for(int i = 1;i<= n;ans[a[i++]]=cnt)
		while(!Q.empty())
		{
			pil t = Q.top();
			if(t.fir>dis[a[i]])break;
			Q.pop();
			cnt--;
			Push(fa[t.sec]);
		}
	for(int i = 1;i<= n;i++)
		printf("%s %d\n",name[i]+1,ans[i]+1);
	return 0;
}
Problem4617

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2.5e5+5;
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend void operator -=(Point &a,const Point &b)
	{a = a-b;}
	friend ll operator *(const Point &a,const Point &b)
	{return 1ll*a.x*b.y-1ll*a.y*b.x;}
	friend Point operator *(const Point &a,int k)
	{return Point(a.x*k,a.y*k);} 
	friend bool operator ==(const Point &a,const Point &b)
	{return a.x==b.x&&a.y==b.y;}
	friend bool operator !=(const Point &a,const Point &b)
	{return a.x!=b.x||a.y!=b.y;}
}a[N],b[N],c[N<<1];
int cnta,cntb,m,n,cnt,ce;
struct E
{
	Point o;int t;
	E(){}
	E(Point _o,int _t):o(_o),t(_t)
	{
		if(o.x<0)o = o*-1;
	}
}e[N<<1];
inline bool cmp1(const Point &x,const Point &y)
{return x.x==y.x?x.y<y.y:x.x<y.x;}
inline bool cmp2(const E &a,const E &b)
{return a.o*b.o<0ll;}
int get_convexhull(Point *p,int n,Point *q)
{
	int k,m;
	m = 0;
	for(int i = 0;i<n;q[m++]=p[i++])
		while(m>1&&(q[m-1]-q[m-2])*(p[i]-q[m-2])<=0)m--;
	k = m;
	for(int i = n-2;~i;q[m++]=p[i--])
		while(m>k&&(q[m-1]-q[m-2])*(p[i]-q[m-2])<=0)m--;
	return --m;
}
bool P_on_Seg(const Point &p,const Point &a,const Point &b)
{
	return (b-a)*(p-a)==0&&
	1ll*(p.x-a.x)*(p.x-b.x)+1ll*(p.y-a.y)*(p.y-b.y)<=0;
}
int getl(int l,int r,const Point &p)
{
	int ret = l++,mid;
	while(l<=r)
	{
		mid = (l+r)>>1;
		if((c[mid]-p)*(c[(mid-1+n)%n]-c[mid])<=0)l=(ret=mid)+1;
		else r = mid-1;
	}
	return ret;
}
int getr(int l,int r,const Point &p)
{
	int ret = r--,mid;
	while(l<=r)
	{
		mid = (l+r)>>1;
		if((c[mid]-p)*(c[(mid+1)%n]-c[mid])>=0)r=(ret=mid)-1;
		else l = mid+1;
	}
	return ret;
}
void solve(const Point &p)
{
	if(P_on_Seg(p,c[0],c[n-1]))
		{cnt++;return ;}
	int o = 0;
	if(p.x>0)
	{
		int l = 1,r = n-1,mid;
		while(l<=r)
		{
			mid = (l+r)>>1;
			if(c[mid]*p>=0)l=(o=mid)+1;
			else r = mid-1;
		}
	}else if(p.y>0)o = n-1;
	if(p.x>=0&&(p-c[o])*(c[o+1]-p)<0){cnt++;return ;}
	if(p.x>=0&&P_on_Seg(p,c[o],c[o+1])){cnt++;return ;}
	int l,r;
	if(p.x>0)l = getl(0,o,p),r = getr(o,n,p);
	else l = getl(m,n,p),r = getr(0,m,p);
	e[++ce] = E(p-c[l],1);
	e[++ce] = E(p-c[r],-1);
	if(cmp2(e[ce],e[ce-1]))cnt++;
}
int main()
{
	int x,y,opt;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d%d%d",&x,&y,&opt);
		if(opt)a[++cnta] = Point(x,y);
		else b[++cntb] = Point(x,y);
	}
	if(cnta==1)
	{
		printf("1");
		return 0;
	}
	sort(a+1,a+cnta+1,cmp1);
	cnt = cnta;cnta = 0;
	for(int i = 1;i<= cnt;i++)
		if(a[i]!=a[i-1]||i==1)
			a[++cnta]=a[i];
	if(cnta==1)
	{
		for(int i = 1;i<= cntb;i++)
			if(a[1]==b[i])cnt++;
		printf("%d\n",cnt);return 0;
	}
	if(cnta==2)
	{
		for(int i = 1;i<= cntb;i++)
			if(P_on_Seg(b[i],a[1],a[2]))
				cnt++;
		printf("%d\n",cnt);return 0;
	}
	n = get_convexhull(a+1,cnta,c);
	for(int i = 1;i<n;i++)c[i]-=c[0];
	for(int i = 1;i<= cntb;i++)b[i]-=c[0];
	c[0]-=c[0];
	for(int i = 0;i<n;i++)if(c[i].x>=c[m].x)m=i;
	for(int i = 0;i<n;i++)c[i+n]=c[i];
	for(int i = 1;i<= cntb;i++)solve(b[i]);
	sort(e+1,e+ce+1,cmp2);
	int ret=0,mv=0,j;
	for(int i = 1;i<= ce;i=j)
	{
		for(j=i;j<=ce&&e[i].o*e[j].o==0;j++)
			ret+=e[j].t;
		if(ret<mv)mv = ret;
	}
	printf("%d\n",cnt+mv);
	return 0;
}
Problem4619

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
struct E
{
	int pre,nxt;
	E(){}
	E(int _pre,int _nxt):pre(_pre),nxt(_nxt){}
}a[N],b[N];
bool cmp1(const E &x,const E &y)
{return x.pre<y.pre;}
bool cmp2(const E &x,const E &y)
{return x.nxt>y.nxt;}
int main()
{
	int n;
	int cnt1=0,cnt2 = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		int pr,nx;
		scanf("%d%d",&pr,&nx);
		if(nx>pr)a[++cnt1] = E(pr,nx);
		else b[++cnt2] = E(pr,nx);
	}
	sort(a+1,a+cnt1+1,cmp1);
	sort(b+1,b+cnt2+1,cmp2);
	long long ans = 0,rem = 0;
	for(int i = 1;i<= cnt1;i++)
	{
		if(rem<1ll*a[i].pre)
		{
			ans+=a[i].pre-rem;
			rem = 0;
		}
		else rem-=a[i].pre;
		rem+=a[i].nxt;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		if(rem<1ll*b[i].pre)
		{
			ans+=b[i].pre-rem;
			rem = 0;
		}
		else rem-=b[i].pre;
		rem+=b[i].nxt;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4624

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{return cp(a.x+b.x,a.y+b.y);}
	friend cp operator -(const cp &a,const cp &b)
	{return cp(a.x-b.x,a.y-b.y);}
	friend cp operator *(const cp &a,const cp &b)
	{return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
}a[N],b[N],c[N];
const int R = 505;
char s[R][R],s2[R][R];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = (len>>1);(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w(1,0),tmp;
			for(int k = 0;k<i>>1;w=w*wn,k++)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
}
int main()
{
	int row,col,h,w,len,l;
	scanf("%d%d",&row,&col);
	for(int i = 0;i<row;i++)scanf("%s",s[i]);
	for(len=1;len<=row*col*2+2;len<<=1);
	l = row*col-1;
	int cas,Ans;
	scanf("%d",&cas);
	for(int Cas = 1;Cas<=cas;Cas++)
	{
		Ans = 0;
		scanf("%d%d",&h,&w);
		for(int i = 0;i<h;i++)scanf("%s",s2[i]);
		for(int i = 0;i<row;i++)
			for(int j = 0;j<col;j++)a[i*col+j]=cp(s[i][j]=='G'?1:-1,0);
		for(int i = l+1;i<len;i++)a[i]=cp();
		for(int i = 0;i<len;i++)b[i]=cp();
		for(int i = 0;i<h;i++)
			for(int j = 0;j<w;j++)b[l-i*col-j]=cp(s2[i][j]=='G'?1:-1,0);
		for(int i = 0;i<len;i++)c[i]=cp();
		conv(a,b,c,len);
		for(int i = 0;i<len-l;i++)ans[i]=(int)(c[l+i].x+0.5);
		int px=0,py=0,t1=0,t2=0;
		for(int i = 0;i<= row-h;i++)for(int j = 0;j<= col-w;j++)
			if(ans[i*col+j]>Ans){Ans=ans[i*col+j],px=i,py=j;}
		for(int i = 0;i<h;i++)for(int j = 0;j<w;j++)
			if(s[px+i][py+j]==s2[i][j])
			{
				if(s2[i][j]=='G')t1++;else t2++;
			}
		printf("Case #%d: %d %d %d %d\n",Cas,px+1,py+1,t1,t2);
	}
	return 0;
}
Problem4625

#include <stdio.h>
#include <map>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5+5;
const int BASE = 30000;
typedef long long ll;
map<pair<int,int>,int>val,vis;
int ex[N],x[N],y[N],c[N];
int dx[]={0,0,1,-1,1,-1};
int dy[]={1,-1,0,0,1,-1};
struct E
{
	int next,to,f;
}e[N*100];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
	if(d[e[i].to]==d[s]-1&&e[i].f)
	{
		int tof = get_mxf(e[i].to,t,min(e[i].f,last));
		if(tof)
		{
			e[i].f-=tof;
			e[i^1].f+=tof;
			if(!(last-=tof))return mf;
		}
	}
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int l[N],r[N];
int main()
{
	int n,z,C,cnt = 0,ans=0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x[i],&y[i],&z,&C);
		x[i]-=z,y[i]-=z;
		c[i] = (x[i]+y[i])%3==0?C*11:C*10;
		ans+=c[i];
		if(!vis[make_pair(x[i],y[i])])
			vis[make_pair(x[i],y[i])]=i,val[make_pair(x[i],y[i])]=c[i];
		else
			val[make_pair(x[i],y[i])]+=c[i],ex[i]=true;
	}
	int idx = 0;
	for(int i = 1;i<= n;i++)
		l[i]=++idx,r[i]=++idx;
	int S = ++idx,T = ++idx;
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==0)
			add(l[i],r[i],val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==1)
			add(S,r[i],val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==2)
			add(l[i],T,val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i])
		{
			for(int j = 0;j<6;j++)
			{
				int xx = x[i]+dx[j],yy = y[i]+dy[j];
				int tmp = vis[make_pair(xx,yy)];
				if(!tmp)continue;
				if ((xx+yy+BASE) % 3 == 0 && (x[i]+y[i]+BASE)%3 == 1) add(r[i],l[tmp],INF);
            	if ((xx+yy+BASE) % 3 == 2 && (x[i]+y[i]+BASE)%3 == 0) add(r[i],l[tmp],INF);

			}
		}
	ans-=dinic(S,T);
	printf("%d.%d\n",ans/10,ans%10);
	return 0;
}
Problem4627

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int a[N],cnt;
ll sum[N],pos[N];
int c[N];
void update(int x)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]++;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int getans(int l,int r)
{
	return getans(r)-getans(l-1);
}
int upper(ll x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<=x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
int lower(ll x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,L,R;
	scanf("%d%d%d",&n,&L,&R);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum[i] = sum[i-1]+a[i];
		pos[i] = sum[i];
	}
	sort(pos+1,pos+n+2);
	cnt = 1;
	for(int i = 2;i<= n+1;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt]=pos[i];
	ll ans = 0;
	update(lower(0));
	for(int i = 1;i<= n;i++)
	{
		ans+=getans(lower(sum[i]-R),upper(sum[i]-L));
		update(lower(sum[i]));
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4628

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int M = N*64;
struct data
{
	int t,i,f;
	data(int _t=0,int _i=0,int _f=0):t(_t),i(_i),f(_f){}
	bool operator <(const data &s)const
	{
		return t<s.t;
	}
}s[N<<1];
int ans[N];
struct Trie
{
	int lazy,s,f;
	int ch[2];
}tr[M];
void Push_down(int p)
{
	int ls = tr[p].ch[0],rs = tr[p].ch[1];
	if(tr[p].lazy)
	{
		if(!tr[ls].f)
		{
			tr[ls].lazy+=tr[p].lazy;
			tr[ls].s+=tr[p].lazy;
		}
		if(!tr[rs].f)
		{
			tr[rs].lazy+=tr[p].lazy;
			tr[rs].s+=tr[p].lazy;
		}
		tr[p].lazy = 0;
	}
}
char opt[N][10],str[N][35];
char ip[N][35];
int l[N],r[N],top=1;
void Update(int now)
{
	int kind = 1;
	if(opt[now][0]=='D')kind = -1;
	int l = strlen(str[now]+1);
	int j = 1;
	for(int i = 1;i<= l;i++)
	{
		if(!tr[j].ch[0])tr[j].ch[0] = ++top;
		if(!tr[j].ch[1])tr[j].ch[1] = ++top;
		Push_down(j);
		j = tr[j].ch[str[now][i]-'0'];
	}
	tr[j].lazy++,tr[j].s++,tr[j].f+=kind;
}
int Getans(int now)
{
	int j = 1;
	for(int i = 1;i<= 32;i++)
	{
		if(!tr[j].ch[0])tr[j].ch[0]=++top;
		if(!tr[j].ch[1])tr[j].ch[1]=++top;
		Push_down(j);
		j = tr[j].ch[ip[now][i]-'0'];
	}
	return tr[j].s;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%s%s",opt[i],str[i]+1);
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",ip[i]+1,&l[i],&r[i]);
		s[(i<<1)-1] = data(l[i],i,-1);
		s[i<<1] = data(r[i],i,1);
	}
	sort(s+1,s+q*2+1);
	int j = 1;
	for(int i = 1;i<= 2*q;i++)
	{
		while(j<=s[i].t)
		{
			Update(j);
			j++;
		}
		ans[s[i].i]+=s[i].f*Getans(s[i].i);
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4629

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 505;
int ch[N][26];
char s[N];
int a[110],fail[N],last[N],w[N],cnt;
void addnew(int v)
{
	int i = 1,now = 0;
	while(s[i])
	{
		if(!ch[now][s[i]-'a'])ch[now][s[i]-'a'] = ++cnt;
		now = ch[now][s[i]-'a'];
		i++;
	}
	w[now]+=v;
}
int q[N],hd,tl;
void Build_fail()
{
	hd = 1,tl = 0;
	for(int i = 0;i<26;i++)
		if(ch[0][i])q[++tl]=ch[0][i];
	while(hd<=tl)
	{
		int x = q[hd++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[x][i];
			if(!j){ch[x][i]=ch[fail[x]][i];continue;}
			int k = fail[x];
			while(k&&!ch[k][i])k=fail[k];
			fail[j] = ch[k][i];
			w[j]+=w[fail[j]];
			if(w[fail[j]])last[j] = fail[j];
			else last[j]=last[fail[j]];
			q[++tl]=j;
		}
	}
}
int f[N][N][6];
bool used[N][N][6];
int K,m;
void dp(int n,int x,int k)
{
	if(k>K||used[n][x][k])return;
	used[n][x][k]=true;
	f[n][x][k]=w[x];
	if(n==m)return ;
	int maxn = -707185547707185547LL,maxb = 0;
	for(int i = 0;i<26;i++)
	{
		dp(n+1,ch[x][i],k);
		if(k<K)
			dp(n+1,ch[x][i],k+1);
		if(f[n+1][ch[x][i]][k]>maxn)
		{
			maxn = f[n+1][ch[x][i]][k];
			maxb = i;
		}
	}
	maxn = 707185547707185547LL;
	for(int i = 0;i<26;i++)
	{
		if(i==maxb)maxn = min(maxn,f[n+1][ch[x][i]][k]);
		else if(k<K)maxn = min(maxn,f[n+1][ch[x][i]][k+1]);
	}
	f[n][x][k]+=maxn;
}
ll di[205][205],tmp[205][205],ret[205][205];
ll ans;
void solve1(int M,bool chu)
{
	ans = 0;
	if(chu)
	{
		memset(di,0xef,sizeof(di));
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<26;j++)
				di[i][ch[i][j]]=w[ch[i][j]];
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
				ret[i][j]=di[i][j];
		M--;
		while(M)
		{
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					tmp[i][j]=-707185547707185547LL;
			if(M&1)
			{
				for(int i = 0;i<= cnt;i++)
					for(int k = 0;k<= cnt;k++)
						for(int j = 0;j<= cnt;j++)
							tmp[i][j]=max(tmp[i][j],ret[i][k]+di[k][j]);
				for(int i = 0;i<= cnt;i++)
					for(int j = 0;j<= cnt;j++)
						ret[i][j]=tmp[i][j];
			}
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					tmp[i][j]=-707185547707185547LL;
			for(int i = 0;i<= cnt;i++)
				for(int k = 0;k<= cnt;k++)
					for(int j = 0;j<= cnt;j++)
						tmp[i][j]=max(tmp[i][j],di[i][k]+di[k][j]);
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					di[i][j]=tmp[i][j];
			M>>=1;
		}
		memset(di,0xef,sizeof(di));
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<26;j++)
				di[i][ch[i][j]]=w[ch[i][j]];
	}
	else
	{
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
			{
				tmp[i][j]=-707185547707185547LL;
				for(int k = 0;k<= cnt;k++)
					tmp[i][j]=max(tmp[i][j],ret[i][k]+di[k][j]);
			}
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
				ret[i][j]=tmp[i][j];
	}
	for(int i = 0;i<= cnt;i++)
		ans = max(ans,ret[0][i]);
}
void solve2()
{
	int M = m;
	int P = M-300;
	ll res = 0;
	int st;
	for(;P<=M-250;P++)
	{
		for(int i = 0;i<= 300;i++)
			for(int j = 0;j<= cnt;j++)
				for(int k = 0;k<= K;k++)
					used[i][j][k]=false;
		m = M-P;
		dp(0,0,0);
		solve1(P,(P==M-300));
		res = max(res,f[0][0][0]+ans);
	}
	printf("%lld\n",res+1);
}
int main()
{
	int n;
	scanf("%d%d%d",&n,&m,&K);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",s+1,&a[i]);
		addnew(a[i]);
	}
	Build_fail();
	if(m>500&&K==0&&cnt<=200){solve1(m,true);printf("%lld\n",ans);}
	else if(m>500&&K!=0&&cnt<=51){solve2();}
	else
	{
		dp(0,0,0);
		printf("%d\n",f[0][0][0]);
	}
	return 0;
}
Problem4631

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int pre[N],nxt[N];
struct C
{int l,r,i;}cld[N];
bool operator <(const C &a,const C &b)
{return a.r<b.r;}
int tr[N<<2],a[N],c[N],n,m;
inline int Push_up(int x,int y)
{
	return cld[x].l>cld[y].l?x:y;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p] = l;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);build(p<<1|1,mid+1,r);
	tr[p] = Push_up(tr[p<<1],tr[p<<1|1]);
}
void update(int p,int l,int r,int pos)
{
	if(l==r){tr[p]=0;return ;}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos);
	else update(p<<1|1,mid+1,r,pos);
	tr[p] = Push_up(tr[p<<1],tr[p<<1|1]);
}
int getans(int p,int l,int r,int d)
{
	if(r<=d)return tr[p];
	int mid = (l+r)>>1,t = getans(p<<1,l,mid,d);
	if(d>mid)t = Push_up(t,getans(p<<1|1,mid+1,r,d));
	return t;
}
int ans = 0;
void Delete(int x)
{
	a[x]--;if(a[x])return ;
	int l = pre[x],r = nxt[x];
	pre[r] = l,nxt[l] = r;r = c[r-1];
	if(!r)return ;
	while(true)
	{
		int t = getans(1,1,m,r);
		if(cld[t].l<=l)return ;
		ans++;update(1,1,m,t);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),pre[i]=i-1,nxt[i]=i+1;
	int lastans = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&cld[i].l,&cld[i].r);
		cld[i].i=i;
	}
	sort(cld+1,cld+m+1);
	for(int i = 1;i<= m;i++)
		if(cld[i].r!=cld[i-1].r)
			for(int j = cld[i-1].r;j<cld[i].r;j++)c[j] = i-1;
	for(int i = cld[m].r;i<= n;i++)c[i]=m;
	build(1,1,m);
	int Q,x;
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%d",&x);x = (x+ans-1)%n+1;
		Delete(x);printf("%d\n",ans);
	}
	return 0;
}
Problem4641

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int a[N],b[N],col[N],nxt[N];
int ans[N],tot,j;
inline bool check(int x,int y)
{
	if(b[x]==-1)
	{
		if(y>=x||y==-1)return true;
	}
	return b[x]==y;
}
int main()
{
	int cas,C;
	scanf("%d%d",&cas,&C);
	while(cas--)
	{
		int n,m,x;
		scanf("%d%d",&n,&m);
		memset(col,0,sizeof(col));
		for(int i = 1;i<= n;i++)
		{
			scanf("%d",&x);
			a[i] = i-col[x];
			col[x] = i;
		}
		memset(col,0,sizeof(col));
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&x);
			if(!col[x])b[i]=-1;
			else b[i]=i-col[x];
			col[x] = i;
		}
		j = tot = 0;
		for(int i = 2;i<= m;i++)
		{
			while(j && !check(j+1,b[i]))j = nxt[j];
			if(check(j+1,b[i]))j++;nxt[i]=j;
		}
		j = 0;
		for(int i = 1;i<= n;i++)
		{
			while(j && !check(j+1,a[i]))j = nxt[j];
			if(check(j+1,a[i]))j++;
			if(j==m)
			{
				ans[++tot] = i-m+1;
				j = nxt[j];
			}
		}
		printf("%d\n",tot);
		for(int i = 1;i<= tot;i++)
			printf("%d ",ans[i]);
		puts("");
	}
	return 0;
}
Problem4650

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int sed = 237;
const int N = 3e4+5;
int u[N],v[N];
char s[N];
int hash[N],pow[N];
void pre()
{
	pow[0]=1;
	for(int i =1;i<N;i++)
		pow[i]=(ll)pow[i-1]*sed%mod;
}
int Hash(int l,int r)
{
	return (hash[r]-(ll)hash[l]*pow[r-l]%mod+mod)%mod;
}
int main()
{
	int cas,p,q,l,r,mid;
	long long ans = 0;
	scanf("%d",&cas);
	pre();
	while(cas--)
	{
		scanf("%s",s+1);int n = strlen(s+1);
		for(int i = 1;i<= n;i++)
			u[i]=v[i]=0,hash[i] = ((ll)hash[i-1]*sed+s[i]-'a')%mod;
		for(int i = 1;2*i<= n;i++)
			for(int j = 1;j+i<= n;j+=i)
			{
				l = 0,r = min(i,j);
				while(l^r)
				{
					mid = (l+r+1)>>1;
					if(Hash(j+i-mid,j+i)==Hash(j-mid,j))l=mid;
					else r = mid-1;
				}
				p = j-l+1;
				l = 0,r = min(i-1,n-j-i);
				while(l^r)
				{
					mid = (l+r+1)>>1;
					if(Hash(j+i,j+i+mid)==Hash(j,j+mid))l=mid;
					else r = mid-1;
				}
				q = j+l+1;
				if(p+i<=q)
				{
					++u[p],--v[q+i];
					--u[q-i+1];++v[p+i*2-1];
				}
			}
		ans = 0;
		for(int i = 1;i<= n;i++)
			u[i]+=u[i-1],v[i]+=v[i-1],ans+=(ll)u[i]*v[i-1];
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4651

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int P = N*25;
const int M = P*4;
const int bas = 2e9;
struct E
{int next,to;}e[M];
struct P
{int x,y,lev;}p[P];
int head[P],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
map<ll,int>pos;
int dfn[P],low[P],Dfn,cnt;
bool flag;
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	int son = 0;
	for(int i = head[x];i;i=e[i].next)
		if(p[e[i].to].lev)
		{
			if(!dfn[e[i].to])
			{
				son++;
				tarjan(e[i].to);
				low[x] = min(low[x],low[e[i].to]);
				if(p[x].lev==2)continue;
				if(dfn[x]==1&&son>=2)flag = true;
				if(dfn[x]!=1&&dfn[x]<=low[e[i].to])flag = true;
			}else
				low[x] = min(low[x],dfn[e[i].to]);
		}
}
bool vis[P];int vt;
void dfs(int x)
{
	vis[x] = true;
	if(p[x].lev)vt++;
	for(int i = head[x];i;i=e[i].next)if(!vis[e[i].to])dfs(e[i].to);
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		for(int i = 0;i<= cnt;i++)head[i]=dfn[i]=low[i]=vis[i]=0;tot=1;
		pos.clear();
		int n,m,c,tmp;cnt = 0;
		bool ans0=false;
		ll x,y;
		scanf("%d%d%d",&n,&m,&c);
		for(int i = 1;i<= c;i++)
		{
			scanf("%lld%lld",&x,&y);
			pos[x*bas+y]=i;
			p[i].x = x,p[i].y = y;p[i].lev = 0;
		}
		cnt = c;
		if(1ll*n*m-c<=1){puts("-1");continue;}
   		if(1ll*n*m==2&&!c){puts("-1");continue;}
		for(int i = 1;i<= c;i++)
			for(int nx = max(1,p[i].x-1);nx<=min(n,p[i].x+1);nx++)
				for(int ny = max(1,p[i].y-1);ny<=min(m,p[i].y+1);ny++)
				{
					if(pos[(ll)nx*bas+ny])continue;
					p[++cnt].x = nx,p[cnt].y = ny;p[cnt].lev = 1;
					pos[(ll)nx*bas+ny]=cnt;
				}
		for(int i = 1;i<= c;i++)
			for(int nx = max(1,p[i].x-2);nx<=min(n,p[i].x+2);nx++)
				for(int ny = max(1,p[i].y-2);ny<=min(m,p[i].y+2);ny++)
				{
					if(pos[(ll)nx*bas+ny])continue;
					p[++cnt].x = nx,p[cnt].y = ny;p[cnt].lev = 2;
					pos[(ll)nx*bas+ny]=cnt;
				}
		for(int i = 1;i<= cnt;i++)
		{
			if((tmp=pos[((ll)(p[i].x+1)*bas+p[i].y)]))
				add(i,tmp);
			if((tmp=pos[((ll)p[i].x*bas+p[i].y+1)]))
				add(i,tmp);
		}
		flag = false;
		for(int i = c+1;i<= cnt;i++)
		{
			if(vis[i])continue;
			vt = 0;dfs(i);
			Dfn = 0;tarjan(i);
			if(Dfn!=vt){ans0=true;break;}
		}
		if(ans0){puts("0");continue;}
		if(1ll*n*m-c==2&&Dfn==2){puts("-1");continue;}
    	if(n==1||m==1){puts("1");continue;}
    	if(flag){puts("1");continue;}
    	puts("2");
	}
	return 0;
}
Problem4652

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int mu[N],prime[N/10],cnt,f[2005],g[2005],k,stack[2005],top;
bool vis[N];
int gcd(int a,int b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
void get_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
			else
				mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i = 1;i<= k;i++)
		f[i] = f[i-1]+(gcd(i,k)==1),g[i]=g[i-1]+(gcd(i,k)==1)*mu[i];
	for(int i = 2;i<= k;i++)if(k%i==0&&mu[i])stack[++top]=i;
	for(int i = 1;i<N;i++)mu[i]+=mu[i-1];
}
map<ll,int>mp,mp2;
inline int calc_mu(int x)
{
	if(x<N)return mu[x];
	if(mp.count(x))mp[x];
	int t = 1;
	for(int i = 2,last;i<= x;i=last+1)
	{
		last = x/(x/i);
		t-=(last-i+1)*calc_mu(x/i);
	}
	return mp[x] = t;
}
inline int calc(int x)
{
	if(x<=k)return g[x];
	if(mp2.count(x))return mp2[x];
	int tmp = calc_mu(x);
	for(int i = 1;i<= top && stack[i]<=x;i++)
	{
		tmp = tmp-(mu[stack[i]]-mu[stack[i]-1])*calc(x/stack[i]);
	}
	return mp2[x] = tmp;
}
inline int F(int x)
{
	return (x/k)*f[k]+f[x%k];
}
int main()
{
	int n,m;
	scanf("%d%d%d",&n,&m,&k);
	get_mu();
	ll ans = 0;
	for(int i = 1,last;i<=min(n,m);i=last+1)
	{
		last = min(n/(n/i),m/(m/i));
		ans += (ll)(calc(last) - calc(i-1)) * F(m/i) * (n/i);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4653

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int M = 200005;
const int INF = (1<<30)+((1<<30)-1);
int maxn[N<<2],lazy[N<<2];
int p[N],tot;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Q
{
	int l,r,len;
}qu[N>>1];
bool cmp(Q a,Q b)
{
	return a.len<b.len;
}
void push_down(int p,int l,int r)
{
	if(l==r||!lazy[p])return ;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=c;
		maxn[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid) update(p<<1|1,mid+1,r,a,b,c);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int find(int x)
{
	int l = 1,r = tot+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(p[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		qu[i].l = read();
		qu[i].r = read();
		qu[i].len = qu[i].r-qu[i].l+1;
		p[++tot] = qu[i].l;p[++tot] = qu[i].r;
	}
	sort(p+1,p+tot+1);
	int tmp = tot;tot = 0;
	for(int i = 1;i<= tmp;i++)
		if(p[i]!=p[tot])
			p[++tot] = p[i];
	for(int i = 1;i<= n;i++)
		qu[i].l = find(qu[i].l),qu[i].r = find(qu[i].r);
	sort(qu+1,qu+n+1,cmp);
	int now = 0;
	int ans = INF;
	for(int i = 1;i<= n;i++)
	{
		while(maxn[1]<m)
		{
			if(now==n)break;
			now++;
			update(1,1,tot,qu[now].l,qu[now].r,1);
		}
		//if(now==n)break;
		if(maxn[1]>=m)ans = min(ans,qu[now].len-qu[i].len);
		update(1,1,tot,qu[i].l,qu[i].r,-1);
	}
	if(ans==INF)printf("-1\n");
	else printf("%d\n",ans);
	return 0;
}
Problem4654

#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
typedef long long ll;
const int N = 8005;
// ---------- decimal lib start ----------
const int PREC=3010;
class Dec{
public:
    Dec();
    Dec(int x);
    bool is_zero() const;
    string to_string(int p) const;
    friend Dec operator + (const Dec &a,const Dec &b);
    friend Dec operator - (const Dec &a,const Dec &b);
    Dec & operator += (int x);
    Dec & operator += (ll x);
    Dec & operator -= (int x);
    Dec & operator /= (int x);
    friend Dec operator - (const Dec &a);
private:
    static const int len=PREC/9+1;
    static const int mo=1000000000;
    static void append_to_string(string &s,ll x);
    bool is_neg;
    ll integer;
    int data[len];
    void init_zero();
    void init(const char *s);
};
Dec::Dec(){init_zero();}
Dec::Dec(int x){
    init_zero();
    if(x<0){is_neg=1;x=-x;}
    integer=x;
}
void Dec::init_zero(){
    is_neg=0;
    integer=0;
    memset(data,0,len*sizeof(int));
}
bool Dec::is_zero()const{
    if(integer)return 0;
    for(int i=0;i<len;i++)if(data[i])return 0;
    return 1;
}
void Dec::init(const char *s){
    init_zero();
    is_neg=0;
    integer=0;
    while(*s!=0){
        if(*s=='-'){is_neg=1;++s;break;}
        else if(*s>=48&&*s<=57)break;
        ++s;
    }
    while(*s>=48&&*s<=57){integer=integer*10+*s-48;++s;}
    if(*s=='.'){
        int pos=0,x=mo/10;
        ++s;
        while(pos<len&&*s>=48&&*s<=57){
            data[pos]+=(*s-48)*x;
            ++s;x/=10;
            if(!x){++pos;x=mo/10;}
        }
    }
}
void Dec::append_to_string(string &s,ll x){
    if(x==0){s.append(1,48);return;}
    char _[30];
    int cnt=0;
    while(x){_[cnt++]=x%10;x/=10;}
    while(cnt--){s.append(1,_[cnt]+48);}
}
string Dec::to_string(int p)const{
    string ret;
    if(is_neg&&!is_zero())ret="-";
    append_to_string(ret,integer);
    ret.append(1,'.');
    for(int i=0;i<len;i++){
        int x=mo/10,tmp=data[i];
        while(x){
            ret.append(1,48+tmp/x);
            tmp%=x;x/=10;
            if(!--p)break;
        }
        if(!p)break;
    }
    if(p>0)ret.append(p,'0');
    return ret;
}
Dec & Dec::operator +=(ll x){
    if(!is_neg){
        if(integer+x>=0){integer+=x;}
        else{
            bool last=0;
            for(int i=len-1;i>=0;i--)
                if(last||data[i]){data[i]=mo-data[i]-last;last=1;}
                else last=0;
            integer=-x-integer-last;
            is_neg=1;
        }
    }else{
        if(integer-x>=0)integer-=x;
        else{
            bool last=0;
            for(int i=len-1;i>=0;i--)
                if(last||data[i]){data[i]=mo-data[i]-last;last=1;}
                else last=0;
            integer=x-integer-last;
            is_neg=0;
        }
    }
    return *this;
}
Dec & Dec::operator +=(int x){return *this+=(ll)x;}
Dec & Dec::operator -=(int x){return *this+=(ll)-x;}
Dec & Dec::operator /=(int x){
    if(x<0){is_neg^=1;x=-x;}
    int last=integer%x;
    integer/=x;
    for(int i=0;i<len;i++){
        ll tmp=1LL*last*mo+data[i];
        data[i]=tmp/x;
        last=tmp-1LL*data[i]*x;
    }
    if(is_neg&&!integer){
        int i;
        for(i=0;i<len;i++)if(data[i]!=0)break;
        if(i==len)is_neg=0;
    }
    return *this;
}
Dec operator -(const Dec &a){
    Dec ret=a;
    if(!ret.is_neg&&!ret.integer){
        int i;
        for(i=0;i<Dec::len;i++)if(!ret.data[i])break;
        if(i<Dec::len)ret.is_neg=1;
    }else ret.is_neg^=1;
    return ret;
}
Dec operator +(const Dec &a,int x){Dec ret=a;return ret+=x;}
Dec operator -(const Dec &a,int x){Dec ret=a;return ret-=x;}
Dec operator /(const Dec &a,int x){Dec ret=a;return ret/=x;}
Dec operator +(const Dec &a,const Dec &b){
    if(a.is_neg==b.is_neg){
        Dec ret=a;
        bool last=0;
        for(int i=Dec::len-1;i>=0;i--){
            ret.data[i]+=b.data[i]+last;
            if(ret.data[i]>=Dec::mo){ret.data[i]-=Dec::mo;last=1;}
            else last=0;
        }
        ret.integer+=b.integer+last;
        return ret;
    }else if(!a.is_neg)return a- -b;
    else return b- -a;
}
Dec operator -(const Dec &a,const Dec &b){return a+-b;}
// ---------- decimal lib end ----------
ld f[15][N],y[N];
int q[N],g[15][N],end[N];
ll h[N];
inline ld slope(int a,int b)
{
	return (y[b]-y[a])/(b-a);
}
int main()
{
	int n,k,p;
	scanf("%d%d%d",&n,&k,&p);
	scanf("%lld",&h[1]);
	for(int i = 2;i<= n;i++)
	{
		scanf("%lld",&h[i]);
		if(h[i]<=h[1])n--,i--;
	}
	sort(h+1,h+n+1);
	for(int i = 2;i<= n;i++)h[i]+=h[i-1];
	for(int i = 1;i<= n;i++)f[0][i] = h[1];
	k = min(k,n-1);int W = min(k,14);
	for(int i = 1;i<= W;i++)
	{
		int l = 1,r = 0;
		for(int j = 2;j<= n;j++)
		{
			y[j-1] = h[j-1]-f[i-1][j-1];
			while(l<r&&slope(q[r-1],q[r])>=slope(q[r],j-1))r--;
			q[++r] = j-1;
			y[j+1] = h[j];
			while(l<r&&slope(q[l],j+1)<=slope(q[l+1],j+1))l++;
			f[i][j] = slope(q[l],j+1);
			g[i][j] = q[l];
		}
	}
	end[W]=n-(k-W);
	for(int i = W;i;i--)end[i-1] = g[i][end[i]];
	Dec ans = Dec(h[1]);
	for(int i = 1;i<= W;i++)ans = (ans+h[end[i]]-h[end[i-1]])/(end[i]-end[i-1]+1);
	for(int i=end[W]+1;i<=n;i++)ans=(ans+h[i]-h[i-1])/2;
    cout<<ans.to_string(p+1);
}
Problem4668

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
int fa[N],h[N],v[N],dep[N],cnt;
int getfa(int x)
{
	if(fa[x] == x) return  x;
	else return getfa(fa[x]);
}
void pre(int x)
{
	if(fa[x]==x)return ;
	pre(fa[x]);
	dep[x] = dep[fa[x]]+1;
}
int Ask(int x,int y)
{
	pre(x),pre(y);
	if(dep[x]<dep[y])swap(x,y);
	int re = 0;
	while(dep[x]>dep[y]&&x!=y)
	{
		re = max(re,v[x]);
		x = fa[x];
	}
	while(x!=y)
	{
		re = max(re,max(v[x],v[y]));
		x = fa[x],y = fa[y];
	}
	return re;
}
int main()
{
	int n,m,lastans = 0;
	int opt,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)fa[i]=i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt,&x,&y);
		x^=lastans,y^=lastans;
		int fx = getfa(x),fy = getfa(y);
		if(opt==0)
		{
			cnt++;
			if(fx!=fy)
			{
				if(h[fx]<=h[fy])
				{
					fa[fx] = fy;v[fx] = cnt;
					h[fy]+=(h[fx]==h[fy]);
				}else
				{
					fa[fy] = fx;v[fy] = cnt;
				}
			}
		}else
		{
			if(fx!=fy)printf("%d\n",lastans = 0);
			else printf("%d\n",lastans=Ask(x,y));
		}
	}
}
Problem4724

#include <stdio.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long ll;
int n,q;
ll a[N];
int main()
{
	ll sum = 0;
	scanf("%d%d",&n,&q);
	for(int i = 0;i<n;i++)
	{
		scanf("%lld",&a[i]);
		(sum+=a[i]*i)%=(n-1);
	}
	if(sum)a[sum]--;
	for(int i = 1;i<n;i++)
		a[i]+=a[i-1];
	ll tmp = 0;
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld",&tmp);
		int ans = upper_bound(a,a+n,tmp)-a;
		if(ans==n)ans=-1;
		printf("%d\n",ans);
	}
	return 0;
}
Problem4725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 10005;
ll a[N],r[N];
ll dec[N];
struct Ans
{
	int j,i;ll val;
	bool operator<(const Ans &s)const
	{
		return val<s.val;
	}
}e[N];
int getans(ll x,int n)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(e[mid].val<x)l=mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int cnt = 0,tot=0;
	a[1] = 1,a[2] = 2;
	dec[++cnt] = 0,dec[++cnt]=1;
	for(int i = 3;;i++)
	{
		if(i&1)a[i] = a[i-1]*2;
		else a[i] = a[i-1]+r[i-1];
		for(int j = i;j;j--)
			dec[++cnt] = a[i]-a[j];
		sort(dec+1,dec+cnt+1);
		cnt = unique(dec+1,dec+cnt+1)-dec-1;
		for(int j = 1;j<=cnt;j++)
			if(dec[j]!=j-1)
				{r[i] = j-1;break;}
		if(!r[i])r[i]=cnt;
		if(a[i]-a[i-1]>10000000000ll){tot=i;break;}
	}
	int tmp = 0;
	for(int i = 1;i<= tot;i++)
		for(int j = 1;j<i;j++)
			e[++tmp] = (Ans){i,j,a[i]-a[j]};
	sort(e+1,e+tmp+1);
	int n;
	ll q;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&q);
		int t = getans(q,tmp);
		if(e[t].val==q)printf("%d %d\n",e[t].j,e[t].i);
		else
		{
			ll ans = q-t+1;
			printf("%lld %lld\n",tot+ans*2-1,tot+ans*2-2);
		}
	}
	return 0;
}
Problem4726

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const double eps = 1e-7;
struct E
{int next,to;}e[N<<1];
double f[N],ans;
int head[N],tot,n,k;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int size[N];
void get_size(int x)
{
	size[x] = 1;
	bool lef = true;
	for(int i = head[x];i;i=e[i].next)
	{
		lef = false;
		get_size(e[i].to);
		size[x]+=size[e[i].to];
	}
	if(lef)f[x] = 1;
	else
	{
		for(int i = head[x];i;i=e[i].next)
			f[x] = max(f[x],min(1.0*size[e[i].to]/(size[x]-1),f[e[i].to]));
	}
	if(size[x]>k)ans = max(ans,f[x]);
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 2;i<=n;i++)
	{
		int x;scanf("%d",&x);
		add(x,i);
	}
	get_size(1);
	printf("%.7lf",ans);
	return 0;
}
Problem4727

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
bool a[N][N],b[N][N],vis[N],bo[N];
int stack[N],top,dfn[N],low[N],nxt[N],Dfn,dcc,bel[N],que[N],size[N],m,p[N],n;
bool ins[N];
void join(int x)
{
	vis[x]=true;
	for(int i = 1;i<= m;i++)if(a[que[i]][x])bo[que[i]]=true;
}
void work()
{
	int head=que[1],tail=que[1];
	int x,y,i,j;
	for(i = 2;i<= m;i++)
	{
		x = que[i];
		if(a[x][head])
		{
			nxt[x] = head;
			head = x;
			continue;
		}
		for(j=head,y=0;y!=tail&&a[j][x];y=j,j=nxt[j]);
		if(y==tail)
		{
			nxt[tail]=x;
			tail = x;
		}else
		{
			nxt[x] = j,nxt[y] = x;
		}
	}
	int mid = head;
	join(head);
	while(mid!=tail)
	{
		x = nxt[mid];
		if(a[x][head])
		{
			mid = x;join(x);
			continue;
		}
		for(i=head;i!=mid && a[i][x];j=i,i=nxt[i]);
		if(i!=mid)
		{
			nxt[j]=x,nxt[mid]=head;
			mid = x,head = i;join(x);
		}else
		{
			for(i = 1;i<= m;i++)if(!vis[que[i]] && bo[que[i]])break;
			for(j=head;j!=mid && a[j][que[i]];j = nxt[j]);
			for(y = nxt[mid];;y=nxt[y])
			{
				join(y);
				if(y==que[i])break;
			}
			nxt[mid] = head;head = j;mid = que[i];
			for(j=head,i=nxt[head];i!=head;j=i,i=nxt[i]);
			nxt[j] = x;
		}
	}
	for(int i = 1;i<= m;i++)bo[que[i]]=vis[que[i]]= false;
	nxt[tail]=head;
}
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = 1;i<=n;i++)if(a[x][i])
	{
		if(!dfn[i])
		{
			tarjan(i);
			low[x] = min(low[x],low[i]);
		}else if(ins[i])
			low[x] = min(low[x],dfn[i]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;p[dcc]=x;
		int tmp;m=0;
		do
		{
			tmp = stack[top--];
			ins[tmp]=false;
			bel[tmp]=dcc;
			size[dcc]++;que[++m]=tmp;
		}while(tmp!=x);
		work();
	}
}
int f[N],g[N];
int dp(int x)
{
	if(f[x])return f[x];
	int y,z;
	for(y=1;y<=dcc;y++)if(b[x][y])
	{
		z=dp(y);
		if(z>f[x])
		{
			g[x] = y;
			f[x] = z;
		}
	}f[x]+=size[x];
	return f[x];
}
void print(int x)
{
	if(!x)return ;
	int y;printf(" %d",x);
	for(y =nxt[x];y!=x;y=nxt[y])
	{
		printf(" %d",y);
	}
	print(p[g[bel[x]]]);
}
int main()
{
	scanf("%d",&n);
	for(int j = 2;j<=n;j++)
		for(int i = 1;i<j;i++)
		{
			scanf("%d",&a[i][j]);
			a[j][i]=!a[i][j];
		}
	for(int i = 1;i<= n;i++)if(!dfn[i])tarjan(i);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(bel[i]!=bel[j])
				b[bel[i]][bel[j]]|=a[i][j];
	for(int i = 1;i<= dcc;i++)f[i]=dp(i);
	for(int i = 1;i<= n;i++)
	{
		printf("%d",f[bel[i]]);
		print(i);printf("\n");
	}
	return 0;
}
Problem4731

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;  
#define MAXN 1000005  
#define MAXM 1000005  
#define INF 1000000000  
#define MOD 1000000007  
#define eps 1e-8  
#define ll long long  
int n,m;  
int M=1;  
int a[MAXN];  
ll c[MAXN];  
ll len[MAXN];  
int tot;  
int L[MAXN],R[MAXN];  
int ta[MAXN];  
void cal(int l,int r,int d){  
    int i,j;  
    if(!d)
        return ;  
    int t=0;  
    int lst=l;  
    for(i=l;i<=r;i++)
    {  
        t++;  
        if(t==len[d-1]||i==r)
        {  
            cal(lst,i,d-1);  
            lst=i+1;  
            t=0;  
        }  
    }  
    t=0;  
    lst=l;  
    tot=0;  
    for(i=l;i<=r;i++)
    {  
        t++;  
        if(t==len[d-1]||i==r)
        {  
            tot++;  
            L[tot]=lst;  
            R[tot]=i;  
            lst=i+1;  
            t=0;  
        }  
    }  
    for(i=tot;i>1;i--)
    {  
        for(j=L[i];j<=R[i];j++)
        {  
            c[j]-=c[j-len[d-1]];  
        }  
    }  
}  
int main()
{  
    int i;  
    scanf("%d",&n);  
    for(i=1;i<=n;i++)
    {  
        scanf("%d",&a[i]);  
    }  
    int tn=0;  
    for(i=1;i<=n;i++)
    {  
        if(a[i]!=1)
        {  
            ta[++tn]=a[i];  
        }  
    }  
    scanf("%d",&m);  
    ta[tn+1]=m;  
    for(i=1;i<=m;i++)
    {  
        scanf("%lld",&c[i]);  
    }  
    len[0]=1;  
    for(i=1;i<=tn+1;i++)
    {  
        len[i]=len[i-1]*ta[i];  
        if(len[i]>=m)
        {  
            cal(1,m,i);  
            break;  
        }  
    }  
    printf("%d\n",n);  
    for(i=1;i<=n;i++)
    {  
        printf(i==n?"%d\n":"%d ",a[i]);  
    }  
    printf("%d\n",m);  
    for(i=1;i<=m;i++)
    {  
        printf(i==m?"%lld\n":"%lld ",c[i]);  
    }  
    return 0;  
}  
Problem4753

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2505;
const double eps = 1e-8;
const double INF = 1e9;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double dp[N][N],ans,p[N],s[N],size[N],g[N];
int K;
void dfs(int x)
{
	size[x] = 0;
	dp[x][0] = 0;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		for(int j = 0;j<= size[x]+size[e[i].to];j++)g[j] = -INF;
		for(int j = 0;j<= size[x];j++)
			for(int k = 0;k<= size[e[i].to];k++)
				g[j+k] = max(g[j+k],dp[x][j]+dp[e[i].to][k]);
		for(int j = 0;j<= size[x]+size[e[i].to];j++)dp[x][j] = max(dp[x][j],g[j]);
		size[x]+=size[e[i].to];
	}
	for(int j = size[x];j>= 0;j--)
		dp[x][j+1]=dp[x][j]+p[x]-s[x]*ans;
	dp[x][0] = 0;
	size[x]++;
}
int main()
{
	int n,fa;
	scanf("%d%d",&K,&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf%d",&s[i],&p[i],&fa);
		add(fa,i);
	}
	double l = 0,r = 10001;
	while(fabs(l-r)>0.0001)
	{
		double mid = (l+r)/2;
		ans = mid;
		for(int i = 0;i<= n;i++)
			for(int j = 0;j<=n;j++)dp[i][j]=-INF;
		dfs(0);
		if(dp[0][K+1]>0)l=mid;
		else r = mid;
	}
	printf("%.3lf\n",l);
	return 0;
}
Problem4755

#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
const int mod1 = 130117;
const int mod2 = 600011;
const int seed = 37;
int a[N<<1], b[N<<1], sum[N<<1][2], num[N<<1][2], mi[N<<1][2], F[N<<1], G[N<<1];
int n, m, ans, l, r;
bool judge(int l1,int r1,int l2,int r2) 
{
    int x,y;
    int mod = mod1;
    x = (LL)(sum[r1][0]-(LL)sum[l1-1][0]*mi[r1-l1+1][0]%mod)%mod;
    y = (LL)(num[l2][0]-(LL)num[r2+1][0]*mi[r2-l2+1][0]%mod)%mod;
    (x+=mod)%=mod, (y+=mod)%=mod;
    if(x!=y) return 0;
    mod = mod2;
    x = (LL)(sum[r1][1]-(LL)sum[l1-1][1]*mi[r1-l1+1][1]%mod)%mod;
    y = (LL)(num[l2][1]-(LL)num[r2+1][1]*mi[r2-l2+1][1]%mod)%mod;
    (x+=mod)%=mod, (y+=mod)%=mod;
    if(x!=y) return 0;
    return 1;
}
inline int solve(int j,int k) 
{
    int l = 0, r = min( j, n-k+1);
    while(l < r) 
    {
        int mid = (l+r+1)>>1;
        if(judge(j-mid+1,j,k,k+mid-1)) l = mid;
        else r = mid - 1;
    }
    return l;
}
char s[N];
int main() 
{
    scanf("%d",&n);
    mi[0][0] = mi[0][1] = 1;
    for(int i=1;i<=n;++i) 
    {
        mi[i][0] = (LL)mi[i-1][0]*seed%mod1;
        mi[i][1] = (LL)mi[i-1][1]*seed%mod2;
    }
    a[0] = b[0] = 0; 
    a[2*n+2] = b[2*n+2] = 28;
    a[1] = b[1] = 27;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i) 
        a[i<<1] = s[i] - 'A' + 1,a[i<<1|1] = 27;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i) 
        b[i<<1] = s[i] - 'A' + 1,b[i<<1|1] = 27;
    int j = 0;
    for(int i=2;i<=(n<<1);++i) 
    {
        if(i <= F[j]+j) F[i] = min(F[2*j-i],j+F[j]-i);
        while(a[i-F[i]-1] == a[i+F[i]+1]) F[i] ++;
        if(i+F[i]>j+F[j]) j = i;
    }
    j = 0;
    for(int i=2;i<=(n<<1);++i) 
    {
        if(i <= j+G[j]) G[i] = min(G[2*j-i],j+G[j]-i);
        while(b[i-G[i]-1] == b[i+G[i]+1]) G[i] ++;
        if(i+G[i]>j+G[j]) j = i;
    }
    for(int i=2;i<=(n<<1);++i) ans = max(ans,max(F[i],G[i]));
    for(int i=1;i<=n;++i) 
    {
        sum[i][0] = (LL)((LL)sum[i-1][0]*seed%mod1+a[i<<1])%mod1;
        sum[i][1] = (LL)((LL)sum[i-1][1]*seed%mod2+a[i<<1])%mod2;
    }
    for(int i=n;i>=1;--i) 
    {
        num[i][0] = (LL)((LL)num[i+1][0]*seed%mod1+b[i<<1])%mod1;
        num[i][1] = (LL)((LL)num[i+1][1]*seed%mod2+b[i<<1])%mod2;
    }
    for(int i=2;i<=(n<<1);++i) 
    {
        l = i - F[i], r = i + F[i];
        l = (l+1) >> 1; r >>= 1;
        ans = max(ans,F[i]+solve(l-1,r)*2);
    }
    for(int i=2;i<=(n<<1);++i) 
    {
        l = i - G[i], r = i + G[i];
        l = (l+1) >> 1, r >>= 1;
        ans = max(ans,G[i]+solve(l,r+1)*2);
    }
    printf("%d\n",ans);
}
Problem4762

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int S = 1<<10;
struct data
{
	int f;
	void operator +=(const data &s)
	{
		f = f+s.f>=mod?f+s.f-mod:f+s.f;
	}
	void operator -=(const data &s)
	{
		f = f-s.f>=0?f-s.f:f-s.f+mod;
	}
}f[2][S][S];
int a[S];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),a[i] = (S-1)^a[i];
	int now = 1,pre = 0,i,j,k;
	f[0][0][0].f=1;
	for(i = 1;i<= n;i++)
	{
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[now][j][k].f = 0;
				if(!k)break;
			}
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[now][j|a[i]][k^(k&a[i])]+=f[pre][j][k];
				f[now][j|a[i]][k^(k&a[i])|a[i]^(a[i]&j)]-=f[pre][j][k];
				if(!k)break;
			}
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[pre][j][k] += f[now][j][k];
				if(!k)break;
			}
		//swap(now,pre);
	}
	printf("%d\n",f[pre][S-1][0].f);
	return 0;
}
Problem4763

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int MD = 320;
const int S = 65540;
const int ss = 65535;
int cnt[S];
typedef unsigned long long ull;
ull MAXN = 0;
struct Bitset
{
	ull s[470];
	int len;
	void clear()
	{memset(s,0,sizeof(s));len = 0;}
	void operator |=(const int &x){s[x>>6] |= 1ll<<(x&63);len = max(len,x>>6);}
	void operator |=(const Bitset &y)
	{
		len = max(len,y.len);
		for(int i = 0;i<=len;i++)
			s[i]|=y.s[i];
	}
	int num()
	{
		int res = 0;
		for(int i = 0;i<=len;i++)
			res+=cnt[s[i]>>48]+cnt[(s[i]>>32)&ss]+cnt[(s[i]>>16)&ss]+cnt[s[i]&ss];
		return res;
	}
	int getans()
	{
		for(int i = 0;i<470;i++)if(s[i]!=MAXN)
			for(int j = 0;j<64;j++)
				if(!(s[i]&((ull)1<<j)))
					return i*64+j;
	}
}b[325][325],ans;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int mark[N],rtnum,rt[N],n,m,flag;
int size[N],dep[N],mx[N],top[N],fa[N][18],w[N];
void dfs(int x)
{
	mx[x] = dep[x];
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			dep[e[i].to] = dep[x]+1;
			fa[e[i].to][0] = x;
			dfs(e[i].to);
			mx[x] = max(mx[x],mx[e[i].to]);
		}
	if(mx[x]-dep[x]>=MD||x==1)
	{
		mark[x] = ++rtnum;
		rt[rtnum] = x;
		mx[x] = 0;
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}

int main()
{
	int x,y;
	scanf("%d%d%d",&n,&m,&flag);
	for(int i = 0;i<64;i++)MAXN = MAXN<<1|1;
	for(int i = 0;i<S;i++)
		for(int j = i;j;j-=j&(-j))
			cnt[i]++;
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dep[1] = 1;
	dfs(1);
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
	for(int i = 1;i<= rtnum;i++)
	{
		Bitset now;
		now.clear();
		now|=w[rt[i]];b[i][i] = now;
		for(int t = fa[rt[i]][0];t;t=fa[t][0])
		{
			now|=w[t];
			if(mark[t])
			{
				b[i][mark[t]] = now;
				if(!top[rt[i]])top[rt[i]] = t;
			}
		}
	}
	int nn,last = 0;
    for(int i=1;i<=m;++i)
    {
        ans.clear();scanf("%d",&nn);
        for(int j=1;j<=nn;++j)
        {
        	scanf("%d%d",&x,&y);
            int xx,yy;
            if(flag) x^=last,y^=last;
            int z=lca(x,y);ans|=w[x];ans|=w[y];
            for(;!mark[x]&&dep[x]>dep[z];)
                x=fa[x][0],ans|=w[x];
            for(;!mark[y]&&dep[y]>dep[z];)
                y=fa[y][0],ans|=w[y];
            for(xx=x;dep[top[xx]]>=dep[z];xx=top[xx]);
            for(yy=y;dep[top[yy]]>=dep[z];yy=top[yy]);
            ans|=b[mark[x]][mark[xx]];
            ans|=b[mark[y]][mark[yy]];
            for(;xx!=yy;)
            {
                if(dep[xx]<dep[yy]) swap(xx,yy);
                xx=fa[xx][0];ans|=w[xx];
            }
        }
        int x=ans.num(),y=ans.getans();
        last=x+y;
        printf("%d %d\n",x,y);
    }
	return 0;
}
Problem4770

#include<cstdio>
#include<algorithm>
using namespace std;
#define MAXN 1010
#define MAXM 1010
typedef long long ll;
ll biao[MAXN][MAXN]={{},{0,0,0,0,0,0,0,0,0,},{0,129140164,129140165,129140167,129140171,129140179,129140195,129140227,129140291,},{0,193710246,64570084,24213786,236084373,77181450,157515737,140774228,215031499,},{0,225995287,121068906,238102183,203547108,218712265,116264831,99443036,79121964,},{0,112997644,108962016,46788094,36549268,117877184,14509798,100438248,107231500,},{0,185638986,53976556,134689163,96426552,194242540,153639990,120659378,101104631,},{0,221959657,227256424,124881873,171543395,157647025,162557411,23785165,258144187,},{0,110979829,87995657,38609442,206828800,253024756,206227824,141710270,10320181,},{0,55489915,109955160,56272067,231265411,63090854,237048705,171426005,85709662,},{0,27744958,238738659,7008635,102222843,120595225,256801988,235521295,180619543,},{0,143012643,24411822,194556475,215231251,130161896,73648531,208001599,170619964,},{0,71506322,157216049,153352677,156238751,192264872,27770309,226347497,54161031,},{0,164893325,184923874,246796406,52697789,171780083,21983921,223228206,185664220,},{0,82446663,171588386,198224372,24087433,169856546,85584783,15039313,51032118,},{0,41223332,233770283,237290397,226108046,172324917,242546032,177098806,40173324,},{0,149751830,40172257,206855876,234897786,42845559,190284536,34527590,26337201,},{0,204016079,44767891,130125758,198580206,248091586,33588797,142939578,109276637,},{0,102008040,53378114,117153053,140321556,207663118,231585645,18039713,42557731,},{0,180144184,222551860,141542926,124678758,256378666,58621640,169814611,164503795,},{0,219212256,51118260,22017057,107400239,71063488,208194809,141040710,82368253,},{0,238746292,9389787,73404282,197290983,187666354,33421568,243481387,230191654,},{0,248513310,258085441,206092103,175865014,46934405,238338656,34885039,160507772,},{0,253396819,46472091,52427070,10622380,31557757,78236842,121818911,78588165,},{0,126698410,14223592,100655489,4793966,28513326,106020021,130112147,61905360,},{0,192489369,53937637,55392462,243667232,206236595,2350355,2101084,238304638,},{0,96244685,115840796,252931583,12885294,108834416,142226001,41501066,77317254,},{0,48122343,186440092,145791627,175931570,191171533,54681626,171376190,8284899,},{0,24061172,35579780,244199696,219925978,194916377,159910040,18680912,56283054,},{0,141170750,129762427,191545910,85767863,96762108,75032252,68489928,100763661,},{0,199725539,123091219,123096044,64432902,33418232,219199667,205120656,160043295,},{0,99862770,147188326,236754524,80629277,18247771,18374728,15226623,146765106,},{0,179071549,43396121,1036568,86131407,196354204,129359671,55657413,95474816,},{0,89535775,177223515,164355065,176671379,141757722,64001077,97905256,148393376,},{0,44767888,56089100,9744293,28759687,254183618,187978963,48484166,10384133,},{0,151524108,71287253,195783672,235105036,63372602,48706668,248893454,173302144,},{0,204902218,189910711,57376262,237466820,231810127,127325080,116537614,29856382,},{0,231591273,257256954,207490218,200639665,46244374,29857601,109793313,58979680,},{0,115795637,205506176,45896798,234868496,29541064,251294633,256749187,63816439,},{0,57897819,124985457,245728025,115443775,144062289,195058805,171514012,53312683,},{0,28948910,21882968,223817069,76823424,21491759,227107331,131344269,97420818,},{0,143614619,14590716,250142242,217871110,158025913,120380172,59940904,105696964,},{0,71807310,75057742,38795205,80612780,246470934,120257251,3687048,158432457,},{0,165043819,201462147,168744597,172739460,61176618,38568071,97892751,11175058,},{0,82521910,219673862,27383363,66850809,196775038,6183180,92038631,31326683,},{0,170401119,101187108,75392768,51235977,45924565,86039077,51855151,254177214,},{0,85200560,221423464,251701329,91563073,211230946,180879303,101994951,244856176,},{0,171740444,202450882,103638399,9527704,148889553,41207463,141727928,145038853,},{0,215010386,225504065,114480260,68277350,11820640,1248372,121446262,9716295,},{0,236645357,26119321,236275454,147928086,206426334,162743844,101312146,105149937,},{0,118322679,258260157,59715480,13946009,169602037,225439100,30268418,150919282,},};
int n,m;
int main(){
    scanf("%d%d",&n,&m);
    printf("%lld\n",biao[n][m]);
}
Problem4771

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
set<int>S[N];
set<int>::iterator it;
int fa[N][18],dep[N],col[N],in[N],out[N],Dfn,seq[N],a[N];
struct E
{int next,to;}e[N];
int head[N],tot,mx;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
void dfs(int x)
{
	dep[x] = dep[fa[x][0]]+1;
	mx = max(mx,dep[x]);
	in[x] = ++Dfn;seq[Dfn] = x;
	for(int i = 1;i<= 17;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	out[x] = Dfn;
}
int lca(int x,int y)
{
	if(dep[y]>dep[x])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int tr[N*100],ls[N*100],rs[N*100],cnt,root[N],n,m;
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	ls[p] = ls[pre],rs[p] = rs[pre];
	tr[p] = tr[pre]+val;
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
}
int getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
void init()
{
	for(int i = 1;i<= cnt;i++)tr[i]=ls[i]=rs[i]=0;
	cnt = 0;
	Dfn = 0;tot = 0;
	for(int i = 1;i<= n;i++)head[i]=0,root[i]=0;
	for(int i = 1;i<= n;i++)S[i].clear();
	mx = 0;
}
bool cmp(int x,int y)
{
	return dep[x]==dep[y]?in[x]<in[y]:dep[x]<dep[y];
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)scanf("%d",&col[i]),a[i]=i;
		for(int i = 2;i<= n;i++)scanf("%d",&fa[i][0]),add(fa[i][0],i);
		dfs(1);
		sort(a+1,a+n+1,cmp);
		int tmp1,tmp2;
		for(int i = 1;i<= n;i++)
		{
			if(dep[a[i]]==dep[a[i-1]])
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[a[i]],1);
			else 
				update(root[dep[a[i]]],root[dep[a[i]]-1],1,n,in[a[i]],1);
			it = S[col[a[i]]].upper_bound(in[a[i]]);
			tmp1 = tmp2 = 0;
			if(it!=S[col[a[i]]].end())
			{
				tmp1 = (*it);
				tmp1 = seq[tmp1];
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp1,a[i])],-1);
			}
			if(it!=S[col[a[i]]].begin())
			{
				it--;
				tmp2 = (*it);
				tmp2 = seq[tmp2];
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp2,a[i])],-1);
			}
			if(tmp1&&tmp2)
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp1,tmp2)],1);
			S[col[a[i]]].insert(in[a[i]]);
		}
		int x,d,ans=0;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&d);
			x = x^ans,d = d^ans;
			ans = getans(root[min(dep[x]+d,mx)],1,n,in[x],out[x]);
			printf("%d\n",ans);
		}
		init();
	}
	return 0;
}
Problem4772

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2001;
const int mod = 1e9+7;
const int S = 1e7;
int gcd[N][N],pow[N][N],f[N][N],sum[N],b[N];
int g[S+5],tmp[S+5];
bool vis[S+5];
int prime[S/10],cnt,a[100005],n,K,p;
void Pre()
{
	sum[n] = 1;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= n;j++)
		{
			if(i==1||j==1)f[i][j] = 1;
			else if(i==j)f[i][j] = (f[i][j-1]+1)%mod;
			else if(i<j)f[i][j] = f[i][j-1];
			else f[i][j] = (f[i-j][j]+f[i][j-1])%mod;
		}
		sum[n-i]=f[i][i];
	}
	g[0] = 0,g[1] = 1;
	for(int i = 2;i<= S;i++)
	{
		if(!vis[i])
		{
			prime[++cnt]=tmp[i]=i;
			g[i] = 2*i-2;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<=S;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
			{
				tmp[i*prime[j]] = prime[j];
				g[i*prime[j]] = (ll)g[i]*g[prime[j]]%mod; 
			}else
			{
				tmp[i*prime[j]] = tmp[i]*prime[j];
				if(tmp[i]!=i)g[i*prime[j]] = (ll)g[i/tmp[i]]*g[tmp[i]*prime[j]]%mod;
				else g[i*prime[j]] = ((ll)g[i]*prime[j]+i*(prime[j]-1))%mod;
				break;
			}
		}
	}
	for(int i = 1;i<= n;i++)gcd[i][0]=gcd[0][i]=gcd[i][i]=i,gcd[i][1]=gcd[1][i]=1;
	for(int i = 2;i<= n;i++)
		for(int j = 2;j<= i;j++)
		{
			if(!gcd[i][j])gcd[i][j] = gcd[j][i-j];
			gcd[j][i] = gcd[i][j];
		}
	for(int i = 1;i<= n;i++)pow[i][0]=1,pow[i][1] = i;
	for(int i = 1;i<= n;i++)
		for(int j = 2;j<= n;j++)
			pow[i][j] = 1ll*pow[i][j-1]*i%K;
}
int F(int x,int y)
{
	if(p==1)return 1%K;
	if(p==2)return gcd[x][y]%K;
	if(p==3)return (pow[x][y]+pow[y][x]+(x^y))%K;
}
inline void add(int &x,const int &y)
{
	x+=y;
	if(x>=mod)x-=mod;
}
int Cnt[S+5];
int main()
{
	scanf("%d%d%d",&p,&n,&K);
	for(int i = 0;i<K;i++)scanf("%d",&a[i]);
	Pre();
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n-i;j++)
            for(int muli=1;muli*i+j<=n;muli++)
                for(int mulj=1;mulj*j+muli*i<=n;mulj++)
                    add(Cnt[F(i,j)],sum[muli*i+mulj*j]);
	int ans = 0;
    for(int i=0;i<K;i++) ans+=1LL*g[a[i]]*Cnt[i]%mod,ans%=mod;
    for(int i=1;i<=n;i++)
    {
        for(int muli=1;muli*i<=n;muli++)
        {
            int Tmp=1LL*muli*(muli-1)/2*(sum[muli*i]-sum[(muli+1)*i]+mod)%mod;
            add(ans,1LL*g[a[F(i,i)]]*Tmp%mod);
        }
    }
    printf("%d\n",ans);
	return 0;
}
Problem4773

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
struct E
{int next,to,val;}e[N*N];
int head[N],tot;
void add(int x,int y,int f)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;}
int f[2][N][N];
int main()
{
	int n,m,x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	memset(f,0x3f,sizeof(f));
	int now = 0,pre = 1;
	for(int i = 1;i<= n;i++)f[pre][i][i]=0;
	for(int ans = 1;ans<= n;ans++)
	{
		memset(f[now],0x3f,sizeof(f[now]));
		for(int st = 1;st<= n;st++)
			for(int pe = 1;pe<= n;pe++)
				for(int i = head[pe];i;i=e[i].next)
					f[now][st][e[i].to] = min(f[now][st][e[i].to],f[pre][st][pe]+e[i].val);
		for(int i = 1;i<= n;i++)
			if(f[now][i][i]<0)
			{
				printf("%d\n",ans);
				return 0;
			}
		swap(now,pre);
	}
	printf("0");
	return 0;
}
Problem4774

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<8;
const int N = 1e4+5;
const int INF = 0x3f3f3f3f;
int dis[S][N];
bool vis[N];
queue<int>Q;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,ans[S];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}

void spfa(int dis[])
{
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].val)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
}
int n,m,d;
bool check_sta(int s)
{
	bool flag = true;
	for(int i = 1;i<= d;i++)
		flag&= ((s>>(i-1))&1)==((s>>(2*d-i))&1);
	return flag;
}
int main()
{
	int x,y,z;
	scanf("%d%d%d",&n,&m,&d);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	memset(dis,0x3f,sizeof(dis));
	for(int i = 1;i<= d;i++)dis[1<<(i-1)][i] = 0;
	for(int i = 1;i<= d;i++)dis[1<<(2*d-i)][n-i+1] = 0;
	int end = 1<<(2*d);
	for(int s = 0;s<end;s++)
	{
		for(int i = 1;i<= n;i++)
		{
			for(int t = s;t;t=(t-1)&s)
				dis[s][i] = min(dis[s][i],dis[t][i]+dis[s^t][i]);
			if(dis[s][i]!=INF)Q.push(i),vis[i]=true;
		}
		spfa(dis[s]);
	}
	memset(ans,0x3f,sizeof(ans));
	for(int s = 0;s<end;s++)
		if(check_sta(s))
			for(int i = 1;i<= n;i++)
				ans[s] = min(ans[s],dis[s][i]);
	for(int s = 0;s<end;s++)
		for(int t = s;t;t = (t-1)&s)
			ans[s] = min(ans[s],ans[s^t]+ans[t]);
	if(ans[end-1]!=INF)printf("%d\n",ans[end-1]);
	else puts("-1");
	return 0;
}
Problem4775

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#define fir first
#define sec second
using namespace std;

const int N = 1e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,dep[N],fa[N][18];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x)
{
	dep[x] = dep[fa[x][0]]+1;
	for(int i = 1;i<= 17;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			fa[e[i].to][0] = x;
			dfs(e[i].to);
		}
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int getdis(int x,int y)
{
	return dep[x]+dep[y]-2*dep[getlca(x,y)];
}
bool used[N];
int size[N],f[N],sum,root;
void get_root(int x,int pre)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}	
void get_size(int x,int pre)
{
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
		{
			get_size(e[i].to,x);
			size[x]+=size[e[i].to];
		}
}
vector<int>E[N];
int father[N];
pair<double,double>A[N];
double w[N],d[N],pw[N],pd[N],A1[N],pA1[N],A2[N],pA2[N],A3[N],pA3[N];
void build(int x,int pre)
{
	get_size(x,0);
	sum = size[x];
	f[root = 0]=sum;
	get_root(x,0);
	x = root;
	father[x] = pre;
	used[x] = true;
	E[pre].push_back(x);
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
			build(e[i].to,x);
}
inline void Add(int x)
{
	double y = A[x].fir*(1-A[x].fir);
	w[x]+=A[x].fir,A3[x]+=y;
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		d[father[i]]+=D*A[x].fir;pd[i]+=D*A[x].fir;
		w[father[i]]+=A[x].fir;pw[i]+=A[x].fir;

		A1[father[i]]+=D*D*y;pA1[i]+=D*D*y;
		A2[father[i]]+=D*2*y;pA2[i]+=D*2*y;
		A3[father[i]]+=y;pA3[i]+=y;
	}
}
inline void Del(int x)
{
	double y = A[x].fir*(1-A[x].fir);
	w[x]-=A[x].fir,A3[x]-=y;
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		d[father[i]]-=D*A[x].fir;pd[i]-=D*A[x].fir;
		w[father[i]]-=A[x].fir;pw[i]-=A[x].fir;

		A1[father[i]]-=D*D*y;pA1[i]-=D*D*y;
		A2[father[i]]-=D*2*y;pA2[i]-=D*2*y;
		A3[father[i]]-=y;pA3[i]-=y;
	}
}
inline void update(int x,double p)
{
	double k0 = p/100.0,k1 = (100.0-p)/100.0;
	Del(x);
	A[x] = make_pair(A[x].fir*k1+A[x].sec*k0,A[x].fir*k0+A[x].sec*k1);
	Add(x);
}
inline void getans(int x)
{
	double ans1 = d[x],ans2 = A1[x];
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		ans1 += d[father[i]]-pd[i]+D*w[father[i]]-D*pw[i];
		ans2 += A1[father[i]]-pA1[i]+D*A2[father[i]]-D*pA2[i]+D*D*A3[father[i]]-D*D*pA3[i];
	}
	printf("%.13f\n",ans1*ans1+ans2);
}
int main()
{
	//freopen("x.in","r",stdin);
	//freopen("x.out","w",stdout);
	int n,m,x,y,id;
	double p;
	scanf("%d%d%d",&id,&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&x),A[i]=make_pair(x,x^1);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1);
	build(1,0);
	for(int i = 1;i<= n;i++)Add(i);
	int opt;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%lf",&x,&p);
			update(x,p);
		}else
		{
			scanf("%d",&x);
			getans(x);
		}
	}
	return 0;
}
Problem4796

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
char str[N];
int s[N];
int check(vector<int> &a)
{
	int ans = 0;
	for(int i = 0;i+1<a.size();i++)
		ans+=a[i]^a[i+1];
	return ans+1;
}
int main()
{
	scanf("%s",str);
	int n = strlen(str)/3;
	for(int i = 0;i<3*n;i++)
		s[i] = str[i]-'0';
	vector<int>ans;
	for(int i = 0;i<n;i++)
	{
		vector<int>a;
	  	a.clear();
		for(int j = -1;j<= 2;j++)
		{
			if(i==0&&j==-1)a.push_back(0);
			else a.push_back(s[i*3+j]);
		}
		if(check(a)>=3)continue;
		a[1]^=1,a[2]^=1;
		if(check(a)>=3)
		{
			s[i*3]^=1;s[i*3+1]^=1;
			ans.push_back(i*3);
			continue;
		}
		a[1]^=1,a[2]^=1;

		a[2]^=1,a[3]^=1;
		assert(check(a)>=3);
		s[i*3+1]^=1,s[i*3+2]^=1;
		ans.push_back(3*i+1);
	}
	int sz = ans.size();
	printf("%d\n",sz);
	for(int i = 0;i<sz;i++)
	{
		printf("%d",ans[i]+1);
		if(i==sz-1)printf("\n");
		else printf(" ");
	}
	return 0;
}
Problem4804

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int prime[N/10],cnt;
bool vis[N];ll F[N];
void quick_shai()
{
	F[1] = 1;
	for(int i = 2;i< N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			F[i] = i-2;
		}
		for(int j = 1;j<= cnt&&(ll)i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)
			{
				if((i/prime[j])%prime[j]!=0)
					F[i*prime[j]] = F[i/prime[j]]*(prime[j]-1)*(prime[j]-1);
				else 
					F[i*prime[j]] = F[i]*prime[j];
				break;
			}
			else 
				F[i*prime[j]] = F[i]*F[prime[j]];
		}
	}
	for(int i = 1;i<N;i++)F[i]+=F[i-1];
}
ll Solve(int n)
{
	int l,r,t; 
	ll ret=0;
	for(l = 1;l*l<= n;l++)
		t=n/l,ret+=(ll)t*t*(F[l]-F[l-1]);
	for(t = n/l;l<= n;l=r+1,t--)
		r=n/t,ret+=(ll)t*t*(F[r]-F[l-1]);
	return ret;
}
int main()
{
	int cas,n;
	quick_shai();
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d",&n);
		printf("%lld\n",Solve(n));
	}
	return 0;
}
Problem4810

#include <stdio.h>
#include <math.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int bel[N];
bitset<N>f,g;
struct Ask
{
	int opt,l,r,x,id;
	Ask(){}
	Ask(int _opt,int _l,int _r,int _x,int _id):opt(_opt),l(_l),r(_r),x(_x),id(_id){}
	bool operator<(const Ask &s)const 
	{
		if(bel[l]==bel[s.l])return r<s.r;
		return bel[l]<bel[s.l];
	}
}ask[N];
int cnt[N],ans[N],a[N];
void Del(int x)
{
	cnt[x]--;
	if(cnt[x]==0)f[x]=0,g[100000-x]=0;
}
void Add(int x)
{
	cnt[x]++;
	if(cnt[x]==1)f[x]=1,g[100000-x]=1;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int bl = sqrt(n)+1;
	for(int i = 1;i<= n;i++)bel[i] = i/bl+1;
	for(int i = 1;i<= m;i++)
	{
		int l,r,opt,x;
		scanf("%d%d%d%d",&opt,&l,&r,&x);
		ask[i] = Ask(opt,l,r,x,i);
	}
	sort(ask+1,ask+m+1);
	int l = 0,r = 0;
	for(int i = 1;i<= m;i++)
	{
		while(l<ask[i].l)Del(a[l]),l++;
		while(l>ask[i].l)l--,Add(a[l]);
		while(r<ask[i].r)r++,Add(a[r]);
		while(r>ask[i].r)Del(a[r]),r--;
		if(ask[i].opt==1)
		{
			if(((f>>ask[i].x)&f).any())ans[ask[i].id] = 1;
			else ans[ask[i].id] =0;
		}
		else if(ask[i].opt==2)
		{
			if(((g>>(100000-ask[i].x))&f).any())ans[ask[i].id] = 1;
			else ans[ask[i].id] =0;
		}
		else
		{
			for(int j = 1;j*j<=ask[i].x;j++)
				if(ask[i].x%j==0)
					if(f[j]==1&&f[ask[i].x/j]==1)
						{ans[ask[i].id] = 1;break;}
			if(ask[i].x==0&&f[0]==1)
				ans[ask[i].id] = 1;
		}
	}
	for(int i= 1;i<= m;i++)
		if(ans[i])printf("yuno\n");
		else printf("yumi\n");
	return 0;
}
Problem4811

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef unsigned long long ull;
int Opt[N],n,m,k;ull Val[N];
struct Seg
{
	ull v0,v1;
	Seg(){}
	Seg(int opt,ull x)
	{
		if(opt==1)
		{
			v0 = 0&x;
			v1 = (~0)&x;
		}else if(opt==2)
		{
			v0 = 0|x;
			v1 = (~0)|x;
		}else
		{
			v0 = 0^x;
			v1 = (~0)^x;
		}
	}
	Seg operator +(const Seg &s)const
	{
		Seg ans;
		ans.v0 = (v0&s.v1)|((~v0)&s.v0);
		ans.v1 = (v1&s.v1)|((~v1)&s.v0);
		return ans;
	}
}trl[N<<2],trr[N<<2];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],fa[N],top[N],son[N],size[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			if(size[e[i].to]>size[son[x]])son[x]=e[i].to;
			size[x]+=size[e[i].to];
		}
}
int Dfn,dfn[N],seq[N];
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		trl[p] = trr[p] = Seg(Opt[seq[l]],Val[seq[l]]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	trl[p] = trl[p<<1]+trl[p<<1|1];
	trr[p] = trr[p<<1|1]+trr[p<<1];
}
void Update(int p,int l,int r,int pos,ull val)
{
	if(l==r)
	{
		trl[p] = trr[p] = Seg(Opt[seq[pos]],val);
		Val[seq[pos]] = val;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)Update(p<<1,l,mid,pos,val);
	else Update(p<<1|1,mid+1,r,pos,val);
	trl[p] = trl[p<<1]+trl[p<<1|1];
	trr[p] = trr[p<<1|1]+trr[p<<1];
}
Seg getansL(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return trl[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getansL(p<<1,l,mid,a,b);
	else if(a>mid)return getansL(p<<1|1,mid+1,r,a,b);
	else return getansL(p<<1,l,mid,a,b)+getansL(p<<1|1,mid+1,r,a,b);
}
Seg getansR(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return trr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getansR(p<<1,l,mid,a,b);
	else if(a>mid)return getansR(p<<1|1,mid+1,r,a,b);
	else return getansR(p<<1|1,mid+1,r,a,b)+getansR(p<<1,l,mid,a,b);
}
Seg getans(int x,int y)
{
	Seg vx(3,0),vy(3,0);
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>=dep[top[y]])
		{
			vx = vx+getansR(1,1,n,dfn[top[x]],dfn[x]);
			x = fa[top[x]];
		}else
		{
			vy = getansL(1,1,n,dfn[top[y]],dfn[y])+vy;
			y = fa[top[y]];
		}
	}
	if(dep[x]>dep[y])
		return vx+getansR(1,1,n,dfn[y],dfn[x])+vy;
	else return vx+getansL(1,1,n,dfn[x],dfn[y])+vy;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d%llu",&Opt[i],&Val[i]);
	int opt,x,y;
	ull z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%llu",&x,&y,&z);
			Seg ans = getans(x,y);
			ull Ans = 0,now = 0;
			for(int j = k-1;j>=0;j--)
			{
				if((ans.v0>>j)&1)
					Ans+=1ull<<j;
				else if(((ans.v1>>j)&1)&&(now+(1ull<<j))<=z)
					Ans+=1ull<<j,now+=1ull<<j;
			}
			printf("%llu\n",Ans);
		}else
		{
			scanf("%d%d%llu",&x,&y,&z);
			Opt[x] = y;
			Update(1,1,n,dfn[x],z);
		}
	}
	return 0;
}
Problem4813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][N],g[N][N],m,n;
void dfs(int x,int fa)
{
	f[x][0] = g[x][0] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			for(int j = m;~j;j--)
				for(int k = 0;k<=j-1;k++)
				{
					if(j-k-2>=0)f[x][j] = max(f[x][j],f[e[i].to][k]+f[x][j-k-2]);
					g[x][j] = max(g[x][j],g[e[i].to][k]+f[x][j-k-1]);
					if(j-k-2>=0)g[x][j] = max(g[x][j],f[e[i].to][k]+g[x][j-k-2]);
				}
		}
	for(int i = 0;i<m;i++)f[x][i+1] = max(f[x][i],f[x][i+1]);
	for(int i = 0;i<m;i++)g[x][i+1] = max(g[x][i],g[x][i+1]);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(0,0);
	printf("%d\n",g[0][m]);
	return 0;
}
Problem4814

#include <bits/stdc++.h>

using namespace std;

#define LL long long
#define inf 0x3f3f3f3f
#define Pi acos(-1.0)
#define eps 1e-12
#define N 6020
#define M 400020

int dcmp(double x)
{
	if(fabs(x) < eps) return 0;
	return x < 0 ? -1 : 1;
}
int sgn(LL x)
{
	if(x == 0) return 0;
	return x < 0 ? -1 : 1;
}
struct point
{
	double x, y, ang;
	point(double x = 0, double y = 0) : x(x), y(y) {}
	point operator - (const point &b) const 
	{
		return point(x - b.x, y - b.y);
	}
	point operator + (const point &b) const 
	{
		return point(x + b.x, y + b.y);
	}
	point operator * (const double &k) const 
	{
		return point(x * k, y * k);
	}
	bool operator < (const point &b) const 
	{
		return ang < b.ang;
	}
	bool operator == (const point &b) const 
	{
		return x == b.x && y == b.y;
	}
	inline double len()
	{
		return sqrt(x * x + y * y);
	}
	inline void get_ang()
	{
		ang = atan2(y, x);
	}
	inline void input()
	{
		int xx, yy;
		scanf("%d%d", &xx, &yy);
		x = 1.0 * xx, y = 1.0 * yy;
	}
};
double dot(point a, point b)
{
	return a.x * b.x + a.y * b.y;
}
double cross(point a, point b)
{
	return a.x * b.y - a.y * b.x;
}
point get_intersection(point a1, point a2, point b1, point b2)
{
	point u = a1 - b1, av = a2 - a1, bv = b2 - b1;
	double t = cross(bv, u) / cross(av, bv);
	return a1 + av * t;
}
const point O = point(0, 0);
point base;
struct Seg{
	point u, v;
	int id, in;
	double ang;
	Seg(){}
	Seg(point u, point v, int in, int id, double ang) : u(u), v(v), in(in), id(id), ang(ang) {}
	bool operator < (const Seg &b) const 
	{
		if(u == b.u)
		{
			return cross(v - u, b.v - u) < 0;
		}
		point aa = get_intersection(u, v, O, base);
		point bb = get_intersection(b.u, b.v, O, base);
		return aa.len() < bb.len();
	}
}L[N];
bool cmp(Seg a, Seg b)
{
	return dcmp(a.ang - b.ang) < 0 || dcmp(a.ang - b.ang) == 0 && a.in > b.in;
}

int all, tot;
multiset<Seg> S;
multiset<Seg>::iterator it[N];
point pp[N], p[N];
point tri[N][3], t[N][4];
void add(point u, point v, int id)
{
	if(u.ang > v.ang) swap(u, v);
	L[all++] = Seg(u, v, 1, id, u.ang);
	L[all++] = Seg(v, u, 0, id, v.ang);
}
double calc(Seg s)
{
	point a = get_intersection(s.u, s.v, O, base);
	return a.len();
}
int solve(int n)
{
	sort(p, p + n);
	sort(L, L + all, cmp);
	S.clear();
	int ret = 0, i = 0, j = 0;
	for(; i < n; ++i)
	{
		while(j < all && (dcmp(L[j].ang - p[i].ang) < 0 || (dcmp(L[j].ang - p[i].ang) == 0 && L[j].in)))
		{
			base = L[j].u;
			if(L[j].in)
				it[L[j].id] = S.insert(L[j]);
			else
				S.erase(it[L[j].id]);
			++j;
		}
		if(S.empty()){++ret; continue;}
		base = p[i];
		double dis = calc(*S.begin());
		if(dcmp(p[i].len() - dis) <= 0) ++ret;
	}
	return ret;
}

int main()
{
	int V, T;
	scanf("%d%d", &V, &T);
		for(int i = 1; i <= V; ++i)
			pp[i].input();
		for(int i = 1; i <= T; ++i)
			for(int j = 0; j < 3; ++j)
				tri[i][j].input();

		int ans = 0;
		for(int i = 1; i <= V; ++i){
			int cnt = 0;
			for(int j = i + 1; j <= V; ++j){
				p[cnt++] = pp[j] - pp[i];
				p[cnt-1].get_ang();
			}
			tot = all = 0;
			for(int j = 1; j <= T; ++j){
				for(int k = 0; k < 3; ++k)
					t[j][k] = tri[j][k] - pp[i];
				t[j][3] = t[j][0];
				point u, v;
				double mx = 0;
				for(int k = 0; k < 3; ++k){
					double ang = dot(t[j][k], t[j][k+1]) / t[j][k].len() / t[j][k+1].len();
					ang = acos(ang);
					if(ang > mx)
						mx = ang, u = t[j][k], v = t[j][k+1];
				}
				u.get_ang(), v.get_ang();
				double d = fabs(u.ang - v.ang);
				if(d < Pi)
					add(u, v, tot++);
				else{
					point tmp = get_intersection(u, v, O, point(-1.0, 0));
					tmp.ang = Pi * dcmp(u.ang);
					add(u, tmp, tot++);
					tmp.ang = Pi * dcmp(v.ang);
					add(v, tmp, tot++);
				}
			}
			int ret = solve(cnt);
			ans += ret;
		}
		printf("%d\n", ans);
	return 0;
}
Problem4815

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e6+5;
const int mod = 1e9+7;
typedef long long ll;
struct P
{int l,r;}pos[2010];
int prime[N],inv[N],mu[N],g[N],f[N],w[N],sum[2010],P[N],s[N];
bool vis[N];
int cnt;
void quick_shai(int n)
{
	inv[0] = inv[1] = 1;
	for(int i = 2;i<=n;i++)
		inv[i] = (ll)(mod-mod/i)*inv[mod%i]%mod;
	cnt = 0;
	g[1] = mu[1] = 1;
	for(int i = 2;i<=n;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
			g[i] = (1-inv[i]+mod)%mod;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<=n;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
			{
				mu[i*prime[j]] = -mu[i];
				g[i*prime[j]] = (ll)g[i]*(1-inv[prime[j]]+mod)%mod;
			}
			else
			{
				mu[i*prime[j]] = 0;
				g[i*prime[j]] = g[i];
				break;
			}
		}
	}	
	f[0] = 0;
	for(int i = 1;i<=n;i++)
		f[i] = (f[i-1]+(ll)g[i]*i%mod*i%mod*i%mod)%mod;
}

int gcd(int a,int b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}

int check(int n)
{
	if(!n)return 0;
	return (s[n]+sum[P[n]])%mod;
}

int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	quick_shai(n);
	int block = sqrt(n);
	int last;
	for(int i = 1;i<= n;i++)
		P[i] = (i-1)/block+1;
	last = P[n];
	pos[1].l = 1;
	for(int i = 2;i<= n;i++)
		if(P[i-1]<P[i]){pos[P[i-1]].r = i-1,pos[P[i]].l = i;}
	pos[last].r = n;
	memset(sum,0,sizeof(sum));
	for(int i = 0;i<= n;i++)w[i]=(ll)i*i%mod;
	for(int i = 1;i<= n;i++)s[i] = (s[i-1]+w[i])%mod;
	int a,b,k;
	ll x,y;
	int Last;
	while(m--)
	{
		scanf("%d%d%lld%d",&a,&b,&x,&k);
		int c = gcd(a,b);
		y = (ll)a/c*b/c;
		x/=y;x%=mod;
		int d = (x-w[c]+mod)%mod;w[c] = x;
		for(int i = c;i<= pos[P[c]].r;i++)s[i] = (s[i]+d)%mod;
		for(int i = P[c]+1;i<= last;i++)sum[i] = (sum[i]+d)%mod;
		ll ans = 0;
		for(int i = 1;i<= k;i = Last+1)
		{
			Last = k/(k/i);
			ans = (ans+(ll)(check(Last)-check(i-1)+mod)*f[k/i]%mod)%mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4816

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
const int mod = 1e9+7;
int f[N],g[N],Invg[N];
int quick_pow(int x,ll y)
{
	int res=1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int getmul(int l,int r)
{
	return (ll)g[r]*Invg[l-1]%mod;
}
int main()
{
	f[0] = 0,f[1] = 1;
	for(int i = 2;i<N;i++)
		f[i] = (f[i-1]+f[i-2])%mod;
	for(int i = 1;i<N;i++)g[i] = f[i];
	Invg[0] = 1,g[0]=1;
	for(int i = 1;i<N;i++)
	{
		Invg[i] = quick_pow(g[i],mod-2);
		for(int j = i+i;j<N;j+=i)
			g[j] = (ll)g[j]*Invg[i]%mod;
		g[i] = (ll)g[i-1]*g[i]%mod;
		Invg[i] = (ll)Invg[i-1]*Invg[i]%mod;
	}
	int cas,n,m;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		int ans = 1,last = 1;
		if(n>m)swap(n,m);
		for(int i = 1;i<= n;i=last+1)
		{
			last = min(n/(n/i),m/(m/i));
			ans = (ll)ans*quick_pow(getmul(i,last),(ll)(n/i)*(m/i))%mod;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem4817

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int n,m;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int Son[N],dfn[N],seq[N],top[N],size[N],dep[N],fa[N],Dfn;
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[Son[x]])Son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(Son[x])dfs2(Son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=Son[x])
			dfs2(e[i].to,e[i].to);
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
int mx[N<<2],lazy[N<<2];
void build(int p,int l,int r)
{
	lazy[p] = 0;
	if(l==r)
	{
		mx[p] = dep[seq[l]];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
void Push_down(int p,int l,int r)
{
	if(l==r||!lazy[p])return ;
	mx[p<<1]+=lazy[p],mx[p<<1|1]+=lazy[p];
	lazy[p<<1]+=lazy[p],lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void Update(int p,int l,int r,int a,int b,int c)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b){mx[p]+=c;lazy[p]+=c;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,c);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,c);
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
int Getans(int p,int l,int r,int a,int b)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans = max(ans,Getans(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,Getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
int son[N][2],father[N],lx[N];
bool is_root(int x)
{
	return son[father[x]][0]!=x&&son[father[x]][1]!=x;
}
void update(int x)
{
	lx[x] = x;
	if(son[x][0])
		lx[x] = lx[son[x][0]];
}
void rotate(int x)
{
	int y = father[x],z = father[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(son[z][0]==y)son[z][0] = x;
		else son[z][1] = x;
	}
	father[y] = x,father[x] = z,father[son[x][d^1]] = y;
	son[y][d] = son[x][d^1];son[x][d^1] = y;
	update(x),update(y);
}
void splay(int x)
{
	while(!is_root(x))
	{
		int y = father[x],z = father[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)!=(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	update(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		if(son[x][1])
		{
			int y = lx[son[x][1]];
			Update(1,1,n,dfn[y],dfn[y]+size[y]-1,1);
		}
		son[x][1] = t;
		if(son[x][1])
		{
			int y = lx[son[x][1]];
			Update(1,1,n,dfn[y],dfn[y]+size[y]-1,-1);
		}
		update(x);
		t = x;x = father[x];
	}
}
int col(int x)
{
	splay(x);
	return lx[x];
}
int main()
{
	scanf("%d%d",&n,&m);
	int a,b;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		add(a,b),add(b,a);
	}
	dfs1(1),dfs2(1,1);
	build(1,1,n);
	for(int i = 1;i<= n;i++)father[i]=fa[i];
	int opt;
	while(m--)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d",&a);
			access(a);
		}else if(opt==2)
		{
			scanf("%d%d",&a,&b);
			int lca = getlca(a,b);
			int flca = fa[lca];
			int valx = Getans(1,1,n,dfn[a],dfn[a]),valy = Getans(1,1,n,dfn[b],dfn[b]);
			int vall = 0;
			if(flca)
			{
				vall = Getans(1,1,n,dfn[flca],dfn[flca]);
				if(col(lca)==col(flca))
					vall--;
			}
			printf("%d\n",valx+valy-2*vall-1);
		}else
		{
			scanf("%d",&a);
			printf("%d\n",Getans(1,1,n,dfn[a],dfn[a]+size[a]-1));
		}
	}
	return 0;
}
Problem4818

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 20170408;
const int N = 105;
const int M = 2e7+5;
int n,m,p;
struct Martix
{
	int d[N];
	Martix(){memset(d,0,sizeof(d));}
	Martix operator *(const Martix &s)const
	{
		Martix res;
		for(int i = 0;i<p;i++)
			for(int j = 0;j<p;j++)
				(res.d[i]+=(ll)d[j]*s.d[(i-j+p)%p]%mod)%=mod;
		return res;
	}
};
bool vis[M];
int prime[M/10],cnt;
void quick_prime()
{
	vis[1] = true;
	for(int i = 2;i<M;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<=cnt&&prime[j]*i<M;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	quick_prime();
	scanf("%d%d%d",&n,&m,&p);
	Martix go1,go2;
	for(int i = 1;i<= m;i++)
	{
		go1.d[i%p]++;
		if(vis[i])
			go2.d[i%p]++;
	}
	Martix a1,a2;
	a1.d[0] = a2.d[0] = 1;
	while(n)
	{
		if(n&1)
		{
			a1 = a1*go1;
			a2 = a2*go2;
		}
		go1 = go1*go1;go2 = go2*go2;
		n>>=1;
	}
	printf("%d\n",(a1.d[0]-a2.d[0]+mod)%mod);
	return 0;
}
Problem4819

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-7;
const int N = 205;
const int M = 3e4+5;
const double INF = 1e9;
struct E
{int next,to,f,from;double c;}e[M];
int head[N],tot=1;
int from[N],a[N][N],b[N][N],n;
void add(int x,int y,int f,double c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f,e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0,e[tot].c=-c;
	e[tot-1].from = x,e[tot].from = y;
}
double dis[N];
bool vis[N];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = s;i<= t;i++)dis[i] = INF;
	dis[s] = 0;
	vis[s] = true;Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=INF;
}
double mcf(int s,int t)
{
	int x = INF;
	double ans = 0;
	for(int i = from[t];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[t];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
	return ans;
}
void rebuild(double mid)
{
	memset(head,0,sizeof(head));
	tot = 1;
	int s= 0,t = 2*n+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			add(i,j+n,1,mid*b[i][j]-a[i][j]);
	for(int i = 1;i<= n;i++)
		add(s,i,1,0),add(i+n,t,1,0);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
		scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
		scanf("%d",&b[i][j]);
	double l = 0,r = 10001;
	while(fabs(r-l)>eps)
	{
		double mid = (l+r)/2;
		rebuild(mid);
		double ans = 0;
		while(spfa(0,2*n+1))ans+=mcf(0,2*n+1);
		if(ans<eps)l = mid;
		else r = mid;
	}
	printf("%.6lf\n",l);
	return 0;
}
Problem4820

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
typedef long long ll;
const int sed = 107;
const int mod = 998244353;
double f[N][N],B[N],pw2[N];
int n,m,deg;
char s[N][N];
ll h[N][N],h0[N][N],pws[N],pw0[N];
int main()
{
	scanf("%d%d",&n,&m);
	deg = n+1;
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s[i]+1);
		for(int j = 1;j<= m;j++)
		{
			h[i][j] = h[i][j-1]*sed+s[i][j];
			h0[i][j] = (h0[i][j-1]*sed+s[i][j])%mod;
		}
	}
	pw2[0] = pws[0] = pw0[0] = 1;
	for(int i = 1;i<= m;i++)
	{
		pw2[i] = pw2[i-1]*0.5;
		pws[i] = pws[i-1]*sed;
		pw0[i] = pw0[i-1]*sed%mod;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<m;k++)
			if(h[i][k]==h[j][m]-h[j][m-k]*pws[k])
			{
				ll x0 = h0[i][k];
				ll x1 = (h0[j][m]-h0[j][m-k]*pw0[k]%mod+mod)%mod;
				if(x0==x1)
					f[i][j]+=pw2[m-k];
			}
	for(int i = 1;i<= n;i++)f[i][i]++,f[i][n+1]--,f[n+1][i]++;
	B[n+1] = 1;
	for(int i = 1,l;i<= deg;i++)
	{
		for(int j = (l=i)+1;j<=deg;j++)if(fabs(f[j][i])>fabs(f[l][i]))l = j;
		for(int j = i;j<= deg;j++)swap(f[i][j],f[l][j]);
		swap(B[i],B[l]);
		double t = f[i][i];
		for(int j = i;j<= deg;j++)f[i][j]/=t;
		B[i]/=t;
		for(int j = 1;j<= deg;j++)if(j!=i)
		{
			t = f[j][i];
			for(int k = i;k<= deg;k++)f[j][k]-=f[i][k]*t;
			B[j]-=B[i]*t;
		}
	}
	for(int i = 1;i<= n;i++)printf("%.10lf\n",B[i]);
	return 0;
}
Problem4821

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct Seg
{
	double sum_x,sum_y,sum_x2,sum_xy;
	double add_x,add_y;
	double cov_x,cov_y;
	bool cover;
}tr[N<<2];
double sum_pre[N<<2],vx[N<<2],vy[N<<2];
struct Res
{
	double sum_x,sum_y,sum_x2,sum_xy;
}res;
int n,m;
void Covers(int p,int l,int r,double S,double T)
{
	if(l>r)return ;
	double len = r-l+1;
	double sum = (l+r)*len/2;
	tr[p].add_x = tr[p].add_y = false;
	tr[p].cov_x = S,tr[p].cov_y = T;
	tr[p].cover = true;
	tr[p].sum_x2 = S*S*len+sum*S+sum*S+sum_pre[r]-sum_pre[l-1];
	tr[p].sum_xy = S*T*len+sum*S+sum*T+sum_pre[r]-sum_pre[l-1];
	tr[p].sum_x = (S+l+S+r)*len/2;
	tr[p].sum_y = (T+l+T+r)*len/2;
}
void Push_Down_cover(int p,int l,int r)
{
	if(l==r)return ;
	if(tr[p].cover)
	{
		int mid =(l+r)>>1;
		Covers(p<<1,l,mid,tr[p].cov_x,tr[p].cov_y);
		Covers(p<<1|1,mid+1,r,tr[p].cov_x,tr[p].cov_y);
		tr[p].cover = false;
	}
}
void Add(int p,int l,int r,double S,double T)
{
	if(l>r)return ;
	Push_Down_cover(p,l,r);
	double len = r-l+1;
	tr[p].add_x+=S,tr[p].add_y+=T;
	tr[p].sum_x2 += 2*S*tr[p].sum_x+S*S*len;
	tr[p].sum_xy += S*tr[p].sum_y+T*tr[p].sum_x+S*T*len;
	tr[p].sum_x+=S*len,tr[p].sum_y+=T*len;
}
void Push_Down_add(int p,int l,int r)
{
	if(l==r)return ;
	if(tr[p].add_x||tr[p].add_y)
	{
		int mid =(l+r)>>1;
		Add(p<<1,l,mid,tr[p].add_x,tr[p].add_y);
		Add(p<<1|1,mid+1,r,tr[p].add_x,tr[p].add_y);
		tr[p].add_x = tr[p].add_y = 0;
	}
}
void Push_Down(int p,int l,int r)
{
	Push_Down_add(p,l,r);
	Push_Down_cover(p,l,r);
}
void Push_Up(int p)
{
	int l = p<<1,r = p<<1|1;
	tr[p].sum_x = tr[l].sum_x+tr[r].sum_x;
	tr[p].sum_y = tr[l].sum_y+tr[r].sum_y;
	tr[p].sum_x2 = tr[l].sum_x2+tr[r].sum_x2;
	tr[p].sum_xy = tr[l].sum_xy+tr[r].sum_xy;
}
void Build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].sum_x = vx[l];
		tr[p].sum_y = vy[l];
		tr[p].sum_x2 = vx[l]*vx[l];
		tr[p].sum_xy = vx[l]*vy[l];
		return ;
	}
	int mid = (l+r)>>1;
	Build(p<<1,l,mid);
	Build(p<<1|1,mid+1,r);
	Push_Up(p);
}
void Covers(int p,int l,int r,int a,int b,double S,double T)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		Covers(p,l,r,S,T);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Covers(p<<1,l,mid,a,b,S,T);
	if(b >mid)Covers(p<<1|1,mid+1,r,a,b,S,T);
	Push_Up(p);
}
void Add(int p,int l,int r,int a,int b,double S,double T)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		Add(p,l,r,S,T);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Add(p<<1,l,mid,a,b,S,T);
	if(b >mid)Add(p<<1|1,mid+1,r,a,b,S,T);
	Push_Up(p);
}
void Getans(int p,int l,int r,int a,int b)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		res.sum_x+=tr[p].sum_x,res.sum_y+=tr[p].sum_y;
		res.sum_x2+=tr[p].sum_x2,res.sum_xy+=tr[p].sum_xy;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Getans(p<<1,l,mid,a,b);
	if(b >mid)Getans(p<<1|1,mid+1,r,a,b);
}

int main()
{
	for(int i = 1;i<N;i++)sum_pre[i] = sum_pre[i-1]+(double)i*i;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lf",&vx[i]);
	for(int i = 1;i<= n;i++)scanf("%lf",&vy[i]);
	Build(1,1,n);
	int opt,l,r;
	double s,t;
	while(m--)
	{
		scanf("%d%d%d",&opt,&l,&r);
		if(opt==1)
		{
			res.sum_x = res.sum_y = 0;
			res.sum_x2 = res.sum_xy = 0;
			Getans(1,1,n,l,r);
			double len = r-l+1;
			double averx = res.sum_x/len;
			double avery = res.sum_y/len;
			printf("%.10lf\n",(res.sum_xy-len*averx*avery)/(res.sum_x2-len*averx*averx));
		}else if(opt==2)
		{
			scanf("%lf%lf",&s,&t);
			Add(1,1,n,l,r,s,t);
		}else
		{
			scanf("%lf%lf",&s,&t);
			Covers(1,1,n,l,r,s,t);
		}
	}
	return 0;
}
Problem4823

#include <cstdio>
#include <map>
#include <algorithm>
using namespace std;
const int maxn=100005,s=100005,t=100006,oo=0x3f3f3f3f;
int rd()
{
    int x=0;
    char c=getchar();
    while (c<'0'||c>'9') c=getchar();
    while (c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x;
}
int fir[maxn],cur[maxn],ne[20*maxn],to[20*maxn],w[20*maxn],dep[maxn],que[maxn],
xx[maxn],yy[maxn],ww[maxn],
n,num,r,c;
map<pair<int,int>,int> id;
void add(int u,int v,int x)
{
    num++;ne[num*2]=fir[u];fir[u]=num*2;to[num*2]=v;w[num*2]=x;
    ne[num*2+1]=fir[v];fir[v]=num*2+1;to[num*2+1]=u;w[num*2+1]=0;
}
bool bfs()
{
    int u,v,hd,tl;
    for (int i=1;i<=n;i++) dep[i]=0;
    dep[t]=0;
    dep[s]=1;
    que[hd=tl=1]=s;
    while (hd<=tl)
    {
        u=que[hd++];
        for (int i=fir[u];i;i=ne[i])
            if (w[i]&&!dep[v=to[i]])
            {
                dep[v]=dep[u]+1;
                que[++tl]=v;
            }
    }
    return dep[t];
}
int dfs(int u,int lim)
{
    if (u==t) return lim;
    int v,x,ret=0;
    for (int &i=cur[u];i&&ret<lim;i=ne[i])
        if (w[i]&&dep[v=to[i]]==dep[u]+1)
        {
            x=dfs(v,min(lim-ret,w[i]));
            ret+=x;
            w[i]-=x;
            w[i^1]+=x;
        }
    return ret;
}
int main()
{
    int u,ans=0;
    c=rd();
    r=rd();
    n=rd();
    for (int i=1;i<=n;i++)
    {
        xx[i]=rd();
        yy[i]=rd();
        ww[i]=rd();
        id[make_pair(xx[i],yy[i])]=i;
    }
    for (int i=1;i<=n;i++)
        switch (xx[i]%4)
        {
            case 0:
                if (yy[i]&1) add(s,i,ww[i]);
                else
                {
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                        add(id[make_pair(xx[i]+1,yy[i])],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(id[make_pair(xx[i],yy[i]+1)],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(id[make_pair(xx[i],yy[i]-1)],i,oo);
                }
                break;
            case 1:
                if (yy[i]&1)
                {
                    if (id.count(make_pair(xx[i]-1,yy[i])))
                        add(id[make_pair(xx[i]-1,yy[i])],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(id[make_pair(xx[i],yy[i]+1)],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(id[make_pair(xx[i],yy[i]-1)],i,oo);
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                    {
                        u=id[make_pair(xx[i]+1,yy[i])];
                        add(i,u,min(ww[i],ww[u]));
                    }
                }
                else add(s,i,ww[i]);
                break;
            case 2:
                if (yy[i]&1)
                {
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                        add(i,id[make_pair(xx[i]+1,yy[i])],oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(i,id[make_pair(xx[i],yy[i]+1)],oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(i,id[make_pair(xx[i],yy[i]-1)],oo);
                }
                else add(i,t,ww[i]);
                break;
            case 3:
                if (yy[i]&1) add(i,t,ww[i]);
                else
                {
                    if (id.count(make_pair(xx[i]-1,yy[i])))
                        add(i,id[make_pair(xx[i]-1,yy[i])],oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(i,id[make_pair(xx[i],yy[i]+1)],oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(i,id[make_pair(xx[i],yy[i]-1)],oo);
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                    {
                        u=id[make_pair(xx[i]+1,yy[i])];
                        add(u,i,min(ww[i],ww[u]));
                    }
                }
        }
    while (bfs())
    {
        for (int i=1;i<=n;i++) cur[i]=fir[i];
        cur[s]=fir[s];
        cur[t]=fir[t];
        ans+=dfs(s,oo);
    }
    printf("%d\n",ans);
}
Problem4824

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 105;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
int c[N][N],f[N][N],g[N][N],size[N],tmp[N],n;
char s[N];
void dfs(int x)
{
	if((x<<1)<=n)add(x,x<<1);
	if((x<<1|1)<=n)add(x,x<<1|1);
	g[x][1] = f[x][1] = size[x] = 1;
	for(int t = head[x];t;t=e[t].next)
	{
		int to = e[t].to;
		dfs(to);
		for(int j = 1;j<= size[to]+size[x];j++)
			tmp[j] = 0;
		for(int i = 1;i<= size[x];i++)
			for(int j = 0;j<= size[to];j++)
				if(s[to]=='>')
					(tmp[i+j]+=(ll)f[x][i]*g[to][j]%mod*c[i+j-1][i-1]%mod
							  *c[size[x]-i+size[to]-j][size[x]-i]%mod)%=mod;
				else
					(tmp[i+j]+=(ll)f[x][i]*(g[to][size[to]]-g[to][j]+mod)%mod
							  *c[i+j-1][i-1]%mod
							  *c[size[x]-i+size[to]-j][size[x]-i]%mod)%=mod;
		for (int i=1; i<=size[x]+size[to]; i++)
            f[x][i] = tmp[i]%mod, g[x][i] = (g[x][i-1]+f[x][i])%mod;
        size[x] += size[to];
	}
}
int main()
{
	scanf("%d",&n);
	scanf("%s",s+2);
	c[0][0] = 1;
	for(int i = 1;i< N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
	dfs(1);
	printf("%d\n",g[1][size[1]]);
	return 0;
}
Problem4826

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
typedef long long ll;
struct List
{
	struct E
	{
		int l,r,type,val,next;
	}e[N*3];
	int head[N],tot;
	void add(int x,int l,int r,int type,int val)
	{
		e[++tot].l = l;e[tot].r = r;e[tot].type = type;
		e[tot].val = val;
		e[tot].next = head[x];
		head[x] = tot;
	}
	void clear()
	{
		memset(head,0,sizeof(head));
		tot = 0;
	}
}ad,as;
struct Ask
{int l,r,id;}ask[N];
struct Seg
{
	ll sum[N<<2],lazy[N<<2];
	void Push_down(int p,int l,int r)
	{
		if(!lazy[p]||l==r)return ;
		int mid = (l+r)>>1;
		sum[p<<1]+=(ll)(mid-l+1)*lazy[p];
		sum[p<<1|1]+=(ll)(r-mid)*lazy[p];
		lazy[p<<1]+=lazy[p],lazy[p<<1|1]+=lazy[p];
		lazy[p] = 0;
	}
	void update(int p,int l,int r,int a,int b,int val)
	{
		if(a>b)return ;
		Push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			sum[p]+=(ll)(r-l+1)*val;
			lazy[p]+=val;
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,val);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,val);
		sum[p] = sum[p<<1]+sum[p<<1|1];
	}
	ll getans(int p,int l,int r,int a,int b)
	{
		if(a>b)return 0;
		Push_down(p,l,r);
		if(l>=a&&r<=b)return sum[p];
		ll ans = 0;
		int mid = (l+r)>>1;
		if(a<=mid)ans = ans+getans(p<<1,l,mid,a,b);
		if(b >mid)ans = ans+getans(p<<1|1,mid+1,r,a,b);
		return ans;
	}
}tr[2];
ll ans[N];
int l[N],r[N],stack[N],top,a[N];
int main()
{
	//freopen("test.in","r",stdin);
	int n,m,p1,p2;
	scanf("%d%d%d%d",&n,&m,&p1,&p2);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	top = 0;
	for(int i = 1;i<= n;i++)
	{
		while(top&&a[stack[top]]<a[i])r[stack[top]]=i-1,top--;
		stack[++top] = i;
	}
	while(top)r[stack[top]]=n,top--;
	for(int i = n;i>= 1;i--)
	{
		while(top&&a[stack[top]]<a[i])l[stack[top]]=i+1,top--;
		stack[++top] = i;
	}
	while(top)l[stack[top]]=1,top--;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].id = i;
		as.add(ask[i].r,ask[i].l,ask[i].r,1,i);
		as.add(ask[i].l-1,ask[i].l,ask[i].r,-1,i);
	}
	for(int i = 1;i<= n;i++)
	{
		ad.add(l[i]-1,r[i]+1,r[i]+1,0,p1);
		ad.add(l[i]-1,i+1,r[i],0,p2);
		ad.add(r[i]+1,l[i],i-1,1,p2);
	}
	for(int i = 1;i<= n;i++)
	{
		for(int j = ad.head[i];j;j=ad.e[j].next)
		{
			int L = ad.e[j].l,R = ad.e[j].r,typ = ad.e[j].type,vl = ad.e[j].val;
			tr[typ].update(1,1,n,max(1,L),min(R,n),vl);
		}
		if(i!=n)tr[0].update(1,1,n,i+1,i+1,p1);
		for(int j = as.head[i];j;j=as.e[j].next)
		{
			int L = as.e[j].l,R = as.e[j].r,typ = as.e[j].type,vl = as.e[j].val;
			for(int k =0;k<2;k++)
				ans[vl]+=(ll)typ*tr[k].getans(1,1,n,L,R);
		}
	}
	for(int i = 1;i<= m;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem4827

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double PI = 3.14159265358979323;
const int N = 4e5+5;
typedef long long ll;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}a[N],b[N],c[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*2*type/i),sin(PI*2*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp t,w(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = a[j+k+(i>>1)]*w;
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
ll ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i] = a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)ans[i]=(ll)(c[i].x+0.5);
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	ll c2 = 0;
	ll c11 = 0,c12 = 0;
	for(int i = 0;i< n;i++)
	{
		scanf("%d",&x);
		c2 += x*x;
		c11+=x;
		c12-=x;
		a[i].x = x;
	}
	for(int i = 0;i< n;i++)
	{
		scanf("%d",&x);
		c2 += x*x;
		c11-=x;
		c12+=x;
		b[i].x = x;
	}
	for(int i = 0;i<n;i++)
	{
		a[i+n] = a[i];
		if(i<n-i-1)swap(b[n-i-1],b[i]);
	}
	int l = 1;
	for(l=1;l<=n*4;l<<=1);
	conv(a,b,c,l);
	ll Ans = 1e18;
	for(int i = 0;i<n;i++)
		for(int j = 0;j<=m;j++)
		{
			Ans = min(Ans,c2+c11*j*2-ans[n+i-1]*2+n*j*j);
			Ans = min(Ans,c2+c12*j*2-ans[n+i-1]*2+n*j*j);
		}
	printf("%lld\n",Ans);
	return 0;
}
Problem4828

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 105;
const int B = 1e6;
int prime[N],cnt;
bool vis[N];
void get_prime()
{
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])prime[cnt++] = i;
		for(int j = 0;j<cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int S[B+5];
map<int,int>s;
int n,m,mc,k,dp[N][N];
int a[N],w[N],C[N],fl[N],maxc;
int Get(int x)
{
	if(x<=B)return S[x];
	else return s[x];
}
void Update(int x,int ans)
{
	if(x<=B)S[x] = ans;
	else s[x] = ans;
}
int calc(int n)
{
	if(n<0)return INF;
	if(n==0)return 0;
	if(n==1)return 1;
	int tmp = n,end = 1;
	for(int i = 0;i< cnt;i++)
		while(tmp%prime[i]==0)
			tmp/=prime[i],end = prime[i];
	if(tmp>1)return INF;
	if(Get(n))return Get(n);
	int lim = k+1;
	for(int i = end;i<lim-1;i++)if(n%i==0)
	{
		int t = i+1;
		tmp = n;
		for(int j = i;j>=2&&t<=lim&&tmp>1;j--)
			while(tmp%j==0)
				tmp/=j,t++;
		if(tmp==1)lim= min(lim,t);
	}
	Update(n,lim);
	return lim;
}
int tmp;
void solve(int x,int pos)
{
	if(tmp==m)return ;
	int t = calc(x);
	if(t>k/2)return ;
	for(int i = pos;i>=0;i--)if((ll)prime[i]*x<=maxc)solve(x*prime[i],i);
	for(int i = 0;i<= k-2*t;i++)
	{
		for(int j = 1;j<= m;j++)
			if(!fl[j])
			{
				int l = calc(C[j]-i-x);
				if(l+i+t<=k)fl[j]=1,tmp++;
			}
	}
}
int main()
{
	get_prime();
	scanf("%d%d%d",&n,&m,&mc);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&C[i]),maxc = max(maxc,C[i]);
	memset(dp,-1,sizeof(dp));
	dp[0][0] = mc;
	for(int i = 0;i< n;i++)
	{
		for(int j = 0;j<= i;j++)if(dp[i][j]!=-1)
		{
			if(dp[i][j]<a[i+1])continue;
			dp[i+1][j] = min(mc,max(dp[i+1][j],dp[i][j]-a[i+1]+w[i+1]));
			dp[i+1][j+1] = min(mc,max(dp[i+1][j+1],dp[i][j]-a[i+1]));
		}
		for(int j = 0;j<= n;j++)if(dp[i+1][j]!=-1)k = max(k,j);
	}
	for(int i = 1;i<= m;i++)
	{
		for(int j =0;j<k&&j<C[i];j++)fl[i]|=(calc(C[i]-j)+j<=k);
		tmp+=fl[i];
	}
	solve(1,14);
	for(int i = 1;i<= m;i++)printf("%d\n",fl[i]);
	return 0;
}
Problem4831

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5+5;
const int M = 1e6+5;
int f[2][M][2],mn[M],a[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
		f[0][0][0] = 0,f[0][0][1] = INF;
		int now = 0,nxt = 1,i,j,s,k;
		for(i = 0;i< n;i++)
		{
			for(j = 0;j<= a[i+1];j++)
				f[nxt][j][0]=f[nxt][j][1]=INF;
			for(j = a[i];j>= 0;j--)
			{
				mn[j] = min(f[now][j][0],j==a[i]?INF:mn[j+1]);
				if(j<=a[i+1])
				{
					for(s = 0;s<2;s++)
					f[nxt][a[i+1]-j][0] = min(f[nxt][a[i+1]-j][0],f[now][j][s]+j);
				}else
					f[nxt][0][1] = min(f[nxt][0][1],f[now][j][0]+a[i+1]);
			}
			for(k = a[i+1];k>=0;k--)
				f[nxt][a[i+1]-k][1] = min(f[nxt][a[i+1]-k][1],(k+1>a[i])?INF:(mn[k+1]+k));
			swap(nxt,now);
		}
		int ans1 = min(f[now][0][0],f[now][0][1]);
		for(j = 0;j<= a[n];j++)
			ans1 = min(ans1,f[now][j][0]);
		f[0][0][0] = 0,f[0][0][1] = -INF;
		now = 0,nxt = 1;
		for(i = 0;i< n;i++)
		{
			for(j = 0;j<= a[i+1];j++)
				f[nxt][j][0]=f[nxt][j][1]=-INF;
			for(j = a[i];j>= 0;j--)
			{
				mn[j] = max(f[now][j][0],j==a[i]?-INF:mn[j+1]);
				if(j<=a[i+1])
				{
					for(s = 0;s<2;s++)
					f[nxt][a[i+1]-j][0] = max(f[nxt][a[i+1]-j][0],f[now][j][s]+j);
				}else
					f[nxt][0][1] = max(f[nxt][0][1],f[now][j][0]+a[i+1]);
			}
			for(k = a[i+1];k>=0;k--)
				f[nxt][a[i+1]-k][1] = max(f[nxt][a[i+1]-k][1],(k+1>a[i])?-INF:(mn[k+1]+k));
			swap(nxt,now);
		}
		int ans2 = max(f[now][0][0],f[now][0][1]);
		for(j = 0;j<= a[n];j++)
			ans2 = max(ans2,f[now][j][0]);
		printf("%d %d\n",ans1,ans2);
	}
	return 0;
}
Problem4833

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
ll f[N],g[N];
int n,p;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res=(ll)res*x%p;
		x = (ll)x*x%p;
		y>>=1;
	}
	return res;
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&p);
		f[1] = g[1] = 1,f[2] = g[2] = 2;
		for(int i = 3;i<= n;i++)
			f[i] = ((f[i-1]<<1)+f[i-2])%p,g[i] = f[i];
		for(int i = 1;i<= n;i++)
		{
			int inv = quick_pow(g[i],p-2);
			for(int j = i+i;j<= n;j+=i)
				g[j] = (ll)g[j]*inv%p;
		}
		ll lcm = 1,ans = 0;
		for(int i = 1;i<= n;i++)
			lcm = (ll)lcm*g[i]%p,(ans+=lcm*i%p)%=p;
		printf("%lld\n",ans);
	}
}
Problem4835

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
struct E
{int next,to;}e[N<<1];
int head[N],tot,big[N],f[N],fa[N],size[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
}
void dfs(int x)
{
	f[x] = 1;size[x]=1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		size[x]+=size[e[i].to];
	}
	for(int i = head[x];i;i=e[i].next)
	{
		if(size[e[i].to]<<1==size[x])
			f[x] = (ll)f[x]*big[e[i].to]%mod*f[e[i].to]%mod;
		else
			f[x] = (ll)f[x]*size[e[i].to]%mod*f[e[i].to]%mod;
	}
}
int main()
{
	//freopen("x.in","r",stdin);
	int n,m;
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)head[i]=big[i]=fa[i]=0;tot = 0;
		int x,y;
		for(int i = 1;i<n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);fa[y] = x;
		}
		for(int i = 1;i<= n;i++)
		{
			int now = i;
			while(now)
			{
				if(fa[now]<i)big[now]++;
				now = fa[now];
			}
		}
		for(int i = 1;i<= n;i++)
			if(!fa[i])
			{
				dfs(i);
				printf("%d\n",f[i]);
				break;
			}
	}
	return 0;
}
Problem4849

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
struct data
{
	int mn,dep,lazy;
	void add(int x)
	{
		mn+=x,dep+=x,lazy+=x;
	}
}a[N];
int ef[N],et[N],n,m;
void Push_up(int p)
{
	int l = p<<1,r = p<<1|1;
	a[p].mn = ef[p]?a[p].dep:INF;
	if(l<=n)a[p].mn = min(a[p].mn,a[l].mn);
	if(r<=n)a[p].mn = min(a[p].mn,a[r].mn);
}
void Push_down(int p)
{
	if(!a[p].lazy)return ;
	int l = p<<1,r = p<<1|1;
	if(l<=n)a[l].add(a[p].lazy);
	if(r<=n)a[r].add(a[p].lazy);
	a[p].lazy = 0;
}
void relax(int p)
{
	if(!p)return ;
	relax(p>>1);
	Push_down(p);
}
void dfs(int x,bool f)
{
	Push_down(x);
	if(ef[x]&&a[x].dep==a[x].mn)
		ef[x]--;
	else
	{
		int to = (x<<1)^(a[x].mn!=a[x<<1].mn);
		dfs(to,1);
	}
	Push_up(x);
	if(f&&!++et[x])a[x].add(2);
}
int ans = 0;
void get_max_flow(int x)
{
	relax(x);
	int mc = INF,mw,c1 = 0;
	for(int i = x;i;i>>=1)
	{
		int c2 = c1+a[i].mn-a[i].dep;
		if(c2<mc)
		{
			mc = c2;
			mw = i;
		}
		c1+=et[i]>0?-1:1;
	}
	for(int i = x;i!=mw;i>>=1)
	{
		Push_up(i);
		if(!et[i]--)a[i].add(-2);
	}
	dfs(mw,0);
	for(;mw;mw>>=1)Push_up(mw);
	ans+=mc;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&ef[i]);
	for(int i = 1;i<= n;i++)a[i].dep = a[i>>1].dep+1;
	int x;
	for(int i = n;i;i--)Push_up(i);
	for(int i = 1;i<= m;i++)
	{
		if(i!=1)printf(" ");
		scanf("%d",&x);
		get_max_flow(x);
		printf("%d",ans);
	}
	return 0;
}
Problem4860

#include <cstdio>
#include <cctype>
#include <algorithm>
const int maxn=400010,inf=2000000010;
int ans,n,x,y,z,i,m,l,r,c[maxn*3],cnt;
inline int max(int a,int b)
{
	return a>b?a:b; 
}
inline void up(int&a,const int&b)
{
	if(a<b)a=b;
}
struct edge{int from,to,color;}e[maxn<<1];
struct data{int dep,sum;};
struct node{int v,lc,rc;}a[maxn*5];
int merge(int x,int y)
{
	if(!x || !y )return x|y;
	a[x].lc=merge(a[x].lc,a[y].lc);
	a[x].rc=merge(a[x].rc,a[y].rc);
	up(a[x].v,a[y].v);
	return x;
}
void add(int&i,int rl,int rr,int x,int v)
{
	if(!i)a[i=++cnt]=(node){v,0,0};
		else up(a[i].v,v);
	if(rl<rr)
	{
		int m=(rl+rr)>>1;
		if(x>m)add(a[i].rc,m+1,rr,x,v);
			else add(a[i].lc,rl,m,x,v);
	}
}
int query(int i,int rl,int rr,int l,int r)
{
	if(!i)return -inf;
	if(rl==l && rr==r)return a[i].v;
	int m=(rl+rr)>>1;
	if(l>m)return query(a[i].rc,m+1,rr,l,r);
		else if(r<=m)return query(a[i].lc,rl,m,l,r);
			else return max(query(a[i].lc,rl,m,l,m),query(a[i].rc,m+1,rr,m+1,r));
}
struct tree
{
	int xb,h[maxn],n,size[maxn],f[maxn],rt,sum,dep[maxn],ll,ss[maxn];
	bool b[maxn];
	data w[maxn];
	void addedge(int x,int y,int z)
	{
		e[++xb]=(edge){y,x,z};
		e[++xb]=(edge){x,y,z};
	}
	void dfs(int x,int fa)
	{
		size[x]=f[x]=1;
		for(int i=h[x];i<h[x+1];++i)
		{
			int y=e[i].to;
			if(y!=fa && !b[y])
			{
				dfs(y,x);
				size[x]+=size[y];
				up(f[x],size[y]);
			}
		}
		up(f[x],sum-size[x]);
		if(f[rt]>f[x])rt=x;
	}
	void got(int x,int fa,int dep,int color,int sum)
	{
		for(int y,i=h[x];i<h[x+1];++i)
		{
			y=e[i].to;
			if(y!=fa && !b[y])
			{
				if(e[i].color==color)w[++ll]=(data){dep+1,sum};
					else w[++ll]=(data){dep+1,sum+c[e[i].color]};
				got(e[i].to,x,dep+1,e[i].color,w[ll].sum);
			}
		}
	}
	void solve(int x)
	{
		b[x]=1;
		int i,rt1=0,rt2=cnt=0,j;
		for(i=h[x];i<h[x+1];++i)
		{   
			if(i>h[x] && e[i].color>e[i-1].color)rt1=merge(rt1,rt2),rt2=0;         
			if(!b[e[i].to])
			{
				w[ll=1]=(data){1,c[e[i].color]};
				got(e[i].to,x,1,e[i].color,c[e[i].color]);
				ss[i]=ll;
				for(j=1;j<=ll;++j)if(w[j].dep<=r)
				{
					if(w[j].dep>=l)up(ans,w[j].sum);
					if(w[j].dep<r)
					{
						up(ans,query(rt1,1,n,max(1,l-w[j].dep),r-w[j].dep)+w[j].sum);
						up(ans,query(rt2,1,n,max(1,l-w[j].dep),r-w[j].dep)-c[e[i].color]+w[j].sum);
					}
				}
				for(j=1;j<=ll;++j)if(w[j].dep<=r)add(rt2,1,n,w[j].dep,w[j].sum);
			}
		}
		for(i=h[x];i<h[x+1];++i)
			if(!b[e[i].to])
			{
				sum=ss[i];
				rt=0;
				dfs(e[i].to,x);
				solve(rt);
			}
	}
}t;
bool cmp(const edge&a,const edge&b)
{
	return a.from==b.from?a.color<b.color:a.from<b.from;
}
int main()
{
	a[0].v=-inf;
	scanf("%d%d%d%d",&n,&m,&l,&r);
	t.n = n;
	for(i=1;i<=m;++i)scanf("%d",&c[i]);
	for(i=1;i<n;++i)
	{
		scanf("%d%d%d",&x,&y,&z);
		t.addedge(x,y,z);
	}
	std::sort(e+1,e+((n-1)*2)+1,cmp);
	for(i=1;i<=((n-1)<<1);++i)
		if(!t.h[e[i].from])t.h[e[i].from]=i;
	t.h[n+1]=(n-1)<<1|1; 
	t.f[t.rt=0]=inf;
	t.sum=n;
	ans=-inf;
	t.dfs(1,0);
	t.solve(t.rt);
	printf("%d\n",ans);
}
Problem4861

#include <bits/stdc++.h>
const int mod = 1e9+7;
using namespace std;
typedef long long LL;
int len[105],cnt,n,m,l,ans;
char s[55][105];
inline void inc(int &x,int y) {x=(x+y)%mod;}

struct Trie{
	int ch[205][27],leef[205],fail[205];
	char s[205];
	void add() {
		scanf("%s",s+1); int n = strlen(s+1);
		int p = 0;
		for (int i=1;i<=n;i++) {
			int c = s[i] - 'a';
			if (!ch[p][c]) ch[p][c] = ++cnt;
			p = ch[p][c];
		}
		leef[p] = 1;
	}

	void set() {
		queue<int> q;
		for (int i=0;i<26;i++) if (ch[0][i])
			fail[ ch[0][i] ] = 0, q.push(ch[0][i]);

		while (!q.empty()) {
			int u=q.front(); q.pop();
			for (int i=0;i<26;i++) if (ch[u][i]) {
				int v = ch[u][i], t = fail[u];
				while (t && !ch[t][i]) t = fail[t];
				fail[v] = ch[t][i];
				leef[v] = leef[v] || leef[ fail[v] ];
				q.push(v);
			}
		}
	}

	int g(int u,char *s) {
		int len = strlen(s+1);
		for (int i=1;i<=len;i++) {
			int c = s[i]-'a';
			while (u && !ch[u][c]) u = fail[u];
			if (ch[u][c]) u = ch[u][c];
			if (leef[u]) return -1;
		}
		return u;
	}

}T;

namespace planA
{
	int F[105][5050];
	void solve() 
	{
		F[0][0] = 1;
		for (int _=0;_<l;_++)
			for (int i=0;i<=cnt;i++) if (F[_][i])
				for (int j=1;j<=n;j++) if (_+len[j]<=l) 
				{
					int ni = T.g(i,s[j]);
					if (ni == -1) continue;
					inc(F[_+len[j]][ni], F[_][i]);
				}
		for (int _=0;_<=cnt;_++) inc(ans, F[l][_]);
		cout << ans << endl;
	}
}

namespace planB
{

	struct Matrix{int a,d[205][205];}A,B,id;

	Matrix operator*(Matrix p1, Matrix p2) 
	{
		Matrix ret = id;ret.a = p1.a;
		for (int i=0;i<=p1.a;i++)
			for (int j=0;j<=p1.a;j++)
				for (int k=0;k<=p1.a;k++)
					inc(ret.d[i][j], 1LL*p1.d[i][k] * p2.d[k][j] % mod);
		return ret;
	}

	Matrix qp(Matrix A, int b) 
	{
		Matrix ret = id;
		ret.a = A.a;
		for (int i=0;i<=A.a;i++) ret.d[i][i] = 1;

		while (b) 
		{
			if (b&1) ret = ret * A;
			b >>= 1, A = A * A;
		}
		return ret;
	}

	void solve() 
	{
		int tp = cnt+1;
		A.a = B.a = 2*tp-1;
		A.d[0][0+tp] = 1;

		for (int i=0;i<=cnt;i++) B.d[i+tp][i] = 1;
		for (int i=0;i<=cnt;i++) 
		{
			for (int j=1;j<=n;j++) 
			{
				int ni = T.g(i,s[j]);
				if (ni == -1) continue;
				if (len[j] == 1)
					B.d[i+tp][ni+tp]++;
				else
					B.d[i][ni+tp]++;
			}
		}
		A = A * B;
		B = qp(B, l);
		A = A * B;
		for (int i=0;i<=cnt;i++) inc(ans, A.d[0][i]);
		cout << ans << endl;
	}
}

int main() 
{
	scanf("%d%d%d",&n,&m,&l);
	for (int i=1;i<=n;i++) 
		scanf("%s",s[i]+1), len[i] = strlen(s[i]+1);
	for (int i=1;i<=m;i++) 
		T.add();
	T.set();
	if (l <= 100) planA::solve(); else planB::solve();
	return 0;
}
Problem4866

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<26;
const int N = 60005;
unsigned short cnt[S+5];
char s[N];
int ans[N],num[N];
int pos[N],pre[N],lb[N],rb[N];
inline char nc(){
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline void read(int &x){
	char c=nc(),b=1;
	for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;
	for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;
}
inline void read(char *s){
	char c=nc(); int len=0;
	for (;!(c>='a' && c<='z');c=nc());
	for (;c>='a' && c<='z';s[++len]=c,c=nc());
}
inline void write(ll x){
	if (x>=10) write(x/10); putchar(x%10+'0');
}

inline void add(int x)
{
	cnt[x]++;
	for(register int i = 0;i<26;i++)cnt[x^(1<<i)]++;
}
inline void del(int x)
{
	cnt[x]--;
	for(register int i = 0;i<26;i++)cnt[x^(1<<i)]--;
}
inline int getans(int x){return cnt[x];}
struct Q
{
	int l,r,id;
	Q(int _l=0,int _r=0,int _id=0):l(_l),r(_r),id(_id){}
	bool operator <(const Q &s)const
	{
		return pos[l]==pos[s.l]?r<s.r:pos[l]<pos[s.l];
	}
}ask[N];
int block;
int main()
{
	//freopen("4866.in","r",stdin);
	//freopen("4866.out","w",stdout);
	int n,m,i,j,k;
	read(n),read(m);
	block = min((int)sqrt(n*28),n);
	read(s);
	for(i = 1;i<= n;i++)pre[i] = pre[i-1]^(1<<(s[i]-'a'));
	int tot = 0;
	for(i = 1;i<= n;i++)
		pos[i] = (i-1)/block+1;
	tot = pos[n];
	for(i = 1;i<= tot;i++)
		lb[i] = (i-1)*block+1,rb[i] = i*block;
	rb[tot] = n;
	for(i =1;i<= tot;i++)
	{
		add(pre[rb[i]]);
		for(j = rb[i]-1;j>=lb[i]-1;j--)
		{
			num[j+1] = num[j+2]+getans(pre[j]);
			add(pre[j]);
		}
		for(j = rb[i];j>=lb[i]-1;j--)
			del(pre[j]);
	}
	int L,R,Cnt = 0;
	for(i = 1;i<= m;i++)
	{
		read(L),read(R);
		if(pos[L]==pos[R])
		{
			add(pre[L-1]);
			for(j = L;j<= R;j++)
				ans[i]+=getans(pre[j]),add(pre[j]);
			for(j = L-1;j<= R;j++)
				del(pre[j]);
		}else
			ask[++Cnt] = Q(L,R,i);
	}
	sort(ask+1,ask+Cnt+1);
	int last = 0,pnt = 0;
	for(i = 1;i<tot;i++)
	{
		last = pnt;
		while(pnt+1<=Cnt&&pos[ask[pnt+1].l]==i)pnt++;
		int r = lb[i+1]-1;
		ll now = 0;
		add(pre[r]);
		for(j = last+1;j<= pnt;j++)
		{
			while(r<ask[j].r)now+=getans(pre[++r]),add(pre[r]);
			ans[ask[j].id] = now+num[ask[j].l];
			del(pre[lb[i+1]-1]);
			for(k = ask[j].l-1;k< rb[i];k++)
				ans[ask[j].id]+=getans(pre[k]);
			add(pre[lb[i+1]-1]);
		}
		for(j = lb[i+1]-1;j<= r;j++)del(pre[j]);
	}	
	for(i = 1;i<= m;i++)write(ans[i]),putchar('\n');
	return 0;
}
Problem4867

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
int dis[N],dfn[N],Dfn,size[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
}
void dfs(int x)
{
	dfn[x] = ++Dfn;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to);
		size[x]+=size[e[i].to];
	}
}
const int M = 2e7+5;
const int Bs = 510;
int B;
int n,Q,len;
int pos[N],_a[N],lb[Bs],rb[Bs],mx[Bs],mn[Bs],Size[Bs],cnt,tag[N];
int qo[N],ql[N],qr[N],qk[N];
int F[M];
#define f(i,j) (*(F+Size[(i)-1]+(j)-mn[(i)]))
void Build()
{
	cnt = 0;
	B = sqrt(n);
	for(int i = 1;i<= n;i+=B)
		lb[++cnt] = i,rb[cnt] = i+B-1;
	rb[cnt] = n;
	for(int i = 1;i<= cnt;i++)
		for(int j = lb[i];j<= rb[i];j++)pos[j] = i;
	for(int i = 1;i<= cnt;i++)mx[i]=-1<<30,mn[i]=1<<30;
	for(int i = 1;i<= n;i++)
		mx[pos[i]] = max(mx[pos[i]],_a[i]),mn[pos[i]] = min(mn[pos[i]],_a[i]);
	for(int i = 1;i<= Q;i++)
		if(qo[i]==2)
			mx[pos[ql[i]]]+=qk[i],mx[pos[qr[i]]]+=qk[i];
	for(int i = 1;i<= cnt;i++)
		mn[i]--,Size[i] = Size[i-1]+mx[i]-mn[i];
	for(int i = 1;i<= n;i++)f(pos[i],_a[i])++;
	for(int i = 1;i<= cnt;i++)
		for(int j = mn[i]+2;j<=mx[i];j++)
			f(i,j)+=f(i,j-1);
}
void Add(int l,int r,int d)
{
	int L = pos[l],R = pos[r];
	if(L==R)
	{
		for(int i = l;i<= r;i++)
		{
			for(int j = _a[i]+tag[L];j<= _a[i]+tag[L]+d-1;j++)
				f(L,j)--;
			_a[i]+=d;
		}
		return ;
	}
	for (int i=L+1;i<R;i++) tag[i]+=d,mn[i]+=d;
	for (int i=l;i<=rb[L];i++)
	{
		for (int j=_a[i]+tag[L];j<=_a[i]+tag[L]+d-1;j++)
			f(L,j)--;
		_a[i]+=d;
	}
	for (int i=lb[R];i<=r;i++)
	{
		for (int j=_a[i]+tag[R];j<=_a[i]+tag[R]+d-1;j++)
			f(R,j)--;
		_a[i]+=d;
	}
}
int tmp[N],pnt;

int getans(int l,int r,int K)
{
	if (K>r-l+1) return -1;
	int lbd=pos[l],rbd=pos[r];
	if (lbd==rbd)
	{
		pnt=0;
		for (int i=l;i<=r;i++) tmp[++pnt]=_a[i]+tag[lbd];
		nth_element(tmp+1,tmp+K,tmp+pnt+1);
		return tmp[K];
	}
	pnt=0;
	for (int i=l;i<=rb[lbd];i++) tmp[++pnt]=_a[i]+tag[lbd];
	for (int i=lb[rbd];i<=r;i++) tmp[++pnt]=_a[i]+tag[rbd];
	sort(tmp+1,tmp+pnt+1);
	int L=-1,R=(n+Q)*len;
	while (L+1<R)
	{
		int MID=(L+R)>>1;tot=0;
		if (L<100000 && R>100000) MID=100000;
		for (int i=lbd+1;i<rbd;i++) 
			if (MID>mn[i]) 
				tot+=f(i,min(MID,mx[i]+tag[i]));
		tot+=upper_bound(tmp+1,tmp+pnt+1,MID)-tmp-1;
		if (tot<K)
			L=MID;
		else
			R=MID;
	}
	return R;
}
int main()
{
	scanf("%d%d%d",&n,&Q,&len);
	int p,d;
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&p,&d);
		add(p,i,d);
	}
	dfs(1);
	for(int i = 1;i<= n;i++)_a[dfn[i]]=dis[i];
	for(int i = 1;i<= Q;i++)
	{
		scanf("%d%d%d",&qo[i],&p,&qk[i]);
		ql[i] = dfn[p],qr[i] = dfn[p]+size[p]-1;
	}
	Build();
	for(int i = 1;i<= Q;i++)
		if(qo[i]==2)Add(ql[i],qr[i],qk[i]);
		else printf("%d\n",getans(ql[i],qr[i],qk[i]));
	return 0;
}
Problem4878

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2e4+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int col[N],vis[N],Dfn;
void dfs(int x)
{
	Dfn++;
	for(int i = head[x];i;i=e[i].next)
		vis[col[e[i].to]] = Dfn;
	for(int i = 1;;i++)
		if(vis[i]<Dfn)
		{
			col[x] = i;
			break;
		}
	for(int i = head[x];i;i=e[i].next)
		if(!col[e[i].to])dfs(e[i].to);
}
void init()
{
	memset(vis,0,sizeof(vis));
	memset(col,0,sizeof(col));
	memset(head,0,sizeof(head)),tot = 0,Dfn = 0;
}
int main()
{
	int cas,n,m,k,x,y;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		scanf("%d%d%d",&n,&m,&k);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
		}
		for(int i = 1;i<= n;i++)
			if(!col[i])dfs(i);
		bool cola = true;
		for(int i = 1;i<= n;i++)
			if(col[i]>k)
			{
				cola = false;
				if(col[i]==k+1)x = i;
			}
		if(cola)
		{
			printf("color");
			for(int i = 1;i<= n;i++)
				printf(" %d",col[i]);
			printf("\n");
			continue;
		}
		printf("path");
		for(int i =1;i<= k+1;i++)
		{
			printf(" %d",x);
			for(int j = head[x];j;j=e[j].next)
				if(col[e[j].to]==col[x]-1)
				{x = e[j].to;break;}
		}
		printf("\n");
	}
	return 0;
}
Problem4879

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
set<int>sx[N],sy[N];
set<int>::iterator it;
int dx[]={1,0,-1,0};
int dy[]={0,1,0,-1};
int n,m,K,opt[N],d[N];
ll L,R;
char s[N];
char ask(int x,int y,int flag)
{
	if(flag)swap(x,y);
	return s[x*m+y];
}
void solve(set<int> &s,int st,int end,ll tl,int wh,bool flag)
{
	int l = st,r = end;
	if(l>r)swap(l,r);
	for(it = s.lower_bound(l);it!=s.end()&&*it<=r;)
	{
		if(flag) sx[*it].erase(sx[*it].find(wh));
        else sy[*it].erase(sy[*it].find(wh));
        if(ask(wh,*it,flag)=='#') L=max(L,tl-abs(*it-st));
        else R=min(R,tl-abs(*it-st)-1);
        s.erase(it++);
	}
}
void debug()
{
	for(int i = 0;i<n&&L<=R;i++)
	{
		for(it=sx[i].begin();it!=sx[i].end();it++)
			printf("%d ",*it);
		puts("");
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for(int i = 0;i<n;i++)
		scanf("%s",s+i*m);
	char op[10];
	for(int i = 1;i<= K;i++)
	{
		scanf("%s",op);
		if(op[0]=='l')opt[i] = 3;
		else if(op[0]=='r')opt[i] = 1;
		else if(op[0]=='u')opt[i] = 2;
		else opt[i] =0;
		scanf("%d",&d[i]);
	}
	for(int i = 0;i<n;i++)for(int j = 0;j<m;j++)sx[i].insert(j);
	for(int i = 0;i<n;i++)for(int j = 0;j<m;j++)sy[j].insert(i);
	int curx = n-1,cury = 0;ll t = 1;
	for(int i = 1;i<= K;i++)
	{
		t+=d[i];
		curx+=d[i]*dx[opt[i]],cury+=d[i]*dy[opt[i]];
	}
	R = t;
	for(int i = K;i;i--)
	{
		int tp = (opt[i]+2)%4;
		int nx = curx+d[i]*dx[tp],ny = cury+d[i]*dy[tp];
		if(tp%2)solve(sx[curx],cury,ny,t,curx,false);
		else solve(sy[cury],curx,nx,t,cury,true);
		t-=d[i],curx=nx,cury=ny;
	}
	for(int i = 0;i<n&&L<=R;i++)
		for(it=sx[i].begin();it!=sx[i].end();it++)
		{
			if(ask(i,*it,false)=='#')
			{
				L = R+1;break;
			}
		}
	if(L>R)L = R = -1;
	printf("%lld %lld\n",L,R);
	return 0;
}
Problem4880

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,X,Y;
struct Line
{
	int x,y;
	Line(){}
	Line(int _x,int _y):x(_x),y(_y){}
	bool operator <(const Line &s)const
	{
		bool pd = ((x<0)^(s.x<0));
		return pd?y*s.x>x*s.y:y*s.x<x*s.y;
	}
}k1[N],k2[N];
int tot1,tot2,L1,L2,ans1,ans2;
int cur0[2],cur1[2];
int main()
{
	int a,b;
	scanf("%d%d%d",&n,&X,&Y);n--;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a,&b);
		if(a<X)k1[++tot1] = Line(X-a,b-Y);
		else if(a>X)k2[++tot2] = Line(X-a,b-Y);
		else
		{
			if(b<Y)L1++,L2++;
			else if(b==Y)L1++;
		}
		cur1[0]+=a<=X;
		cur1[1]+=a<X;
		cur0[0]+=b<=Y;
		cur0[1]+=b<Y;
	}
	sort(k1+1,k1+tot1+1);sort(k2+1,k2+tot2+1);
	ans1 = 0,ans2 = n+4;
	for(int i = 1;i<= tot1;i++)
	{
		if(k1[i].x*k1[i].y<0)continue;
		a = i-1,b = i;
		int p1 = lower_bound(k2+1,k2+tot2+1,k1[i])-k2;
		int p2 = upper_bound(k2+1,k2+tot2+1,k1[i])-k2;
		a+=(tot2-p2+1),b+=(tot2-p1+1);
		ans1 = max(ans1,b),ans2 = min(ans2,a);
	}
	for(int i = 1;i<= tot2;i++)
	{
		if(k2[i].x*k2[i].y<0)continue;
		a = tot2-i,b = tot2-i+1;
		int p1 = lower_bound(k1+1,k1+tot1+1,k2[i])-k1;
		int p2 = upper_bound(k1+1,k1+tot1+1,k2[i])-k1;
		a+=(p1-1),b+=(p2-1);
		ans1 = max(ans1,b),ans2 = min(ans2,a);
	}
	ans1+=L1,ans2+=L2;
	ans1 = max(ans1,max(cur1[0],cur0[0]));
	ans2 = min(ans2,min(cur1[1],cur0[1]));
	printf("%d %d\n",n+1-ans1,n+1-ans2);
	return 0;
}
Problem4881

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 998244353;
int c[N],a[N],f[N];
int getans(int x)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))ans=max(ans,c[i]);
	return ans;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))c[i] = max(c[i],y);
}
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
set<int>S;
set<int>::iterator it;
set<int>::iterator tmp;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int mx = 0;
	for(int i = 1;i<= n;i++)
	{
		f[i] = getans(n-a[i])+1;
		update(n-a[i]+1,f[i]);
		mx = max(mx,f[i]);
	}
	if(mx>2)
	{
		puts("0");
		return 0;
	}
	for(int i = 1;i<= n;i++)
	{
		int mx = a[i];
		it = S.upper_bound(a[i]);
		while(it!=S.end())
		{
			mx = max(mx,*it);
			tmp = it;
			it++;S.erase(tmp);
		}
		S.insert(mx);
	}
	printf("%d\n",quick_pow(2,S.size()));
	return 0;
}
Problem4886

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250005;
int cnt,mx;
int a[N],b[N],g[N<<1],idx[N<<1],fa[N<<1],mxv[N<<1];
bool d[N<<1];
map<int,int>h;
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x]=getfa(fa[x]);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
		idx[++cnt]=a[i],idx[++cnt]=b[i];
	}
	sort(idx+1,idx+cnt+1);
	for(int i = 1;i<= cnt;i++)
		if(i==1||idx[i]!=idx[i-1])
			g[h[idx[i]]=++mx] = idx[i];
	long long ans = 0;
	for(int i = 1;i<= mx;i++)
	{
		fa[i] = i;mxv[i] = g[i];
		ans-=g[i];
	}
	for(int i = 1;i<= n;i++)
	{
		ans+=a[i]+b[i];
		int fx = getfa(h[a[i]]),fy = getfa(h[b[i]]);
		if(fx!=fy)
		{
			d[fx]|=d[fy];
			mxv[fx] = max(mxv[fx],mxv[fy]);
			fa[fy] = fx;
		}else
			d[fx] = true;
	}
	for(int i = 1;i<= mx;i++)
		if(getfa(i)==i&& !d[i])ans+=mxv[i];
	printf("%lld\n",ans);
	return 0;
}
Problem4887

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 2017;
struct Martix
{
	int d[35][35];
	int w,h;
	Martix(int _w=0,int _h=0):w(_w),h(_h){memset(d,0,sizeof(d));}
	Martix operator *(const Martix &s)const
	{
		Martix res(s.w,h);
		for(int i = 1;i<= res.w;i++)
			for(int k = 1;k<= s.h;k++)
				if(s.d[i][k])
					for(int j = 1;j<= res.h;j++)
						(res.d[i][j]+=s.d[i][k]*d[k][j]%mod)%=mod;
		return res;
	}
	friend Martix operator ^(const Martix &a,int s)
	{
		Martix res(a.w,a.h);
		Martix t = a;
		for(int i = 1;i<= a.w;i++)res.d[i][i] = 1;
		while(s)
		{
			if(s&1)res = res*t;
			t = t*t;
			s>>=1;
		}
		return res;
	}
};
int main()
{
	int n,m;
	int x,y;
	scanf("%d%d",&n,&m);
	Martix go(n+1,n+1),ans(n+1,1);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		go.d[x][y]++;
		go.d[y][x]++;
	}
	for(int i = 1;i<= n+1;i++)
		go.d[i][i]=1,go.d[n+1][i]=1;
	ans.d[1][1] = 1;
	int t;
	scanf("%d",&t);
	ans = ans*(go^t);
	int Ans = 0;
	for(int i = 1;i<= n+1;i++)(Ans+=ans.d[i][1])%=mod;
	printf("%d\n",Ans);
	return 0;
}
Problem4888

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int Max = 1e6+1e5;
int c[2][Max];
int a[N],ans[N],n;
inline int Get_bit(int x,int y)
{
	return (x>>(y-1))&1;
}
void Update(int id,int x,int y)
{
	for(int i = x;i<Max;i+=i&(-i))
		c[id][i]+=y;
}
int Getans(int id,int x)
{
	int res = 0;
	for(int i = x;i;i-=i&(-i))
		res+=c[id][i];
	return res;
}

int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		a[i]+=a[i-1];
	}
	for(int i = 1,ba = 1;i<= 20;i++)
	{
		memset(c,0,sizeof(c));
		for(int j = 1;j<= n;j++)
		{
			ans[i]+=Getans(Get_bit(a[j],i),ba+1)-Getans(Get_bit(a[j],i),a[j]%ba+1)
			+Getans(!Get_bit(a[j],i),a[j]%ba+1)+Get_bit(a[j],i);
			Update(Get_bit(a[j],i),a[j]%ba+1,1);
		}
		ba = ba<<1;
	}
	int Ans = 0;
	for(int i = 1,ba = 1;i<= 20;i++,ba<<=1)Ans+=(ans[i]&1)*ba;
	printf("%d\n",Ans);
	return 0;
}
Problem4889

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e4+5;
const int B = 500;
const int mod = 1e9+7;
int st[B],end[B],bel[N],n;
struct data
{
	int a,v;
	bool operator <(const data &s)const
	{
		if(a==s.a)return v<s.v;
		return a<s.a;
	}
}ord[B][B+5],num[N];
int sum[B][B+5];
ll tot_ans;
struct Bit_array
{
	int c[N];
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i;i-=i&(-i))
			(ans+=c[i])%=mod;
		return ans;
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			(c[i]+=y)%=mod;
	}
	int getans(int x,int y)
	{
		return (getans(y)-getans(x-1)+mod)%mod;
	}
}c1,c2;
int less_than(int x,int block)
{
	int l = 1,r = end[block]-st[block]+2;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(ord[block][mid].a<x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
int bigger_than(int x,int block)
{
	int l = 1,r = end[block]-st[block]+2;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(ord[block][mid].a<=x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
void rebuild(int i)
{
	for(int j = st[i];j<=end[i];j++)
			ord[i][j-st[i]+1] = num[j];
	sort(ord[i]+1,ord[i]+end[i]-st[i]+2);
	for(int k = 1;k<= end[i]-st[i]+1;k++)
		sum[i][k] = sum[i][k-1]+ord[i][k].v;
}
int main()
{
	int m;
	scanf("%d%d",&n,&m);
	int bsize = sqrt(0.7*n)+1;
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&num[i].a,&num[i].v);
	for(int i = 1;i<= n;i++)
	{
		tot_ans+=(c2.getans(num[i].a+1,n)+(ll)c1.getans(num[i].a+1,n)*num[i].v%mod)%mod;
		tot_ans = (tot_ans%mod+mod)%mod;
		c1.update(num[i].a,1);
		c2.update(num[i].a,num[i].v);
	}
	int bnum = 0;
	for(int i = 1;i<= n;i+=bsize)
		st[++bnum]=i,end[bnum]=i+bsize-1;
	end[bnum] = n;
	int j;
	for(int i = 1;i<= bnum;i++)
	{
		for(j = st[i];j<=end[i];j++)
			ord[i][j-st[i]+1] = num[j],bel[j]=i;
		sort(ord[i]+1,ord[i]+end[i]-st[i]+2);
		for(int k = 1;k<= end[i]-st[i]+1;k++)
			sum[i][k] = sum[i][k-1]+ord[i][k].v;
	}
	int x,y;
	//scanf("%d",&m);
	while(m--)
	{
		scanf("%d%d",&x,&y);
		if(x>y)swap(x,y);
		int L = bel[x],R = bel[y];
		if(L==R)
		{
			for(int i = x+1;i< y;i++)
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;
			for(int i = x+1;i< y;i++)
				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
			if(num[x].a<num[y].a)tot_ans+=num[x].v+num[y].v;
			else if(num[x].a>num[y].a)tot_ans-=num[x].v+num[y].v;
			swap(num[x],num[y]);
			rebuild(L);
		}else
		{
			for(int i = x+1;i<=end[L];i++)
			{
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;

				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			for(int i = st[R];i< y;i++)
			{
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;

				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			for(int i = L+1;i<= R-1;i++)
			{
				int lx = less_than(num[x].a,i);
				int bx = bigger_than(num[x].a,i);
				int ly = less_than(num[y].a,i);
				int by = bigger_than(num[y].a,i);
				tot_ans-=sum[i][lx]+(ll)lx*num[x].v%mod;
				tot_ans+=sum[i][end[i]-st[i]+1]-sum[i][bx]+(ll)(end[i]-st[i]+1-bx)*num[x].v%mod;
				tot_ans+=sum[i][ly]+(ll)ly*num[y].v%mod;
				tot_ans-=sum[i][end[i]-st[i]+1]-sum[i][by]+(ll)(end[i]-st[i]+1-by)*num[y].v%mod;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			if(num[x].a<num[y].a)tot_ans+=num[x].v+num[y].v;
			else if(num[x].a>num[y].a)tot_ans-=num[x].v+num[y].v;
			swap(num[x],num[y]);
			rebuild(L),rebuild(R);
		}
		tot_ans = (tot_ans%mod+mod)%mod;
		printf("%lld\n",tot_ans);
	}
	return 0;
}
Problem4891

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef long double ld;
int n,m,k;
ll b[100005],a[22][100005],M;
int fp,ts[100];
ll fs[100];
ll mul(ll a,ll b,ll c)
{
    if(c<=2000000000ll)return a*b%c;
    ll r=a*b-ll(ld(a)/c*b)*c;
    if(r>=c||r<=-c)r%=c;
    return r>=0?r:r+c;
}
ll pw(ll a,ll n,ll P)
{
    ll v=1;
    for(;n;n>>=1,a=mul(a,a,P))if(n&1)v=mul(v,a,P);
    return v;
}
ll gcd(ll a,ll b)
{
    if(a<0)a=-a;
    for(ll c;b;c=a,a=b,b=c%b);
    return a;
}
bool mr(ll n)
{
    ll z=n-1;
    int t=0;
    while(~z&1)z>>=1,++t;
    for(int i=0;i<15;++i)
    {
        ll a=rand()%(n-1)+1;
        ll x=pw(a,z,n);
        for(int j=0;j<t;++j)
        {
            ll y=mul(x,x,n);
            if(y==1&&x!=1&&x!=n-1)return 0;
            x=y;
        }
        if(x!=1)return 0;
    }
    return 1;
}
ll get(ll x,int c)
{
    int i=1,j=2;
    ll a=(rand()^ll(rand())<<31)%(x-1)+1,b=a;
    while(1)
    {
        a=mul(a,a,x);
        if((a+=c)>=x)a%=x;
        ll p=gcd(a-b,x);
        if(p!=1)return p;
        if((++i)==j)j<<=1,b=a;
    }
}
void calc(ll n)
{
    if(n==1)return;
    if(mr(n))
    {
        fs[fp++]=n;
        return;
    }
    for(int c=12347;;++c)
    {
        ll a=get(n,c);
        if(a!=n)
        {
            ll b=gcd(a,n/a);
            calc(a/b);
            calc(n/a/b);
            calc(b);
            return;
        }
    }
}
ll cal(ll*b,ll*a,ll M)
{
    fp=0;
    calc(M);
    std::sort(fs,fs+fp);
    fp=std::unique(fs,fs+fp)-fs;
    ll phi_M=M;
    for(int i=0;i<fp;++i)ts[i]=0,phi_M=phi_M/fs[i]*(fs[i]-1);
    ll B=1,A=1,x;
    for(int i=1;i<=m;++i)
    {
        x=b[i];
        if(fs[0]==2)for(;~x&1;x>>=1,++ts[0]);
        for(int j=(fs[0]==2);j<fp;++j)
        {
            for(ll p=fs[j],y=x/p;y*p==x;x=y,y=y/p,++ts[j]);
        }
        B=mul(B,x,M);
    }
    for(int i=1;i<=m;++i)
    {
        x=a[i];
        if(fs[0]==2)for(;~x&1;x>>=1,--ts[0]);
        for(int j=(fs[0]==2);j<fp;++j)
        {
            for(ll p=fs[j],y=x/p;y*p==x;x=y,y=y/p,--ts[j]);
        }
        A=mul(A,x,M);
    }
    B=mul(B,pw(A,phi_M-1,M),M);
    for(int i=0;i<fp;++i)
    {
        if(ts[i]<0)return -1;
        B=mul(B,pw(fs[i],ts[i],M),M);
    }
    return B;
}
int main()
{
    srand(200037);
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;++i)scanf("%lld",&b[i]);
    for(int t=1;t<=n;++t)
    	for(int i=1;i<=m;++i)
    		scanf("%lld",&a[t][i]);
    for(int i=0;i<k;++i)
    {
    	int x;
    	scanf("%d%lld",&x,&M);
        printf("%lld\n",cal(b,a[x],M));
    }
    return 0;
}
Problem4892

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
const int sed = 37;
const int N = 1e5+5;
ull Pow[N],h1[N],h2[N];
char s1[N],s2[N];
int l1,l2,T,c;
void check(int l1,int r1,int l2,int r2)
{
	while(c<=3&&l1<=r1)
	{
		if(s1[l1]!=s2[l2])l1++,l2++,c++;
		else if(s1[r1]!=s2[r2])r1--,r2--,c++;
		else break;
	}
	if(l1>r1||c>3)return ;
	if(h1[r1]-h2[r2]==(h1[l1-1]-h2[l2-1])*Pow[r1-l1+1])return ;
	int d = (r1-l1)>>1;
	check(l1,l1+d,l2,l2+d);
	check(l1+d+1,r1,l2+d+1,r2);
}
void work()
{
	l1=strlen(s1+1);
	l2=strlen(s2+1);
	for(int i = 1;i<= l1;i++)h1[i]=h1[i-1]*sed+s1[i];
	for(int i = 1;i<= l2;i++)h2[i]=h2[i-1]*sed+s2[i];
	int ans = 0;
	for(int i = 1;i<= l1-l2+1;i++)
	{
		c = 0;
		check(i,i+l2-1,1,l2);
		if(c<=3)ans++;
	}
	printf("%d\n",ans);
}
int main()
{
	Pow[0] = 1;
	for(int i = 1;i<N;i++)Pow[i] = Pow[i-1]*sed;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%s%s",s1+1,s2+1);
		work();
	}
	return 0;
}
Problem4893

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define mp(a,b) make_pair(a,b)
const int N = 1e5+5;
int a[N],b[3],c[3];
set<pair<int,pair<int,int> > >S;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		b[a[i]]++;
	}
	b[0]>>=1,b[1]>>=1,b[2]>>=1;
	for(int i = 1;i<= n;i++)
	{
		c[a[i]]++;
		if(b[0]==c[0]&&b[1]==c[1]&&b[2]==c[2])
			return printf("1\n"),0;
	}
	c[0] = c[1] = c[2] = 0;
	for(int i = 1;i<= n;i++)
	{
		c[a[i]]++;
		if(S.count(mp(c[0]-b[0],mp(c[1]-b[1],c[2]-b[2]))))
			return printf("2\n"),0;
		S.insert(mp(c[0],mp(c[1],c[2])));
	}
	printf("3\n");
	return 0;
}
Problem4896

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 6e6+5;
char s[100];
int ch[N][10],siz[N],cnt;
vector<int>num[N];
void Insert(int id)
{
	int now = 0,i = 1;
	while(s[i])
	{
		if(!ch[now][s[i]-'a'])ch[now][s[i]-'a'] = ++cnt;
		now = ch[now][s[i]-'a'];
		i++;
		siz[now]++;
		if(siz[now]>num[now].size())num[now].push_back(id);
	}
}
void Delete()
{
	int now = 0,i= 1;
	while(s[i])
	{
		now = ch[now][s[i]-'a'];
		siz[now]--;
		i++;
	}
}
int Find()
{
	int now = 0,i = 1;
	while(s[i])
	{
		now = ch[now][s[i]-'a'];
		i++;
	}
	return now;
}
int main()
{
	int n,k,a,b,c,lst=0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		if(k==3)
		{
			scanf("%s",s+1);
			scanf("%d%d%d",&a,&b,&c);
			a = ((ll)a*abs(lst)+b)%c;
			int pos = Find();
			if(num[pos].size()<=a)lst = -1;
			else lst = num[pos][a];
			printf("%d\n",lst);
		}else
		{
			scanf("%s",s+1);
			if(k==1)Insert(i);
			else Delete();
		}
	}
	return 0;
}
Problem4897

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int INF = 1e9;
int dp[N][N],dp1[N][N][N];
int mx[N][N],mn[N][N];
int n,a,b,w[N];
void DP(int l,int r)
{
	register int i,j,k,o;
	for(i = l;i<= r;i++)
		for(j = l;j<= r;j++)
			for(k = l;k<= r;k++)
				dp1[i][j][k] = INF;
	dp1[l][l][l] = 0;
	for(i = l;i<= r;i++)
	{
		if(i!=l)dp1[i][i][i] = min(dp1[i][i][i],dp[l][i-1]);
		for(j = l;j<= r;j++)
			for(k = l;k<= r;k++)
			{
				if(dp1[i][j][k]==INF)continue;
				dp1[i+1][w[j]>w[i+1]?j:i+1][w[k]<w[i+1]?k:i+1] = min(dp1[i+1][w[j]>w[i+1]?j:i+1][w[k]<w[i+1]?k:i+1] ,dp1[i][j][k]);
				for ( o = i + 1 ; o <= r ; o++ )
                	dp1[o][j][k] = min ( dp1[o][j][k] , dp1[i][j][k] + dp[i+1][o] );  
			}
	}
}
int main()
{
	scanf("%d%d%d",&n,&a,&b);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= n;i++)
	{
		mx[i][i] = mn[i][i] = w[i]; 
		for(int j = i+1;j<= n;j++)
			mx[i][j] = max(mx[i][j-1],w[j]),
			mn[i][j] = min(mn[i][j-1],w[j]);
	}
	for(int l = 1;l<= n;l++)
	{
		for(int i = 1;i<= n-l+1;i++)
		{
			int j = i+l-1;
			dp[i][j] = a+b*(mx[i][j]-mn[i][j])*(mx[i][j]-mn[i][j]);
			DP(i,j);
			for (int k = i ; k <= j ; k++ ) 
				for (int o = i ; o <= j ; o++ ) 
				{  
                	if ( w[k] < w[o] ) continue;  
                	dp[i][j] = min ( dp[i][j] , dp1[j][k][o] + a + b * (w[k]-w[o]) * (w[k]-w[o]) );  
            	}  
		}
	}
	printf ("%d\n",dp[1][n]);  
	return 0;
}
Problem4899

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 705;
const int P = 705;
const int M = 1505;
struct E
{int next,to;}e[M];
int head[M],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
double g[M],dis[N][N],f[N][P];
int d[M],n,m,p;
void dfs(int x)
{
	g[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		g[x]+=g[e[i].to]/d[x];
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int x,y;
		scanf("%d%d%d",&n,&m,&p);
		for(int i = 1;i<= m-n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);d[x]++;
		}
		for(int i = 1;i<= n;i++)dfs(i);
		for(int i = 1;i<= n;i++)
			for(int j = i+1;j<= n;j++)
				dis[i][j] = 
			(dis[i][j-1]+1.0/(d[j-1]+1)+1.0*d[j-1]/(d[j-1]+1)*g[j-1])*(d[j-1]+1);
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= p;j++)
				f[i][j]=1e18;
		f[1][1] = 0;
		int lim = (n+p-1)/p+1;
		for(int i = 1;i<= n;i++)
			for(int j = 1;j< p;j++)
				for(int k = i+1;k<= i+lim&&k<= n;k++)
					f[k][j+1] = min(f[k][j+1],f[i][j]+dis[i][k]);
		printf("%.4f\n",f[n][p]);tot=0;
		for(int i = 1;i<= m;i++)d[i]=0,head[i]=0,g[i]=0;
	}
	return 0;
}
Problem4906

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+20;
struct data
{
	ll f[4][4];
	data(){memset(f,0,sizeof(f));}
	data(ll a,ll b,ll c)
	{
		f[0][0]=f[3][3]=a;f[1][1]=b;f[2][2]=c;
		f[0][1]=max(a,b),f[1][2]=max(b,c),f[2][3]=max(c,a);
		f[0][2]=f[1][3]=f[0][3]=max(max(b,c),a);
	}
	friend data operator +(const data &a,const data &b)
	{
		data c;
		for(int l = 1;l<= 4;l++)
			for(int i = 0;i+l-1<4;i++)
			{
				int j = i+l-1;
				for(int k = i;k<= j;k++)
					c.f[i][j]=max(c.f[i][j],a.f[i][k]+b.f[k][j]);
			}
		return c;
	}
}s[N];
int fa[N],size[N],ch[N][2];
int rt,mark,A[N],B[N],C[N],L[N],n,cnt,q[N],top,tms;
ll Size[N],tot;
void Push_up(int x)
{
	s[x] = data(1ll*A[x]*L[x],1ll*B[x]*L[x],1ll*C[x]*L[x]);
	if(ch[x][0])s[x] = s[ch[x][0]]+s[x];
	if(ch[x][1])s[x] = s[x]+s[ch[x][1]];
	Size[x] = Size[ch[x][0]]+Size[ch[x][1]]+L[x];
	size[x] = size[ch[x][0]]+size[ch[x][1]]+1;
}
int Find(int x,ll pos)
{
	ll Sz1 = Size[ch[x][0]],Sz2 = Sz1+L[x];
	if((Sz1<pos||(!ch[x][0]&&!pos))&&Sz2>=pos)return x;
	else if(Sz1>=pos)return Find(ch[x][0],pos);
	else {tot+=Sz2;return Find(ch[x][1],pos-Sz2);}
}
void Insert(int &x,int ai,int bi,int ci,ll pos,int len,int last=0)
{
	if(!x)
	{
		x = ++cnt;
		s[x] = data(1ll*ai*len,1ll*bi*len,1ll*ci*len);
		L[x]=Size[x]=len;
		A[x]=ai,B[x]=bi,C[x]=ci;fa[x]=last;size[x]=1;
		return ;
	}
	ll Sz = Size[ch[x][0]]+L[x];
	if(pos<Sz)Insert(ch[x][0],ai,bi,ci,pos,len,x);
	else Insert(ch[x][1],ai,bi,ci,pos-Sz,len,x);
	Push_up(x);
	if(max(size[ch[x][0]],size[ch[x][1]])>0.7*size[x])mark=x;
}
void Update(int x,int k,ll pos,int Len)
{
	if(x==k)
	{
		L[x] = Len;
		Push_up(x);
		return ;
	}
	if(Size[ch[x][0]]>=pos)Update(ch[x][0],k,pos,Len);
	else Update(ch[x][1],k,pos-L[x]-Size[ch[x][0]],Len);
	Push_up(x);
}
void Dfs(int x)
{
	if(ch[x][0])Dfs(ch[x][0]);
	q[++top]=x;
	if(ch[x][1])Dfs(ch[x][1]);
}
void Build(int &x,int l,int r,int last)
{
	if(l>r)
	{
		x=0;
		return ;
	}
	int mid = (l+r)>>1;
	x = q[mid];fa[x] = last;
	Build(ch[x][0],l,mid-1,x);
	Build(ch[x][1],mid+1,r,x);
	Push_up(x);
}
void rebuild(int x)
{
    mark=top=0;
    Dfs(x);
    int y=fa[x];
    if(!y) Build(rt,1,top,0);
    else Build(ch[y][ch[y][1]==x],1,top,y);
}

int main()
{
	scanf("%d",&n);
	Insert(rt,0,0,0,0,0);
	ll pre = 0;
	for(int i = 1;i<= n;i++)
	{
		ll pi;int ai,bi,ci,x;
		scanf("%lld%d%d%d%d",&pi,&ai,&bi,&ci,&x);
		tot = tms = 0;
		int k = Find(rt,pi);
		if(tot+Size[ch[k][0]]+L[k]!=pi)
		{
			ll Left=tot+Size[ch[k][0]]+L[k]-pi;
            tms=0;
            Update(rt,k,pi,L[k]-Left);    
            Insert(rt,ai,bi,ci,pi,x);
            if(mark) rebuild(mark);
            Insert(rt,A[k],B[k],C[k],pi+x,Left);
		}else Insert(rt,ai,bi,ci,pi,x);
		printf("%lld\n",s[rt].f[0][3]-pre);
		pre = s[rt].f[0][3];
		if(mark)rebuild(mark);
	}
	return 0;
}
Problem4908

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=200005;
int n;
int a[N],b[N];
int Q,x[N],y[N];
int sx[N],icnt;
inline int Bin(int x)
{
	return lower_bound(sx+1,sx+icnt+1,x)-sx;
}
const int BB=505;
int B,lp[BB],rp[BB];
int pos[N],cnt;
int v[N],c[N];
int idx[N];
int pnt[BB],lc[BB][BB]; 
ll svc[BB][BB],sv[BB][BB];
int p[BB],q[BB];
ll ans[BB];
#define Size(x) (rp[x]-lp[x]+1)
inline ll Sum(int x)
{
	return sv[x][p[x]]*q[x]-svc[x][p[x]]+(svc[x][pnt[x]]-svc[x][p[x]])-(sv[x][pnt[x]]-sv[x][p[x]])*q[x];
}
ll Ans=0;
int _c[512];
int tmp[N],t2[N];
void rsort(int l,int r)
{
	for (int i=l;i<=r;i++) c[i]+=50000;

	for (int i=0;i<512;i++) _c[i]=0;
	for (int i=l;i<=r;i++) _c[c[i]&511]++;
	for (int i=1;i<512;i++) _c[i]+=_c[i-1];
	for (int i=r;i>=l;i--) tmp[_c[c[i]&511]--]=i;

	for (int i=0;i<512;i++) _c[i]=0;
	for (int i=1;i<=r-l+1;i++) _c[c[tmp[i]]>>9]++;
	for (int i=1;i<512;i++) _c[i]+=_c[i-1];
	for (int i=r-l+1;i;i--) t2[_c[c[tmp[i]]>>9]--]=tmp[i];

	for (int i=l;i<=r;i++) idx[i]=t2[i-l+1],c[i]-=50000;
}
void Build(int x)
{
	rsort(lp[x],rp[x]);
	Ans-=ans[x]; pnt[x]=0;
	for (int j=lp[x];j<=rp[x];j++)
		if (j==lp[x] || c[idx[j]]!=c[idx[j-1]])
		{
			pnt[x]++,lc[x][pnt[x]]=c[idx[j]];
			sv[x][pnt[x]]=sv[x][pnt[x]-1]+v[idx[j]];
			svc[x][pnt[x]]=svc[x][pnt[x]-1]+(ll)v[idx[j]]*c[idx[j]];
		}
		else
		{
			sv[x][pnt[x]]+=v[idx[j]];
			svc[x][pnt[x]]+=(ll)v[idx[j]]*c[idx[j]];
		}
	q[x]=0;
	p[x]=upper_bound(lc[x]+1,lc[x]+pnt[x]+1,0)-lc[x]-1;
	Ans+=(ans[x]=Sum(x));
}

void Reb(int x,int l,int r,int t)
{
	if (l>r) return;
	for (int i=lp[x];i<=rp[x];i++) c[i]-=q[x];
	for (int i=l;i<=r;i++) c[i]+=t;
	Build(x);
}
void Add(int l,int r,int t)
{
	int lb=pos[l],rb=pos[r];
	if (lb==rb)
	{
		Reb(lb,l,r,t);
		return;
	}
	Reb(lb,l,rp[lb],t);
	Reb(rb,lp[rb],r,t);
	for (int i=lb+1;i<rb;i++)
	{
		Ans-=ans[i];
		q[i]-=t;
		while (p[i]+1<=pnt[i] && lc[i][p[i]+1]<=q[i]) p[i]++;
		while (p[i]>0 && lc[i][p[i]]>q[i]) p[i]--; 
		Ans+=(ans[i]=Sum(i));
	}
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
		scanf("%d",&a[i]),sx[++icnt]=a[i];
	for (int i=1;i<=n;i++) 
		scanf("%d",&b[i]),sx[++icnt]=b[i];
	scanf("%d",&Q); 
	for (int i=1;i<=Q;i++) 
		scanf("%d%d",&x[i],&y[i]),sx[++icnt]=y[i];
	sort(sx+1,sx+icnt+1); 
	icnt=unique(sx+1,sx+icnt+1)-sx-1;
	for (int i=1;i<icnt;i++) 
		v[i]=sx[i+1]-sx[i];
	B=sqrt(icnt);
	for (int i=1;i<=icnt;i++) 
		pos[i]=(i-1)/B+1; cnt=pos[icnt];
	for (int i=1;i<=cnt;i++) 
		lp[i]=(i-1)*B+1,rp[i]=i*B; rp[cnt]=icnt;
	for (int i=1;i<=n;i++) 
		a[i]=Bin(a[i]),b[i]=Bin(b[i]),c[a[i]]++,c[b[i]]--;
	for (int i=1;i<=icnt;i++) 
		c[i]+=c[i-1];
	for (int i=1;i<=cnt;i++)
		Build(i);
	printf("%lld\n",Ans);
	for (int i=1;i<=Q;i++)
	{
		y[i]=Bin(y[i]);
		if (y[i]<a[x[i]])
			Add(y[i],a[x[i]]-1,1),a[x[i]]=y[i];
		else if (a[x[i]]<y[i])
			Add(a[x[i]],y[i]-1,-1),a[x[i]]=y[i];
		printf("%lld\n",Ans);
	}
	return 0;
}
Problem4911

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int mxK = 130;
const int mod = 10007;
const int inv2 = (mod+1)>>1;

inline void FWT(int *a,int n,int type)
{
	for(int i = 1;i<n;i<<=1)
		for(int j = 0;j<n;j+=(i<<1))
			for(int k = 0;k<i;k++)
			{
				int x = a[j+k],y = a[j+k+i];
				a[j+k] = (x+y)%mod;
				a[j+k+i] = (x-y+mod)%mod;
				if(!type)(a[j+k]*=inv2)%=mod,(a[j+k+i]*=inv2)%=mod;
			}
}
int quick_pow(int x,int y)
{int res=1;while(y){if(y&1)res=res*x%mod;x=x*x%mod;y>>=1;}return res;}
int K,kx[mxK][mxK];
int inv[mod];
void pre(int n)
{
	for(int i = 0;i<n;i++)
		kx[i][i]=1,FWT(kx[i],n,1);
	for(int i = 1;i<mod;i++)inv[i]=quick_pow(i,mod-2);
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int fa[N],size[N],top[N];
int dep[N],son[N];
vector<int>P[N];
void dfs1(int x)
{
	size[x] = 1;dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	P[tp].push_back(x);
	top[x] = tp;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct data
{
	int x,y;
	data(int num=0)
	{
		if(num)x=num,y=0;
		else x=y=1;
	}
	int val(){return y?0:x;}
	data & operator *=(int a)
	{
		if(!a)y++;
		else x = x*a%mod;
		return *this;
	} 
	data & operator /=(int a)
	{
		if(!a)y--;
		else x = x*inv[a]%mod;
		return *this;
	}
};
data Base[N][mxK];
int cnt,pos[N],rt[N];
int ps[N<<2],ls[N<<2],rs[N<<2];
int val[N<<2][mxK],lv[N<<2][mxK],rv[N<<2][mxK],sum[N<<2][mxK];
inline void update(int p)
{
	int l = ls[p],r = rs[p];
	for(int i = 0;i<K;i++)
	{
		val[p][i] = (val[l][i]+val[r][i]+rv[l][i]*lv[r][i])%mod;
		lv[p][i] = (lv[l][i]+lv[r][i]*sum[l][i])%mod;
		rv[p][i] = (rv[r][i]+rv[l][i]*sum[r][i])%mod;
		sum[p][i] = sum[l][i]*sum[r][i]%mod;
	}
}
inline void Build(int &p,int l,int r,int t)
{
	p = ++cnt;
	if(l==r)
	{
		for(int i = 0;i<K;i++)
			val[p][i]=lv[p][i]=rv[p][i]=sum[p][i]=Base[P[t][l-1]][i].val();
		pos[P[t][l-1]] = p;
		return ;
	}
	int mid = (l+r)>>1;
	Build(ls[p],l,mid,t);
	Build(rs[p],mid+1,r,t);
	update(p);ps[ls[p]]=ps[rs[p]]=p;
}
int ans[mxK],tmp[mxK];
void Update(int u)
{
	int t = top[u];
	if (fa[t])
		for (int j=0;j<K;j++)
			Base[fa[t]][j]/=(lv[rt[t]][j]+kx[0][j])%mod;
	for(int j = 0;j<K;j++)
		ans[j] = (ans[j]+mod-val[rt[t]][j])%mod;

	int x = pos[u];
	for(int i = 0;i<K;i++)
		val[x][i]=lv[x][i]=rv[x][i]=sum[x][i]=Base[u][i].val();
	x = ps[x];
	while(x)
		update(x),x=ps[x];

	if (fa[t])
		for (int j=0;j<K;j++)
			Base[fa[t]][j]*=(lv[rt[t]][j]+kx[0][j])%mod;
	for(int j = 0;j<K;j++)
		ans[j] = (ans[j]+val[rt[t]][j])%mod;
}
int n,Val[N],last[N],pnt;
inline bool cmp(int a,int b)
{
	return dep[a]>dep[b];
}
int main()
{
	//freopen("4911.in","r",stdin);
	//freopen("4911.out","w",stdout);
	int x,y,Q;
	char order[10];
	scanf("%d%d",&n,&K);
	int t = 1;
	while(t<K)t<<=1;K = t;
	pre(K);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);Val[i] = x;
		for(int j = 0;j<K;j++)Base[i][j]=data(kx[x][j]);
	}
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		if(top[i]==i)
			last[++pnt]=i;
	sort(last+1,last+pnt+1,cmp);
	for(int i = 1;i<= pnt;i++)
	{
		int x = last[i];
		Build(rt[x],1,P[x].size(),x);
		if(fa[x])
		{
			int f = fa[x];
			for(int j = 0;j<K;j++)
				Base[f][j]*=(lv[rt[x]][j]+kx[0][j])%mod;
		}
		for(int j = 0;j<K;j++)
			ans[j] = (ans[j]+val[rt[x]][j])%mod;
	}
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%s",order);
		if(order[0]=='C')
		{
			scanf("%d%d",&x,&y);
			for(int j=0;j<K;j++)
				Base[x][j]/=kx[Val[x]][j];
			Val[x]=y;
			for (int j=0;j<K;j++)
				Base[x][j]*=kx[Val[x]][j];
			while (x!=0)
				Update(x),x=fa[top[x]];
		}
		else
		{
			scanf("%d",&x);
			for(int j = 0;j<K;j++)tmp[j]=ans[j];
			FWT(tmp,K,0);
			printf("%d\n",tmp[x]);
		}
	}
	return 0;
}
Problem4915

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int main()
{
	ll l,r;
	scanf("%lld%lld",&l,&r);
	printf("4\n%lld\n",max(r/11-l+1,0ll)+max(r/29-l+1,0ll));
	return 0;
}
Problem4919

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <set>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
typedef long long ll;
int v[N],p[N],idx[N];
multiset<int>heap[N];
multiset<int>::iterator it;
struct E
{int next,to;}e[N];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
int merge(int x,int y)
{
	if(heap[x].size()<heap[y].size())swap(x,y);
	for(it = heap[y].begin();it!=heap[y].end();it++)
		heap[x].insert(*it);
	heap[y].clear();
	return x;
}	
void debug(int x)
{
	printf("Case #%d\n",x);
	for(it = heap[x].begin();it!=heap[x].end();it++)
		printf("%d ",*it);
	printf("\n");
}
int cnt;
void dfs(int x)
{
	bool lef = true;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to),lef = false;
	if(lef)idx[x] = ++cnt;
	else idx[x] = idx[e[head[x]].to];
	for(int i = e[head[x]].next;i;i=e[i].next)
		idx[x] = merge(idx[x],idx[e[i].to]);
	it = heap[idx[x]].lower_bound(v[x]);
	if(it==heap[idx[x]].end())heap[idx[x]].insert(v[x]);
	else heap[idx[x]].erase(it),heap[idx[x]].insert(v[x]);
	//debug(idx[x]);
}
int main()
{
	int n,rot;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&v[i],&p[i]);
		add(p[i],i);if(p[i]==0)rot=i;
	}
	dfs(rot);
	printf("%d\n",heap[idx[rot]].size());
	return 0;
}
Problem4921

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 998244353;
int f[N],ls[N],a[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		f[i] = gcd(f[i-1],a[i]);
	}
	for(int i = 2;i<= n;i++)
		if(f[i]==f[i-1])ls[i] = ls[i-1];
		else ls[i] = i-1;
	ls[0] = -1;
	int ans = 0,now = 0;
	for(int i = n;i>= 2;i--)
	{
		now = gcd(now,a[i]);
		for(int j = i-2;j>= 0;j=ls[j])
			ans = (ans+(ll)(j-ls[j])*gcd(now,f[j])%mod)%mod;
		if(i==n)ans = (ans-now+mod)%mod;
	}
	for(int i = 2;i<= n-1;i++)
		(ans+=f[i])%=mod;
	printf("%d\n",ans);
	return 0;
}
﻿









HOMEBack

	

			 
		 
		 
		 
		
			
		
	
한국어中文فارسیEnglishไทย
版权所有 ©2008-2012 大视野在线测评 |  | 
湘ICP备13009380号站长统计站长统计站长统计
Based on opensource project .
hustoj
F.A.Qs	Home	Discuss	ProblemSet	Status	Ranklist	Contest	入门OJ	ModifyUser   Infinity37	Logout	捐赠本站
Notice:请某些用户不要在讨论区发无意义的讨论帖。
Problem1008

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
long long mod = 100003;
long long quick(long long x,long long y)
{
    if(y==0)return 1;
    long long tmp = quick(x,y/2);
    if(y%2==1)return tmp*tmp%mod*x%mod;
    else return tmp*tmp%mod;
}
int main()
{
    long long n,m;
    scanf("%lld%lld",&m,&n);
    long long ans = quick(m,n);
    long long not_ = m*quick(m-1,n-1)%mod;
    printf("%lld\n",((ans-not_)%mod+mod)%mod);
    return 0;
}
Problem1010

#include <stdio.h>
#include <algorithm>
#include <stdlib.h>
#include <math.h>
using namespace std;
#define MaxN 50000+5
int n,l,L,R = 1;
long long sum[MaxN],F[MaxN],Y[MaxN];
int q[MaxN];
long long Z(int x){return F[x]+Y[x]*Y[x];}
long long G(int x){return Y[x]-l-1;}
double calc(int j1,int j2){return 1.0*(Z(j1)-Z(j2))/(Y[j1]-Y[j2]);}
int main()
{
    int x;
    scanf("%d%d",&n,&l);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&x);
        sum[i] = sum[i-1]+x;
        Y[i] = sum[i]+i;
    }
    for(int i = 1;i<= n;i++)
    {
        long long Gi = G(i);
        while(L+1<R&&calc(q[L],q[L+1])<=Gi*2)
            L++;
        F[i] = F[q[L]]+(Gi-Y[q[L]])*(Gi-Y[q[L]]);
        while(L+1<R&&calc(q[R-1],i)<=calc(q[R-2],q[R-1]))
            R--;
        q[R++] = i;
    }
    printf("%lld",F[n]);
    return 0;
}
Problem1014

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int sed = 37;
#define is(x) (son[fa[x]][1]==x)
typedef unsigned long long LL;
char start[N];
int digit[N];
LL power[N]={1};
struct node
{
	int root,n;
	LL hash[N];
	int val[N],fa[N],son[N][2],size[N];
	inline void update(int p)
	{
		size[p]=size[son[p][0]]+size[son[p][1]]+1;
		hash[p]=hash[son[p][0]]*power[size[son[p][1]]+1]+val[p]*power[size[son[p][1]]]+hash[son[p][1]];
	}
	inline void Build(int l,int r,int mid)
	{
		if(l<mid)		{
			int lmid=l+mid-1>>1;
			Build(l,mid-1,lmid);
			fa[lmid]=mid;
			son[mid][0]=lmid;
		}
		if(mid<r)
		{
			int rmid=mid+1+r>>1;
			Build(mid+1,r,rmid);
			fa[rmid]=mid;
			son[mid][1]=rmid;
		}
		val[mid]=digit[mid],update(mid);
	}
	inline void link(int x,int y,int d){son[y][d]=x;fa[x]=y;}
	inline void Rotate(int x)
	{
		int y=fa[x],z=fa[y],id=is(x),t=son[x][!id];
		if(t)fa[t]=y;son[y][id]=t;
		link(x,z,is(y));
		link(y,x,!id);
		update(y);
	}
	inline void Splay(int x,int k)
	{
		int y,z;
		while(fa[x]!=k)
		{
			y=fa[x];
			z=fa[y];
			if(z==k){Rotate(x);break;}
			if(is(x)==is(y))Rotate(y),Rotate(x);
			else Rotate(x),Rotate(x);
		}
		update(x);
		if(!k)root=x;
	}
	inline int Select(int rank,int k)
	{
		if(size[root]<rank)return -1;
		int x=root;
		while(size[son[x][0]]+1!=rank)
		{
			if(size[son[x][0]]+1>rank)x=son[x][0];
			else rank=rank-size[son[x][0]]-1,x=son[x][1];
		}
		Splay(x,k);
		return x;
	}
	inline void newnode(int &x,int y,int w)
	{
		x=++n;
		son[x][0]=son[x][1]=0;
		val[x]=w;
		fa[x]=y;
		size[x]=1;
	}
	inline void Insert(int x,int p)
	{
		int l=Select(x,0),r=Select(x+1,l);
		newnode(son[r][0],r,p);
		Splay(n,0);
	}
	inline void Change(int x,int p){x=Select(x,0),val[x]=p,Splay(x,0);}
	inline bool check(int a,int b,int len)
	{
		int x;
		Select(a-1,0);x=Select(a+len,root);
		if(x==-1)return 0;
		LL hash1=hash[son[x][0]];
		Select(b-1,0);x=Select(b+len,root);
		if(x==-1)return 0;
		LL hash2=hash[son[x][0]];
		return hash1==hash2;
	}
}tree;
char s[N];
int main()
{
	scanf("%s",s+1);
	int m,n=strlen(s+1);
	for(int i = 1;i<N;i++)power[i] = power[i-1]*sed;
	tree.n=n+2;
	for(int i = 2;i<= n+1;i++)
		digit[i] = s[i-1]-'a'+1;
	tree.root=(1+tree.n)>>1;
	tree.Build(1,tree.n,1+tree.n>>1);
	scanf("%d",&m);
	char a[10];
	int l,r;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",a);
		if(a[0]=='Q')
		{
			scanf("%d%d",&l,&r);
			int L = 0,R = tree.n,ans = 0;
			while(L<=R)
			{
				int mid = (L+R)>>1;
				if(tree.check(l+1,r+1,mid))L=mid+1,ans=mid;
				else R=mid-1;
			}
			printf("%d\n",ans);
		}else if(a[0]=='R')
		{
			scanf("%d%s",&l,a);
			tree.Change(l+1,a[0]-'a'+1);
		}else
		{
			scanf("%d%s",&l,a);
			tree.Insert(l+1,a[0]-'a'+1);
		}
	}
	return 0;
}
Problem1015

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 400005;
struct E
{int next,to;}e[N];
int head[N],tot,T;
int fa[N];
bool used[N];
void add_e(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;

	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int getfa(int x)
{
	if(fa[x]==x||!fa[x])
		return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void add_p(int x)
{
	int root = getfa(x);
	for(int i = head[x];i;i = e[i].next)
	{
		int q= getfa(e[i].to);
		if(used[e[i].to]&&q!=root){fa[q] = root;T--;}
	}
	return ;
}
int ask[N],ans[N],b[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		x++;y++;
		add_e(x,y);
	}
	int k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&ask[i]);
		ask[i]++;
		b[ask[i]] = 1;
	}
	for(int i = 1;i<= n;i++)
		if(b[i]==0)
		{
			T++;
			add_p(i);
			used[i] = true;
		}
	ans[k] = T;
	for(int i = k;i>=1;i--)
	{
		T++;
		add_p(ask[i]);
		used[ask[i]] =true;
		ans[i-1] = T;
	}
	for(int i = 0;i<= k;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem1016

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 1005;
const int mod = 31011;
struct E
{
	int u,v,l;
	bool operator<(const E &s)const
	{
		return l<s.l;
	}
}e[M];
int n,m;
int fa[N],U[N],vis[N];
int G[N][N],C[N][N];
vector<int>V[N];
int getfa(int x,int fa[])
{
	return fa[x]==x?x:fa[x]=getfa(fa[x],fa);
}
int gauss(int a[][N],int n)
{
	for(int i= 0;i<n;i++)
		for(int j = 0;j<n;j++)
			a[i][j]%=mod;
	int ans = 1;
	for(int i = 1;i<n;i++)
	{
		for(int j = i+1;j<n;j++)
			while(a[j][i])
			{
				int t = a[i][i]/a[j][i];
				for(int k = i;k<n;k++)
					a[i][k]=(a[i][k]-a[j][k]*t)%mod;
				for(int k = i;k<n;k++)
					swap(a[i][k],a[j][k]);
				ans = -ans;
			}
		if(a[i][i]==0)return 0;
		ans = ans*a[i][i]%mod;
	}
	if(ans<0)ans=-ans;
	return (ans+mod)%mod;
}
void solve()
{
	sort(e,e+m);
	for(int i = 1;i<= n;i++)fa[i]=i,vis[i]=0;
	int edge = -1,ans=1;
	for(int k = 0;k<= m;k++)
	{
		if(edge!=e[k].l||k==m)
		{
			for(int i = 1;i<= n;i++)
				if(vis[i])
				{
					int u = getfa(i,U);
					V[u].push_back(i);
					vis[i]=0;
				}
			for(int i = 1;i<= n;i++)
				if(V[i].size()>1)
				{
					for(int a = 1;a<=n;a++)
						for(int b = 1;b<=n;b++)
							C[a][b]=0;
					int len = V[i].size();
					for(int a = 0;a<len;a++)
						for(int b = a+1;b<len;b++)
						{
							int a1 = V[i][a],b1 = V[i][b];
							C[a][b] = (C[b][a]-=G[a1][b1]);
							C[a][a]+=G[a1][b1];
							C[b][b]+=G[a1][b1];
						}
					int tmp = gauss(C,len);
					ans = ans*tmp%mod;
					for(int a = 0;a<len;a++)
						fa[V[i][a]]=i;
				}
			for(int i = 1;i<= n;i++)
			{
				U[i] = fa[i] = getfa(i,fa);
				V[i].clear();
			}
			if(k==m)break;
			edge=e[k].l;
		}
		int a = e[k].u,b=e[k].v;
		int a1 = getfa(a,fa),b1=getfa(b,fa);
		if(a1==b1)continue;
		vis[a1]=vis[b1]=1;
		U[getfa(a1,U)]=getfa(b1,U);
		G[a1][b1]++;
		G[b1][a1]++;
	}
	bool flag = false;
	for(int i = 2;i<= n&&!flag;i++)
		if(U[i]!=U[i-1])
			flag = true;
	if(m==0)
		flag=1;
	printf("%d\n",flag?0:ans%mod);
}
int main()
{
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		memset(G,0,sizeof(G));
		for(int i = 1;i<= n;i++)
			V[i].clear();
		for(int i = 0;i<m;i++)
			scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].l);
		solve();
	}
	return 0;
}
Problem1017

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2005;
int kind[N],num[N],cost[N],power[N],ind[N];
int f[N][M][N*2];
int g[N][M];
struct E
{
	int val,next,to;
}e[N<<1];
int head[N],tot,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	if(head[x]==0)
	{
		num[x] = min(num[x],m/cost[x]);
		for(int j = 0;j<=num[x];j++)
			for(int k = 0;k<= j;k++)
				f[x][j*cost[x]][k] = power[x]*(j-k);
		return ;
	}
	num[x] = 105;
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		num[x] = min(num[x],num[e[i].to]/e[i].val);
		cost[x] += cost[e[i].to]*e[i].val;
	}
	num[x] = min(num[x],m/cost[x]);
	int cnt = 0;
	memset(g,-0x3f,sizeof(g));
    g[0][0]=0;	
	for(int l = num[x];l>= 0;l--)
	{
		cnt=0;
		for(int i = head[x];i;i = e[i].next)
		{
			cnt++;
			for(int j = 0;j<= m;j++)
				for(int k = 0;k<=j;k++)
					if(l*e[i].val<=num[e[i].to])
						g[cnt][j] = max(g[cnt][j],g[cnt-1][j-k]+f[e[i].to][k][l*e[i].val]);
		}
		for(int k = 0;k<= l;k++)
			for(int j = 0;j<= m;j++)
				f[x][j][k] = max(f[x][j][k],g[cnt][j]+power[x]*(l-k));
	}	
}
int main()
{
	memset(f,-0x3f,sizeof(f));
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&power[i]);
		char ju[3];
		scanf("%s",ju);
		if(ju[0]=='B')
			scanf("%d%d",&cost[i],&num[i]);
		else
		{
			int num,x,y;
			scanf("%d",&num);
			for(int	j = 1;j<= num;j++)
			{
				scanf("%d%d",&x,&y);
				add(i,x,y);ind[x]++;
			}
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(!ind[i])
		{
			dfs(i);
			for(int j = 0;j<= m;j++)
				for(int k = 0;k<= num[i];k++)
					ans = max(ans,f[i][j][k]);
		}
	printf("%d\n",ans);
	return 0;
}
Problem1023

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 2e6+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N],fa[N],a[N],dep[N],pos[N],low[N],q[N],Dfn,ans;
void solve(int x,int y)
{
	int cnt = dep[y]-dep[x]+1,h = 1,t = 1,i;
	for(i = y;i!=x;i = fa[i])a[cnt--]=f[i];a[1] = f[x];
	cnt = dep[y]-dep[x]+1,q[1] = 1;
	for(i=1;i<=cnt;i++)a[i+cnt]=a[i];
	for(i=2;i<=cnt+(cnt>>1);i++)
	{
		if(i-q[h]>(cnt>>1))h++;
		ans = max(ans,a[i]+i+a[q[h]]-q[h]);
		while(h<=t&&a[i]-i>=a[q[t]]-q[t])
			t--;
		q[++t] = i;
	}
	for(int i = 2;i<= cnt;i++)
		f[x] = max(f[x],a[i]+min(i-1,cnt-i+1));
}
void dfs(int x)
{
	pos[x] = low[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)
	{
		if(e[i].to==fa[x])continue;
		if(!pos[e[i].to])
		{
			fa[e[i].to] = x;
			dep[e[i].to] = dep[x]+1;
			dfs(e[i].to);
		}
		low[x] = min(low[x],low[e[i].to]);
		if(low[e[i].to]>pos[x])
		{
			ans = max(ans,f[e[i].to]+f[x]+1);
			f[x] = max(f[x],f[e[i].to]+1);
		}
	}
	for(int i = head[x];i;i=e[i].next)
		if(fa[e[i].to]!=x&&pos[x]<pos[e[i].to])
			solve(x,e[i].to);
}
int main()
{
	int n,m,cnt;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int x,y;
		scanf("%d",&cnt);
		scanf("%d",&x);
		for(int j = 2;j<= cnt;j++)
		{
			scanf("%d",&y);
			add(x,y);
			x = y;
		}
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}
Problem1026

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long f[15][15];
long long get_ans(long long x)
{
	int num[15] = {},cnt = 0;
	long long ans = 0;
	while(x)
	{
		num[++cnt] = x%10;
		x/=10;
	}
	for(int i = 1;i<= num[cnt]-1;i++)
		ans+=f[cnt][i];
	for(int i = cnt-1;i>=1;i--)
		for(int j = 1;j<= 9;j++)
			ans+=f[i][j];
	for(int i = cnt-1;i>= 1;i--)
	{
		for(int j = 0;j<= num[i]-1;j++)
			if(abs(j-num[i+1])>=2)
				ans+=f[i][j];
		if(abs(num[i+1]-num[i])<2)break;
	}
	return ans;
}
int main()
{
	long long a,b;
	scanf("%lld%lld",&a,&b);
	for(int i = 0;i<= 9;i++)
		f[1][i] = 1;
	for(int i = 2;i<= 10;i++)
		for(int j = 0;j<= 9;j++)
			for(int k = 0;k<=9;k++)
				if(abs(j-k)>=2)
					f[i][j]+=f[i-1][k];
	printf("%lld",get_ans(b+1)-get_ans(a));
	return 0;
}
Problem1027

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const double eps = 1e-7;
const int N = 505;
const int INF = 0x3f3f3f3f;
struct Point
{
	double x,y;
	Point(){}
	Point(double x,double y):x(x),y(y){}
	Point operator+(const Point &a)const
	{
		return Point(x+a.x,y+a.y);
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	double operator*(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
	double operator^(const Point &a)const
	{
		return x*a.x+y*a.y;
	}
}mtr[N],req[N];
struct Line
{
	Point p,v;
	Line(){}
	Line(const Point &a,const Point &b):p(a),v(b){}
};
int map[N][N];
void display()
{
	for(int i = 1;i<= 10;i++)
	{
		for(int j = 1;j<= 10;j++)
			if(map[i][j]==INF)printf("0");
			else printf("1");
		printf("\n");
	}
}
int main()
{
	memset(map,0x3f,sizeof(map));
	int n,m;
	double c;
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= m;i++)
		scanf("%lf%lf%lf",&mtr[i].x,&mtr[i].y,&c);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf%lf",&req[i].x,&req[i].y,&c);
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<=m;j++)
		{
			bool flag=true;
			for(int k = 1;k<= n;k++)
			{
				double cro = (mtr[i]-req[k])*(mtr[j]-req[k]);
				if(cro>eps){flag = false;break;}
				if(fabs(cro)<eps&&((mtr[i]-req[k])^(mtr[j]-req[k]))>eps)
					{flag = false;break;}
			}
			if(flag)map[i][j] = 1;
		}
	for(int k = 1;k<= m;k++)
		for(int i = 1;i<= m;i++)
			for(int j = 1;j<= m;j++)
				map[i][j] = min(map[i][j],map[i][k]+map[k][j]);
	int ans = INF;
	for(int i = 1;i<= m;i++)
		ans = min(ans,map[i][i]);
	if(ans!=INF)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem1030

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'A')
const int P = 6005;
const int N = 65;
const int Len = 105;
const int mod = 10007;
char s[Len];
int f[Len][P];
struct AC_Machine
{
	int ch[P][26],cnt,fail[P],q[P],h,t;
	bool danger[P];
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)ch[0][i] = 1;
	}
	void insert()
	{
		int now = 1,i = 0;
		while(s[i])
		{
			if(!ch[now][s(i)])ch[now][s(i)] = ++cnt;
			now = ch[now][s(i)];
			i++;
		}
		danger[now] = true;
	}
	void build()
	{
		h = t,t = -1;
		q[++t] = 1,fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				if(danger[fail[to]])
					danger[to] = true;
				q[++t] = to;
			}
		}
	}
	void dp(int x)
	{
		for(int i = 1;i<= cnt;i++)
		{
			if(danger[i]||!f[x-1][i])continue;
			for(int j = 0;j<26;j++)
			{
				int k=i;
				while(!ch[k][j])k=fail[k];
				(f[x][ch[k][j]]+=f[x-1][i])%=mod;
			}
		}
	}
}AC;
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	return tmp*tmp%mod;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int ans = quick_pow(26,m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		AC.insert();
	}
	AC.build();
	f[0][1] = 1;
	for(int i = 1;i<=m;i++)AC.dp(i);
	for(int i = 1;i<= AC.cnt;i++)
		if(!AC.danger[i])
			ans = (ans-f[m][i]+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
Problem1031

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Len = 200000+5;
char s[Len];
int c[Len],sa[Len],val[Len],q[Len],newval[Len];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)c[i]=0;
	for(i = 0;i<len;i++)c[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)c[i]+=c[i-1];
	for(i = len-1;i>=0;i--)sa[--c[val[i]]] = i;
	for(int d=1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;
		for(i = 0;i<lim;i++)c[i] = 0;
		for(i = 0;i<len;i++)c[val[q[i]]]++;
		for(i = 1;i<lim;i++)c[i]+=c[i-1];
		for(i = len-1;i>= 0;i--)sa[--c[val[q[i]]]] = q[i];
		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i = j+1;k<=j;k++)newval[sa[k]] = lim;
		}
		for(int i = 0;i<len;i++)val[i] = newval[i];
		if(lim==len)break;
	}
}
int main()
{
	scanf("%s",s);
	int len = strlen(s);
	for(int i = 0;i<len;i++)
		s[i+len] = s[i];
	build_sa(2*len,256);
	for(int i = 0;i< 2*len;i++)
		if(sa[i]<len)
			printf("%c",s[sa[i]+len-1]);
	return 0;
}
Problem1036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 30005;
int W[N],n;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int maxn[N<<2],sum[N<<2];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int son[N],size[N],deep[N],top[N],fa[N],w[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] =tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i= e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void update(int p,int l,int r,int x,int c)
{
	if(l==r){sum[p] = maxn[p] = c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)
		update(p<<1,l,mid,x,c);
	else update((p<<1)+1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
	maxn[p] = max(maxn[p<<1],maxn[(p<<1)+1]);
}
int getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return maxn[p];
	int mid = (l+r)>>1;
	int ans = -0x3f3f3f3f;
	if(a<=mid)
		ans = max(ans,getmax(p<<1,l,mid,a,b));
	if(b>mid)
		ans = max(ans,getmax((p<<1)+1,mid+1,r,a,b));
	return ans;
}
int getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)
		ans += getsum(p<<1,l,mid,a,b);
	if(b>mid)
		ans += getsum((p<<1)+1,mid+1,r,a,b);
	return ans;
}
int get_ans(int x,int y,int opt)
{
	int ans;
	if(opt==1)ans = 0;
	else ans = -0x3f3f3f3f;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)ans+=getsum(1,1,n,w[top[x]],w[x]);
		else ans = max(ans,getmax(1,1,n,w[top[x]],w[x]));
		x= fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)ans+=getsum(1,1,n,w[y],w[x]);
	else ans = max(ans,getmax(1,1,n,w[y],w[x]));
	return ans;
}
int main()
{
	memset(maxn,-0x3f,sizeof(maxn));
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i< n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	for(int i = 1;i<= n;i++)
		scanf("%d",&W[i]);
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(1,1,n,w[i],W[i]);
	int q;
	scanf("%d",&q);
	char j[10];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",j,&x,&y);
		if(j[1]=='H')update(1,1,n,w[x],y);
		else if(j[1]=='S')printf("%d\n",get_ans(x,y,1));
		else printf("%d\n",get_ans(x,y,0));
	}
	return 0;
}
Problem1036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 30005;
const int N = 30005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,a[N],n;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],son[N],top[N],fa[N],dep[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to]=x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
int dfn[N],seq[N],Dfn;
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int sum[N<<2],mx[N<<2];
void Push_up(int p)
{
	sum[p] = sum[p<<1]+sum[p<<1|1];
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = mx[p] = a[seq[l]];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	Push_up(p);
}
void update(int p,int l,int r,int pos,int val)
{
	if(l==r)
	{
		mx[p] = val;
		sum[p] = val;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,val);
	else update(p<<1|1,mid+1,r,pos,val);
	Push_up(p);
}
int Getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getsum(p<<1,l,mid,a,b);
	if(b>mid)ans+=Getsum(p<<1|1,mid+1,r,a,b);
	return ans;
}
int Getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	int ans = -INF;
	if(a<=mid)ans = max(ans,Getmax(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,Getmax(p<<1|1,mid+1,r,a,b));
	return ans;
}
int getsum(int x,int y)
{
	int ans = 0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=Getsum(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	if(dep[y]>dep[x])swap(x,y);
	ans += Getsum(1,1,n,dfn[y],dfn[x]);
	return ans;
}
int getmax(int x,int y)
{
	int ans = -INF;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans = max(ans,Getmax(1,1,n,dfn[top[x]],dfn[x]));
		x = fa[top[x]];
	}
	if(dep[y]>dep[x])swap(x,y);
	ans = max(ans,Getmax(1,1,n,dfn[y],dfn[x]));
	return ans;
}
int main()
{
	int x,y,q;
	scanf("%d",&n);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	scanf("%d",&q);
	char opt[10];
	while(q--)
	{
		scanf("%s",opt);
		if(opt[0]=='C')
		{
			scanf("%d%d",&x,&y);
			update(1,1,n,dfn[x],y);
			a[x] = y;
		}
		else if(opt[1]=='M')
		{
			scanf("%d%d",&x,&y);
			printf("%d\n",getmax(x,y));
		}else
		{
			scanf("%d%d",&x,&y);
			printf("%d\n",getsum(x,y));
		}
	}
	return 0;
}
Problem1040

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N],a[N],st[N],top;
LL f[N],g[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	return fa[x] = getfa(fa[x]);
}
void dfs(int x,int fa,int ban)
{
	for(int i = head[x];i;i = e[i].next)
		if(fa!=e[i].to)
			dfs(e[i].to,x,ban);
	f[x]= a[x],g[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		if(e[i].to==ban)
			f[x]+=g[e[i].to],g[x]+=g[e[i].to];
		else 
		{
			f[x]+=g[e[i].to];
			g[x]+=max(g[e[i].to],f[e[i].to]);
		}
	}
}
int main()
{
	int n,x;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a[i],&x);
		int fx = getfa(x),fy = getfa(i);
		if(fx==fy){st[++top] = x,st[++top] = i;continue;}
		fa[fx]= fy;
		add(x,i),add(i,x);
	}
	LL t_ans = 0;
	LL ans = 0;
	for(int i = 1;i<= top;i=i+2)
	{
		ans = 0;
		dfs(st[i],0,st[i+1]);
		ans = max(ans,max(f[st[i]],g[st[i]]));
		dfs(st[i+1],0,st[i]);
		ans = max(ans,max(f[st[i+1]],g[st[i+1]]));
		t_ans+=ans;
	}
	printf("%lld\n",t_ans);
	return 0;
}
Problem1042

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c[5],n[5],s;
long long f[100005],w[5];
long long getans(int sta)
{
	int tmp = s;
	long long fh = 1;
	for(int i = 0;i<4;i++)
		if((sta&(1<<i))!=0)
			{tmp-=w[i+1];fh = -fh;}
	if(tmp>=0)return fh*f[tmp];
	else return 0;
}
int main()
{
	int tot;
	for(int i = 1;i<= 4;i++)
		scanf("%d",&c[i]);
	scanf("%d",&tot);
	while(tot--)
	{
		memset(f,0,sizeof(f));
		for(int i = 1;i<= 4;i++)
			scanf("%d",&n[i]);
		scanf("%d",&s);
		for(int i = 1;i<= 4;i++)
			w[i] = c[i]*(n[i]+1);
		f[0] = 1;
		for(int i = 1;i<= 4;i++)
			for(int j = 0;j<= s;j++)
				if(j-c[i]>=0)f[j] += f[j-c[i]];
		long long ans = f[s];
		for(int i = 1;i<1<<4;i++)
			ans+=getans(i);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem1044

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
int Max_lth,maxn = 0,suml = 0;
int lth[50005],sum[50005];
int f[2][50005],n,m;
int line[50005];
bool check(int x)
{
    int tmp=0,sum=0;
    for(int i=1;i<=n;i++)
    {
        sum+=lth[i];
        if(sum>x){tmp++;sum=lth[i];}
        if(tmp>m)return 0;
        if(lth[i]>x)return 0;
    }
    return 1;
}
void solve()
{
	int l = maxn,r = suml+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(mid))r = mid;
		else l = mid+1;
	}
	Max_lth = l;
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&lth[i]);
		sum[i] = sum[i-1]+lth[i];
		suml+=lth[i];
		maxn = max(maxn,lth[i]);
	}
	solve();
	int ans = 0;
	f[0][0] = 1;
	for(int i = 1;i<= m;i++)
	{
		int last = (i-1)&1,now = i&1;
		int l = 1,r = 1,tot = f[last][0];line[1] = 0;
		for(int j = 1;j<= n;j++)
		{
			while(l<=r&&sum[j]-sum[line[l]]>Max_lth)
				{tot = (tot-f[last][line[l++]]+mod)%mod;}
			f[now][j] = tot;
			line[++r] = j;
			tot = (f[last][j]+tot)%mod;
		}
		for(int j = n-1;j>=1;j--)
		{
			if(suml-sum[j]>Max_lth)break;
			ans = (ans+f[now][j])%mod;
		}
		memset(f[last],0,sizeof(f[last]));
	}
	printf("%d %d",Max_lth,ans);
	return 0;
}
Problem1046

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int M = 1005;
int f[N],c[N],pos[N],a[N],cnt,n,m;
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r =mid;
	}
	return l;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = max(c[i],y);
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans = max(ans,c[i]);
	return ans;
}
int t_ans = 0;
void pre()
{
	for(int i = n;i>=1;i--)
	{
		int tmp = find(a[i]);
		tmp = n-tmp+1;
		f[i] = getans(tmp-1)+1;
		update(tmp,f[i]);
		t_ans = max(t_ans,f[i]);
	}
}
void solve(int x)
{
	int last = 0;
	for(int i = 1;i<= n;i++)
		if(f[i]>=x&&a[i]>last)
		{
			printf("%d",a[i]);
			if(x!=1)printf(" ");
			last = a[i];
			x--;
			if(!x)break;
		}
	printf("\n");
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		pos[i] = a[i];
	}
	sort(pos+1,pos+n+1);
	for(int i = 1;i<= n;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt] = pos[i];
	pre();
	scanf("%d",&m);
	int x;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&x);
		if(x>t_ans)printf("Impossible\n");
		else solve(x);
	}
	return 0;
}
Problem1047

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int f[13][1005][1005];
int g[13][1005][1005];
int log[1005];
int a,b,n,ans = 0x3f3f3f3f;
void init()
{
	for(int j = 1;j<= 12;j++)
		for(int l = 1;l+(1<<j)-1<= a;l++)
			for(int i = 1;i+(1<<j)-1<= b;i++)
			{
				f[j][l][i] = max(max(f[j-1][l][i],f[j-1][l][i+(1<<(j-1))]),
								 max(f[j-1][l+(1<<(j-1))][i],f[j-1][l+(1<<(j-1))][i+(1<<(j-1))]));
				g[j][l][i] = min(min(g[j-1][l][i],g[j-1][l][i+(1<<(j-1))]),
								 min(g[j-1][l+(1<<(j-1))][i],g[j-1][l+(1<<(j-1))][i+(1<<(j-1))]));
			}
	log[1] = 0;
	for(int i = 2;i<= 1000;i++)
		log[i] = log[i>>1]+1;
}
void ask(int x,int y)
{
	int xl = x,xr = x+n-1;
	int yl = y,yr = y+n-1;
	int m_ans = 0,n_ans = 0x3f3f3f3f;
	m_ans = max(f[log[n]][xl][yl],f[log[n]][xl][yr-(1<<log[n])+1]);
	m_ans = max(m_ans,max(f[log[n]][xr-(1<<log[n])+1][yl],f[log[n]][xr-(1<<log[n])+1][yr-(1<<log[n])+1]));
	n_ans = min(g[log[n]][xl][yl],g[log[n]][xl][yr-(1<<log[n])+1]);
	n_ans = min(n_ans,min(g[log[n]][xr-(1<<log[n])+1][yl],g[log[n]][xr-(1<<log[n])+1][yr-(1<<log[n])+1]));
	ans = min(ans,m_ans-n_ans);
}
int main()
{
	memset(g,0x3f,sizeof(g));
	int x;
	scanf("%d%d%d",&a,&b,&n);
	for(int i = 1;i<= a;i++)
	{
		for(int j = 1;j<= b;j++)
		{
			scanf("%d",&x);
			f[0][i][j] = g[0][i][j] = x;
		}
	}
	init();
	for(int i = 1;i<= a-n+1;i++)
		for(int j = 1;j<= b-n+1;j++)
			ask(i,j);
	printf("%d",ans);
	return 0;
}
Problem1051

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct M
{
    int next,to;
}edge[50005];
int head[50005],tot,cnt,zn,z[50005],dep[50005],low[50005],n,m;
bool in[10005],v[10005];
void add(int x,int y)
{
    edge[++tot].to = y;
    edge[tot].next = head[x];
    head[x] = tot;
}
int pn,t[10005],ln[10005],lnn[10005];
void tarjan(int x)
{
    v[x] = true;
    z[++zn] = x;
    in[x] = true;
    dep[x] = low[x] = ++cnt;
    for(int i = head[x];i;i=edge[i].next)
    {
        if(!v[edge[i].to])
            {tarjan(edge[i].to);low[x] = min(low[x],low[edge[i].to]);}
        else if(in[edge[i].to])
            {low[x] = min(low[x],dep[edge[i].to]);}
    }
    if(dep[x]==low[x])
    {
        pn++;
        int tmp;
        do
        {
            tmp = z[zn--];
            in[tmp] = false;
            ln[tmp] = pn;
            lnn[pn]++;
        }while(tmp!=x);
    }
    return ;
}
void dfs(int x)
{
    if(x==n+1)return ;
    for(int i = head[x];i;i = edge[i].next)
    {
        if(ln[x]!=ln[edge[i].to])
            t[ln[x]]++;
    }
    dfs(x+1);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 1;i<= m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
    }
    for(int i = 1;i<= n;i++)
        if(!v[i])tarjan(i);
    dfs(1);
    int ans = 0,tmp = 0;
    for(int i = 1;i<= pn;i++)
    {
        if(t[i]==0)
        {
            if(ans)
            {
                ans = 0;
                break;
            }
            ans=lnn[i]; 
        }
    }
    printf("%d",ans);
    return 0;
}
Problem1055

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c2n[256],num[5];
bool change[5][5][5];
int Able[205][205][5];
char str[205];
bool able(int l,int r,int target)
{
	if(r-l+1==2&&change[c2n[str[l]]][c2n[str[r]]][target])return true;
	else if(r-l+1==1&&target==c2n[str[l]])return true;
	if(Able[l][r][target]!=-1)return Able[l][r][target];
	for(int i = l;i<= r-1;i++)
		for(int k = 1;k<= 4;k++)
			for(int t = 1;t<= 4;t++)
				if(change[k][t][target]&&able(l,i,k)&&able(i+1,r,t))
					return Able[l][r][target] = 1;
	return Able[l][r][target] = 0;
}
int main()
{
	c2n['W'] = 1;
	c2n['I'] = 2;
	c2n['N'] = 3;
	c2n['G'] = 4;
	char s[3];
	for(int i = 1;i<= 4;i++)scanf("%d",&num[i]);
	for(int i = 1;i<= 4;i++)
		for(int j = 1;j<= num[i];j++)
		{
			scanf("%s",s);
			change[c2n[s[0]]][c2n[s[1]]][i] = true;
		}
	scanf("%s",str+1);
	int n = strlen(str+1);
	memset(Able,-1,sizeof(Able));
	bool flag = false;
	if(able(1,n,1))printf("W"),flag = true;
	if(able(1,n,2))printf("I"),flag = true;
	if(able(1,n,3))printf("N"),flag = true;
	if(able(1,n,4))printf("G"),flag = true;
	if(!flag)printf("The name is wrong!\n");
	return 0;
}
Problem1060

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N =  500005;
LL f[N];
struct E{int to,next,val;}e[N*2];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
LL ans = 0;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			f[x] = max(f[e[i].to]+e[i].val,f[x]);
		}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			ans += f[x]-f[e[i].to]-e[i].val;
		}	
}
int main()
{
	int n,x,y,z,s;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	dfs(s,0);
	printf("%lld",ans);
	return 0;
}
Problem1067

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
#define mod 10007
int n,m;
struct Y
{
    int year,rr;
}num[50005];
struct E
{
    int next,val,no;
}edge[50005];
int logx[50005];
int f[50005][20];
void init()
{
    for(int j = 1;j<= 19;j++)
    {
        for(int i = 1;i<=n;i++)
        {   
            if((i+(1<<(j-1)))<=n)
            {
                if(num[f[i][j-1]].rr>=num[f[i+(1<<(j-1))][j-1]].rr)
                    f[i][j] = f[i][j-1];
                else 
                    f[i][j] = f[i+(1<<(j-1))][j-1];
            }
            else f[i][j]= f[i][j-1];
        }
    }
    logx[1] = 0;
    for(int i = 2;i<= 50000;i++)
        logx[i] = logx[i>>1]+1;
    return ;
}
int check(int l,int r)
{
    if(l>r)return -1;
    int len = r-l+1;
    if(num[f[l][logx[len]]].rr>num[f[r-(1<<logx[len])+1][logx[len]]].rr)
        return f[l][logx[len]];
    else return f[r-(1<<logx[len])+1][logx[len]];
}
void ch(int st,int en)
{
    int l = 0,r = n+1,mid,poss,pose;
    while(l<r)
    {
        mid = (l+r)>>1;
        if(num[mid].year>=st)r = mid;
        else l = mid+1;
    }
    poss = l;
    l = 0;r = n+1;
    while(l<r)
    {
        mid = (l+r)>>1;
        if(num[mid].year>=en)r = mid;
        else l = mid+1;
    }
    pose = l;
    if(num[pose].year>en)
        pose--;
    //printf("%d %d\n",poss,pose);
    //printf("%d %d\n",num[poss].year,num[pose].year);
    if(num[pose].year!=en&&num[poss].year!=st)
    {
        printf("maybe\n");
        return ;
    }
    else if(num[pose].year==en&&num[poss].year!=st)
    {
        if(num[check(poss,pose)].year!=num[pose].year)
            printf("false\n");
        else printf("maybe\n");
    }
    else if(num[pose].year!=en&&num[poss].year==st)
    {
        if(num[check(poss+1,pose)].rr>=num[poss].rr)
            printf("false\n");
        else printf("maybe\n");
    }
    else
    {
        if(num[pose].rr>num[poss].rr)printf("false\n");
        else if(num[check(poss+1,pose)].year!=en)printf("false\n");
        else if(pose-poss!=en-st)printf("maybe\n");
        else printf("true\n");
    }
    return ;
}
int main()
{
    num[0].year = -0x3f3f3f3f;
    //freopen("rains.in","r",stdin);
    //freopen("rains.out","w",stdout);
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d%d",&num[i].year,&num[i].rr);
        f[i][0] = i;
    }
    /*for(int j = 1;j<= n;j++)
    {
        for(int i = head[hash(num[j].year)];i;i = edge[i].next)
            printf("%d ",edge[i].val);
        printf("\n");
    }*/
    init();
    scanf("%d",&m);
    for(int i = 1;i<= m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(x>y){printf("false\n");continue;}
        //int fx = find(x),fy = find(y);
        //printf("fx = %d fy = %d\n",fx,fy);
        //if(num[fy].rr>num[fx].rr){printf("false\n");continue;}
        //if(fx==-1||fy==-1||fy-fx!=y-x){printf("maybe\n");continue;}
        ch(x,y);
    }
    return 0;
}
Problem1070

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 605;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,f,c,from;}e[M];
int head[N],tot=1,st,end;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;e[tot].c=c;head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;e[tot].c=-c;head[y]=tot;
	e[tot-1].from=x;e[tot].from=y;
}
int dis[N],from[N];
bool v[N];
queue<int>Q;
bool spfa()
{
	for(int i = st;i<= end;i++)dis[i]=INF;
	Q.push(st);dis[st]=0;v[st]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[x]+e[i].c<dis[e[i].to])
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to]=i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[end]!=INF;
}
double ans;
void mcf()
{
	int x = INF;
	for(int i = from[end];i;i=from[e[i].from])
		x = min(e[i].f,x);
	for(int i = from[end];i;i=from[e[i].from])
		{e[i].f-=x;e[i^1].f+=x;ans+=e[i].c*x;}
}
int ti[61][10];
int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&ti[i][j]);
	st=0,end=n*(m+1)+1;
	for(int i = 1;i<= n*m;i++)
		add(st,i,1,0);
	for(int i = n*m+1;i<=n*m+n;i++)
		add(i,end,1,0);
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
				add((i-1)*n+j,n*m+k,1,ti[k][i]*j);
	while(spfa())mcf();
	printf("%.2f",ans/(double)n);
	return 0;
}
Problem1072

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1005;
const int M = 1<<10;
int f[M][N],buk[10],cnt[M];
LL p10[11];
char str[20];
void init()
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	return ;
}
int main()
{
	int d,n,t;
	init();
	p10[0] = 1;
	for(int i = 1;i<= 10;i++)
		p10[i] = p10[i-1]*10;
	scanf("%d",&t);
	while(t--)
	{
		memset(buk,0,sizeof(buk));
		memset(f,0,sizeof(f));
		scanf("%s%d",str+1,&d);
		n = strlen(str+1);
		for(int i = 1;i<= n;i++)
			buk[str[i]-'0']++;
		f[0][0] = 1;
		for(int i = 1;i<= n;i++)
		{
			for(int sta = 0;sta<1<<n;sta++)
			{
				if(cnt[sta]!=i-1)continue;
				for(int s = 1;s<= n;s++)
				{
					if((1<<(s-1))&sta)continue;
					for(int yu = 0;yu<d;yu++)
					{
						LL nm = ((str[s]-'0')*p10[i-1]+yu)%d;
						f[sta|(1<<(s-1))][nm]+=f[sta][yu];
					}
				}
			}
		}
		int ans = f[(1<<n)-1][0];
		for(int i = 0;i<=9;i++)
			for(int j = buk[i];j>=1;j--)
				ans/=j;
		printf("%d\n",ans);
	}
	return 0;
}
Problem1076

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int P = 1<<15;
const int N = 105;
double f[N][P];
int pre[N],val[N];
int main()
{
	int k,n,t,x;
	scanf("%d%d",&k,&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&val[i],&t);
		while(t)
		{
			pre[i]|=1<<(t-1);
			scanf("%d",&t);
		}
	}
	double p = 1.0/(double)n;
	for(int i = k;i>= 1;i--)
		for(int j = 0;j<1<<n;j++)
		{
			//double ans = 0;
			for(int k = 1;k<= n;k++)
				if((j&pre[k])==pre[k])
					f[i][j]+=max(f[i+1][j],f[i+1][j|(1<<(k-1))]+val[k]);
				else f[i][j]+=f[i+1][j];
			f[i][j]*=p;
		}
	printf("%.6f\n",f[1][0]);
	return 0;
}
Problem1079

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
typedef long long LL;
int f[6][16][16][16][16][16];
bool used[6][16][16][16][16][16];
int cnt[6];
int dp(int last,int a,int b,int c,int d,int e)
{
	if(!a&&!b&&!c&&!d&&!e)return 1;
	if(a<0||b<0||c<0||d<0||e<0)return 0;
	if(used[last][a][b][c][d][e])return f[last][a][b][c][d][e];
	LL ans = 0;
	ans+=(LL)(a+(last==2?-1:0))*dp(1,a-1,b,c,d,e)%mod;
	ans+=(LL)(b+(last==3?-1:0))*dp(2,a+1,b-1,c,d,e)%mod;
	ans+=(LL)(c+(last==4?-1:0))*dp(3,a,b+1,c-1,d,e)%mod;
	ans+=(LL)(d+(last==5?-1:0))*dp(4,a,b,c+1,d-1,e)%mod;
	ans+=(LL)e*dp(5,a,b,c,d+1,e-1)%mod;
	ans = ans%mod;
	used[last][a][b][c][d][e] = true;
	f[last][a][b][c][d][e] = ans;
	return ans;
}
int main()
{
	int k,x;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&x);
		cnt[x]++;
	}
	printf("%d\n",dp(0,cnt[1],cnt[2],cnt[3],cnt[4],cnt[5]));
	return 0;
}
Problem1082

#include<cstdio>
#include<cmath>
#include<ctime>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<set>
#define ll long long
#define inf 1000000000
using namespace std;
int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
bool flag;
int n,m,mid;
int a[55],b[1005],bl[1005];
ll sa;
int sb[1005];
void dfs(int ak,int bk,int w)
{
	if(bk==0)flag=1;
	while(ak<=n&&a[ak]<b[1]){w+=a[ak];ak++;}
	if(flag||ak>n)return;
	if(w+sb[mid]>sa)return;
	int t=ak,t1=ak,t2=bk,t3=w;
	if(b[bk]==b[bk+1]&&bk!=mid)t=bl[bk+1];
	for(int i=t;i<=n;i++)
		if(a[i]>=b[bk])
		{
			bl[bk]=i;a[i]-=b[bk];
			bk--;
			dfs(ak,bk,w);
			ak=t1;bk=t2;w=t3;a[i]+=b[t2];
		}
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	m=read();
	for(int i=1;i<=m;i++)b[i]=read();
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	while(b[m]>a[n])m--;
	int tot=0;
	for(int i=1;i<=n;i++)	
		if(a[i]>b[1])a[++tot]=a[i];
	n=tot;
	for(int i=1;i<=n;i++)sa+=a[i];
	for(int i=1;i<=m;i++)sb[i]=sb[i-1]+b[i];
	int l=1,r=m,ans=0;
	while(l<=r)
	{
		mid=(l+r)>>1;
		flag=0;dfs(1,mid,0);
		if(flag)ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1087

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long ans[10][82]=
{
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,9,16,8,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,16,78,140,79,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,25,228,964,1987,1974,978,242,27,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,36,520,3920,16834,42368,62266,51504,21792,3600,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,49,1020,11860,85275,397014,1220298,2484382,3324193,2882737,1601292,569818,129657,18389,1520,64,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,64,1806,29708,317471,2326320,12033330,44601420,119138166,229095676,314949564,305560392,204883338,91802548,25952226,4142000,281571,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,81,2968,65240,962089,10087628,77784658,450193818,1979541332,6655170642,17143061738,33787564116,50734210126,57647295377,49138545860,31122500764,14518795348,4959383037,1237072414,224463798,29275410,2673322,163088,6150,125,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	printf("%lld\n",ans[n][k]);
	return 0;
}
Problem1090

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
int dp[105][105];
char str[105];
int calc(int x)
{
	int cnt = 0;
	while(x)
	{
		x/=10;
		cnt++;
	}
	return cnt;
}
int Dp(int l,int r)
{
	if(r==l)return 1;
	if(dp[l][r]!=INF)return dp[l][r];
	for(int k = l;k< r;k++)
		dp[l][r] = min(dp[l][r],min(r-l+1,Dp(l,k)+Dp(k+1,r)));
	for(int k = 1;l+k<=r;k++)
	{
		bool flag = true;
		if((r-l+1)%k==0)
		{
			for(int t = 1;t<(r-l+1)/k;t++)
			{
				for(int p = 0;p<k;p++)
					if(str[l+p]!=str[l+t*k+p])
						{flag = false;break;}
				if(!flag)break;
			}
		}else continue;
		if(flag)dp[l][r] = min(dp[l][r],Dp(l,l+k-1)+2+calc((r-l+1)/k));
	}
	return dp[l][r];
}
int main()
{
	scanf("%s",str+1);
	int n = strlen(str+1);
	memset(dp,0x3f,sizeof(dp));
	printf("%d\n",Dp(1,n));
	return 0;
}
Problem1096

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
int x[N],p[N],c[N],q[N],l,r;
LL sum[N],os[N],f[N];
double calc(int j,int k)
{
	return (double)(f[k]-f[j]+sum[k]-sum[j])/(double)(os[k]-os[j]);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&x[i],&p[i],&c[i]);
	for(int i = 1;i<=n;i++)
		os[i] = os[i-1]+p[i];
	for(int i = 1;i<=n;i++)
		sum[i] = sum[i-1]+(LL)x[i]*p[i];
	for(int i = 1;i<= n;i++)
	{
		while(l<r&&calc(q[l],q[l+1])<x[i])l++;
		if(l<=r)f[i] = f[q[l]]+sum[q[l]]-sum[i]+(os[i]-os[q[l]])*x[i]+c[i];
		while(l<r&&calc(q[r-1],q[r])>calc(q[r],i))r--;
		q[++r] = i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem1097

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 200005;
const int N = 20005;
const int S = 1<<20;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M<<1];
struct H
{int pos,val;}heap[N<<2];
int head[N],tot,cnt,n,m,k;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	e[tot].val = f;
	head[y] = tot;
}
int f[25][N],v[N];
bool cmp(H a,H b){return a.val>b.val;}
void dijk(int st)
{
	memset(f[st],0x3f,sizeof(f[st]));
	memset(v,0,sizeof(v));
	f[st][st] = 0;
	heap[1].val = 0,heap[1].pos = st;
	cnt++;
	while(cnt)
	{
		int x = heap[1].pos;
		pop_heap(heap+1,heap+cnt+1,cmp);
		cnt--;
		if(v[x])continue;
		v[x] = true;
		for(int i = head[x];i;i = e[i].next)
		{
			int to = e[i].to;
			if(f[st][x]+e[i].val<f[st][to])
			{
				f[st][to] = f[st][x]+e[i].val;
				cnt++;
				heap[cnt].pos = to;heap[cnt].val = f[st][to];
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
	}
	return ;
}
int pre[25],ban[25],num[S],dp[25][S];
void init()
{
	for(int i = 0;i<S;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			num[i]++;
		}
	}
	memset(dp,-1,sizeof(dp));
	for(int i = 1;i<= k+1;i++)
		dijk(i);
	return ;
}
int dfs(int x,int y)
{
    if(dp[x][y]>=0)return dp[x][y];
    if(y==(1<<k)-1)return f[x][n];
    dp[x][y]=INF;
    for(int i= 2;i<= k+1;i++)
    	if((y&pre[i])==pre[i])
    		dp[x][y]=min(dp[x][y],f[x][i]+dfs(i,y|(1<<(i-2))));
    return dp[x][y];  
}
int main()
{
	int x,y,c,ord;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c);
	}
	init();
	scanf("%d",&ord);
	for(int i = 1;i<= ord;i++)
	{
		scanf("%d%d",&x,&y);
		ban[x]|=(1<<(y-2));
		pre[y]|=(1<<(x-2));
	}
	printf("%d\n",dfs(1,0));
	return 0;
}
Problem1103

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500000+5;
int c[N],cnt;
int in_w[N],out_w[N];
struct E{int next,to;}e[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa)
{
	in_w[x] = ++cnt;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	out_w[x] = ++cnt;
}
void update(int x,int dec)
{
	for(int i = x;i<=N;i +=(i&(-i)))
		c[i]+=dec;
	return ;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i -= (i&(-i)))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,m,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	dfs(1,0);
	for(int i = 1;i<= n;i++)
		{update(in_w[i],1);update(out_w[i],-1);}
	scanf("%d",&m);
	char ju[5];
	for(int i = 1;i<= n+m-1;i++)
	{
		scanf("%s",ju);
		if(ju[0]=='A')
		{
			scanf("%d%d",&x,&y);
			update(in_w[y],-1);update(out_w[y],1);
		}else
		{
			scanf("%d",&x);
			printf("%d\n",getans(in_w[x])-1);
		}
	}
	return 0;
}
Problem1106

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int c[N],mark[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= 2*n;i++)
	{
		scanf("%d",&x);
		if(mark[x])
		{
			ans += getans(i-1)-getans(mark[x]);
			update(mark[x],-1);
		}else
		{
			mark[x] = i;
			update(i,1);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1110

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int a[N],w[N],cnt[N],stack[N],top;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&a[i]);
	sort(a+1,a+m+1);
	int top = 0;
	for(int i = 1;i<= m;i++)
		if(i==1||a[i]!=a[i-1])
			stack[++top] = a[i];
	for(int i = 1;i<= n;i++)
		for(int j = top;j;j--)
			cnt[j]+=w[i]/stack[j],w[i]%=stack[j];
	int i,j,k;
	int ans = 0;
	for(i=1,j=1;i<=top;i++)
	{
		for(;j<=m&&a[j]==stack[i];j++)
		{
			if(cnt[i])
			{
				ans++,cnt[i]--;
				continue;
			}
			for(k=i+1;k<= top;k++)
				if(cnt[k])
					break;
			if(k==top+1)
			{
				printf("%d\n",ans);
				return 0;
			}
			for(;k>i;k--)  
                cnt[k]--,cnt[k-1]+=stack[k]/stack[k-1];  
            ++ans;--cnt[i];  
		}	
	}
	printf("%d\n",ans);
	return 0;
}
Problem1122

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
typedef long long LL;
int sum[N<<1],mn[N],Q[N<<1],l,r;
char opt[N];
LL Abs(LL x){return x>0?x:-x;}
int main()
{
	int n,p,q,x,y;
	scanf("%d%d%d%d%d",&n,&p,&q,&x,&y);
	scanf("%s",opt+1);
	for(int i = n*2;i>n;i--)
		sum[i] = sum[i+1]+(opt[i-n]=='+'?1:-1);
	for(int i = n;i>=1;i--)
		sum[i] = sum[i+1]+(opt[i]=='+'?1:-1);
	r = -1;
	for(int i = 2*n;i>=1;i--)
	{
		while(l<=r&&sum[i]>sum[Q[r]])r--;
		Q[++r] = i;
		while(l<=r&&Q[l]-i>=n)l++;
		if(i<=n)mn[i] = sum[i]-sum[Q[l]];
	}
	LL get = sum[n+1];
	LL cng = (q-p-get)/2;
	LL ans = 1e18;
	for(int i = 0;i<n;i++)
	{
		LL cost = Abs(cng)*x+(LL)y*i;
		if(i==0)
		{
			mn[1]+=p+max(cng,0ll)*2;
			if(mn[1]<0)cost += (LL)x*2*((1-mn[1])/2);
		}else
		{
			mn[n-i+1]+=p+max(cng,0ll)*2;
			if(mn[n-i+1]<0)cost += (LL)x*2*((1-mn[n-i+1])/2);
		}
		ans = min(ans,cost);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem1123

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 1000005;
typedef long long LL;
struct E
{int next,to;}e[M];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int dfn[N],low[N],top,cnt,size[N],n,m;
bool v[N];
LL ans[N];
void tarjan(int x,int l)
{
	v[x] = true;
	dfn[x] = low[x] = ++cnt;
	int tmp = 0;
	size[x] = 1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(!v[e[i].to])
		{
			tarjan(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			size[x]+=size[e[i].to];
			if(low[e[i].to]>=dfn[x])
			{
				ans[x]+=(LL)tmp*size[e[i].to];
				tmp+=size[e[i].to];
			}
		}else low[x] = min(low[x],dfn[e[i].to]);
	}
	ans[x]+=(LL)tmp*(n-tmp-1);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	tarjan(1,0);
	for(int i = 1;i<= n;i++)
		printf("%lld\n",(ans[i]+n-1)<<1);
	return 0;
}
Problem1124

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int degree[N],aim[N];
int ans1,ans2,n;
namespace Ans1
{
	int degree[N];
	bool vis[N],dead[N];
	void Solve()
	{
		static int q[N];
		int hd = 1,tl = 0;
		memcpy(degree,::degree,sizeof(degree));
		for(int i = 1;i<= n;i++)if(!degree[i])q[++tl]=i;
		while(hd<=tl)
		{
			int x = q[hd++];
			vis[x] = true;
			if(!dead[aim[x]])
			{
				dead[aim[x]] = vis[aim[x]] = true;ans1++;
				if(!--degree[aim[aim[x]]])
					q[++tl] = aim[aim[x]];
			}
		}
		for(int i =1;i<= n;i++)
			if(!vis[i])
			{
				int cnt = 0,x = i;
				while(!vis[x])
				{
					vis[x] = true;
					cnt++;
					x = aim[x];
				}
				ans1+=(cnt+1)>>1;
			}
	}
}
namespace Ans2
{
	struct E
	{int next,to;}e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	bool vis[N];
	int stack[N],top;
	void bfs(int x)
	{
		static int q[N];
		int hd = 1,tl = 0;
		q[++tl] = x;vis[x] = true;
		while(hd<=tl)
		{
			int cur = q[hd++];
			stack[++top] = cur;
			for(int i = head[cur];i;i=e[i].next)
				if(!vis[e[i].to])
					vis[e[i].to]=true,q[++tl] = e[i].to;
		}
	}
	void Solve()
	{
		for(int i = 1;i<= n;i++)
			add(i,aim[i]);
		for(int i = 1;i<= n;i++)
			if(!vis[i])
			{
				top = 0;
				bfs(i);
				if(top==1)ans2++;
				else
				{
					int cnt = 0,size = top;
					while(top)
						cnt+=degree[stack[top--]]==0;
					ans2+=size-max(1,cnt);
				}
			}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&aim[i]);
		degree[aim[i]]++;
	}
	Ans1::Solve();
	Ans2::Solve();
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem1132

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3005;
struct Point
{
	int x,y;
	double sl;
	Point(){}
	Point(int x,int y):x(x),y(y)
	{
		sl = x?(double)y/x:1e10;
	}
	bool operator<(const Point &a)const
	{
		if(x==a.x)
			return y<a.y;
		return x<a.x;
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
}a[N],poi[N];
bool cmp(const Point &a,const Point &b)
{
	return a.sl<b.sl;
}
int main()
{
	int n,tot;
	ll ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+n+1);
	for(int i = 1;i<= n;i++)
	{
		tot = 0;
		ll sumx = 0,sumy = 0;
		for(int j = i+1;j<= n;j++)
			poi[++tot]=a[j]-a[i];
		sort(poi+1,poi+tot+1,cmp);
		for(int j = 1;j<= tot;j++)
		{
			ans+=sumx*poi[j].y-sumy*poi[j].x;
			sumx+=poi[j].x;
			sumy+=poi[j].y;
		}
	}
	printf("%lld.%d",ans>>1,(ans&1)?5:0);
	return 0;
}
Problem1133

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 605;
const int K = 65;
int f[K][N];
int sum[N][N],pre[N][K];
int s(int x1,int y1,int x2,int y2)
{
	return sum[x2][y2]-sum[x1][y2]-sum[x2][y1]+sum[x1][y1];
}
int main()
{
	int n,K;
	scanf("%d%d",&n,&K);
	for(int i = 1;i<n;i++)
		for(int j = 1;i+j<= n;j++)
			scanf("%d",&sum[i][j+i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			sum[i][j] += sum[i][j-1];
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			sum[i][j]+=sum[i-1][j];
	memset(f,0xef,sizeof(f));
	f[0][0] = 0;
	for(int i = 1;i< n;i++)
		for(int j = 1;j<= K;j++)
			for(int k = 0;k<i;k++)
			{
				//f[i][j][k] = max(f[i][j][k],f[i-1][j][k]);
				int tmp = f[j-1][k]+s(k,i,i,n);
				if(tmp>f[j][i])
				{
					pre[i][j] = k;
					f[j][i] = tmp;
				}
			}
	int ans = 0xefefefef;
	int tmp = 0;
	for(int k = 0;k<= n;k++)
	{
		if(f[K][k]>ans)
			ans = f[K][k],tmp = k;
	}
	int stack[605],top=0;
	while(top<K)
	{
		stack[++top] = tmp;
		tmp = pre[tmp][K-top+1];
	}
	//printf("%d\n",ans);
	for(int i = top;i> 1;i--)
		printf("%d ",stack[i]);
	printf("%d\n",stack[1]);
	return 0;
}
Problem1143

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int M = 1e4+5;
const int INF = 0x3f3f3f3f;
int a[105][105],lk[105],n,m,u,v;
bool map[105][105],vis[105];
bool find(int x)
{
	for(int i = 1;i<= n;i++)
		if(a[x][i]&&!vis[i])
		{
			vis[i] = true;
			if(find(lk[i])||!lk[i])
			{
				lk[i] = x;
				return true;
			}
		}
	return false;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&u,&v);
		map[u][v] = true;
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				map[i][j]|=(map[i][k]&map[k][j]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(i!=j&&map[i][j])
				a[i][j] = true;
	int ans = n;
	for(int i = 1;i<= n;i++)
	{
		memset(vis,0,sizeof(vis));
		ans-=find(i);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1145

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int mod = 16777216;
typedef long long ll;
ll c[N],l[N],r[N];
int a[N],n;
ll getans(int x)
{
	ll ans =0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void update(int x,ll y)
{
	for(int i = x;i<=n;i+=i&(-i))
		(c[i]+=y+mod)%=mod;
}
int cnt1()
{
	memset(c,0,sizeof(c));
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = (ans+(l[i]*(i-2)-getans(a[i])-l[i]*(l[i]-1)/2)*((ll)n-i-r[i])%mod+mod)%mod;
		update(a[i],i-1);
	}
	return (int)ans;
}
int cnt2()
{
	memset(c,0,sizeof(c));
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = (ans+((ll)n-i-r[i])*getans(a[i])%mod+mod)%mod;
		update(a[i],l[i]);
	}
	return (int)ans;
}
int cnt3()
{
	memset(c,0,sizeof(c));
	ll ans =0;
	for(int i = n;i;i--)
	{
		ans = (ans+((ll)n-i-r[i])*(getans(a[i])-r[i]*(r[i]-1)/2)%mod+mod)%mod;
		update(a[i],a[i]-1);
	}
	return (int)ans;
}
int cnt4()
{
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans = (ans+(n-i-r[i])*(n-i-r[i]-1)*(n-i-r[i]-2)/6)%mod;
	return (int)ans;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<= n;i++)
	{
		l[i]=getans(a[i]);
		r[i]=a[i]-1-l[i];
		update(a[i],1);
	}
	ll ans = ((cnt1()+cnt2()+cnt3()-cnt4())%mod+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem1146

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
const int INF = 1e8+1;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,q;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],son[N],w[N],top[N],fa[N],cnt,id[N],d[N],dpt[N];
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x] = 1;
	dpt[x] = dpt[f]+1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==f)continue;
		dfs1(e[i].to,x);
		size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	id[cnt] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_rank(root[p],y);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,y);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,y);
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void build()
{
	for(int i = 1;i<=cnt;i++)
		build(1,1,cnt,i,d[id[i]]);
}
void get_rank(int x,int y,int k)
{
	while(top[x]!=top[y])
	{
		if(dpt[top[x]]<dpt[top[y]])swap(x,y);
		get_rank(1,1,n,w[top[x]],w[x],k);
		x = fa[top[x]];
	}
	if(dpt[x]<dpt[y])swap(x,y);
	get_rank(1,1,n,w[y],w[x],k);
}
void get_number(int x,int y,int k)
{
	int l = -INF,r = 1,ans;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		tmp = 1;
		get_rank(x,y,mid);
		if(tmp<=k){l = mid+1;ans= mid;}
		else r = mid-1;
	}
	if(ans!=1)printf("%d\n",-ans);
	else printf("invalid request!\n");
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){scanf("%d",&d[i]);d[i] = -d[i];}
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1,0);
	dfs2(1,1);
	build();
	int k,a,b;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&k,&a,&b);
		if(k==0)
		{
			change(1,1,n,w[a],d[a],-b);
			d[a] = -b;
		}else
			get_number(a,b,k);
	}
	return 0;
}
Problem1149

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int l[N],r[N],maxx,minx,n,ans;
void dfs(int x,int dep)
{
	if(x==-1){maxx = max(maxx,dep),minx = min(minx,dep);return ;}
	dfs(l[x],dep+1);
	dfs(r[x],dep+1);
}
int solve(int x,int dep)
{
	int a,b;
	if(x==-1)
	{
		if(dep==minx)return 1;
		else return 2;
	}
	a = solve(l[x],dep+1);
	b = solve(r[x],dep+1);
	if((a==1&&b==2)||(a==1&&b==3)||(a==3&&b==2))ans++;
	if(a==3&&b==3){printf("-1\n");exit(0);}
	return a|b;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&l[i],&r[i]);
	maxx = 0,minx = N*10;
	dfs(1,0);
	if(maxx-minx>=2)printf("-1\n");
	else if(maxx==minx)printf("0\n");
	else
	{
		solve(1,0);
		printf("%d\n",ans);
	}
	return 0;
}
Problem1150

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int INF = 0x3f3f3f3f;
struct Heap
{int no,val;}heap[N];
bool cmp(const Heap &a,const Heap &b)
{
	return a.val>b.val;
}
int len[N],pre[N],L[N],R[N];
int main()
{
	int n,k,y;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&y);
		len[i] = y-pre[i-1];
		pre[i] = y;
		L[i] = i-1,R[i]=i+1;
	}
	int cnt = 0;
	for(int i = 2;i<= n;i++)
	{
		heap[++cnt] = (Heap){i,len[i]};
		push_heap(heap+1,heap+cnt+1,cmp);
	}
	L[2] = 0,R[n]=0;
	int ans = 0;
	for(int i =1;i<= k;i++)
	{
		while(heap[1].val!=len[heap[1].no])
			pop_heap(heap+1,heap+cnt+1,cmp),cnt--;
		int x = heap[1].no;
		int l = L[x],r = R[x];
		pop_heap(heap+1,heap+cnt+1,cmp),cnt--;
		ans+=len[x];
		L[R[x] = R[r]]=x;
		R[L[x] = L[l]]=x;
		len[x] = (l&&r)?min(INF,len[l]+len[r]-len[x]):INF;
		len[l] = len[r] = INF;
		heap[++cnt] = (Heap){x,len[x]};
		push_heap(heap+1,heap+cnt+1,cmp);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1151

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<5;
const int N = 1e4+5;
int f[N][S],g[N][S],n,C;
bool ok[N*5][S];
struct P
{
	int pos;
	int f,l;
	int fear,love;
}c[N*5];
int mod(int x)
{
	return (x%n+n)%n;
}
int main()
{
	int x;
	scanf("%d%d",&n,&C);
	for(int i = 1;i<= C;i++)
	{
		scanf("%d%d%d",&c[i].pos,&c[i].f,&c[i].l);
		for(int j = 1;j<=c[i].f;j++)
		{
			scanf("%d",&x);
			c[i].fear|=(1<<mod(x-c[i].pos));
		}
		for(int j = 1;j<=c[i].l;j++)
		{
			scanf("%d",&x);
			c[i].love|=(1<<mod(x-c[i].pos));
		}
		for(int j = 0;j<S;j++)
			if((j&c[i].fear)||((31^j)&c[i].love))
				ok[i][j] = true,g[c[i].pos][j]++;
	}
	int ans = 0;
	for(int i = 0;i<1<<4;i++)
	{
		memset(f[0],200,sizeof(f[0]));
		f[0][i<<1] = 0;
		for(int j = 1;j<= n;j++)
			for(int k = 0;k<1<<5;k++)
				f[j][k] = max(f[j-1][(k&15)<<1],f[j-1][(k&15)<<1|1])+g[j][k];
		ans = max(ans,max(f[n][i<<1],f[n][i<<1|1]));
	}
	printf("%d\n",ans);
	return 0;
}
Problem1170

#include <stdio.h>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll mod1 = 1e9+7;
const ll mod2 = 1e9+9;
const ll base1 = 2591;
const ll base2 = 2593;
const int N = 1e3+5;
const int MOD = N*N;
ll sum1[N][N],sum2[N][N];
ll basel[3]={0,1,1},baser[3]={0,1,1};
char s[N][N];
ll ans_time,ans1,ans2;
struct Hash_list
{
	int next;
	ll hv1,hv2;
	int times;
}e[N*N];
int head[N*N],tot;
inline int& Hash(ll h1,ll h2)
{
	ll x = h1*h2%MOD;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].hv1==h1&&e[i].hv2==h2)
			return e[i].times;
	tot++;
	e[tot].next = head[x];e[tot].hv1 = h1,e[tot].hv2 = h2;
	e[tot].times = 0;head[x] = tot;
	return e[tot].times;
}
int n,m,a,b;
ll gethash1(int i,int j)
{
	return 
		((sum1[i][j]-
		sum1[i-a][j]*basel[1]-
		sum1[i][j-b]*baser[1]+
		sum1[i-a][j-b]*basel[1]%mod1*baser[1])%mod1+mod1)%mod1;
}
ll gethash2(int i,int j)
{
	return 
		((sum2[i][j]-
		sum2[i-a][j]*basel[2]-
		sum2[i][j-b]*baser[2]+
		sum2[i-a][j-b]*basel[2]%mod2*baser[2])%mod2+mod2)%mod2;
}
int main()
{
	//freopen("x.in","r",stdin);
	scanf("%d %d\n",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		fread(s[i]+1,m+1,1,stdin);
		for(int j = 1;j<= m;j++)
			sum1[i][j] = sum2[i][j] = s[i][j];
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			sum1[i][j]=(sum1[i][j]+sum1[i-1][j]*base1)%mod1,
			sum2[i][j]=(sum2[i][j]+sum2[i-1][j]*base1)%mod2;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			sum1[i][j]=(sum1[i][j]+sum1[i][j-1]*base2)%mod1,
			sum2[i][j]=(sum2[i][j]+sum2[i][j-1]*base2)%mod2;
	scanf("%d%d",&a,&b);
	printf("%d %d\n",a,b);
	for(int i = 1;i<= a;i++)
		basel[1]*=base1,basel[1]%=mod1,
		basel[2]*=base1,basel[2]%=mod2;
	for(int i = 1;i<= b;i++)
		baser[1]*=base2,baser[1]%=mod1,
		baser[2]*=base2,baser[2]%=mod2;
	ans_time = 0;
	for(int i = a;i<= n;i++)
		for(int j = b;j<= m;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			int &val = Hash(hash1,hash2);
			if(++val>ans_time)
			{
				ans_time = val;
				ans1 = hash1,ans2 = hash2;
			}
		}
	bool flag = true;
	for(int i = a;i<= n&&flag;i++)
		for(int j = b;j<= m&&flag;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			if(hash1==ans1&&hash2==ans2)
			{
				for(int k=i-a+1;k<=i;k++,puts(""))
					for(int l = j-b+1;l<=j;l++)
						putchar(s[k][l]);
				flag = false;
			}
		}
	printf("%lld\n",ans_time);
	for(int i = a;i<= n;i++)
		for(int j = b;j<= m;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			if(hash1==ans1&&hash2==ans2)
				printf("%d %d\n",i-a+1,j-b+1);
		}
	return 0;
}
Problem1181

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int INF = 1<<30;
int _a[N],a[N],b[N];
int s[N],ans[N];
bool cmp(int x,int y)
{
	return _a[x]>_a[y];
}
int f[2][N];
int V,n,m,tot;
bool check(int idx,int mid)
{
	for(int i = 0;i<= m;i++)
		f[0][i] = f[1][i] = INF;
	f[0][0] = 0;
	int now = 0;
	for(int i = 1;i<= min(n,21);i++)
	{
		if(i==idx)continue;
		for(int j = 0;j<= m;j++)
		{
			f[now^1][j] = INF;
			for(int k = 0;k<= j;k++)
			{
				int x = (a[idx]*k+mid)/(mid+1)-a[i];
				if(a[idx]*k%(mid+1)==0 && b[i]>b[idx] && k)
					x++;
				x = max(x,0);
				if (k && (a[i]+x)*20<V) 
					x+=(V+19-20*(a[i]+x))/20;
				f[now^1][j] = min(f[now^1][j],f[now][j-k]+x);
			}
		}
		now^=1;
	}
	return f[now][m-mid]<=V-tot;
}
int main()
{
	scanf("%d%d%d",&V,&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&_a[i]);
		b[i] = i;
		tot+=_a[i];
	}
	for(int i = 1;i<= n;i++)
	{
		_a[i]+=V-tot;
		for(int j = 1;j<= m;j++)
		{
			int mk = 0;
			for(int k = 1;k<= n;k++)
				if(_a[k]*20>=V&&(mk==0||_a[k]*(s[mk]+1)>_a[mk]*(s[k]+1)))
					mk = k;
			s[mk]++;
		}
		printf("%d",s[i]);
		if(i==n)printf("\n");else printf(" ");
		for(int j = 0;j<= n;j++)s[j]=0;
		_a[i]-=V-tot;
	}
	sort(b+1,b+n+1,cmp);
	for(int i = 1;i<= n;i++)a[i] = _a[b[i]];
	for(int i = 1;i<= n;i++)
	{
		if(a[i]*20<V){ans[b[i]]=0;continue;}
		int l = -1,r = m,mid;
		while(l+1<r)
		{
			mid = (l+r)>>1;
			if(check(i,mid))
				r = mid;
			else 
				l = mid;
		}
		ans[b[i]] = r;
	}
	for(int i = 1;i<= n;i++)
		printf("%d",ans[i]),printf("%c",i==n?'\n':' ');
	return 0;
}
Problem1187

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF=2e9;
const int MAXN=3005;
int i;
struct na
{
	int x,z;
	na(int _x,int _z):x(_x),z(_z){}
};
int n,m,x,y,z,a[21],k,p1,p2,en,t;
bool map[11][101];
int f[2][MAXN+1],ans=-INF,re[101][11];
int v[2][MAXN+1];
queue <na> q;
inline int gx(int x,int q1,int q2)
{
	k=0;
	for (register int i=m+1;i;i--) 
		k=k*3+(i==x?q1:(i==x+1?q2:a[i]));
	return k;
}
inline void up(int x,int z,int lj,int la)
{
	if (la) lj+=re[x/m+1][x%m+1];
	x++;
	k=x%2;
	if (v[k][z]!=x) v[k][z]=x,f[k][z]=-INF,q.push(na(x,z));
	if (f[k][z]<lj) f[k][z]=lj;
}
int main()
{
	int i,j,p;
	scanf("%d%d",&n,&m);
	memset(f,INF,sizeof(f));
	for (j=1;j<=n;j++)
	for (i=1;i<=m;i++)
	scanf("%d",&re[j][i]),map[i][j]=1;
	en=n*m-1;
	f[0][0]=0;
	v[0][0]=1;
	q.push(na(0,0));
	while(!q.empty())
	{
		p=0;
		na no=q.front();q.pop();
		int an=f[no.x%2][no.z];
		if(no.x%m==0) no.z*=3;
		x=no.x%m+1;y=no.x/m+1;
		for (i=1;i<=m+1;i++) a[i]=0;
		for (i=1,j=no.z;j;i++,j/=3)
		{
			a[i]=j%3;
			if (a[i]) p++;
		}
		if (a[x]==1&&a[x+1]==2)
		{
			if (ans<an+re[y][x]&&p==2) ans=an+re[y][x];
		}
		else if (a[x]==2&&a[x+1]==1) up(no.x,gx(x,0,0),an,1);
		else if (a[x]==0&&a[x+1]==0)
		{
			if (no.x!=en)
			{
				if (map[x][y+1]&&map[x+1][y]) up(no.x,gx(x,1,2),an,1);
				up(no.x,gx(x,0,0),an,0);
			}
		}
		else if (a[x]==0)
		{
			if (map[x+1][y]) up(no.x,gx(x,0,a[x+1]),an,1);
			if (map[x][y+1]) up(no.x,gx(x,a[x+1],0),an,1);
		}
		else if (a[x+1]==0)
		{
			if (map[x+1][y]) up(no.x,gx(x,0,a[x]),an,1);
			if (map[x][y+1]) up(no.x,gx(x,a[x],0),an,1);
		}
		else if (a[x]==a[x+1])
		{
			p1=p2=0;
			if (a[x]==1)
			for (j=0,i=x+2;i<=m+1;i++)
			{
				if (a[i]==1) j--;
				if (a[i]==2) j++;
				if (j>0&&!p1) p1=i,j--;
				if (j>0&&p1){p2=i;break;}
			}
			else
			for (j=0,i=x-1;i;i--)
			{
				if (a[i]==1) j++;
				if (a[i]==2) j--;
				if (j>0&&!p2) p2=i,j--;
				if (j>0&&p2){p1=i;break;}
			}
			a[p1]=1;a[p2]=2;up(no.x,gx(x,0,0),an,1);
		}
		//printf("%d\n",ans);
	}
	printf("%d\n",ans);
}
Problem1189

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define mid (l+r)/2
#define inf 0x3f3f3f3f
#define T n*n*m*m+2
const int N=25;
const int M=200000;
char s[N];
bool use[N][N],flag[N][N];
struct S{int x,y,c;}l[N*N];
struct Q{int st,en,va;}aa[M*2];
int n,m,map[N][N],f[N][N][N][N],sum,point[M],next[M*2],cur[M],dis[M],pre[M],gap[M],tot;
const int xi[4]={-1,0,0,1},yi[4]={0,-1,1,0};
inline void bfs(int xa,int ya)
{
	int i,h,t,k,x,y;
	memset(use,1,sizeof(use));
	h=t=1;l[h].x=xa;l[h].y=ya;l[h].c=0;
	while(h<=t){
		x=l[h].x;y=l[h].y;
		for(i=0;i<4;++i)
		{
			int xx=x+xi[i],yy=y+yi[i];
			if(xx>0&&xx<=n&&yy>0&&y<=m&&map[xx][yy]==1&&use[xx][yy])
			{
				l[++t].x=xx;l[t].y=yy;l[t].c=l[h].c+1;
				use[xx][yy]=false;
				f[xx][yy][xa][ya]=l[t].c;
				flag[xx][yy]=true;
			}
		}
		h+=1;
	}
}
inline void add(int x,int y,int z)
{
	tot+=1;next[tot]=point[x];point[x]=tot;
	aa[tot].st=x;aa[tot].en=y;aa[tot].va=z;
	tot+=1;next[tot]=point[y];point[y]=tot;
	aa[tot].st=y;aa[tot].en=x;aa[tot].va=0;
}
inline int ISAP(int ss,int tt)
{
	bool f;
	int minn,ans=0,i,u,y;
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	memset(pre,0,sizeof(pre));
	gap[0]=tt-ss+1; u=ss;
	for(i=ss;i<=tt;++i) cur[i]=point[i];
	while(dis[ss]<tt-ss+1)
	{
		f=false;
		for(i=cur[u];i;i=next[i])
			if(aa[i].va>0&&dis[u]==dis[aa[i].en]+1)
			{
			cur[u]=i;f=true;break;
			}
		if(f)
		{
			pre[u=aa[i].en]=i;
			if(u==tt)
			{
				minn=inf;
				for(i=u;i!=ss;i=aa[pre[i]].st)
					minn=min(minn,aa[pre[i]].va);
				ans+=minn;
				for(i=u;i!=ss;i=aa[pre[i]].st)
				{
					aa[pre[i]].va-=minn;
					aa[pre[i]^1].va+=minn;
				}
				u=ss;
			}   
		}
		else
		{
			--gap[dis[u]];
			if(!gap[dis[u]]) return ans;
			y=2*tt; cur[u]=point[u];
			for(i=point[u];i;i=next[i])
				if(aa[i].va>0) y=min(y,dis[aa[i].st]);
			++gap[dis[u]=y+1];
			if(u!=ss) u=aa[pre[u]].st;
		}
	}
	return ans;
}
inline bool check(int x)
{
	int i,j,p,q;
	tot=1;
	memset(point,0,sizeof(point));
	memset(next,0,sizeof(next));
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		{
		int now=((i-1)*m+j-1)*n*m;
		if(map[i][j]==0)
		{
			for(p=1;p<x;++p)
				add(now+p+1,now+p+2,inf),add(now+p+1,T,1);
			add(now+x+1,T,1);
		}
		if(map[i][j]==1)
		{
			add(1,now+1,1);
			for(p=1;p<=n;++p)
				for(q=1;q<=m;++q)
				if(f[i][j][p][q])
					add(now+1,((p-1)*m+q-1)*n*m+f[i][j][p][q]+1,1);
		}
		}
	return ISAP(1,T)==sum;
}
int main()
{
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)
	{
		scanf("%s",&s);
		for(j=0;j<m;++j)
		{
			if(s[j]=='D') map[i][j+1]=0;
			if(s[j]=='.') map[i][j+1]=1,sum+=1;
			if(s[j]=='X') map[i][j+1]=2;
		}
	}
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		if(map[i][j]==0)
			bfs(i,j);
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		if(!flag[i][j]&&map[i][j]==1)
		{
			printf("impossible\n");
			return 0;
		}
	int l=1,r=n*m,ans=inf;
	while(l<r)
	{
		if(check(mid)) ans=min(ans,mid),r=mid;
		else l=mid+1;
	}
	printf("%d\n",ans);
}
Problem1190

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 105;
ll f[35][1005];
int main()
{
	int n,w,x,v;
	while(scanf("%d%d",&n,&w)!=EOF)
	{
		if(n==-1&&w==-1)break;
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d",&x,&v);
			int tmp = 0;
			while(!(x&1))x>>=1,tmp++;
			for(int j = 1000;j>= x;j--)
				f[tmp][j] = max(f[tmp][j],f[tmp][j-x]+v);
		}
		for(int i = 0;i<= 30;i++)
			for(int j = 1;j<= 1000;j++)
				f[i][j]=max(f[i][j],f[i][j-1]);
		ll ans = 0;
		for(int j = 1;j<= min(1000,w);j++)ans = max(ans,f[0][j]);
		for(int i = 1;i<= 30&&(1<<i)<=w;i++)
			for(int j = min(1000,w>>i);j>= 0;j--)
			{
				for(int k = 0;k<= j;k++)
					f[i][j] = max(f[i][j],f[i][j-k]+f[i-1][min(k+k+((w>>i-1)&1),1000)]);
				ans = max(f[i][j],ans);
			}
		printf("%d\n",ans);

	}
	return 0;
}
Problem1194

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define fir first
#define sec second
const int N = 55;
const int L = 65540;
struct E
{int next,to;}e[N*N];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
vector<int>member[N];
int bel[N],cnt,dfn[N],low[N],Dfn,stack[N],top;
bool vis[N];
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	for(int i = head[x];i;i=e[i].next)
	{
		if(vis[e[i].to])continue;
		if(dfn[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}
	}
	if(dfn[x]==low[x])
	{
		++cnt;
		int tmp;
		do
		{
			tmp = stack[top--];
			bel[tmp] = cnt;
			member[cnt].push_back(tmp);
			vis[tmp] = true;
		}while(tmp!=x);
	}
}
struct AM
{
	int n,m;
	int trs[N][2],out[N];
	void Read()
	{
		int x;
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&x);
			out[x] = true;
		}
		for(int i = 0;i< n;i++)
			scanf("%d%d",&trs[i][0],&trs[i][1]);
	}
}a[N];
bool bfs(const AM &x,const AM &y)
{
	static pii q[L];
	static bool v[N][N];
	memset(v,0,sizeof(v));
	int hd=1,tl=0;
	q[++tl] = make_pair(0,0);
	v[0][0] = true;
	while(hd<=tl)
	{
		pii sta = q[hd++];
		if(x.out[sta.fir] && !y.out[sta.sec])
			return false;
		for(int i = 0;i<2;i++)
		{
			int xx = x.trs[sta.fir][i];
			int yy = y.trs[sta.sec][i];
			if(v[xx][yy])continue;
			v[xx][yy] = true;
			q[++tl] = make_pair(xx,yy);
		}
	}
	return true;
}
int f[N],ans,n;
void topo()
{
	static int q[N],deg[N];
	for(int i = 1;i<= n;i++)
		for(int j = head[i];j;j=e[j].next)
			if(bel[i]!=bel[e[j].to])
				deg[bel[e[j].to]]++;
	int hd = 1,tl = 0;
	for(int i = 1;i<= cnt;i++)
		if(!deg[i])
			q[++tl] = i;
	while(hd<=tl)
	{
		int tmp = q[hd++];
		f[tmp]+=member[tmp].size();
		for(int id = 0;id<member[tmp].size();id++)
		{
			int x = member[tmp][id];
			for(int i = head[x];i;i=e[i].next)
			{
				if(bel[e[i].to]==tmp)continue;
				f[bel[e[i].to]] = max(f[bel[e[i].to]],f[tmp]);
				if(!--deg[bel[e[i].to]])q[++tl] = bel[e[i].to];
			}
		}
		ans = max(ans,f[tmp]);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		a[i].Read();
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(i!=j&&bfs(a[i],a[j]))
				add(i,j);
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	topo();
	printf("%d\n",ans);
	return 0;
}
Problem1196

#include <cstdio> 
#include <cstring> 
#include <iostream> 
#include <algorithm> 
#define MAX 20010 
using namespace std;  
struct Edge{
 	int x,y; 	
	int cost,_cost;  	
	bool operator <(const Edge &a)const 
	{ 		
		return cost < a.cost; 	
	} 	
	void Read() 
	{ 		
		scanf("%d%d%d%d",&x,&y,&cost,&_cost); 	
	} 
}edge[MAX];  
int points,k,edges; 
int father[MAX];  
int Find(int x) 
{ 	
	if(father[x] == x)	
	return x; 	
	return father[x] = Find(father[x]); 
}  
inline bool Judge(int ans) 
{ 	
	for(int i = 1; i <= points; ++i) 		
		father[i] = i; 	
	int first = 0,added = 0; 	
	for(int i = 1; i <= edges; ++i) 
	{ 		
		int fx = Find(edge[i].x);
		int fy = Find(edge[i].y); 		
		if(fx != fy)
		 { 			
		 	if(edge[i].cost <= ans)
			{ 				
				++first,++added;
				father[fx] = fy; 			
			} 			
			else if(edge[i]._cost <= ans) 
			{ 				
				++added; 				
				father[fx] = fy;
 			} 		
		 } 	
	 } 	
	 return first >= k && added == points - 1;
  }  
int main() 
{ 	
	cin >> points >> k >> edges; 	
	for(int i = 1; i <= edges - 1; ++i)  	
		edge[i].Read(); 	
	sort(edge + 1,edge + edges + 1); 	
	int l = 0,r = 30000,ans = 30000; 	
	while(l <= r) 
	{ 		
		int mid = (l + r) >> 1; 		
		if(Judge(mid)) 			
			ans = mid,r = mid - 1; 		
		else	
			l = mid + 1; 	
	} 	
	cout << ans << endl;
 	return 0; 
 }
 
Problem1202

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int fa[105];
int pos[105];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else
	{
		int tmp = getfa(fa[x]);
		pos[x] = pos[fa[x]]+pos[x];
		return fa[x] = tmp;
	}
}
void work()
{
	memset(fa,0,sizeof(fa));
	memset(pos,0,sizeof(pos));
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	int flag = true;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		int fx = getfa(x),fy = getfa(y+1);
		if(fx==fy)
		{
			if(pos[y+1]-pos[x]!=c)flag = false;
		}
		else
		{
			fa[fy] = x;
			pos[fy] = c-pos[y+1];
		}
	}
	if(flag)printf("true\n");
	else printf("false\n");
	return ;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
		work();
	return 0;
}
Problem1208

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL INF = 1e18;
const int mod = 1e6;
struct Treap
{
	Treap *ls,*rs;
	int key,cnt,size;
	LL val;
	Treap(int x);
	void push_up();
}*root0,*root1;
Treap :: Treap(int x)
{
	ls = rs = NULL;
	key = rand();
	val = x;
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key<x->key)
			go_right(x);
	}else
	{
		insert(x->rs,y);
		if(x->rs->key<x->key)
			go_left(x);
	}
	x->push_up();
}
void dele(Treap *&x,int y)
{
	if(y<x->val)
		dele(x->ls,y);
	else if(y>x->val)
		dele(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)
			x = x->rs;
		else if(!x->rs)
			x = x->ls;
		else
		{
			go_left(x);
			dele(x->ls,y);
			if(x->ls && x->ls->key<x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
LL ans;
void ask_pro(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<y)
	{
		ans = max(ans,x->val);
		ask_pro(x->rs,y);
	}
	else ask_pro(x->ls,y);
}
void ask_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>y)
	{
		ans = min(ans,x->val);
		ask_sub(x->ls,y);
	}
	else ask_sub(x->rs,y);
}
int main()
{
	int n,a,b;
	scanf("%d",&n);
	LL sum = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a,&b);
		if(a==0&&!root1)
			insert(root0,b);
		else if(a==1&&!root0)
			insert(root1,b);
		else
		{
			if(a==0)
			{
				ans = 0;
				ask_pro(root1,b);
				int tmp1 = ans;
				ans = INF;
				ask_sub(root1,b);
				int tmp2 = ans;
				if(tmp1==0){sum+=abs(b-tmp2);dele(root1,tmp2);}
				else if(tmp2==INF){sum+=abs(b-tmp1);dele(root1,tmp1);}
				else if(abs(b-tmp1)>abs(b-tmp2)){sum+=abs(b-tmp2);dele(root1,tmp2);}
				else if(abs(b-tmp1)<abs(b-tmp2)){sum+=abs(b-tmp1);dele(root1,tmp1);}
				else{sum+=abs(b-tmp1);dele(root1,tmp1);}
			}else
			{
				ans = 0;
				ask_pro(root0,b);
				int tmp1 = ans;
				ans = INF;
				ask_sub(root0,b);
				int tmp2 = ans;
				if(tmp1==0){sum+=abs(b-tmp2);dele(root0,tmp2);}
				else if(tmp2==INF){sum+=abs(b-tmp1);dele(root0,tmp1);}
				else if(abs(b-tmp1)>abs(b-tmp2)){sum+=abs(b-tmp2);dele(root0,tmp2);}
				else if(abs(b-tmp1)<abs(b-tmp2)){sum+=abs(b-tmp1);dele(root0,tmp1);}
				else{sum+=abs(b-tmp1);dele(root0,tmp1);}
			}
		}
	}
	printf("%lld\n",sum%mod);
	return 0;
}
Problem1212

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int Len = 1<<20;
char w[Len+5];
char s[35];
	int ch[305][26],fail[305],cnt,q[305],h,t;
	bool end[305];
	int len[305];
	void init()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i] =1;
	}
	void insert()
	{
		int now = 1,i = 0;
		while(s[i])
		{
			if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
			now = ch[now][s(i)];
			i++;
		}
		len[now] = i;
	}
	void build()
	{
		int h = 0,t = -1;
		q[++t] = 1,fail[0] =1;
		while(h<=t)
		{
			int x=q[h++];
			for(int i = 0;i<26;i++)
			{
				int j=ch[x][i];
				if(!j)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[j] = ch[k][i];
				end[j]|=end[fail[j]];
				q[++t]=j;
			}
		}
	}
bool v[Len+5];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	init();
	for(int i = 1;i<=n;i++)
	{
		scanf("%s",s);
		insert();
	}
	build();
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",w+1);
		int lth = strlen(w+1);
		int now = 1,ans = 0;
		v[0]=true;
		for(int j = 1;j<=lth;j++)
		{
			while(now!=1&&!ch[now][w[j]-'a'])
				now = fail[now];
			if(ch[now][w[j]-'a'])
			{
				now = ch[now][w[j]-'a'];
				for(int tmp = now;tmp!=1;tmp = fail[tmp])
					if(len[tmp])
					{
						v[j]|=v[j-len[tmp]];
						if(v[j])break;
					}
			}
			if(v[j])ans =max(ans,j);
		}
		for(int j = 1;j<=lth;j++)v[j] = false;
		printf("%d\n",ans);
	}
	return 0;
}
Problem1226

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int S = 1<<8;
const int INF = 0x3f3f3f3f;
#define f(i,j,k) (f[i][j][k+8])
int t[N],b[N];
int f[N][S][20];
int v(int pos1,int pos2)
{
	if(pos1==0)return 0;
	return (t[pos1]^t[pos2]);
}
void work()
{
int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
		scanf("%d%d",&t[i],&b[i]);
	for(int i = 1;i<= n+1;i++)
		for(int j = 0;j<1<<8;j++)
			for(int k = -8;k<= 7;k++)
				f(i,j,k) = INF;
	f(1,0,-1) = 0;
	for(int i = 1;i<= n;i++)
		for(int s = 0;s<1<<8;s++)
			for(int k = -8;k<=7;k++)
			{
				if(!(f(i,s,k)<INF))continue;
				if(s&1)f(i+1,s>>1,k-1) = min(f(i,s,k),f(i+1,s>>1,k-1));
				else
				{
					int r = INF;
					for(int l = 0;l<= 7;l++)
						if(!(s&(1<<l)))
						{
							if(i+l>r)break;
							r = min(r,i+b[i+l]+l);
							f(i,s|(1<<l),l)=min(f(i,s|(1<<l),l),f(i,s,k)+v(i+k,i+l));
						}
				}
			}
	int ans = 0x3f3f3f3f;
	for(int i = -8;i<=-1;i++)
		ans = min(ans,f(n+1,0,i));
	printf("%d\n",ans);
	return ;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem1227

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 2147483647;
int d[N];
int sum[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		d[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=d[i];
	return ans;
}
struct P
{int x,y,l,r,u,d;}p[N];
bool cmp(const P &a,const P &b)
{
	return a.y<b.y||(a.y==b.y&&a.x<=b.x);
}
int fac[N],env[N];
int c[N][20];
void init()
{
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0]=1;
		for(int j=1;j<=10;j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j];
	}
}
int id[N],X[N];
int find(int x)
{
	int l = 1,r = id[0]+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l=mid+1;
		else r=mid;
	}
	return l;
}
int main()
{
	int n,m,w,k;
	init();
	scanf("%d%d%d",&n,&m,&w);
	for(int i = 1;i<= w;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		X[i] = p[i].x;
	}
	scanf("%d",&k);
	sort(X+1,X+w+1);
	id[id[0]=1]=X[1];
	for(int i = 2;i<= w;i++)
		if(X[i]!=X[i-1])
			id[++id[0]]=X[i];
	sort(p+1,p+w+1,cmp);
	int tmp = 0;
	for(int i = 1;i<= w;i++)p[i].x=find(p[i].x);
	for(int i = 1;i<= w;i++)
	{
		if(p[i].y==p[i-1].y)tmp++;else tmp=1;
		p[i].l=tmp;
		sum[p[i].x]++;
		p[i].u=sum[p[i].x];
	}
	tmp = 0;
	for(int i = w;i>=1;i--)
	{
		if(p[i].y==p[i+1].y)tmp++;else tmp=1;
		p[i].r=tmp;
		p[i].d=sum[p[i].x]-p[i].u;
	}
	int ans = 0;
	for(int i = 1;i<= w;i++)
	{
		update(p[i].x,c[p[i].u][k]*c[p[i].d][k]-getans(p[i].x)+getans(p[i].x-1));
		if(i>1&&p[i].y==p[i-1].y)
			ans+=c[p[i-1].l][k]*c[p[i].r][k]*(getans(p[i].x-1)-getans(p[i-1].x));
	}
	printf("%d\n",ans&mod);
	return 0;
}
Problem1231

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1<<16;
long long f[2][N][17];
int cnt[N],s[17];
int abs(int x){return x<0?-x:x;}
void init()
{
	for(int i = 0;i<N;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	return ;
}
int main()
{
	int n,k;
	init();
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&s[i]);
	for(int i = 0;i< n;i++)
		f[1][1<<i][i+1] = 1;
	for(int i = 2;i<= n;i++)
	{
		int I = i&1,I_=(i-1)&1;
		for(int sta = 0;sta<1<<n;sta++)
		{
			if(cnt[sta]!=i-1)continue;
			for(int l = 1;l<= n;l++)
			{
				if(!(sta&(1<<(l-1))))continue;
				for(int t = 1;t<= n;t++)
				{
					if(sta&(1<<(t-1)))continue;
					if(abs(s[t]-s[l])<=k)continue;
					f[I][sta|(1<<(t-1))][t]+=f[I_][sta][l];
				}
			}
		}
		memset(f[I_],0,sizeof(f[I_]));
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=f[n&1][(1<<n)-1][i];
	printf("%lld\n",ans);
	return 0;
}
Problem1251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
struct Splay 
{
	Splay *ls,*rs,*fa;
	int lazy_add,max_val,val;
	int size;
	bool lazy_rev;
	Splay(int x);
	void push_down();
	void push_up();
}*null = new Splay(0xefefefef),*root = null;
Splay :: Splay (int x)
{
	ls = rs = fa = null;
	lazy_add = lazy_rev = 0;
	max_val = val = x;
	size = null?1:0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	max_val = max(max(ls->max_val,rs->max_val),val);
}
void Splay :: push_down()
{
	if(this==null)return ;
	if(lazy_add)
	{
		if(ls!=null)
		{
			ls->lazy_add += lazy_add;
			ls->max_val+=lazy_add;
			ls->val+=lazy_add;
		}
		if(rs!=null)
		{
			rs->lazy_add += lazy_add;
			rs->max_val+=lazy_add;
			rs->val+=lazy_add;
		}
		lazy_add = 0;
	}
	if(lazy_rev)
	{
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		ls->lazy_rev^=1;
		rs->lazy_rev^=1;
		lazy_rev = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *tar)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y = y-x->ls->size;
			if(y==1)
				break;
			y--;
			x = x->rs;
		}
	}
	splay(x,tar);
}
void update()
{
	int l,r,c;
	scanf("%d%d%d",&l,&r,&c);
	Find(root,l,null);
	Find(root,r+2,root);
	root->rs->ls->val+=c;
	root->rs->ls->max_val+=c;
	root->rs->ls->lazy_add+=c;
	//root->rs->push_up();
	//root->push_up();
}
void reverse()
{
	int l,r;
	scanf("%d%d",&l,&r);
	Find(root,l,null);
	Find(root,r+2,root);
	Splay *tmp = root->rs->ls;
	tmp->lazy_rev^=1;
	swap(tmp->ls,tmp->rs);
}
void get_max()
{
	int l,r;
	scanf("%d%d",&l,&r);
	Find(root,l,null);
	Find(root,r+2,root);
	printf("%d\n",root->rs->ls->max_val);
}
/*
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}*/
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = new Splay(0);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa = x;
	if(x->rs!=null)x->rs->fa = x;
	x->push_up();
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int opt;
	root = new Splay(Inv);
	root->rs = new Splay(Inv);
	build(root->rs->ls,1,n);
	root->rs->ls->fa = root->rs;
	root->rs->fa =root;
	root->rs->push_up();
	root->push_up();
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)update();
		else if(opt==2)reverse();
		else get_max();
	}
	return 0;
}
Problem1261

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double INF = 1e9+1;
double dp[35][35][35];
int rt[35][35][35];
int d[35],n;
double k,c;
double dfs(int l,int r,int dep)
{
	if(l==r)
		return (k*(dep+1)+c)*d[l];
	if(r<l)return 0;
	if(dp[l][r][dep]<1e9+1)return dp[l][r][dep];
	for(int i = l;i<= r;i++)
	{
		double tmp1 = dfs(l,i-1,dep+1);
		double tmp2 = dfs(i+1,r,dep+1);
		if(tmp1+tmp2+(k*(dep+1)+c)*d[i]<dp[l][r][dep])
		{
			dp[l][r][dep] = tmp1+tmp2+(k*(dep+1)+c)*d[i];
			rt[l][r][dep] = i;
		}
	}
	return dp[l][r][dep];
}
/*void print(int l,int r,int dep)
{
	if(l==r)
	{
		printf("%d")
	}
	int t = rt[l][r][dep];

}*/
int main()
{
	int sum = 0;
	for(int i = 0;i<= 31;i++)
		for(int j = 0;j<= 31;j++)
			for(int k = 0;k<= 31;k++)
				dp[i][j][k] = INF;
	scanf("%d%lf%lf",&n,&k,&c);
	for(int i = 1;i<= n;i++)
		{scanf("%d",&d[i]);sum+=d[i];}
	double ans = dfs(1,n,0);
	ans = ans/(double)sum;
	printf("%.3f",ans);
	//print(1,n,0);
	return 0;
}
Problem1264

#include<stdio.h>
int pos[20005][6];
int dna2[100005];
int cnt[20005];
int a[1000005];
int f[100005];
int find(int x,int end)
{
	int l=1,r = end+1,mid;
	while(l<r)
	{
		mid = (l+r)/2;
		if(f[mid]>=x)
		{
			r = mid;
		}else
		{
			l = mid+1;
		}
	}
	return l;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= 5*n;i++)
	{
		int x;
		scanf("%d",&x);
		pos[x][5-cnt[x]] = i;
		cnt[x]++;
	}
	for(int i = 1;i<= 5*n;i++)
	{
		scanf("%d",&dna2[i]);
		for(int j = 1;j<=5;j++)
		{
			a[(i-1)*5+j] = pos[dna2[i]][j];
		}
	}
	int ans = 0;
	for(int i = 1;i<= 25*n;i++)
	{
		if(a[i]>f[ans])
		{
			ans++;
			f[ans] = a[i];
		}else
		{
			f[find(a[i],ans)] = a[i];
		}
	}
	printf("%d",ans);
	return 0;
}
Problem1266

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 3e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;};
int d[N],dis[N];
bool v[N];
queue<int>Q;
struct G
{
	E e[M];
	int head[N],tot;
	void init()
	{
		memset(head,0,sizeof(head));
		tot=1;
	}
	void addE(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].f = f;
		head[x] = tot;
	}
	void addF(int x,int y,int f)
	{
		e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;head[x]=tot;
		e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;head[y]=tot;
	}
	void spfa(int s)
	{
		memset(dis,0x3f,sizeof(dis));
		dis[s]=0;v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f+dis[x]<dis[e[i].to])
				{
					dis[e[i].to]=dis[x]+e[i].f;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
		}
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[t]=0;
		Q.push(t);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(d[e[i].to]==-1&&e[i^1].f)
				{
					d[e[i].to]=d[x]+1;
					Q.push(e[i].to);
				}
		}
		return d[s]!=-1;
	}
	int get_maxflow(int s,int t,int mf)
	{
		if(s==t)return mf;
		int last = mf;
		for(int i = head[s];i;i=e[i].next)
			if(d[e[i].to]==d[s]-1&&e[i].f)
			{
				int tof = get_maxflow(e[i].to,t,min(e[i].f,last));
				if(tof)
				{
					e[i].f-=tof;
					e[i^1].f+=tof;
					if(!(last-=tof))return mf;
				}
			}
		d[s]=-1;
		return mf-last;
	}
	int dinic(int s,int t)
	{
		int ans=0,nowflow;
		while(bfs(s,t))
			while((nowflow=get_maxflow(s,t,INF)))
				ans+=nowflow;
		return ans;
	}
}G,F;
int x[M],y[M],c[M],t[M];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x[i],&y[i],&t[i],&c[i]);
		G.addE(x[i],y[i],t[i]),G.addE(y[i],x[i],t[i]);
	}
	G.spfa(1);
	printf("%d\n",dis[n]);
	F.init();
	for(int i = 1;i<= m;i++)
	{
		if(dis[x[i]]+t[i]==dis[y[i]])
			F.addF(x[i],y[i],c[i]);
		if(dis[y[i]]+t[i]==dis[x[i]])
			F.addF(y[i],x[i],c[i]);
	}
	int ans = F.dinic(1,n);
	printf("%d\n",ans);
	return 0;
}
Problem1269

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct splay
{
	splay *ls,*rs,*fa;
	bool rev;
	int size;char c;
	splay(char c);
	void push_up();
	void push_down();
	void reverse();
}*null=new splay(0),*root=null;
splay :: splay(char C)
{
	ls = rs = fa = null;
	rev = false;
	size = C?1:0;
	c = C;
}
void splay :: push_up()
{
	size = ls->size+(c!=0)+rs->size;
}
void splay :: push_down()
{
	if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = false;
	}
}
void splay :: reverse()
{
	rev^=1;
	swap(ls,rs);
}
void go_left(splay *x)
{
	splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa=y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void go_right(splay *x)
{
	splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void Splay (splay *x,splay *tar)
{
	while(true)
	{
		splay *y = x->fa,*z = x->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(y==x->ls)go_right(x);
			else go_left(x);
			break;
		}else
		{
			if(x==y->ls)
			{
				if(y==z->ls)go_right(y);
				go_right(x);
			}else
			{
				if(y==z->rs)go_left(y);
				go_left(x);
			}
		}
	}
}
void find(splay *x,int y,splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;x=x->rs;
		}
	}
	Splay(x,z);
}
char s[1<<21];
void build(splay *&x,int l,int r)
{
	if(l>r)return ;
	int mid = (l+r)>>1;
	x = new splay(s[mid]);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa=x;
	if(x->rs!=null)x->rs->fa=x;
	x->push_up();
}
int pointer;
int main()
{
	char opt[20];
	int m,lth;
	scanf("%d",&m);
	root=new splay('\n');
	root->rs=new splay('\n');
	root->rs->fa= root;
	root->push_up();
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='M')
			scanf("%d",&pointer);
		else if(opt[0]=='I')
		{
			scanf("%d",&lth);
			do s[0]=getchar();while(s[0]=='\n'||s[0]=='\r');
			if(lth^1)gets(s+1);
			find(root,pointer+1,null);
			find(root,pointer+2,root);
			build(root->rs->ls,0,lth-1);
			root->rs->ls->fa=root->rs;
			root->rs->push_up();
			root->push_up();
		}else if(opt[0]=='D')
		{
			scanf("%d",&lth);
			find(root,pointer+1,null);
			find(root,pointer+lth+2,root);
			root->rs->ls=null;
			root->rs->push_up();
			root->push_up();
		}else if(opt[0]=='R')
		{
			scanf("%d",&lth);
			find(root,pointer+1,null);
			find(root,pointer+lth+2,root);
			root->rs->ls->reverse();
		}else if(opt[0]=='G')
		{
			find(root,pointer+2,null);
			printf("%c\n",root->c);
		}else if(opt[0]=='P')
			pointer--;
		else pointer++;
	}
	return 0;
}
Problem1293

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x7fffffff
using namespace std;
int n,k,cnt,ans=inf;
int head[65];
int next[1000005],v[1000005],a[1000005];
inline int read()
{
    char ch=getchar();
    int f=1,x=0;
    while(!(ch>='0'&&ch<='9')){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+(ch-'0');ch=getchar();}
    return x*f;
}
bool cal(int x)
{
	int mx=0;
	for(int i=1;i<=k;i++)
	{
		while(v[head[i]]>x)
		{
		    if(!next[head[i]])return 0;
			head[i]=next[head[i]];
			}
		if(v[head[i]]<=x)mx=max(mx,x-v[head[i]]);
	}
	ans=min(ans,mx);
	return 1;
}
int main()
{
	n=read();k=read();
	for(int i=1;i<=k;i++)
	{
		int x=read();
		for(int j=1;j<=x;j++)
		{
			int y=read();
			v[++cnt]=y;
			next[cnt]=head[i];
			head[i]=cnt;
			a[cnt]=y;
		}
	}
	sort(a+1,a+cnt+1);
	for(int i=cnt;i>0;i--)
	{
		if(a[i]!=a[i+1])
		if(!cal(a[i]))break;
	}
	printf("%d",ans);
	return 0;
}
Problem1296

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int map[55][55];
int stack[55],top;
int f[2501];
int g[55][55][55][2];
int w[55][55];
int main()
{
	int n,m,t;
	scanf("%d%d%d",&n,&m,&t);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%1d",&map[i][j]);
	for(int x = 1;x<= n;x++)
		for(int y = 1;y<= m;y++)
		{
			for(int i = min(m,t);i>=1;i--)
			{
				g[x][y][i][0] = max(g[x][y][i][0],g[x][y-1][i][0]+(map[x][y]==0));
				g[x][y][i][0] = max(g[x][y][i][0],g[x][y-1][i-1][1]+(map[x][y]==0));
				g[x][y][i][1] = max(g[x][y][i][1],g[x][y-1][i][1]+(map[x][y]==1));
				g[x][y][i][1] = max(g[x][y][i][1],g[x][y-1][i-1][0]+(map[x][y]==1));
			}
		}
	for(int x = 1;x<=n;x++)
		for(int i = 1;i<= min(m,t);i++)
		{
			int num = 0;
			for(int y = 1;y<= m;y++)
			{
				num = max(num,g[x][y][i][0]);
				num = max(num,g[x][y][i][1]);
			}
			w[x][i] = num;
		}
	for(int x = 1;x<=n;x++)
		for(int j = t;j>=0;j--)
			for(int i = 1;i<= min(m,t);i++)
				if(j>=i)f[j] = max(f[j],f[j-i]+w[x][i]);
	printf("%d\n",f[t]);
	return 0;
}
Problem1305

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 405;
const int M = 4e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int cntb[N],cntg[N];
char map[N][N];
void debug()
{
	for(int i = 0;i<= 7;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].f);
		printf("\n");
	}
}
void build(int n,int mid,int k)
{
    tot=1;memset(head,0,sizeof(head));
    for(int i=1;i<=n;i++)add(0,i*2-1,mid);
    for(int i=1;i<=n;i++)add(i*2-1,i*2,k);
    for(int i=1;i<=n;i++)add(n*2+i*2,n*2+i*2-1,k);
    for(int i=1;i<=n;i++)add(n*2+i*2-1,4*n+1,mid);
    for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
		{
			if(map[i][j]=='N')
				add(i*2,n*2+j*2,1);
			else
				add(i*2-1,2*n+j*2-1,1);
		}
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%s",map[i]+1);
	int st = 0,end = 4*n+1;
	int l = 0,r = n,ans=0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		build(n,mid,k);
		if(dinic(st,end)>=n*mid)l=mid+1,ans=mid;
		else r = mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1324

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x]=tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y]=tot;
}
int d[N],n,m;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_MF(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow&&d[e[i].to]==d[s]-1)
		{
			int tof = get_MF(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,NF;
	while(bfs(s,t))
		while((NF=get_MF(s,t,INF)))
			ans+=NF;
	return ans;
}
int getid(int x,int y)
{
	return (x-1)*m+y;
}
int main()
{
	int x,sum=0;
	scanf("%d%d",&n,&m);
	int st = 0,end = n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			sum+=x;
			if((i+j)&1)add(getid(i,j),end,x);
			else
			{
				add(st,getid(i,j),x);
				if(i!=1)add(getid(i,j),getid(i-1,j),INF);
				if(j!=1)add(getid(i,j),getid(i,j-1),INF);
				if(i!=n)add(getid(i,j),getid(i+1,j),INF);
				if(j!=m)add(getid(i,j),getid(i,j+1),INF);
			}
		}
	printf("%d\n",sum-dinic(st,end));
	return 0;
}
Problem1342

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int a[N],ans[N],top;
int Q[N],P[N],hq,tq,hp,tp;
int main()
{
	int n,m,c;
	scanf("%d%d%d",&n,&m,&c);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	hq = 0,tq = -1,hp = 0,tp = -1;
	//Q[0] = P[0] = 1;
	for(int i = 1;i<= n;i++)
	{
		while(hq<=tq&&a[Q[tq]]<=a[i])tq--;
		Q[++tq] = i;
		while(hp<=tp&&a[P[tp]]>=a[i])tp--;
		P[++tp] = i;
		while(hq<=tq&&Q[hq]<i-m+1)hq++;
		while(hp<=tp&&P[hp]<i-m+1)hp++;
		if(i>=m&&a[Q[hq]]-a[P[hp]]<=c)
			ans[++top] = i-m+1;
	}
	for(int i = 1;i<= top;i++)
		printf("%d\n",ans[i]);
	if(top==0)printf("NONE\n");
	return 0;
}
Problem1369

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int f[N][16];
void dp(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dp(e[i].to,x);
	for(int t = 1;t<= 15;t++)
	{
		f[x][t] = t;
		for(int i = head[x];i;i = e[i].next)
		{
			if(fa==e[i].to)continue;
			int tmp = 0x3f3f3f3f;
			for(int k = 1;k<= 15;k++)
			{
				if(t==k)continue;
				tmp = min(tmp,f[e[i].to][k]);
			}
			f[x][t] = f[x][t]+tmp;
		}
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dp(1,0);
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= 15;i++)
		ans = min(ans,f[1][i]);
	printf("%d\n",ans);
	return 0;
}
Problem1396

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
struct Seg_Tree
{
	int minn[N<<2],lazy[N<<2];
	void build(int p,int l,int r)
	{
		lazy[p]=minn[p]=INF;
		if(l==r)return ;
		int mid = (l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
	}
	void push_down(int p,int l,int r)
	{
		if(lazy[p]==INF||l==r)return ;
		minn[p<<1] = min(minn[p<<1],lazy[p]);
		minn[p<<1|1] = min(minn[p<<1|1],lazy[p]);
		lazy[p<<1] = min(lazy[p<<1],lazy[p]);
		lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
		lazy[p] = INF;
	}
	void update(int p,int l,int r,int a,int b,int x)
	{
		push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			minn[p] = min(minn[p],x);
			lazy[p] = min(lazy[p],x);
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,x);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,x);
		minn[p]=min(minn[p<<1],minn[p<<1|1]);
	}
	int getans(int p,int l,int r,int x)
	{
		push_down(p,l,r);
		if(l==r)return minn[p];
		int mid=(l+r)>>1;
		if(x<=mid)return getans(p<<1,l,mid,x);
		else return getans(p<<1|1,mid+1,r,x);
	}
}T1,T2;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1];
	bool end[N<<1];
	int cnt,last;
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p = last,np=++cnt,q,nq;
		last = np,len[np]=len[p]+1;
		end[np] = true;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	void getans(int n)
	{
		for(int i = 1;i<= cnt;i++)
			end[fa[i]] = false;
		for(int i = 1;i<= cnt;i++)
			if(end[i])
			{
				int l = len[i]-len[fa[i]],r = len[i];
				T1.update(1,1,n,l,r,r-l+1);
				if(l>1)T2.update(1,1,n,1,l-1,r);
			}
		for (int i=1;i<=n;i++)
			printf("%d\n",min(T1.getans(1,1,n,i),T2.getans(1,1,n,i)-i+1));
	}
}sam;
char s[N];
int main()
{
	sam.init();
	scanf("%s",s+1);
	int lth = strlen(s+1);
	for(int i = 1;i<=lth;i++)
		sam.insert(s[i]-'a');
	T1.build(1,1,lth);
	T2.build(1,1,lth);
	sam.getans(lth);
	return 0;
}
Problem1396

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
struct Seg_Tree
{
	int mn[N<<2],lazy[N<<2];
	void build(int p,int l,int r)
	{
		lazy[p] = mn[p] = INF;
		if(l==r)return ;
		int mid = (l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
	}
	void push_down(int p,int l,int r)
	{
		if(lazy[p]==INF||l==r)return ;
		mn[p<<1] = min(mn[p<<1],lazy[p]);
		mn[p<<1|1] = min(mn[p<<1|1],lazy[p]);
		lazy[p<<1] = min(lazy[p<<1],lazy[p]);
		lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
		lazy[p] = INF;
	}	
	void Update(int p,int l,int r,int a,int b,int c)
	{
		push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			lazy[p] = min(lazy[p],c);
			mn[p] = min(mn[p],c);
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)Update(p<<1,l,mid,a,b,c);
		if(b >mid)Update(p<<1|1,mid+1,r,a,b,c);
		mn[p] =min(mn[p<<1],mn[p<<1|1]);
	}
	int Getans(int p,int l,int r,int x)
	{
		push_down(p,l,r);
		if(l==r)return mn[p];
		int mid = (l+r)>>1;
		if(x<=mid)return Getans(p<<1,l,mid,x);
		else return Getans(p<<1|1,mid+1,r,x);
	}
}t1,t2;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1];
	bool end[N<<1];
	int cnt,last;
	void init()
	{
		cnt = last = 1;
	}
	void insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np] = len[p]+1;
		end[np] =true;
		for(;p&&!trs[p][x];p = fa[p])trs[p][x] = np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] =q;
			else
			{
				fa[nq =++cnt] =fa[q];
				len[nq] = len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p =fa[p])trs[p][x] = nq;
			}
		}
	}
	void getans(int n)
	{
		for(int i = 1;i<= cnt;i++)
			end[fa[i]] =false;
		for(int i = 1;i<= cnt;i++)
			if(end[i])
			{
				int l =len[i]-len[fa[i]],r = len[i];
				t1.Update(1,1,n,l,r,r-l+1);
				if(l>1)t2.Update(1,1,n,1,l-1,r);
			}
		for(int i = 1;i<= n;i++)
			printf("%d\n",min(t1.Getans(1,1,n,i),t2.Getans(1,1,n,i)-i+1));
	}
}sam;
char s[N];
int main()
{
	sam.init();
	scanf("%s",s+1);
	int n = strlen(s+1);
	t1.build(1,1,n);
	t2.build(1,1,n);
	for(int i = 1;i<= n;i++)
		sam.insert(s[i]-'a');
	sam.getans(n);	
	return 0;
}
Problem1406

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int stack[50005],ans[10000005];
int main()
{
	int top = 0,cnt = 0;
	ll n;
	scanf("%lld",&n);
	for(ll i = 1;i*i<=n;i++)
		if(n%i==0)
			stack[++top]=n/i;
	for(int i = 1;i<= top;i++)
	{
		for(ll j = stack[i];j<=n;j+=stack[i])
		{
			if((j-2)%(n/stack[i])==0)
				ans[++cnt] = (j-1)%n;
			if((j+2)%(n/stack[i])==0)
				ans[++cnt] = (j+1)%n;
		}
	}
	sort(ans+1,ans+cnt+1);
	top = 0;
	for(int i = 1;i<= cnt;i++)
		if(ans[i]!=ans[top])
			ans[++top]=ans[i];
	for(int i = 1;i<= top;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem1408

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int mod = 10000;
int p[N],e[N];
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{
	int k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
		scanf("%d%d",&p[i],&e[i]);
	int ans1=0,ans2=0,ans3,tmp1,tmp2;
	for(int i = 1;i<= k;i++)
	{
		if(p[i]==2)continue;
		tmp1 = (ans1+ans2*(p[i]-1)%mod)%mod;
		tmp2 = (ans2+(ans1+1)*(p[i]-1)%mod)%mod;
		ans1 = tmp1,ans2 = tmp2;
	}
	int m = 1;
	for(int i = 1;i<= k;i++)
		m = m*quick_pow(p[i]%mod,e[i])%mod;
	ans3 = (((m-1)-ans1-ans2)%mod+mod)%mod;
	printf("%d\n%d\n%d\n",ans1,ans2,ans3);
	return 0;
}
Problem1415

#include <stdio.h>
#include <queue>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const double eps = 1e-8;
struct Edge{int next,to;}e[N<<1];
int head[N],tot,cnt[N],v[N],dis[N];
int step[N][N];
double f[N][N];
queue <int>Q;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void spfa(int sta)
{
	memset(v,0,sizeof(v));
	memset(dis,0x3f,sizeof(dis));
	Q.push(sta);
	v[sta] = true;
	dis[sta] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i = e[i].next)
		{
			if(dis[x]+1<dis[e[i].to]||(dis[x]+1==dis[e[i].to]&&x<step[sta][e[i].to]))
			{
				step[sta][e[i].to] = x;
				dis[e[i].to] = dis[x]+1;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
		}
	}
	return ;
}
double dfs(int x,int y)
{
	if(x==y)return f[x][y] = 0;
	if(f[x][y]>eps)return f[x][y];
	if(step[y][x]==y||step[y][step[y][x]]==y)return f[x][y] = 1.0;
	int tmp = step[y][step[y][x]];
	double ans = dfs(tmp,y);
	for(int i=head[y];i;i = e[i].next)
		ans+=dfs(tmp,e[i].to);
	ans = ans/(double)(cnt[y]+1)+1;
	f[x][y] = ans;
	return ans;
}
int main()
{
	int n,E,c,m;
	scanf("%d%d%d%d",&n,&E,&c,&m);
	int x,y;
	for(int i = 1;i<= E;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
		cnt[x]++;cnt[y]++;
	}
	for(int i = 1;i<= n;i++)
		spfa(i);
	//printf("warning\n");
	memset(f,0xc2,sizeof(f));
	printf("%.3f",dfs(c,m));
	return 0;
}
Problem1419

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const double eps = 5e-7;
double f[2][N];
int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	for(int i = 1;i<=a;i++)
	{
		int I = i&1,I_ = (i-1)&1;
		f[I][0] = i;
		for(int j = 1;j<=b;j++)
		f[I][j] = 
			max(0.0,(double)i/(double)(i+j)*(f[I_][j]+1)+(double)j/(double)(i+j)*(f[I][j-1]-1));
	}
	printf("%.6f",f[a&1][b]-eps);
	return 0;
}
Problem1433

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 2e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
queue<int>Q;
int d[N],map[N][N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans=0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF)))
			ans+=nowflow;
	return ans;
}
int is_sch[N];
void debug()
{
	for(int i = 0;i<=7;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].flow);
		printf("\n");
	}
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 1;
}
void work()
{
	init();
	int n,x,num=0;
	scanf("%d",&n);
	int st = 0,end = 2*n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&is_sch[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(is_sch[i])
			{if(!x)add(st,i,1),num++;}
		else if(!is_sch[i])add(st,i,1),num++;
	}
	for(int i = 1;i<= n;i++)if(is_sch[i])add(i+n,end,1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&map[i][j]);
			if((map[i][j]&&is_sch[j])||(i==j&&is_sch[i]))
				add(i,j+n,1);
		}
	int ans = dinic(st,end);
	if(ans>=num)printf("^_^\n");
	else printf("T_T\n");
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem1444

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'A')
const int N = 105;
const double eps = 1e-6;
const double EPS = 1e-4;
int p[15],q[15],cnt;
int ch[N][15],n,m,l,pos[N];
char s[15];
int fail[N],danger[N];
void init()
{
	cnt = 1;
	for(int i = 0;i<m;i++)
		ch[0][i] = 1;
}
void insert(int id)
{
	int now = 1,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
		now = ch[now][s(i)];
		i++;
	}
	danger[now] = true;
	pos[id] = now;
}
int Q[N],h,t;
void build()
{
	h = 0,t = -1;
	Q[++t]=1,fail[0]=1;
	while(h<=t)
	{
		int x=Q[h++];
		for(int i = 0;i<m;i++)
		{
			int j = ch[x][i];
			if(j)
			{
				Q[++t] = j;
				int r = fail[x];
				while(!ch[r][i])r = fail[r];
				fail[j] = ch[r][i];
				danger[j]|=danger[fail[j]];
			}
			else ch[x][i] = ch[fail[x]][i];
		}
	}
}
struct Matrix 
{
	int w,h;
	double d[105][105];
	Matrix(){}
	Matrix(int _w,int _h):w(_w),h(_h){memset(d,0,sizeof(d));}
	void operator*=(const Matrix &S)
	{
		Matrix res(w,S.h);
		for(int i = 1;i<=res.w;i++)
			for(int j = 1;j<=res.h;j++)
			{
				res.d[i][j] = 0;
				for(int k = 1;k<=h;k++)
					res.d[i][j]+=d[i][k]*S.d[k][j];
			}
		*this = res;		
	}
};
void debug(const Matrix &f)
{
	for(int i = 1;i<= 6;i++)
	{
		for(int j = 1;j<= 6;j++)
			printf("%5.2f",f.d[i][j]);
		printf("\n");
	}
}
int main()
{
	scanf("%d%d%d",&n,&l,&m);
	for(int i = 0;i< m;i++)
		scanf("%d%d",&p[i],&q[i]);
	init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		insert(i);
	}
	build();
	Matrix f(cnt,cnt);
	for(int i= 1;i<= cnt;i++)
	{
		if(danger[i])
			f.d[i][i]=1;
		else
			for(int j =0;j<m;j++)
				f.d[i][ch[i][j]]+=(double)p[j]/(double)q[j];
	}
	for(int i = 1;i<= 50;i++)
		f*=f;
	for(int i = 1;i<= n;i++)
		printf("%.2f\n",f.d[1][pos[i]]);
	return 0;
}
Problem1452

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 301;
struct T
{
	int c[N][N];
	T()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y,int v)
	{
		for(int i= x;i<N;i+=i&(-i))
			for(int j = y;j<N;j+=j&(-j))
				c[i][j]+=v;
	}
	int getans(int x,int y)
	{
		int ans= 0;
		for(int i= x;i>0;i-=i&(-i))
			for(int j = y;j>0;j-=j&(-j))
				ans+=c[i][j];
		return ans;
	}
}tree[105];
int map[N][N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&map[i][j]);
			tree[map[i][j]].update(i,j,1);
		}
	int q,opt,a,b,c,d,v;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&a,&b,&v);
			tree[map[a][b]].update(a,b,-1);
			tree[v].update(a,b,1);
			map[a][b] = v;
		}else
		{
			int ans = 0;
			scanf("%d%d%d%d%d",&a,&b,&c,&d,&v);
			ans = ans+tree[v].getans(b,d);
			ans = ans-tree[v].getans(b,c-1);
			ans = ans-tree[v].getans(a-1,d);
			ans = ans+tree[v].getans(a-1,c-1);
			printf("%d\n",ans);
		}
	}
	return 0;
}
Problem1457

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int P = 105;
const int C = 10005;
const int N = 1005;
int sg[P][P];
int vis[C];
void Init()
{
	int cnt = 0;
	for(int i = 1;i<= 100;i++)
		for(int j = 1;j<=100;j++)if(i!=j)
		{
			++cnt;
			for(int k = 1;k<i;k++)if(j!=(i-k))vis[sg[i-k][j]]=cnt;
			for(int k = 1;k<j;k++)if(i!=(j-k))vis[sg[i][j-k]]=cnt;
			for(int k = min(i,j)-1;k>=1;k--)vis[sg[i-k][j-k]]=cnt;
			for(int k = 0;k<C;k++)
				if(vis[k]!=cnt)
					{sg[i][j]=k;break;}
		}
}
int main()
{
	Init();
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		bool flag = false;
		int n,x,y,ans = 0;
		scanf("%d",&n);
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d",&x,&y);
			if(!x || !y|| x==y)flag = true;
				ans^=sg[x][y];
		}
		if(flag)printf("^o^\n");
		else 
		{
			if(ans>0)printf("^o^\n");
			else printf("T_T\n");
		}
	}
	return 0;
}
Problem1458

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e4+5;
const int M = 8e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
}
queue<int>Q;
int d[N],st,end;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int r[105],c[105],map[105][105];
int R[105],C[105];
int main()
{
	int m,n,k;
	scanf("%d%d%d",&m,&n,&k);
	int st = 0,end = n*m+1;
	for(int i = 1;i<= m;i++)r[i]=n,scanf("%d",&R[i]);
	for(int i = 1;i<= n;i++)c[i]=m,scanf("%d",&C[i]);
	int x,y;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y]++;
		r[x]--;c[y]--;
	}
	int ans = 0;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			if(!map[i][j])
				ans++,add(i,j+m,1);
	for(int i = 1;i<=m;i++)if(r[i]<R[i]){printf("JIONG!\n");return 0;}
	for(int i = 1;i<=n;i++)if(c[i]<C[i]){printf("JIONG!\n");return 0;}
	for(int i = 1;i<=m;i++)add(st,i,r[i]-R[i]);
	for(int i = 1;i<=n;i++)add(i+m,end,c[i]-C[i]);
	ans-=dinic(st,end);
	//for(int i = head[0];i;i=e[i].next)
	//	if(e[i].flow)
	//		{printf("JIONG!\n");return 0;}
	printf("%d\n",ans);
	return 0;
}
Problem1484

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 5005;
const int INF = 0x7f7f7f7f;
LL a[N],b[N];
LL Abs(LL a){return a>0?a:-a;}
void work()
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	int n,d;
	scanf("%d%d",&n,&d);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	if(Abs(a[n]-a[1])>(LL)(n-1)*d){printf("impossible\n");return ;}
	b[1]=a[1];
	for(int i = 2;i<= n;i++)
		b[i] = b[i-1]-d;
	LL s,x,delta,minx,tmp;
	while(a[n]!=b[n])
	{
		s = 0,minx = INF;
		delta = INF,tmp = -INF;
		for(int i=n;i>1;i--)
		{
			if(a[i]>b[i])s++,minx = min(minx,a[i]-b[i]);
			else s--;
			if(tmp<s&&b[i-1]+d>b[i])
				tmp = s,x = i,delta = minx;
		}
		delta = min(delta,b[x-1]+d-b[x]);
		for(int i = x;i<= n;i++)b[i]+=delta;
	}
	LL ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=Abs(b[i]-a[i]);
	printf("%lld\n",ans);
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)work();
	return 0;
}
Problem1491

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
double map[N][N],sol[N][N];
double imp[N];
int main()
{
	for(int i = 1;i<N;i++)
		for(int j = 1;j<N;j++)
			map[i][j] = 1e9;
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		map[x][y] = map[y][x] = c;
		sol[x][y] = sol[y][x] = 1;
	}
	for(int k = 1;k<= n;k++)
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= n;j++)
			{
				if(i==j||j==k||i==k)continue;
				if(map[i][k]+map[k][j]<map[i][j])
				{
					map[i][j] = map[i][k]+map[k][j];
					sol[i][j] = sol[i][k]*sol[k][j];
				}else if(map[i][k]+map[k][j]==map[i][j])
					sol[i][j]+=sol[i][k]*sol[k][j];
			}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int v = 1;v<= n;v++)
			{
				if(i==j||j==v||i==v)continue;
				if(map[i][v]+map[v][j]!=map[i][j]||sol[i][j]<=0)continue;
				imp[v] += sol[i][v]*sol[v][j]/sol[i][j];
			}
	for(int i = 1;i<= n;i++)
		printf("%.3f\n",imp[i]);
	return 0;
}
Problem1492

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef double db;
typedef pair<db,db>PA;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
db f[N];
struct P
{
	db a,b,rate,slope;
	int pos;
	bool operator<(const P &s)const
	{
		return slope<s.slope;
	}
}q[N],nq[N];
PA p[N],np[N];
int st[N],top,n;
double getslope(PA x,PA y)
{
	if(x.first==y.first)
		return y.second>=x.second?INF:-INF;
	return (y.second-x.second)/(y.first-x.first);
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)
	{
		f[mid] = max(f[mid],f[mid-1]);
		p[mid].first = f[mid]/(q[mid].a+q[mid].b/q[mid].rate);
		p[mid].second = f[mid]/(q[mid].a*q[mid].rate+q[mid].b);
		return ;
	}
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if(q[i].pos<=mid)
			nq[l1++] = q[i];
		else nq[l2++] = q[i];
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	CDQ(l,mid);
	top = 0;
	for(int i = l;i<= mid;i++)
	{
		while(top>1&&getslope(p[st[top-1]],p[st[top]])<getslope(p[st[top]],p[i]))
			st[top--] = 0;
		st[++top] = i;
	}
	for(int i = mid+1;i<= r;i++)
	{
		while(top>1&&getslope(p[st[top-1]],p[st[top]])<q[i].slope)
			st[top--] =0;
		f[q[i].pos] = max(f[q[i].pos],q[i].a*p[st[top]].first+q[i].b*p[st[top]].second);
	}
	CDQ(mid+1,r);
	l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if((p[l1]<p[l2]||l2>r)&&l1<=mid)
			np[i] = p[l1++];
		else np[i] = p[l2++];
	memcpy(p+l,np+l,sizeof(p[0])*(r-l+1));
}
int main()
{
	scanf("%d%lf",&n,&f[0]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf%lf",&q[i].a,&q[i].b,&q[i].rate);
		q[i].slope = -q[i].a/q[i].b;
		q[i].pos = i;
	}
	sort(q+1,q+n+1);
	CDQ(1,n);
	printf("%.3lf",f[n]);
	return 0;
}
Problem1493

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
int n,m;
struct col_seg
{
	int cnt,lc,rc;
	col_seg(int x)
	{
		cnt = 1;
		if(!x)
			cnt = 0;
		lc = rc = x;
	}
	col_seg();
	col_seg uni(col_seg x,col_seg y)
	{
		col_seg re(0);
		re.lc = x.lc?x.lc:y.lc;
		re.rc = y.rc?y.rc:x.rc;
		re.cnt = x.cnt+y.cnt-(x.rc==y.lc);
		return re;
	}
};
col_seg operator + (const col_seg x,const col_seg y)
{
	col_seg re(0);
	re.lc = x.lc?x.lc:y.lc;
	re.rc = y.rc?y.rc:x.rc;
	re.cnt = x.cnt+y.cnt-(x.rc==y.lc);
	return re;
}
struct Splay
{
	int num,size;
	Splay *ls,*rs,*fa;
	col_seg *col;
	int lazy_r,lazy_c;
	Splay(int x);
	void push_up();
	void push_down();
}*null = new Splay(0),*root = null;
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	num = x;
	size = x?1:0;
	lazy_r = lazy_c = 0;
	col = new col_seg(x);
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	*col = (*ls->col)+col_seg(num)+(*rs->col);
}
void Splay :: push_down()
{
	if(lazy_r)
	{
		ls->lazy_r ^= 1;
		rs->lazy_r ^= 1;
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		swap(ls->col->lc,ls->col->rc);
		swap(rs->col->lc,rs->col->rc);
		lazy_r = 0;
	}
	if(lazy_c)
	{
		if(ls!=null)
		{	
			ls->num = ls->lazy_c = lazy_c;
			*ls->col = col_seg(lazy_c);
		}
		if(rs!=null)
		{
			rs->num = rs->lazy_c = lazy_c;
			*rs->col = col_seg(lazy_c);
		}
		lazy_c = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
void R()
{
	int x;
	scanf("%d",&x);
	Find(root,n-x+1,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
	Find(root,1,null);
	Find(root,2,root);
	root->rs->ls = tmp;
	tmp->fa = root->rs;
	root->rs->push_up();
	root->push_up();
}
void F()
{
	Find(root,2,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	tmp->lazy_r ^= 1;
	swap(tmp->ls,tmp->rs);
	swap(tmp->col->lc,tmp->col->rc);
}
void S()
{
	int x,y;
	scanf("%d%d",&x,&y);
	if(x==y)return ;
	else if(x>y)swap(x,y);
	Find(root,x+1,null);
	Find(root,y+1,root);
	swap(root->rs->num,root->num);
}
void P()
{
	int x,y,z;
	scanf("%d%d%d",&x,&y,&z);
	if(x<=y)
	{
		Find(root,x,null);
		Find(root,y+2,root);
		Splay *tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
	}else
	{
		Find(root,x,null);
		Find(root,n+2,root);
		Splay *tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
		Find(root,1,null);
		Find(root,y+2,root);
		tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
	}
}
void C()
{
	Find(root,1,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	int z = tmp->col->cnt-(tmp->col->lc==tmp->col->rc);
	if(!z)z++;
	printf("%d\n",z);
}
void CS()
{
	int x,y;
	scanf("%d%d",&x,&y);
	if(x<=y)
	{
		Find(root,x,null);
		Find(root,y+2,root);
		Splay *tmp = root->rs->ls;
		printf("%d\n",tmp->col->cnt);
	}
	else
	{
		Find(root,x,null);
		Find(root,n+2,root);
		Splay *tmp = root->rs->ls;
		col_seg stmp = *tmp->col;
		Find(root,1,null);
		Find(root,y+2,root);
		tmp = root->rs->ls;
		stmp = stmp+(*tmp->col);
		printf("%d\n",stmp.cnt);
	}
}
int main()
{
	int x,c;
	char opt[10];
	scanf("%d%d",&n,&c);
	Insert(root,Inv,null);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	Insert(root,Inv,null);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='R')R();
		else if(opt[0]=='F')F();
		else if(opt[0]=='S')S();
		else if(opt[0]=='P')P();
		else if(opt[0]=='C'&&!opt[1])C();
		else CS();
	}
	return 0;
}
Problem1497

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
const int M = 4e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF)))
			ans+=nowflow;
	return ans;
}
int p[N];
int main()
{
	int n,m,sum=0;
	scanf("%d%d",&n,&m);
	int s = 0,end = n+m+1;
	for(int i = 1;i<= n;i++)scanf("%d",&p[i]);
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		sum+=z;
		add(s,i+n,z);
		add(i+n,x,INF),add(i+n,y,INF);
	}
	for(int i = 1;i<= n;i++)
		add(i,end,p[i]);
	printf("%d\n",sum-dinic(s,end));
	return 0;
}
Problem1499

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int INF = 0x3f3f3f3f;
using namespace std;
const int N = 205;
struct pos{
	int x,y;
	pos(int a,int b){x = a;y = b;}
	pos(){}
};
int f[N][N],g[N][N],L,R;
char map[N][N];
pos line[N];
int n,m;
int dis(pos t,pos z)
{
	return abs(t.x-z.x)+abs(t.y-z.y);
}
int getans(pos t,int len)
{
	while(L<=R&&dis(t,line[L])>len)L++;
	if(L>R)return -INF;
	return f[line[L].x][line[L].y]+dis(t,line[L]);
}
void Insert(pos t)
{
	while(L<=R&&dis(t,line[R])<=f[t.x][t.y]-f[line[R].x][line[R].y])R--;
	line[++R] = t;
}
void go_up(int lth)
{
	for(int j = 1;j<= m;j++) 
	{
		L = 1,R = 0;
		for(int i = n;i;i--)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_down(int lth)
{
	for(int j = 1;j<= m;j++)
	{
		L = 1,R = 0;
		for(int i = 1;i<= n;i++)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_left(int lth)
{
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = 0;
		for(int j = m;j;j--)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_right(int lth)
{
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = 0;
		for(int j = 1;j<=m;j++)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
int main()
{
	int sx,sy,t,x,y,z;
	scanf("%d%d%d%d%d",&n,&m,&sx,&sy,&t);
	for(int i = 1;i<= n;i++)
		scanf("%s",map[i]+1);
	memset(f,128,sizeof(f));
	memset(g,128,sizeof(g));
	f[sx][sy] = 0;
	for(int i = 1;i<= t;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(z==1)go_up(y-x+1);
		else if(z==2)go_down(y-x+1);
		else if(z==3)go_left(y-x+1);
		else go_right(y-x+1);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			ans = max(ans,f[i][j]);
	printf("%d\n",ans);
	return 0;
}
Problem1500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Minm = 0xefefefef;
const int Inv = 20000307;
struct Max_s
{
	int l_max,r_max,all_max,sum;
	void init(int x,int y)
	{
		if(x>0)l_max = r_max = all_max = sum = x*y;
		else
		{
			l_max = r_max = all_max = x;
			sum = x*y;
		}
	}
	void uni(const Max_s &x,const Max_s &y)
	{
		all_max = max(x.all_max,y.all_max);
		all_max = max(all_max,x.r_max+y.l_max);
		l_max = max(x.l_max,x.sum+y.l_max);
		r_max = max(y.r_max,y.sum+x.r_max);
		sum = x.sum+y.sum;
	}
};
struct Splay
{
	Splay *ls,*rs,*fa;
	int size,num,max_num;
	int lazy_c,lazy_r;
	Max_s ms;
	Splay(int x);
	Splay();
	void push_up();
	void push_down();
}*null = new Splay(),*root = null,*Z,*tmp;
int Y;
Splay :: Splay ()
{
	num = max_num = Minm;
	size = 0;
	fa = ls = rs = this;
	ms.init(Minm,0);
}
Splay :: Splay (int x)
{
	num = max_num = x;
	size = 1;
	ls = rs = fa = null;
	ms.init(x,1);
	lazy_c = Inv,lazy_r = 0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	max_num = max(max(ls->max_num,rs->max_num),num);
	ms.init(num,1);
	ms.uni(ls->ms,ms);
	ms.uni(ms,rs->ms);
}
void Splay :: push_down()
{
	if(this==null)return ;
	else
	{
		if(lazy_c!=Inv)
		{
			ls->lazy_c = rs->lazy_c = lazy_c;
			ls->num = ls->max_num = lazy_c;
			rs->num = rs->max_num = lazy_c;
			ls->ms.init(lazy_c,ls->size);
			rs->ms.init(lazy_c,rs->size);
			lazy_c = Inv;
		}
		if(lazy_r!=0)
		{
			ls->lazy_r^=1;
			rs->lazy_r^=1;
			swap(ls->ls,ls->rs);
			swap(rs->ls,rs->rs);
			swap(ls->ms.l_max,ls->ms.r_max);
			swap(rs->ms.l_max,rs->ms.r_max);
			lazy_r = 0;
		}
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x)
{
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==Z)break;
		if(z==Z)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(x);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(x);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x)
{
	while(true)
	{
		x->push_down();
		if(Y<=x->ls->size)x = x->ls;
		else
		{
			Y-=x->ls->size;
			if(Y==1)break;
			Y--;
			x = x->rs;
		}
	}
	splay(x);
}
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		Z = null;
		splay(x);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
void Free(Splay *x)
{
	if(x==null)return ;
	Free(x->ls);
	Free(x->rs);
	free(x);
}
void INSERT()
{
	int tot,pos;
	scanf("%d%d",&pos,&tot);
	Y = pos+1;Z = null;Find(root);
	Y = pos+2;Z = root;Find(root);
	tmp = root;root = null;
	int x;
	for(int i = 1;i<= tot;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	tmp->rs->ls = root;
	root->fa = tmp->rs;
	root = tmp;
	root->rs->push_up();
	root->push_up();
}
void DELETE()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	tmp = root->rs->ls;
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
	Free(tmp);
}
void update()
{
	int pos,tot,c;
	scanf("%d%d%d",&pos,&tot,&c);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	root->rs->ls->lazy_c = c;
	tmp = root->rs->ls;
	tmp->num = tmp->max_num = c;
	tmp->ms.init(c,tmp->size);
	root->rs->push_up();
	root->push_up();
}
void reverse()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	tmp = root->rs->ls;
	tmp->lazy_r ^=1;
	swap(tmp->ls,tmp->rs);
	swap(tmp->ms.l_max,tmp->ms.r_max);
}
void get_sum()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	printf("%d\n",root->rs->ls->ms.sum);
}
void get_max()
{
	Y = 1;Z = null;Find(root);
	Y = root->size;Z = root;Find(root);
	printf("%d\n",root->rs->ls->ms.all_max);
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	Insert(root,0,null);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	char opt[20];
	Insert(root,0,null);
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='G')get_sum();
		else if(opt[0]=='I')INSERT();
		else if(opt[0]=='D')DELETE();
		else if(opt[0]=='R')reverse();
		else
		{
			if(opt[2]=='K')update();
			else get_max();
		}
	}
	return 0;
}
/*
那时候，日子也正长
过了今天，还有明天，过了今年，还有明年。
过了春还有夏，过了秋还有冬。
过了冬又能望见来年春到,依旧桃花满梢油菜黄。
*/
Problem1500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define maxn 1001000
#define inf 2147483646
using namespace std;
int c[maxn][2],fa[maxn];
int a[maxn],key[maxn],sum[maxn],la[maxn],ra[maxn],ma[maxn],cov[maxn],size[maxn];
int q[maxn];
bool rev[maxn];
int n,m,tot,num,rot,st,ed,tail;

void update(int x)
{
        if (!x) return;
        la[x]=max(la[c[x][0]],sum[c[x][0]]+key[x]+max(0,la[c[x][1]]));
        ra[x]=max(ra[c[x][1]],sum[c[x][1]]+key[x]+max(0,ra[c[x][0]]));
        ma[x]=max(max(ma[c[x][0]],ma[c[x][1]]),key[x]+max(0,ra[c[x][0]])+max(0,la[c[x][1]]));
        sum[x]=sum[c[x][0]]+sum[c[x][1]]+key[x];
        size[x]=size[c[x][0]]+size[c[x][1]]+1;
}

void reverse(int x)
{
        if (!x) return;
        swap(c[x][0],c[x][1]);
        swap(la[x],ra[x]);
        rev[x]^=1;
}

void recover(int x,int z)
{
        if (!x) return ;
        key[x]=cov[x]=z;
        sum[x]=size[x]*z;
        la[x]=ra[x]=ma[x]=max(z,sum[x]);
}

void down(int x)
{
        if (!x) return;
        if (rev[x])
        {
                reverse(c[x][0]);
                reverse(c[x][1]);
                rev[x]=0;
        }
        if (cov[x]!=-inf)
        {
                recover(c[x][0],cov[x]);
                recover(c[x][1],cov[x]);
                cov[x]=-inf;
        }
}

void relax(int x,int rot)
{
        if (x!=rot) relax(fa[x],rot);
        down(x);
}

void rotate(int x,int &rot)
{
        int y=fa[x],z=fa[y];
        int p=(c[y][1]==x),q=p^1;
        if (y==rot) rot=x; 
        else if (c[z][0]==y) c[z][0]=x; else c[z][1]=x;
        fa[x]=z; fa[y]=x; fa[c[x][q]]=y;
        c[y][p]=c[x][q]; c[x][q]=y;
        update(y);
}

void splay(int x,int &rot)
{
        relax(x,rot);
        while (x!=rot)
        {
                int y=fa[x], z=fa[y];
                if (y!=rot)
                        if ((c[y][0]==x)xor(c[z][0]==y)) rotate(x,rot); 
                    else rotate(y,rot);
                rotate(x,rot);
        }
        update(x);
}

int pick()
{
        if (tail) return q[tail--];
        else return ++num;
}

int setup(int x)
{
        int t=pick();
        key[t]=a[x];
        cov[t]=-inf;
        rev[t]=0;
        la[t]=ra[t]=ma[t]=-inf;
        return t;
}

int build(int l,int r)
{
        int mid=(l+r)>>1,left=0,right=0;
        if (l<mid)      left=build(l,mid-1);
        int t=setup(mid);
        if (r>mid)      right=build(mid+1,r);
        if (left)       c[t][0]=left,fa[left]=t;
        if (right)c[t][1]=right,fa[right]=t;
        update(t);
        return t;
}

int find(int t,int k)
{
        down(t);
        if (k==size[c[t][0]]+1) return t;
        if (k<size[c[t][0]]+1) return find(c[t][0],k);
        if (k>size[c[t][0]]+1) return find(c[t][1],k-size[c[t][0]]-1);
}

void del(int &x)
{
        if (!x) return;
        q[++tail]=x;
        fa[x]=0;
        del(c[x][0]);
        del(c[x][1]);
        la[x]=ra[x]=ma[x]=-inf;
        x=0;
}

int main()
{
        scanf("%d %d",&n,&m);
        for (int i=2;i<=n+1;i++)
        {
                scanf("%d",&a[i]);      
        }
        a[st=1]=0; a[ed=n+2]=0;
        ra[0]=la[0]=ma[0]=-inf;
        rot=build(1,n+2);
        char sign[20];
        int x,y,l,r,z,ans;
        for (int i=1;i<=m;i++)
        {
                scanf("%s",&sign);
                if (sign[0]=='I')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x+1); r=find(rot,x+2);
                        splay(r,rot); splay(l,c[rot][0]);
                        for (int j=1;j<=y;j++) 
                                scanf("%d",&a[j]);
                        int tmp=build(1,y);
                        fa[tmp]=l; c[l][1]=tmp;                 
                        update(l); update(r);
                }
                if (sign[0]=='D')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x);  r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        del(c[l][1]);
                        update(l); update(r);
                }                       
                if (sign[0]=='M'&&sign[2]=='K')
                {
                        scanf("%d %d %d",&x,&y,&z);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        recover(c[l][1],z);
                }
                if (sign[0]=='R')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        reverse(c[l][1]);
                }
                if (sign[0]=='G')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        ans=sum[c[l][1]];
                        printf("%d\n",ans);
                }
                if (sign[0]=='M'&&sign[2]=='X')
                {
                        splay(ed,rot); splay(st,c[rot][0]);
                        ans=ma[c[st][1]];
                        printf("%d\n",ans);
                }
        }
        return 0;
}
Problem1503

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Treap
{
	Treap *ls,*rs;
	int val,size,cnt,key;
	Treap(){}
	Treap(int x)
	{
		ls = rs = NULL;
		val = x;
		size = cnt = 1;
		key = rand();
	}
	void push_up()
	{
		size = cnt;
		if(ls)size+=ls->size;
		if(rs)size+=rs->size;
	}
}*root = NULL;
int DEC = 0,PER = 0,go_away;
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs= y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x= y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&now,int x)
{
	if(!now) {now = new Treap(x);return ;}
	if(now->val==x)now->cnt++;
	else if(x<now->val)
	{
		Insert(now->ls,x);
		if(now->ls->key > now->key)
			go_right(now);
	}
	else 
	{
		Insert(now->rs,x);
		if(now->rs->key > now->key)
			go_left(now);
	}
	now->push_up();
}
int Delete(Treap *&now,int x)
{
	int ans = 0;
	if(!now)return 0;
	if(now->val+DEC>=x)
	{
		ans = Delete(now->ls,x);
		now->size-=ans;
	}
	else
	{
		if(now->ls)ans+=now->ls->size;
		ans+= now->cnt;
		now = now->rs;
		ans=ans+Delete(now,x);
	}		
	if(now)now->push_up();
	return ans;
}
int get_rank(Treap *x,int k)
{
	if(x->ls!=NULL&&k<=x->ls->size)return get_rank(x->ls,k);
	if(x->ls!=NULL)k-=x->ls->size;
	if(k<=x->cnt)return x->val;
	k-=x->cnt;
	return get_rank(x->rs,k);
}
int main()
{
	int n,Min,k;
	scanf("%d%d",&n,&Min);
	char ju[3];
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",ju,&k);
		if(ju[0]=='I')
		{
			if(k>=Min)
				Insert(root,k-DEC);
		}else if(ju[0]=='A')DEC+=k;
		else if(ju[0]=='S')
		{
			DEC-=k;
			int tmp = Delete(root,Min);
			go_away+=tmp;
		}
		else 
		{
			if(root==NULL||k>root->size)printf("-1\n");
			else printf("%d\n",get_rank(root,root->size-k+1)+DEC);
		}
	}
	printf("%d\n",go_away);
	return 0;
}
Problem1505

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 101;
const int INF = 1e9;
double g[N][N],f[N][N][N];
int l_k[N][N][N],l_j[N][N][N];
int main()
{
	double k1,k2;
	int n,m;
	scanf("%lf%lf%d%d",&k1,&k2,&m,&n);
	for(int i = 0;i<N;i++)
		for(int j = 0;j<N;j++)
			g[i][j] = INF;
	for(int i = 0;i<N;i++)
		for(int j = 0;j<N;j++)
			for(int k = 0;k<N;k++)
				f[i][j][k] = INF;
	g[0][0] = 0;
	for(int i = 1;i<= 100;i++)
		for(int j = 1;j<= i;j++)
			for(int k = j-1;k<i;k++)
				g[i][j] = min(g[i][j],g[k][j-1]+(double)(i-k)*(i-k)*k2);
	f[0][0][0] = 0;
	for(int k = 1;k<= 100;k++)
		for(int i = 1;i<= m;i++)
			for(int j = 1;j<= n;j++)
				for(int lk = l_k[k][i-1][j];lk<k;lk++)
					for(int lj = l_j[k][i-1][j];lj<j;lj++)
						if(f[lk][i-1][lj]+(k-lk)*(k-lk)*k1+g[k-lk][j-lj]<f[k][i][j])
						{
							f[k][i][j] = f[lk][i-1][lj]+(double)(k-lk)*(k-lk)*k1+g[k-lk][j-lj];
							l_k[k][i][j] = lk;
							l_j[k][i][j] = lj;
						}
	printf("%.1f\n",f[100][m][n]);
	return 0;
}
Problem1507

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Splay
{
	Splay *ls,*rs,*fa;
	char c;
	int size;
	Splay(char S);
	void push_up();
}*null =new Splay(0),*root = null;
Splay :: Splay (char S)
{
	ls = rs = fa = null;
	c = S;
	size = c?1:0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
char s[1<<21];
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = new Splay(s[mid]);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)
		x->ls->fa = x;
	if(x->rs!=null)
		x->rs->fa = x;
	x->push_up();
}
int now;
void print(Splay *x)
{
	if(x==null)return ;
	print(x->ls);
	putchar(x->c);
	print(x->rs);
}
int main()
{
	int m,x;
	char opt[105];
	scanf("%d",&m);
	root = new Splay('\n');
	root->rs = new Splay('\n');
	root->rs->fa = root;
	root->push_up();
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d",&x);
			for(int j= 0;j<x;j++)
			{
				do s[j] = getchar();while(s[j]<32||s[j]>126);
			}
			Find(root,now+1,null);
			Find(root,now+2,root);
			build(root->rs->ls,0,x-1);
			root->rs->ls->fa = root->rs;
			root->rs->push_up();
			root->push_up();
		}
		else if(opt[0]=='D')
		{
			scanf("%d",&x);
			Find(root,now+1,null);
			Find(root,min(now+2+x,root->size),root);
			root->rs->ls = null;
			root->rs->push_up();
			root->push_up();
		}
		else if(opt[0]=='G')
		{
			scanf("%d",&x);
			Find(root,now+1,null);
			Find(root,min(now+2+x,root->size),root);
			print(root->rs->ls);
			puts("");
		}
		else if(opt[0]=='M')
			scanf("%d",&now);
		else if(opt[0]=='P')
			now--;
		else now++;
	}
	return 0;
}
Problem1512

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+100;
const int M = 1e6+100;
const int INF = 36500;
struct E
{int next,to;};
bool v[N],ins[N],tag[N];
int stack[N],dep[N],low[N],dfn,bel[N],scc,top;
int ind[N],f[N];
queue<int>Q;
struct G
{
	int head[N],tot;
	E e[N];
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}	
	void tarjan(int x)
	{
		v[x] = ins[x] = true;
		stack[++top] = x;
		dep[x] = low[x] = ++dfn;
		for(int i = head[x];i;i = e[i].next)
		{
			if(!v[e[i].to])
				{tarjan(e[i].to);low[x] = min(low[x],low[e[i].to]);}
			else if(ins[e[i].to])
				{low[x] = min(low[x],dep[e[i].to]);}
		}
		if(dep[x]==low[x])
		{
			scc++;
			int tmp = -1;
			do
			{
				tmp = stack[top--];
				ins[tmp] = false;
				bel[tmp] = scc;
			}while(tmp!=x);
		}
	}
	void topo(int n)
	{
		f[bel[n+1]] = 1;
		if(tag[bel[n+1]])f[bel[n+1]]+=INF;
		for(int i = 1;i<= scc;i++)
			if(ind[i]==0)
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i = e[i].next)
			{
				f[e[i].to]+=f[x];
				if(f[e[i].to]>INF)f[e[i].to]=INF+1;
				if(!--ind[e[i].to])
				{
					if(tag[e[i].to]&&f[e[i].to]>0)f[e[i].to] = INF+1;
					Q.push(e[i].to);
				}
			}
		}
	}
}g1,g2;
void rebuild(int n)
{
	for(int i = 1;i<= n+1;i++)
	{
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			int u = i,t = g1.e[j].to;
			if(bel[u]==bel[t]){tag[bel[u]] = true;continue;}
			g2.add(bel[u],bel[t]);
			ind[bel[t]]++;
		}
	}
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		g1.add(y,x);
	}
	for(int i = 1;i<= n+1;i++)
		if(!v[i])
			g1.tarjan(i);
	rebuild(n);
	g2.topo(n);
	int maxn = 0;
	for(int i = 1;i<= n;i++)
		if(f[bel[i]]>maxn)
			maxn = f[bel[i]];
	if(maxn>36500)printf("zawsze\n");
	else printf("%d\n",maxn);
	top = 0;
	for(int i = 1;i<= n;i++)
		if(f[bel[i]]==maxn)
			stack[++top] = i;
	printf("%d\n",top);
	for(int i = 1;i<= top;i++)
		printf("%d ",stack[i]);
	printf("\n");
	return 0;
}
Problem1513

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e3+5;
int S,D,lx,rx,sy,xy;
struct X_seg
{
	int val[N],lazy[N];
	void update(int p,int l,int r,int a,int b,int k)
	{
		val[p] = max(val[p],k);
		if(l>=a&&r<=b){lazy[p] = max(lazy[p],k);return ;}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,k);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,k);
	}
	int getans(int p,int l,int r,int a,int b)
	{
		if(l>=a&&r<=b)return val[p];
		int mid = (l+r)>>1;
		int ans = lazy[p];
		if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
		if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
		return ans;
	}
};
struct Y_seg
{
	X_seg val[N],lazy[N];
	void update(int p,int l,int r,int a,int b,int y)
	{
		val[p].update(1,1,S,xy,sy,y);
		if(l>=a&&r<=b){lazy[p].update(1,1,S,xy,sy,y);return ;}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,y);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,y);
	}
	int getans(int p,int l,int r,int a,int b)
	{
		if(l>=a&&r<=b)return val[p].getans(1,1,S,xy,sy);
		int mid = (l+r)>>1;
		int ans = lazy[p].getans(1,1,S,xy,sy);
		if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
		if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
		return ans;
	}
}M;
int main()
{
	int n,d,s,x,y,t;
	scanf("%d%d%d",&D,&S,&n);
	for(int i =1;i<= n;i++)
	{
		scanf("%d%d%d%d%d",&d,&s,&t,&x,&y);
		lx = x+1,rx = x+d,xy = y+1,sy = y+s;
		int ans = M.getans(1,1,D,lx,rx);
		M.update(1,1,D,lx,rx,ans+t);
	}
	xy = 1,sy = S;
	printf("%d\n",M.getans(1,1,D,1,D));
	return 0;
}
Problem1529

#include <stdio.h> 
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int main()
{
	int n,x;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)fa[i] = i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		uni(x,i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i)
			ans++;
	printf("%d\n",ans);
	return 0;
}
Problem1537

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct P
{int x,y,p;}pos[N];
int id[N],n,m,k,f[N];
bool cmp(P a,P b)
{
	if(a.y!=b.y)
		return a.y<b.y;
	return a.x<b.x;
}
struct Tree
{
	int c[N];
	Tree()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			c[i] = max(c[i],y);
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans = max(ans,c[i]);
		return ans;
	}
}C;
int find(int x)
{
	int l = 1,r = k+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l= mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%d",&pos[i].x,&pos[i].y,&pos[i].p);
		id[i] = pos[i].x;
	}
	sort(id+1,id+k+1);
	sort(pos+1,pos+k+1,cmp);
	int ans = 0;
	for(int i = 1;i<= k;i++)
	{
		f[i] = C.getans(find(pos[i].x))+pos[i].p;
		ans = max(ans,f[i]);
		C.update(find(pos[i].x),f[i]);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1552

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#define pa pair<int,int>
#define inf 1000000000
#define ll long long 
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,root,top;
int ans[100005],s[100005];
int fa[100005],c[100005][2];
int v[100005],mn[100005],size[100005],pos[100005];
bool rev[100005];
struct data{int pos,v;}a[100005];
inline bool operator<(const data &a,const data &b)
{return a.pos<b.pos;}
inline bool cmp(const data &a,const data &b)
{return a.v<b.v||(a.v==b.v&&a.pos<b.pos);}
void update(int x)
{
	int l=c[x][0],r=c[x][1];
	mn[x]=v[x];pos[x]=x;
	if(mn[l]<mn[x]){mn[x]=mn[l];pos[x]=pos[l];}
	if(mn[r]<mn[x]){mn[x]=mn[r];pos[x]=pos[r];}
	size[x]=size[l]+size[r]+1;
}
void pushdown(int x)
{
    int l=c[x][0],r=c[x][1];
	rev[x]^=1;rev[l]^=1;rev[r]^=1;
	swap(c[x][0],c[x][1]);
}
void rotate(int x,int &k)
{
    int y=fa[x],z=fa[y],l,r;
    if(c[y][0]==x)l=0;else l=1;r=l^1;
    if(y==k)k=x;
    else {if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
    fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
    c[y][l]=c[x][r];c[x][r]=y;
    update(y);update(x);
}
void splay(int x,int &k)
{
	top=0;s[++top]=x;
    for(int i=x;fa[i];i=fa[i])
        s[++top]=fa[i];
    for(int i=top;i;i--)
        if(rev[s[i]])pushdown(s[i]);
    while(x!=k)
    {
        int y=fa[x],z=fa[y];
        if(y!=k)
        {    
            if(c[y][0]==x^c[z][0]==y)
                rotate(x,k);
            else rotate(y,k);
        }
        rotate(x,k);
    }
}
int find(int x,int rk)
{
	if(rev[x])pushdown(x);
	int l=c[x][0],r=c[x][1];
	if(size[l]+1==rk)return x;
	else if(size[l]>=rk)return find(l,rk);
	else return find(r,rk-size[l]-1);
}
int querymn(int L,int R)
{
	int x=find(root,L),y=find(root,R+2);
	splay(x,root);splay(y,c[x][1]);
	int z=c[y][0];
	return pos[z];
}
void rever(int L,int R)
{
	int x=find(root,L),y=find(root,R+2);
	splay(x,root);splay(y,c[x][1]);
	int z=c[y][0];
	rev[z]^=1;
}
void build(int l,int r,int f)
{
	if(l>r)return;
	if(l==r)
	{
		fa[l]=f;size[l]=1;
		mn[l]=v[l]=a[l].v;pos[l]=l;
		if(l<f)c[f][0]=l;
		else c[f][1]=l;
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid-1,mid);build(mid+1,r,mid);
	fa[mid]=f;v[mid]=a[mid].v;update(mid);
	if(mid<f)c[f][0]=mid;
	else c[f][1]=mid;
}
int main()
{
    n=read();
    a[1].v=a[n+2].v=inf;mn[0]=inf;
	for(int i=2;i<=n+1;i++)
	{
		scanf("%d",&a[i].v);
		a[i].pos=i;
	}
	sort(a+2,a+n+2,cmp);
	for(int i=2;i<=n+1;i++)a[i].v=i-1;
	sort(a+2,a+n+2);
	build(1,n+2,0);
	root=(n+3)>>1;
	for(int i=1;i<=n;i++)
	{
		int x=querymn(i,n);
		splay(x,root);
		ans[i]=size[c[x][0]];
		rever(i,ans[i]);
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d",ans[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem1565

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1,ind[N],d[N],f[N];
int ans,m,n,st,end;
bool Can[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
	ind[x]++;
}
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i].flow&&d[e[i].to]==-1&&Can[e[i].to])
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int dinic(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow&&last)
		{
			int tof = dinic(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}else d[e[i].to]=-1;
		}
	d[s] = -1;
	return mf-last;
}
int get_maxflow(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=dinic(s,t,INF);
	return ans;
}
void topo()
{
	for(int i = st;i<=end;i++)
		if(!ind[i])
			Q.push(i);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		if(f[x]>0)ans+=f[x];
		Can[x] = true;
		for(int i=head[x];i;i=e[i].next)
			if(i&1)
				if(!--ind[e[i].to])
					Q.push(e[i].to);
	}
}
void debug()
{
	for(int i = st;i<= end;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].flow);
		printf("\n");
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	st = 0,end = n*m+1;
	for(int i = 1;i<end;i++)
	{
		scanf("%d",&f[i]);
		if(f[i]>0)add(st,i,f[i]);
		else add(i,end,-f[i]);
		int k,r,c;
		scanf("%d",&k);
		while(k--)
		{
			scanf("%d%d",&r,&c);
			add(r*m+c+1,i,INF);
		}
		if(i%m)
			add(i,i+1,INF);
	}
	topo();
	ans-=get_maxflow(st,end);
	printf("%d\n",ans);
	return 0;
}
Problem1570

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5010;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1,n,m,T;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(s);
	d[s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
vector<int>to[N],val[N];
int main()
{
	scanf("%d%d%d",&n,&m,&T);
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		to[x].push_back(y);
		val[x].push_back(z);
	}
	int st=0,ed=N-1,ans =0;
	add(st,1,T);
	for(int day = 1;;day++)
	{
		for(int i = 1;i<= n;i++)
			for(int j = 0;j<to[i].size();j++)
				add(n*(day-1)+i,n*day+to[i][j],val[i][j]);
		for(int i = 1;i<= n;i++)
			add(n*(day-1)+i,n*day+i,INF);
		add(n*day+n,ed,INF);
		if((ans+=dinic(st,ed))==T)
		{
			printf("%d\n",day);
			return 0;
		}
	}
	return 0;
}
Problem1579

#include <queue>
#include <stack>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <limits.h>
#include <string.h>
#include <string>
#include <algorithm>

using namespace std;

const int MAX = 10010;
struct NODE{int to,len;NODE *next;};
NODE *p[MAX],node[MAX*10];
int cou;
int dis[25][MAX],L;
void init()
{
	cou = 0;
	memset(node,'\0',sizeof(node));
	memset(p,'\0',sizeof(p));
}
void Add(int x,int y,int w)
{
	node[cou].len = w;
	node[cou].to = y;
	node[cou].next = p[x];
	p[x] = &node[cou++];
}
struct cmp{
	bool operator()(int a,int b)
	{
		return dis[L][a] > dis[L][b];
	}
};
void Dijkstra(int s,int n,int *dis)
{
	bool used[MAX];
	memset(used,0,sizeof(used));
	used[s] = true;
	dis[s] = 0; int now = s;
	for(int i=0; i<n-1; i++)
	{
		NODE *head = p[now];
		while( head )
		{
			if( dis[head->to] > dis[now] + head->len )
				dis[head->to] = dis[now] + head->len;
			head = head->next;
		}
		int mmin = INT_MAX;
		for(int k=1; k<=n; k++)
			if( !used[k] && mmin > dis[k] )
				mmin = dis[now = k];
		used[now] = true;
	}
}
void Dijkstra1(int s,int n,int l)
{
	priority_queue<int,vector<int>,cmp> q;
	bool used[MAX];
	memset(used,0,sizeof(used));
	used[s] = true;
	int now = s;
	dis[l][s] = 0;
	q.push(s);
	while( !q.empty() )
	{
		int now = q.top(); used[now] = true;
		NODE *head = p[now]; q.pop();
		while( head )
		{
			if( dis[l][head->to] > min( dis[l-1][now],dis[l][now] + head->len ) )
			{
				dis[l][head->to] = min( dis[l-1][now],dis[l][now] + head->len );
				q.push(head->to);
			}
			head = head->next;
		}
	}
}

int main()
{
	int n,m,K,x,y,w;
	
	while( ~scanf("%d%d%d",&n,&m,&K) )
	{
		while( m-- )
		{
			scanf("%d%d%d",&x,&y,&w);
			Add(x,y,w); Add(y,x,w);
		}
		for(int k=0; k<=K; k++)
			for(int i=1; i<=n; i++)
				dis[k][i] = 500000000;
		Dijkstra(1,n,dis[0]);
		
		for(L=1; L<=K; L++)
			Dijkstra1(1,n,L);
		printf("%d\n",dis[K][n]);
	}

return 0;
}
Problem1588

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
struct Treap{
	Treap *ls,*rs;
	int key,val,cnt,size;
	Treap(int x)
	{
		ls = rs = NULL;
		key = rand();
		cnt = size = 1;
		val = x;
	}
	void push_up()
	{
		size = cnt;
		if(ls)size+=ls->size;
		if(rs)size+=rs->size;
	}
}*root = NULL;
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y>x->val)
	{
		Insert(x->rs,y);
		if(x->rs->key > x->key)
			go_left(x);
	}
	else
	{
		Insert(x->ls,y);
		if(x->ls->key > x->key)
			go_right(x);
	}
	x->push_up();
}
int get_pre(Treap *x,int y)
{
	if(!x)return -0x3f3f3f3f;
	if(x->val>y)return get_pre(x->ls,y);
	else return max(x->val,get_pre(x->rs,y));
}
int get_suc(Treap *x,int y)
{
	if(!x)return 0x3f3f3f3f;
	if(x->val<y)return get_suc(x->rs,y);
	else return min(x->val,get_suc(x->ls,y));
}
int main()
{
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(i==1){ans+=x;Insert(root,x);}
		else
		{
			int tmp = get_pre(root,x),minn = INF;
			if(tmp!=-INF) minn = x-tmp;
			tmp = get_suc(root,x);
			if(tmp!=INF)minn = min(minn,tmp-x);
			ans+=minn;
			Insert(root,x);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1597

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 50005;
struct LAND{int wid,lth;}ld[N];
int line[N],L,R;
int l[N],w[N];
LL f[N];
bool cmp(LAND a,LAND b)
{
    if(a.lth!=b.lth)return a.lth>b.lth;
    return a.wid<b.wid;
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
        scanf("%d%d",&ld[i].wid,&ld[i].lth);
    sort(ld+1,ld+n+1,cmp);
    int cnt = 0;
    for(int i = 1;i<= n;i++)
    {
        if(cnt==0||ld[i].wid>w[cnt])
        {
            cnt++;
            w[cnt] = ld[i].wid;
            l[cnt] = ld[i].lth;
        }
    }
    int L = 1,R = 1;line[L] =0;
    for(int i = 1;i<= cnt;i++)
    {
        while(L<R&&(LL)(l[line[L+1]+1]-l[line[L]+1])*w[i]<f[line[L]]-f[line[L+1]])
            L++;
        f[i] = f[line[L]]+(LL)l[line[L]+1]*w[i];
        while(L<R&&(LL)(l[line[R]+1]-l[i+1])*(f[line[R]]-f[line[R-1]])>(LL)(l[line[R-1]+1]-l[line[R]+1])*(f[i]-f[line[R]]))
            R--;
        line[++R] = i;
    }
    printf("%lld\n",f[cnt]);
    return 0;
}
Problem1645

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 40005;
typedef long long LL;
struct L
{int pos,h,f;}line[N<<1];
int cnt,id[N],x[N],y[N],v[N],tp[N];
bool cmp(L a,L b)
{
	return a.pos<b.pos;
}
bool cmi(int a,int b)
{
	return v[a]<v[b];
}
int sum[N<<2],lazy[N<<2];
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	int mid = (l+r)>>1;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	sum[p<<1]+=lazy[p]*(mid-l+1);
	sum[p<<1|1]+=lazy[p]*(r-mid);
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sum[p]+=(r-l+1)*c;
		lazy[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int getans(int p,int l,int r)
{
	push_down(p,l,r);
	if(l==r)
	{
		if(sum[p])return l;
		else return l-1;
	}
	int mid = (l+r)>>1;
	if(!sum[p<<1|1])return getans(p<<1,l,mid);
	else return getans(p<<1|1,mid+1,r);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&v[i]);
		id[i] = i;
	}
	sort(id+1,id+n+1,cmi);
	for(int i = 1;i<= n;i++)
		tp[id[i]] = i;
	for(int i = 1;i<= n;i++)
	{
		line[++cnt].pos = x[i];line[cnt].h = tp[i];line[cnt].f = 1;
		line[++cnt].pos = y[i],line[cnt].h = tp[i];line[cnt].f =-1;
	}
	sort(line+1,line+cnt+1,cmp);
	int last = 0;
	LL ans = 0;
	for(int i = 1;i<= cnt;i++)
	{
		ans+=(LL)v[id[last]]*(line[i].pos-line[i-1].pos);
		update(1,1,n,1,line[i].h,line[i].f);
		last = getans(1,1,n);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem1672

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int Mn = 86399+5;
const int N = 1e4+5;
const LL INF = 1e18;
struct C
{int s,t,c;}cl[N];
bool cmp(C a,C b)
{
	return a.s<b.s;
}
LL f[Mn],t[Mn<<2];
void build(int p,int l,int r)
{
	t[p] = INF;
	if(l==r)
	{
		f[l] = INF;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
}
void push_down(int p,int l,int r)
{
	if(t[p]==INF)return ;
	if(l==r){f[l] = min(f[l],t[p]);t[p] = INF;return ;}
	t[p<<1] = min(t[p],t[p<<1]);
	t[p<<1|1] = min(t[p],t[p<<1|1]);
	t[p] = INF;
}
void update(int p,int l,int r,int a,int b,LL c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		t[p] = min(t[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	return ;
}
LL getans(int p,int l,int r,int x)
{
	push_down(p,l,r);
	if(x<=0)return 0;
	if(l==r)return f[l];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int main()
{
	int n,m,e;
	scanf("%d%d%d",&n,&m,&e);
	m++,e++;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&cl[i].s,&cl[i].t,&cl[i].c);
		cl[i].s++;cl[i].t++;
	}
	sort(cl+1,cl+n+1,cmp);
	build(1,1,e);
	update(1,1,e,1,m,0);
	for(int i = 1;i<= n;i++)
	{
		int s = cl[i].s,t = cl[i].t,v = cl[i].c;
		LL tmp = getans(1,1,e,s-1);
		if(tmp>=INF){printf("-1\n");return 0;}
		update(1,1,e,s,t,tmp+v);
	}
	printf("%lld\n",getans(1,1,e,e));
	return 0;
}
Problem1688

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 1<<16;
int cow[N];
int sta[M],cnt;
void init(int k)
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i,c = 0;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			c++;
		} 
		if(c==k)
			sta[++cnt] = i;
	}
	return ;
}
int main()
{
	int n,d,k;
	scanf("%d%d%d",&n,&d,&k);
	init(k);
	for(int i = 1;i<= n;i++)
	{
		int c,x;
		scanf("%d",&c);
		for(int j = 1;j<= c;j++)
		{
			scanf("%d",&x);
			cow[i]|=(1<<(x-1));
		}
	}
	int t_ans = 0;
	for(int i= 1;i<= cnt;i++)
	{
		int ans = 0;
		for(int j = 1;j<= n;j++)
		{
			if((cow[j]|sta[i])!=sta[i])continue;
			else ans++;
		}
		t_ans = max(ans,t_ans);
	}
	printf("%d\n",t_ans);
	return 0;
}
Problem1692

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
char s[N];
int cnt[N],q[N],v[N],nv[N],sa[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int lim,int len)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl=1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
int main()
{
	int n;
	char ch;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
	{
		ch = getchar();while(ch<'A'||ch>'Z')ch = getchar();
		s[i]=ch;
	}
	int len = n;
	s[len]='$';
	for(int i = n-1;i>=0;i--)
		s[++len]=s[i];
	len++;
	build_sa(256,len);
	build_rank(len);
	int l = 0,r = n+1;
	for(int i = 0;i<n;i++)
	{
		if(r>=len||rnk[l]<rnk[r])
			{printf("%c",s[l]);l++;}
		else {printf("%c",s[r]);r++;}
		if(i%80==79)printf("\n");
	}
	return 0;
}
Problem1717

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int maxN = 1000001;
int cnt[maxN],q[N],sa[N],h[N],rnk[N],v[N],nv[N];
int s[N],n,k;
bool is_same(int a,int b,int ln,int len)
{
	return (v[a]==v[b])&&((a+ln>len&&b+ln>len)||(a+ln<len&&b+ln<len&&v[a+ln]==v[b+ln]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]] = i;
	for(int d = 1;;d++)
	{
		int ln = 1<<(d-1),id = 0;
		for(i = len-ln;i<len;i++)q[id++]=i;
		for(i = 0;i<len;i++)if(sa[i]>=ln)q[id++]=sa[i]-ln;

		for(i = 0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[v[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],ln,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
bool check(int mid,int len)
{
	int tmp = 0;
	for(int i = 1;i<len;i++)
	{
		if(h[i]>=mid)tmp++;
		else tmp = 0;
		if(tmp>=k-1)return true;
	}
	return false;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 0;i< n;i++)scanf("%d",&s[i]);
	build_sa(n,maxN);
	build_rank(n);
	build_height(n);
	int l = 0,r = n,ans=0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(check(mid,n))l=mid+1,ans=mid;
		else r = mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<12;
const int mod = 100000000;
int f[13][N];
int map[13];
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<m;j++)
		{
			scanf("%d",&x);
			map[i] |= (x^1)<<j;
		}
	f[0][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		for(int last = 0;last< 1<<m;last++)
		{
			if((last&map[i-1])||(last&(last<<1))||(last&(last>>1)))continue;
			for(int now = 0;now<1<<m;now++)
			{
				if((now&map[i])||(now&(now<<1))||(now&(now>>1)))continue;
				if(now&last)continue;
				f[i][now] = (f[i][now]+f[i-1][last])%mod;
			}
		}
	}
	int ans = 0;
	for(int i = 0;i<1<<m;i++)
		ans = (ans+f[n][i])%mod;
	printf("%d\n",ans);
	return 0;
}
Problem1742

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
long long f[N][N][2];
int pos[N],n,s;
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%d",&pos[i]);
	pos[++n] = s;
	sort(pos+1,pos+n+1);
	s = find(s);
	memset(f,0x3f,sizeof(f));
	f[s][1][0] = f[s][1][1] = 0;
	for(int len = 2;len <= n;len++)
	{
		for(int l = 1;l+len-1<= n;l++)
		{
			int r = l+len-1;
			f[l][len][1] = min(f[l][len][1],min(f[l+1][len-1][1]+(n-len+1)*(pos[l+1]-pos[l]),f[l+1][len-1][0]+(n-len+1)*(pos[r]-pos[l])));
			f[l][len][0] = min(f[l][len][0],min(f[l][len-1][0]+(n-len+1)*(pos[r]-pos[r-1]),f[l][len-1][1]+(n-len+1)*(pos[r]-pos[l])));
		}
	}
	printf("%lld\n",min(f[1][n][0],f[1][n][1]));
	return 0;
}
Problem1778

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
const double eps = 1e-9;
double f[N][N],cnt[N],ans[N];
int n,m,x,y;
double p,q;
void swapn(int x,int y)
{
	for(int i = 1;i<= n+1;i++)
		swap(f[x][i],f[y][i]);
	return ;
}
void work()
{
	for(int i = 1;i<= n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swapn(xn,i);
		for(int line = i+1;line<=n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = i;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n;i>= 1;i--)
	{
		for(int j = n;j>i;j--)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%lf%lf",&p,&q);
	double rate = p/q;
	if(rate>1)rate = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		f[x][y]+=1;f[y][x]+=1;
		cnt[x]+=1;cnt[y]+=1;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(fabs(cnt[j])>eps)
				f[i][j]/=cnt[j];
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			f[i][j]*=rate-1;
	for(int i = 1;i<= n;i++)
		f[i][i]+=1;
	f[1][n+1] = rate;
	work();
	for(int i = 1;i<= n;i++)
		printf("%.9f\n",fabs(ans[i]));	
	return 0;
}
Problem1782

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,c[N],w[N],son[N],size[N],cnt,p[N],top[N],end[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void dfs1(int x,int fa)
{
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
void dfs2(int x,int fa,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],x,tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&e[i].to!=son[x])
			dfs2(e[i].to,x,e[i].to);
	end[x] = cnt;
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs1(1,0);
	dfs2(1,0,1);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d",&p[i]);
		printf("%d\n",getans(w[p[i]]));
		update(w[p[i]],1);
		update(end[p[i]]+1,-1);
	}
	return 0;
}
Problem1798

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int M = 100005;
int mod;
int mul_tag[N<<2],add_tag[N<<2];
int sum[N<<2];
void build(int p,int l,int r)
{
	mul_tag[p] = 1,add_tag[p] = 0;
	if(l==r)
	{
		scanf("%d",&sum[p]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = (sum[p<<1]+sum[p<<1|1])%mod;
}
void push_down(int p,int l,int r)
{
	if(l==r||(mul_tag[p]==1&&add_tag[p]==0))return ;
	int mid = (l+r)>>1;
	sum[p<<1] = ((LL)sum[p<<1]*mul_tag[p]%mod+(LL)add_tag[p]*(mid-l+1)%mod)%mod;
	sum[p<<1|1] = ((LL)sum[p<<1|1]*mul_tag[p]%mod+(LL)add_tag[p]*(r-mid)%mod)%mod;
	mul_tag[p<<1] = (LL)mul_tag[p<<1]*mul_tag[p]%mod;
	mul_tag[p<<1|1] = (LL)mul_tag[p<<1|1]*mul_tag[p]%mod;
	add_tag[p<<1] = ((LL)add_tag[p<<1]*mul_tag[p]+add_tag[p])%mod;
	add_tag[p<<1|1] = ((LL)add_tag[p<<1|1]*mul_tag[p]+add_tag[p])%mod;
	mul_tag[p] = 1;
	add_tag[p] = 0;	
}
void update(int p,int l,int r,int a,int b,int c,int opt)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		if(opt)
			{add_tag[p]+=c;sum[p] = (sum[p]+(LL)c*(r-l+1)%mod)%mod;}
		else
		{
			add_tag[p] = (LL)add_tag[p]*c%mod;
			mul_tag[p] = (LL)mul_tag[p]*c%mod;
			sum[p] = (LL)sum[p]*c%mod;
		}
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c,opt);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c,opt);
	sum[p] = (sum[p<<1]+sum[p<<1|1])%mod;
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans = (ans+getans(p<<1,l,mid,a,b))%mod;
	if(b>mid)ans = (ans+getans(p<<1|1,mid+1,r,a,b))%mod;
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&mod);
	build(1,1,n);
	int opt,l,r,c;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt<=2)
		{
			opt--;
			scanf("%d%d%d",&l,&r,&c);
			update(1,1,n,l,r,c,opt);
		}else
		{
			scanf("%d%d",&l,&r);
			printf("%d\n",getans(1,1,n,l,r));
		}
	}
	return 0;
}
Problem1806

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,ans,f[2][4][4][4][4];
inline int Get_Char()
{
	char c;
	do c=getchar(); while(c!='M'&&c!='F'&&c!='B');
	switch(c)
	{
		case 'M':return 1;
		case 'F':return 2;
		case 'B':return 3;
	}
}
inline int Score(int x,int y)
{
	if(x==0) return 1;
	return x==y?1:2;
}
inline int Score(int x,int y,int z)
{
	int temp=x*y*z;
	switch(temp)
	{
		case 6:return 3;
		case 1:
		case 8:
		case 27:return 1;
		case 0:return Score(y,z);
		default: return 2;
	}
}
int main()
{
	scanf("%d",&n);
	memset(f,0xef,sizeof f);
	f[0][0][0][0][0]=0;
	for(int i=1;i<=n;i++)
	{
		int temp=Get_Char();
		memset(f[i&1],0xef,sizeof(f[i&1]));
		for(int a1=0;a1<=3;a1++)
			for(int a2=(a1?1:0);a2<=3;a2++)
				for(int b1=0;b1<=3;b1++)
					for(int b2=(b1?1:0);b2<=3;b2++)
						if(f[~i&1][a1][a2][b1][b2]>=0)
						{
							f[i&1][a2][temp][b1][b2]=max(f[i&1][a2][temp][b1][b2]
														,f[~i&1][a1][a2][b1][b2]+Score(a1,a2,temp));
							f[i&1][a1][a2][b2][temp]=max(f[i&1][a1][a2][b2][temp]
														,f[~i&1][a1][a2][b1][b2]+Score(b1,b2,temp));
						}
	}
	for(int a1=0;a1<=3;a1++)
		for(int a2=(a1?1:0);a2<=3;a2++)
			for(int b1=0;b1<=3;b1++)
				for(int b2=(b1?1:0);b2<=3;b2++)
					ans=max(ans,f[n&1][a1][a2][b1][b2]);
	printf("%d\n",ans);
	return 0;
}
Problem1816

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 60
#define inf 0x3f3f3f3f
using namespace std;
int n,m,a[N],ans;
bool check(int mid)
{
    int remain=min(m,mid);
    for(int i=1;i<=n;i++)
    {
        if(a[i]>=mid)continue;
        remain-=mid-a[i];
        if(remain<0)return 0;
    }
    return 1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    int l=0,r=inf,mid,ans;
    while(l<=r)
    {
        if(r-l<=3)
        {
            ans=0;
            for(int i=l;i<=r;i++)
                if(check(i))ans=i;
            printf("%d\n",ans);
            return 0;
        }
        mid=(l+r)>>1;
        if(check(mid))l=mid;
        else r=mid-1;
    }
    printf("%d\n",ans);
    return 0;
}
Problem1821

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
using namespace std;
struct E	
{
	int x,y;
	double val;
	bool operator < (const E &s) const
	{
		return val < s.val;
	}
}edge[2000005];
int tot,fa[1005];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])
		return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int x[1005],y[1005];
int main()
{
	//freopen("group.in","r",stdin);
	//freopen("group.out","w",stdout);
	int n,k;
	scanf("%d%d",&n,&k);
	int cnt = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	for(int i = 1;i<= n;i++)
	{
		for(int j = i+1;j<= n;j++)
		{
			edge[++tot].x = i;
			edge[tot].y = j;
			edge[tot].val = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
			edge[++tot].x = j;
			edge[tot].y = i;
			edge[tot].val = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
		}
	}
	double ans = 0;
	std::sort(edge+1,edge+tot+1);
	for(int i = 1;i<= tot;i++)
	{
		int fx = getfa(edge[i].x);
		int fy = getfa(edge[i].y);
		if(fx==fy)continue;
		if(cnt>=n-k)
		{
			ans = edge[i].val;
			break;
		}
		cnt++;
		uni(fx,fy);
	}
	printf("%.2lf",ans);
	return 0;
}
Problem1823

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2e4+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool ins[N];
int dfn[N],low[N],stack[N],top,cnt,bel[N],dcc;
void tarjan(int x)
{
	low[x] = dfn[x] = ++cnt;
	stack[++top] = x;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
int getnum(char s[10])
{
	int now = 1;
	int ans = 0;
	while(s[now])
	{
		ans=ans*10+s[now]-'0';
		now++;
	}
	return ans*2;
}
void work()
{
	memset(head,0,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(bel,0,sizeof(bel));
	tot = cnt = dcc = top = 0;
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	char s1[10],s2[10];
	for(int i=1;i<=m;i++)
	{
		scanf("%s%s",s1,s2);
		x = getnum(s1),y = getnum(s2);
		if(s1[0]=='m')x++;
		if(s2[0]=='m')y++;
		add(x^1,y);
		add(y^1,x);
	}
	for(int i = 2;i<= 2*n+1;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i = 1;i<= n;i++)
	{
		if(bel[i<<1]==0||bel[i<<1|1]==0)continue;
		if(bel[i<<1]==bel[i<<1|1])
			{printf("BAD\n");return ;}
	}
	printf("GOOD\n");
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)work();
	return 0;
}
Problem1828

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
int mn[N<<2],lazy[N<<2];
struct Q
{
	int l,r;
}ask[N];
bool cmp(Q a,Q b)
{
	return a.r<b.r;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		scanf("%d",&mn[p]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
}
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	mn[p<<1] = mn[p<<1]+lazy[p];
	mn[p<<1|1] = mn[p<<1|1]+lazy[p];
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		mn[p]--;
		lazy[p]--;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b);
	if(b>mid)update(p<<1|1,mid+1,r,a,b);
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return mn[p];
	int mid = (l+r)>>1;
	int ans = INF;
	if(a<=mid)ans = min(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)ans = min(ans,getans(p<<1|1,mid+1,r,a,b));
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
	return ans;
}
int main()
{
	int n,m,ans = 0;
	scanf("%d%d",&n,&m);
	build(1,1,n);
	for(int i = 1;i<= m;i++)
		scanf("%d%d",&ask[i].l,&ask[i].r);
	sort(ask+1,ask+m+1,cmp);
	for(int i = 1;i<= m;i++)
	{
		if(getans(1,1,n,ask[i].l,ask[i].r)>=1)
		{
			update(1,1,n,ask[i].l,ask[i].r);
			ans++;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1833

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL f[15][10][10];
LL p10[15],ans[10][2];
void solve(LL x,int opt)
{
	if(x==0)return ;
	int num[15] = {};
	int cnt = 0;
	LL tmp = x;
	while(x)
	{
		num[++cnt] = x%10;
		x/=10;
	}
	for(int i = 1;i<=num[cnt]-1;i++)
		for(int j = 0;j<= 9;j++)
			ans[j][opt]+=f[cnt][i][j];
	ans[num[cnt]][opt]+=tmp%p10[cnt-1]+1;
	for(int i = cnt-1;i>=1;i--)
		for(int j = 1;j<= 9;j++)
			for(int k = 0;k<= 9;k++)
				ans[k][opt]+=f[i][j][k];
	for(int i = cnt-1;i>=1;i--)
	{
		for(int j = 0;j<= num[i]-1;j++)
			for(int k = 0;k<= 9;k++)
				ans[k][opt]+=f[i][j][k];
		ans[num[i]][opt]+=tmp%p10[i-1]+1;
	}
	return ;
}
int main()
{
	p10[0] = 1;
	for(int i = 1;i<= 12;i++)p10[i] = p10[i-1]*10;
	LL a,b;
	scanf("%lld%lld",&a,&b);
	for(int i = 0;i<= 9;i++)
		for(int j = 0;j<=9;j++)
			if(i==j)f[1][i][j] = 1;
	for(int i = 2;i<= 12;i++)
		for(int j = 0;j<= 9;j++)
			for(int k = 0;k<= 9;k++)
			{
				for(int l = 0;l<= 9;l++)
					f[i][j][k]+=f[i-1][l][k];
				if(k==j)f[i][j][k]+=p10[i-1];		
			}
	solve(a-1,0);
	solve(b,1);
	for(int i = 0;i< 9;i++)printf("%lld ",ans[i][1]-ans[i][0]);
	printf("%lld\n",ans[9][1]-ans[9][0]);
	return 0;
}
Problem1834

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 5e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int nxt,to,fr,f,c;}e[M];
int head[N],tot=1,from[N];
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].nxt=head[x];head[x]=tot;
	e[tot].f=f,e[tot].c=c,e[tot].fr=x;
	e[++tot].to=x;e[tot].nxt=head[y];head[y]=tot;
	e[tot].f=0,e[tot].c=-c,e[tot].fr=y;
}
bool v[N];
int dis[N],S,T;
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	Q.push(S);
	v[S] = true;dis[S] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].nxt)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans =0,mxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	mxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int a[M],b[M],C[M],W[M];
int main()
{
	//freopen("x.in","r",stdin);
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i= 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a[i],&b[i],&C[i],&W[i]);
		add(a[i],b[i],C[i],0);
	}
	S = 1,T = n;
	while(spfa())mcf();
	printf("%d",mxf);
	add(0,1,k,0);
	S = 0;
	memset(from,0,sizeof(from));
	ans = mxf = 0;
	for(int i = 1;i<= m;i++)
		add(a[i],b[i],INF,W[i]);
	while(spfa())mcf();
	printf(" %d\n",ans);
	return 0;
}
Problem1854

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
int fa[N];
int vis[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		int fx = getfa(x),fy = getfa(y);
		if(fx==fy)
			vis[fx] = true;
		else
		{
			if(fx>fy){vis[fy] = true;fa[fy] = fx;}
			else {vis[fx] = true;fa[fx] = fy;}
		}
	}
	for(int i = 1;i<= N+1;i++)
		if(!vis[i])
			{printf("%d\n",i-1);break;}
	return 0;
}
Problem1855

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int T = 2005;
const int P = 2005;
int asi[T],bsi[T],api[T],bpi[T];
int f[T][P];
int line[P],L,R;
int main()
{
	memset(f,128,sizeof(f));
	int t,maxp,w;
	scanf("%d%d%d",&t,&maxp,&w);
	for(int i = 1;i<= t;i++)
		scanf("%d%d%d%d",&api[i],&bpi[i],&asi[i],&bsi[i]);
	for(int i = 1;i<= t;i++)
	{
		
		for(int j = 0;j <= asi[i];j++)f[i][j] = -api[i]*j;
		for(int j = 0;j <= maxp;j++)
			f[i][j] = max(f[i][j],f[i-1][j]);
		int t = i-w-1;
		if(t>=0)
		{
			L = 1,R = 0;
			for(int j = 0;j<=maxp;j++)
			{
				while(L<=R&&j-line[L]>asi[i])L++;
				int tmp = f[t][j]+j*api[i];
				while(L<=R&&tmp>=f[t][line[R]]+line[R]*api[i])
					R--;
				line[++R]= j;
				if(L<=R)f[i][j] = max(f[i][j],f[t][line[L]]+line[L]*api[i]-j*api[i]);
			}
			L = 1,R = 0;
			for(int j = maxp;j>= 0;j--)
			{
				while(L<=R&&line[L]-j>bsi[i])L++;
				int tmp = f[t][j]+j*bpi[i];
				while(L<=R&&tmp>=f[t][line[R]]+line[R]*bpi[i])
					R--;
				line[++R]= j;
				if(L<=R)f[i][j] = max(f[i][j],f[t][line[L]]+line[L]*bpi[i]-j*bpi[i]);
			}
		}
	}
	int ans = -1e9;
	for(int i = 0;i<= maxp;i++)
		ans = max(ans,f[t][i]);
	printf("%d",ans);
	return 0;
}
Problem1861

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
const int N = 2e5;
struct Splay
{
	Splay *ls,*rs,*fa;
	int size,num;
	Splay (int x);
	void push_up();
}*null = new Splay(0),*root,*tree[N];
int a[N],n,m;
Splay :: Splay (int x)
{
	ls = rs = fa = null;
	size = x?1:0;
	num = x;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)
				go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		if(x->ls->size>=y)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
int get_rank(Splay *x)
{
	int ans = x->ls->size;
	for(;x!=root;x = x->fa)
		if(x==x->fa->rs)
			ans+=x->fa->ls->size+1;
	return ans;
}
void Insert(Splay *x,int y)
{
	Find(root,y,null);
	Find(root,y+1,root);
	root->rs->ls = x;
	x->fa = root->rs;
	root->rs->push_up();
	root->push_up();
}
void Delete(int y)
{
	Find(root,y,null);
	Find(root,y+2,root);
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
}
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = tree[a[mid]];
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa = x;
	if(x->rs!=null)x->rs->fa = x;
	x->push_up();
}
void init()
{
	root = new Splay(Inv);
	root->rs = new Splay(Inv);
	build(root->rs->ls,1,n);
	root->rs->ls->fa = root->rs;
	root->rs->push_up();
	root->rs->fa = root;
	root->push_up();
}
void top()
{
	int pos;
	scanf("%d",&pos);
	int tmp = get_rank(tree[pos]);
	Delete(tmp);
	Insert(tree[pos],1);
}
void bot()
{
	int pos;
	scanf("%d",&pos);
	int tmp = get_rank(tree[pos]);
	Delete(tmp);
	Insert(tree[pos],n);
}
void Change()
{
	int x,y;
	scanf("%d%d",&x,&y);
	int tmp = get_rank(tree[x]);
	Delete(tmp);
	Insert(tree[x],tmp+y);
}
void Ask()
{
	int x;
	scanf("%d",&x);
	printf("%d\n",get_rank(tree[x])-1);
}
void Query()
{
	int x;
	scanf("%d",&x);
	Find(root,x+1,null);
	printf("%d\n",root->num);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		tree[i] = new Splay(i);
	init();
	char opt[10];
	for(int i = 1;i<=m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')Query();
		else if(opt[0]=='A')Ask();
		else if(opt[0]=='T')top();
		else if(opt[0]=='B')bot();
		else if(opt[0]=='I')Change();
	}
	return 0;
}
Problem1861

#include<iostream>
#include<cstdio>
#include<cstring>
#define inf 1000000000
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,rt,sz;
int c[80005][2],fa[80005],deep[80005];
int a[80005],size[80005],v[80005],pos[80005];
void update(int k)
{
	size[k]=size[c[k][0]]+size[c[k][1]]+1;
}
void rotate(int x,int &k)
{
	int y=fa[x],z=fa[y],l,r;
	if(c[y][0]==x)l=0;else l=1;r=l^1;
	if(y==k)k=x;
	else {if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
	fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
	c[y][l]=c[x][r];c[x][r]=y;
	update(y);update(x);
}
void splay(int x,int &k)
{
	while(x!=k)
	{
		int y=fa[x],z=fa[y];
		if(y!=k)
		{	
			if(c[y][0]==x^c[z][0]==y)
				rotate(x,k);
			else rotate(y,k);
		}
		rotate(x,k);
	}
}
void build(int l,int r,int f)
{
	if(l>r)return;
	int now=l,last=f;
	if(l==r)
	{
		v[now]=a[l];size[now]=1;fa[now]=last;
		if(l<f)c[last][0]=now;
		else c[last][1]=now;
		return;
	}
	int mid=(l+r)>>1;now=mid;
	build(l,mid-1,mid);build(mid+1,r,mid);
	v[now]=a[mid];fa[now]=last;update(now);
	if(mid<f)c[last][0]=now;
	else c[last][1]=now;
}
int find(int k,int rank)
{
	int l=c[k][0],r=c[k][1];
	if(size[l]+1==rank)return k;
	else if(size[l]>=rank)return find(l,rank);
	else return find(r,rank-size[l]-1);
}
void del(int k)
{
	int x,y,z;
	x=find(rt,k-1);y=find(rt,k+1);
	splay(x,rt);splay(y,c[x][1]);
	z=c[y][0];c[y][0]=0;fa[z]=size[z]=0;
	update(y);update(x);
}
void move(int k,int val)
{
	int x,y,z=pos[k],rank;
	splay(z,rt);rank=size[c[z][0]]+1;
	del(rank);
	if(val==inf)x=find(rt,n),y=find(rt,n+1);
	else if(val==-inf)x=find(rt,1),y=find(rt,2);
	else x=find(rt,rank+val-1),y=find(rt,rank+val);
	splay(x,rt);splay(y,c[x][1]);
	size[z]=1;fa[z]=y;c[y][0]=z;
	update(y);update(x);
}
int main()
{
	n=read();m=read();
	for(int i=2;i<=n+1;i++)
		a[i]=read(),pos[a[i]]=i;
	build(1,n+2,0);
	rt=(3+n)>>1;
	char ch[10];int S,T;
	for(int i=1;i<=m;i++)
	{
		scanf("%s",ch);S=read();
		switch(ch[0])
		{
		case 'T':move(S,-inf);break;
		case 'B':move(S,inf);break;
		case 'I':T=read();move(S,T);break;
		case 'A':splay(pos[S],rt);printf("%d\n",size[c[pos[S]][0]]-1);break;
		case 'Q':printf("%d\n",v[find(rt,S+1)]);break;
		}
	}
	return 0;
}
Problem1878

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int M = 200005;
int a[N],last[1000005],next[N];
int num[N],c[N];
struct ask{int x,y,ans,no;}A[M];
bool cmp(ask a,ask b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
bool cmp1(ask a,ask b){return a.no<b.no;}
void update(int x)
{
	if(x==0)return ;
	for(int i = x;i<=N;i+=i&(-i))
		c[i]++;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		if(last[a[i]]!=0)next[last[a[i]]] = i;
		else update(i);
		last[a[i]] = i;
	}
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&A[i].x,&A[i].y);
		A[i].no = i;
	}
	sort(A+1,A+m+1,cmp);
	int l = 1;
	for(int i = 1;i<= m;i++)
	{
		while(l<A[i].x)
		{
			update(next[l]);
			l++;
		}
		int tmp = getans(A[i].y);
		A[i].ans = tmp-getans(A[i].x-1);
	}
	sort(A+1,A+m+1,cmp1);
	for(int i = 1;i<= m;i++)
		printf("%d\n",A[i].ans);
	return 0;
}
Problem1901

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int INF = 1e9+1;
int n,m;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	size = cnt = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(x->val<y)
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}else
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)
		Delete(x->ls,y);
	else if(y>x->val)
		Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)
			tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_rank(root[p],y);return ;}
	int mid=(l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,y);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,y);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF;int ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans = mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int a[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	char opt[3];int x,y,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')
		{
			scanf("%d%d%d",&x,&y,&k);
			get_number(x,y,k);
		}else
		{
			scanf("%d%d",&x,&k);
			change(1,1,n,x,a[x],k);
			a[x] = k;
		}
	}
	return 0;
}
Problem1911

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
LL sum[N];
LL f[N];
int Q[N],L,R,n,a,b,c,x;
LL Y(int x)
{
    return f[x]+sum[x]*sum[x]*a;
}
int main()
{
    //memset(f,128,sizeof(f));
    scanf("%d%d%d%d",&n,&a,&b,&c);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&x);
        sum[i] = sum[i-1]+x;
    }
    L = R = 1;
    Q[L] = 0;
    for(int i = 1;i<= n;i++)
    {
        while(L<R&&-(sum[i]*2*a+b)>(double)(Y(Q[L])-Y(Q[L+1]))/(double)(sum[Q[L+1]]-sum[Q[L]]))
            L++;
        f[i] = f[Q[L]]+
               (sum[i]-sum[Q[L]])*(sum[i]-sum[Q[L]])*a+(sum[i]-sum[Q[L]])*b+c;
        while(L<R&&(double)(Y(Q[R-1])-Y(Q[R]))/(double)(sum[Q[R]]-sum[Q[R-1]])>(double)(Y(Q[R])-Y(i))/(double)(sum[i]-sum[Q[R]]))
            R--;
        Q[++R] = i;
    }
    printf("%lld",f[n]);
    return 0;
}
Problem1912

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot = 1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = 1;
	head[x] = tot;
}
int max_dep,end;
int pre[N],prp[N];
void dfs(int x,int fa,int pe,int dep)
{
	pre[x] = pe;
	prp[x] = fa;
	if(dep>max_dep)
	{
		max_dep = dep;
		end = x;
	}
	for(int i = head[x];i;i =e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,i,dep+e[i].val);
}
int md[N],stack[N],top;
bool cmp(int a,int b){return a>b;}
void dp(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			dp(e[i].to,x);
			md[x] = max(md[x],md[e[i].to]+e[i].val);
		}
	top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&md[e[i].to]+e[i].val>=0)
			stack[++top] = md[e[i].to]+e[i].val;
	sort(stack+1,stack+top+1,cmp);
	if(top>=2)max_dep = max(max_dep,stack[1]+stack[2]);
	else if(top>=1)max_dep = max(max_dep,stack[1]);
}
int main()
{
	int n,k,x,y;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0,0,0);
	int tmp = end;
	max_dep = 0;
	dfs(end,0,0,0);
	int len1 = max_dep;
	if(k==1)printf("%d\n",2*(n-1)-max_dep+1);
	else
	{
		max_dep = 0;
		while(tmp!=end)
		{
			e[pre[end]].val = -1;
			e[pre[end]^1].val = -1;
			end = prp[end];
		}
		dp(1,0);
		printf("%d\n",2*(n-1)-len1+1-max_dep+1);
	}
	return 0;
}
Problem1917

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,c[N],g[N],mrk[N],Ans[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	c[y]--;
}
int ans = 0;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			int tmp = min(c[x],c[e[i].to]);
			c[x]-=tmp,c[e[i].to]-=tmp,ans+=tmp<<1;
			if(c[e[i].to])g[x]=e[i].to;
		}
}
void solve(int x,int fa)
{
	Ans[x]=ans;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			if(c[x]){c[x]--,ans++,mrk[x]=0;}
			else if(g[e[i].to]){c[g[e[i].to]]--,ans++,mrk[x]=1;}
			else {c[e[i].to]++,ans--,mrk[x]=2;}
			solve(e[i].to,x);
			if(mrk[x]==0){c[x]++,ans--;}
			else if(mrk[x]==1){c[g[e[i].to]]++,ans--;}
			else {c[e[i].to]--,ans++;}
		}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		x++,y++;
		add(x,y),add(y,x);
	}
	ans = (n-1)<<1;
	dfs(1,0);solve(1,0);
	for(int i = 1;i<= n;i++)
		printf("%d\n",Ans[i]);
	return 0;
}
Problem1927

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,f,c,from;}e[M];
int head[N],tot=1;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	e[tot].f=f;e[tot].c=c;e[tot].from=x;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;
	e[tot].f=0;e[tot].c=-c;e[tot].from=y;
}
queue<int>Q;
int dis[N],from[N];bool v[N];
 bool spfa(int s,int t)
{
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	v[s]=true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to]=i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to]=true;
				}
			}
	}
	return dis[t]!=INF;
}
int ans,st,end;
void mcf()
{
	int x = INF;
	for(int i = from[end];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[end];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int a[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	st = 0,end = 2*n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		add(st,i,1,0);
		add(i+n,end,1,0);
		add(0,i+n,1,a[i]);
	}
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(x>y)swap(x,y);
		add(x,y+n,1,z);
	}
	while(spfa(st,end))mcf();
	printf("%d\n",ans);
	return 0;
}
Problem1930

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f,c;}e[N*N];
int head[N<<1],tot = 1;
void add(int x,int y,int f,int c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].f = f,e[tot].c = c;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	e[tot].f = 0;e[tot].c = -c;
}
int dis[N<<1],n;bool vis[N<<1];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = s;i<= t;i++)dis[i] = -1;
	dis[s] = 0;
	vis[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]<dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=-1;
}
bool visit[N<<1];
int getflow(int p,int s,int t,int mf)
{
	if(p==t)return mf;
	visit[p] = true;
	int last = mf;
	for(int i = head[p];i;i=e[i].next)
		if(e[i].f&&dis[p]+e[i].c==dis[e[i].to]&&(!visit[e[i].to]||e[i].to==t))
		{
			int tof = getflow(e[i].to,s,t,min(last,e[i].f));
			e[i].f-=tof;
			e[i^1].f+=tof;
			last-=tof;
			if(!last)
				return mf;
		}
	return mf-last;
}
int Maxcost(int s,int t)
{
	int res = 0;
	while(spfa(s,t))
	{
		memset(visit,0,sizeof(visit));
		res+=getflow(s,s,t,INF)*dis[t];
	}
	return res;
}
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
	void read()
	{
		scanf("%d%d",&x,&y);
	}
	bool operator <(const Point &s)const
	{
		return x<s.x||(x==s.x&&y<s.y);
	}
}p[N];
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		p[i].read();
	sort(p+1,p+n+1);
	add(0,1,2,0);
	int S = 1,T = 2*n+2;
	for(int i = 1;i<= n;i++)
		add(S,i<<1,1,0),
		add(i<<1|1,T,1,0),
		add(i<<1,i<<1|1,1,1),
		add(i<<1,i<<1|1,1,0);
	for(int i = 1;i<= n;i++)
	{
		int Min = INF;
		for(int j = i+1;j<= n;j++)
		{
			if(p[j].y<Min&&p[j].y>=p[i].y)
				add(i<<1|1,j<<1,2,0);
			if(p[j].y>=p[i].y)
				Min = min(Min,p[j].y);
		}
	}
	printf("%d\n",Maxcost(0,T));
	return 0;
}
Problem1935

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const int M = 500005;
int id[N*3],n,m;
struct Tree
{
	int c[N];
	Tree()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			c[i]+=y;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans+=c[i];
		return ans;
	}
}C;
struct A
{int x,y,no,ans;}ask[M<<2];
bool cmp(A a,A b)
{return a.y<b.y;}
bool fir(A a,A b)
{return a.no<b.no;}
struct T
{int x,y;}tr[N];
bool cmt(T a,T b)
{
	if(a.y!=b.y)
		return a.y<b.y;
	return a.x<b.x;
}
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l = mid+1;
		else r = mid;
	}
	if(id[l]>x)return --l;
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&tr[i].x,&tr[i].y);
		tr[i].x+=2;tr[i].y+=2;
		id[i] = tr[i].x;
	}
	sort(tr+1,tr+n+1,cmt);
	sort(id+1,id+n+1);
	int a,b,c,d,cnt = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		a+=2,b+=2,c+=2,d+=2;
		ask[++cnt].x = c;ask[cnt].y = d;ask[cnt].no = cnt;
		ask[++cnt].x = a-1;ask[cnt].y = d;ask[cnt].no = cnt;
		ask[++cnt].x = c;ask[cnt].y = b-1;ask[cnt].no = cnt;
		ask[++cnt].x = a-1;ask[cnt].y = b-1;ask[cnt].no = cnt;
	}
	sort(ask+1,ask+cnt+1,cmp);
	int j = 1;
	for(int i = 1;i<= cnt;i++)
	{
		while(tr[j].y<=ask[i].y&&j<=n)
		{
			C.update(find(tr[j].x),1);
			j++;
		}
		ask[i].ans = C.getans(find(ask[i].x));
	}
	sort(ask+1,ask+cnt+1,fir);
	for(int i = 1;i<= m;i++)
	{
		int t = (i-1)*4;
		printf("%d\n",ask[t+1].ans-ask[t+2].ans-ask[t+3].ans+ask[t+4].ans);
	}
}
Problem1951

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL mod[5] = {0,2,3,4679,35617};
LL fac[5][40000];
LL env[5][40000];
LL c(int n,int m,int modn)
{
    LL tmp = fac[modn][m]*fac[modn][n-m]%mod[modn];
    return fac[modn][n]*env[modn][tmp]%mod[modn];
}
LL lucas(int n,int m,int m_n)
{
    LL ans = 1;
    while(n&&m&&ans) 
    {
        ans = (ans*c(n%mod[m_n],m%mod[m_n],m_n))%mod[m_n];
        n /= mod[m_n];
        m /= mod[m_n];
    }
    return ans;
}
LL xx,yy,d;
void ex_gcd(LL a,LL b)
{
    if(b==0)
    {
        xx = 1;
        yy = 0;
        d = a;
        return ;
    }
    ex_gcd(b,a%b);
    LL tmp = xx;
    xx = yy;
    yy = tmp-a/b*xx;
}
LL M[15],Mt = 999911658ll,ans;
LL a[15],envM[5];
LL remain()
{
    LL ans = 0;
    for(int i = 1;i<= 4;i++)
        ans =(ans+envM[i]*a[i]*M[i]%Mt)%Mt;
    return ans;
}
LL p = 0;
void div(LL x)
{
    LL i;
    for(i = 1;i*i<= x;i++)
    {
        //printf("%lld:\n",i);
        if(x%i==0)
        {
            for(int j = 1;j<= 4;j++)
            {
                a[j] = lucas(x,i,j);
                //printf("%lld ",a[j]);
            }
            p = (p+remain())%Mt;
            //printf("\nnow_ans = %lld\n",p);
            //printf("%lld:\n",x/i);
            if(i*i!=x)
            {
                for(int j = 1;j<= 4;j++)
                {
                    a[j] = lucas(x,x/i,j);
                    //printf("%lld ",a[j]);
                }
                p = (p+remain())%Mt;
                //printf("\nnow_ans = %lld\n",p);
            }
        }
    }
}
LL quick(LL x,LL y)
{
    if(y==0)return 1;
    LL tmp = quick(x,y/2);
    if(y%2==1)return tmp*tmp%(Mt+1)*x%(Mt+1);
    else return tmp*tmp%(Mt+1);
}
int main()
{
    long long n,g;
    scanf("%lld%lld",&n,&g);
    for(int i = 1;i<= 4;i++)
    {
        M[i] = Mt/mod[i];
        ex_gcd(M[i],mod[i]);
        xx = (xx%mod[i]+mod[i])%mod[i];
        envM[i] = xx;
    }
    for(int i = 1;i<= 4;i++)
    {
        fac[i][0] = env[i][1] = 1;
        for(LL j = 1;j<= mod[i]+1;j++)
        {
            //if(j==0){fac[i][j] = 1;env[i][j] = 1;continue;}
            fac[i][j] = fac[i][j-1]*j%mod[i];
            if(j!=1)env[i][j] = ((mod[i]-mod[i]/j)*env[i][mod[i]%j])%mod[i];
        }
    }
    /*for(int i = 1;i<= 4;i++)
    {
        for(LL j = 1;j<= 4;j++)
        {
            printf("%lld %lld:%lld\n",fac[i][j],env[i][j],j*env[i][j]%mod[i]);
        }
    }*/
    div(n);
    p = p+Mt;
    printf("%lld\n",quick(g,p));
    return 0;
}
Problem1976

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 7e4+5;
const int M = 7e5+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot=1;
void add(int x,int y,int f1,int f2)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f1;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=f2;
}
queue<int>Q;
int pos[45][45][45];
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int main()
{
	int n,id = 0;
	scanf("%d",&n);
	int st = 0,end = n*n*n+1;
	for(int i=1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
				pos[i][j][k]=++id;
	for(int i= 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
			{
				if(i!=n)add(pos[i][j][k],pos[i+1][j][k],1,1);
				if(j!=n)add(pos[i][j][k],pos[i][j+1][k],1,1);
				if(k!=n)add(pos[i][j][k],pos[i][j][k+1],1,1);
			}
	char ch;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
			{
				ch = getchar();while(ch!='P'&&ch!='N'&&ch!='?')ch = getchar();
				if(ch=='P')
				{
					if((i+j+k)&1)add(st,pos[i][j][k],INF,0);
					else add(pos[i][j][k],end,INF,0);
				}else if(ch=='N')
				{
					if((i+j+k)&1)add(pos[i][j][k],end,INF,0);
					else add(st,pos[i][j][k],INF,0);
				}
			}
	int ans = dinic(st,end);
	printf("%d",3*n*n*(n-1)-ans);
	return 0;
}
Problem1997

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 2e6+5;
struct E
{int next,to;}e[M];
int head[N],tot,c[N],pos[N],u[10005],v[10005];
inline void add(int x,int y)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;}
int dfn[N],Dfn,low[N],bel[N],stack[N],top,dcc;
bool ins[N];
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	tot = Dfn = dcc = top = 0;
}
struct data
{
	int l,r;
	data(int _l=0,int _r=0):l(_l),r(_r){}
}qj[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n,m;
		scanf("%d%d",&n,&m);
		init();
		for(int i = 1;i<= m;i++)scanf("%d%d",&u[i],&v[i]);
		for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
		for(int i = 1;i<= n;i++)pos[c[i]] = i;
		if(m>3*n-6){puts("NO");continue;}
		int cnt = 0,x,y;
		for(int i = 1;i<= m;i++)
		{
			x = pos[u[i]],y = pos[v[i]];
			if(x>y)swap(x,y);
			if(y-x==1||(x==1&&y==n))continue;
			qj[++cnt] = data(x,y);
		}
		m = cnt;
		for(int i = 1;i<= m;i++)
			for(int j = i+1;j<= m;j++)
				if((qj[i].l<qj[j].l&&qj[j].l<qj[i].r&&qj[i].r<qj[j].r)||
					(qj[j].l<qj[i].l&&qj[i].l<qj[j].r&&qj[j].r<qj[i].r))
				{
					add(i<<1,j<<1|1);
					add(i<<1|1,j<<1);
					add(j<<1,i<<1|1);
					add(j<<1|1,i<<1);
				}
		for(int i = 2;i<= (m<<1|1);i++)
			if(!dfn[i])tarjan(i);
		bool flag = true;
		for(int i = 1;i<= m&&flag;i++)
			if(bel[i<<1]==bel[i<<1|1])flag = false;
		if(flag)puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem1999

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 5e5+5;
struct E
{int next,to,val;}e[M<<1];
int head[M],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].val  = f;
	e[tot].next = head[x];
	head[x] = tot;
}
queue <int>Q;
int pre[M];
int path[M],cnt,v[M];
LL dis[M],dep[M],Mdep[M],lth[M];
int line[M],L,R;
int end,n,s;
void bfs(int s)
{
	Q.push(s);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!dis[e[i].to]&&e[i].to!=s)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(dis[e[i].to]>dis[end])end = e[i].to;
				Q.push(e[i].to);
			}
	}
	int st = end;
	memset(dis,0,sizeof(dis));
	Q.push(st);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!dis[e[i].to]&&e[i].to!=st)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				pre[e[i].to] = x;
				if(dis[e[i].to]>dis[end])end = e[i].to;
				Q.push(e[i].to);
			}
	}
	int x = end;
	while(x!=st)
	{
		path[++cnt] = x;
		lth[cnt] = dis[end]-dis[x];
		v[x] = true;
		x = pre[x];
	}
	path[++cnt] = x;
	v[x] = true;
	lth[cnt] = dis[end]-dis[x];
	return ;
}
void get_Maxdep(int st,int no)
{
	dep[st] = 0;
	Q.push(st);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		Mdep[no] = max(Mdep[no],dep[x]);
		for(int i = head[x];i;i = e[i].next)
			if(!v[e[i].to]&&!dep[e[i].to])
				dep[e[i].to] = dep[x]+e[i].val,Q.push(e[i].to);
	}
}
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c);
		add(y,x,c);
	}
	bfs(1);
	for(int i = 1;i<= cnt;i++)
		get_Maxdep(path[i],i);
	int j = 1;
	LL ans = 1e18+1;
	L = 0,R = -1;
	for(int i = 1;i<= cnt;i++)
	{
		while(L<=R&&lth[i]-lth[line[L]]>s)L++;
		while(i>=j&&lth[i]-lth[j]>s)j++;
		while(L<=R&&Mdep[i]>=Mdep[line[R]])R--;
		line[++R] = i;
		ans = min(ans,max(Mdep[line[L]],max(lth[j],lth[cnt]-lth[i])));
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2001

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 0x3f3f3f3f;
typedef long long ll;
int fa[N],Fa[N];
void Init(int n)
{
	for(int i = 1;i<=n;i++)fa[i] = i;
}
int getfa(int x)
{
	return fa[x]==x?x:(fa[x]=getfa(fa[x]));
}
struct P
{
	int x,y,w,k,id;
	bool operator<(const P &s)const 
		{return w<s.w;}
}e[20][N];
struct C
{
	int x,to;
}chg[N];
int pos[N],dis[N],pa[N];
void init(int m)
{
	for(int i = 1;i<= m;i++)
		dis[e[0][i].id] = e[0][i].w;
}
void solve(int d,int L,int R,int n,int m,ll ans = 0ll)
{
	for(int i = 1;i<= m;i++)
	{
		P &a = e[d][i],a2 = e[d-1][i];
		a = (P){a2.x,a2.y,dis[a2.id],0,a2.id};
		pos[a.id] = i;
	}
	if(L==R)
	{
		C &b = chg[L];
		e[d][pos[b.x]].w = dis[b.x] = b.to;
		Init(n);
		sort(e[d]+1,e[d]+m+1);
		for(int i = 1;i<= m;i++)
		{
			P &tmp = e[d][i];
			int x = getfa(tmp.x),y = getfa(tmp.y);
			if(x==y)continue;
			fa[y] = x;
			ans+=tmp.w;
		}
		printf("%lld\n",ans);
		return ;
	}
	int mid = (L+R)>>1;
	for(int i = L;i<=R;i++)e[d][pos[chg[i].x]].k = 1;
	Init(n);
	sort(e[d]+1,e[d]+m+1);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			a.k = 2;
		}
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==1)e[d][i].w = -INF;
	Init(n);
	sort(e[d]+1,e[d]+m+1);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k!=0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			if(a.k!=1)a.k = 3;
		}
	Init(n);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==3)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			ans+=a.w;
		}
	int newn = 0,newm = 0;
	for(int i = 0;i<= n;i++)Fa[i] = 0;
	for(int i = 1;i<= n;i++)
	{
		int x = getfa(i);
		if(!Fa[x])Fa[x] = ++newn;
	}
	for(int i = 1;i<= m;i++)
		if(e[d][i].k!=0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			e[d][++newm] = (P){Fa[x],Fa[y],a.w,a.k,a.id};
		}
	solve(d+1,L,mid,newn,newm,ans);
	solve(d+1,mid+1,R,newn,newm,ans);
}
int main()
{
	int n,m,q;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&e[0][i].x,&e[0][i].y,&e[0][i].w);
		e[0][i].id = i;
	}
	for(int i = 1;i<= q;i++)
		scanf("%d%d",&chg[i].x,&chg[i].to);
	init(m);
	solve(1,1,q,n,m);
	return 0;
}
Problem2002

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 2e5+5;
struct Splay{
	Splay *fa,*ls,*rs;
	int size;
	void push_up();
	Splay();
}*null = new Splay(),tree[M];
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
Splay :: Splay()
{
	ls = rs = fa = null;
	size = 1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==x->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void link(Splay *x,Splay *y)
{
	access(x);
	splay(x);
	x->ls->fa = null;
	x->ls = null;
	x->fa = y;
	x->push_up();
}
int main()
{
	null->ls = null->rs = null->fa = null;
	null ->size = 0;
	int n,x;
	Splay *root;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(i+x<=n)
			tree[i].fa = &tree[i+x];
	}
	int m,p,y;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&p);
		if(p==1)
		{
			scanf("%d",&x);x++;
			access(&tree[x]);
			splay(&tree[x]);
			printf("%d\n",tree[x].size);
		}else
		{
			scanf("%d%d",&x,&y);x++;
			if(x+y<=n)root = &tree[x+y];
			else root = null;
			link(&tree[x],root);
		}
	}
	return 0;
}
Problem2004

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<set>
#include<ctime>
#include<vector>
#include<queue>
#include<algorithm>
#include<map>
#include<cmath>
#define mod 30031
#define inf 1000000000
#define rad 100000000
#define pa pair<int,int>
#define ll long long 
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int bin[20];
int n,K,P,cnt;
int v[205];
struct M{
	ll v[205][205];
	M(){
		memset(v,0,sizeof(v));
	}
	friend M operator*(M a,M b){
		M c;
		for(int i=1;i<=cnt;i++)
			for(int j=1;j<=cnt;j++)
			{
				for(int k=1;k<=cnt;k++)
					c.v[i][j]+=a.v[i][k]*b.v[k][j];
				c.v[i][j]%=mod;
			}
		return c;
	}
	friend M operator^(M a,int b){
		M ans;
		for(int i=1;i<=cnt;i++)ans.v[i][i]=1;
		for(int i=b;i;i>>=1,a=a*a)
			if(i&1)ans=ans*a;
		return ans;
	}
}a,b,ans;
int lowbit(int x)
{
	return x&(-x);
}
void dfs(int now,int num,int sta)
{
	if(num==K)
	{
		v[++cnt]=sta;
		return;
	}
	for(int i=now-1;i;i--)
		dfs(i,num+1,sta+bin[i-1]);
}
void pre()
{
	for(int i=1;i<=cnt;i++)
		for(int j=1;j<=cnt;j++)
		{
			int x=(v[i]<<1)^bin[P]^v[j];
			if(x==lowbit(x))
			    b.v[i][j]=1;
		}
}
int main()
{
	bin[0]=1;for(int i=1;i<20;i++)bin[i]=bin[i-1]<<1;
	n=read();K=read();P=read();
	dfs(P,1,bin[P-1]);
	pre();
	ans.v[1][1]=1;
	M t=b^(n-K);
	ans=ans*t;
	printf("%d\n",ans.v[1][1]);
	return 0;
}
Problem2005

#include<stdio.h>
typedef long long LL;
long long f[100005];
LL min(LL a,LL b)
{
    if(a>b)return b;
    return a;
}
int main()
{
    LL n,m;
    scanf("%lld%lld",&n,&m);
    LL tmp = min(n,m);
    LL ans = 0;
    for(LL i = tmp;i>=1;i--)
    {
        f[i] = (n/i)*(m/i);
        for(LL j = 2;j<= n/i;j++)
        {
            f[i] = f[i] - f[i*j];
        }
        ans = ans+f[i]*(2*i-1);
    }
    printf("%lld",ans);
    return 0;
}
Problem2007

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
//int map[N][N][4];
struct E{int to,next,val;}e[N*N*9];
int head[N*N],tot,cnt,st,end,n;
struct H{int v;long long p;}P[N*N*4];
void go_up(int x)
{
	int i = x;
	while((i>>1)>=1&&P[i].v<P[i>>1].v)
	{
		swap(P[i],P[i>>1]);
		i = i>>1;
	}
}
int getnum(int i,int j){return (i-1)*n+j;}
bool cmp(H a,H b){return a.v>b.v;}
void go_down(int x)
{
	int i = x;
	while(((i<<1)|1)<=cnt)
	{
		if(P[i].v>P[i<<1].v&&P[i].v>P[(i<<1)|1].v)
		{
			swap(P[i],P[i<<1].v>P[(i<<1)|1].v?P[(i<<1)|1]:P[i<<1]);
			i = P[i<<1].v>P[(i<<1)|1].v?((i<<1)|1):(i<<1);
		}else if(P[i].v>P[i<<1].v)
		{
			swap(P[i],P[i<<1]);
			i = i<<1;
		}
		else if(P[i].v>P[i<<1|1].v)
		{
			swap(P[i],P[i<<1|1]);
			i = i<<1|1;
		}
		else break;
	}
	if((i<<1)<=cnt&&P[i<<1].v<P[i].v)
		swap(P[i],P[i<<1]);
}
void insert(int per,long long lth)
{
	H tmp;
	tmp.v = lth;tmp.p = per;
	P[++cnt] = tmp;
	go_up(cnt);
}
int pop()
{
	int tmp = P[1].p;
	swap(P[1],P[cnt]);
	cnt--;
	go_down(1);
	return tmp;
}
long long f[N*N];
bool in[N*N];
void dijk()
{
	memset(f,0x3f,sizeof(f));
	f[st] = 0;
	P[1].v = 0,P[1].p = st;
	cnt++;
	//insert(st,0);
	while(cnt)
	{
		int x = P[1].p;
		pop_heap(P+1,P+cnt+1,cmp);
		cnt--;
		if(in[x])continue;
		in[x] = true;
		for(int i = head[x];i;i = e[i].next)
		{
			int y = e[i].to;
			if(f[x]+e[i].val<f[y])
			{
				f[y] = f[x]+e[i].val;
				cnt++;
				P[cnt].p = y;P[cnt].v = f[y];
				push_heap(P+1,P+cnt+1,cmp);
				//insert(y,f[y]);
			}
		}
	}
	return ;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void show_edge(int x)
{
    for(int i = head[x];i;i = e[i].next)
        printf("%d %d:%d\n",x,e[i].to,e[i].val);
}
int main()
{
	scanf("%d",&n);
	int a;
	st = n*n+1,end = n*n+2;
    for(int i=1;i<=n;i++){scanf("%d",&a);add(st,getnum(1,i),a);}
    for(int i=1;i<n;i++)
        for(int j=1;j<=n;j++) 
            {scanf("%d",&a);add(getnum(i,j),getnum(i+1,j),a);}
    for(int i=1;i<=n;i++)
        {scanf("%d",&a);add(getnum(n,i),end,a);}
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        add(getnum(i,1),end,a);
        for(int j=2;j<=n;j++) {scanf("%d",&a);add(getnum(i,j),getnum(i,j-1),a);}
        scanf("%d",&a);
    	add(st,getnum(i,n),a);
    }
    for(int i=1;i<=n;i++) scanf("%d",&a);
    for(int i=1;i<n;i++)
        for(int j=1;j<=n;j++) 
        	{scanf("%d",&a);add(getnum(i+1,j),getnum(i,j),a);}
    for(int i=1;i<=n;i++) scanf("%d",&a);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        for(int j=2;j<=n;j++){scanf("%d",&a);add(getnum(i,j-1),getnum(i,j),a);}
        scanf("%d",&a);
    }
	dijk();
	printf("%lld\n",f[end]);
	return 0;
}
Problem2038

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 50100;
int n,q,size;
int pos[N],c[N];
ll s[N];
ll sqr(ll x){return x*x;}
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
struct Ask
{
	int l,r,bel;
	ll up,dwn;
	bool operator <(const Ask &s)const
	{
		if(pos[l]==pos[s.l])return r<s.r;
		else return l<s.l;
	}
}ask[N];
bool cmp(const Ask &a,const Ask &b)
{
	return a.bel<b.bel;
}
ll ans;
void update(int x,int add)
{
	ans-=sqr(s[c[x]]);
	s[c[x]]+=add;
	ans+=sqr(s[c[x]]);
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	size = sqrt(n)+1;
	for(int i = 1;i<= n;i++)
		pos[i] = i/size;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].bel = i;
	}
	sort(ask+1,ask+m+1);
	int l = 1,r = 0;
	for(int i = 1;i<= m;i++)
	{
		while(r<ask[i].r)r++,update(r,1);
		while(r>ask[i].r)update(r,-1),r--;
		while(l>ask[i].l)l--,update(l,1);
		while(l<ask[i].l)update(l,-1),l++;
		if(ask[i].l==ask[i].r)
			ask[i].up = 0,ask[i].dwn = 1;
		else
		{
			ask[i].up = ans-(ask[i].r-ask[i].l+1);
			ask[i].dwn = (ll)(ask[i].r-ask[i].l+1)*(ask[i].r-ask[i].l);
			ll g = gcd(ask[i].up,ask[i].dwn);
			ask[i].up/=g,ask[i].dwn/=g;
		}
	}
	sort(ask+1,ask+m+1,cmp);
	for(int i = 1;i<= m;i++)
		printf("%lld/%lld\n",ask[i].up,ask[i].dwn);
	return 0;
}
Problem2049

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
struct Splay
{
	Splay *ls,*rs,*fa;
	bool rev;
	Splay();
	void reverse();
	void push_down();
}*null = new Splay(),tree[N];
void Splay :: push_down()
{
	if(fa->ls==this||fa->rs==this)
		fa->push_down();
	if(rev)
	{
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		ls->rev^=1;
		rs->rev^=1;
		rev = 0;
	}
}
Splay :: Splay()
{
	ls = rs = fa = null;
	rev = false;
}
void Splay :: reverse()
{
	swap(ls,rs);
	rev^=1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void splay(Splay *x)
{
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else 
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
Splay* find_root(Splay *x)
{
	while(x->fa!=null)
		x = x->fa;
	return x;
}
void link(Splay *x,Splay *y)
{
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	x->fa = null;
	y->ls = null;
}
int main()
{
	null->ls = null->rs = null->fa = null;
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	char opt[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		scanf("%d%d",&x,&y);
		if(opt[0]=='C')link(&tree[x],&tree[y]);
		else if(opt[0]=='D')cut(&tree[x],&tree[y]);
		else
		{
			Splay *tmp = find_root(&tree[x]);
			if(tmp==find_root(&tree[y]))printf("Yes\n");
			else printf("No\n");
		}
	}
	return 0;
}
Problem2055

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f,c,from;
}e[M];
int head[N],tot = 1;
int in[N],out[N],ans;
void add(int x,int y,int lr,int ur,int c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].f = ur-lr,e[tot].c = c,e[tot].from = x;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	e[tot].f = 0;e[tot].c = -c;e[tot].from = y;
	out[x]+=lr,in[y]+=lr;
	ans+=lr*c;
}
bool vis[N];
int dis[N],from[N];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = 1;i<= t;i++)dis[i] = INF,vis[i] = false;
	Q.push(s);
	dis[s] = 0;
	vis[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=INF;
}
void get_mcf(int s,int t)
{
	int x = INF;
	for(int i = from[t];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[t];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=x*e[i].c;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int SS = n+n+2,TT = n+n+3,S = n+n+4,T = n+n+5;
	add(SS,n+n+1,0,m,0);
	for(int i = 1;i<= n;i++)
		add(n+n+1,i,0,INF,0),add(i+n,TT,0,INF,0);
	int x;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		add(i,i+n,x,x,0);
	}
	for(int i = 1;i< n;i++)
		for(int j = 1;j<=n-i;j++)
		{
			scanf("%d",&x);
			if(x==-1)continue;
			add(n+i,i+j,0,INF,x);
		}
	add(TT,SS,0,INF,0);
	for(int i = 1;i<= TT;i++)
		if(in[i]<out[i])
			add(i,T,0,out[i]-in[i],0);
		else if(out[i]<in[i])
			add(S,i,0,in[i]-out[i],0);
	while(spfa(S,T))get_mcf(S,T);
	printf("%d\n",ans);
	return 0;
}
Problem2064

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1<<10;
const int INF = 0x3f3f3f3f;
int cnt[M];
int f[M][M],logn[15];
int a[15],b[15],suma[M],sumb[M];
void dfs(int k,int state,int *t,int s,int *ans)
{
    if(k==t[0]+1)return ;
    ans[state<<(t[0]-k)]=s;
    dfs(k+1,state*2+1,t,s+t[k+1],ans);
    dfs(k+1,state*2,t,s,ans);
}
void init()
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	for(int i = 2;i<= 10;i++)
		logn[i] = logn[i>>1]+1;
	dfs(0,0,a,0,suma);
    dfs(0,0,b,0,sumb);
}
int main()
{
	//memset(f,0x3f,sizeof(f));
	scanf("%d",&a[0]);
	for(int i = 1;i<= a[0];i++)
		scanf("%d",&a[i]);
	scanf("%d",&b[0]);
	for(int i = 1;i<= b[0];i++)
		scanf("%d",&b[i]);
	init();
	for(int i = 1;i<1<<a[0];i++)
	{
		for(int j = 1;j<1<<b[0];j++)
		{
			for(int k = 1;k<= a[0];k++)
			{
				int tmp = 1<<(k-1);
				if((i&tmp)>0)f[i][j] = max(f[i][j],f[i-tmp][j]);
			}
			for(int k = 1;k<= b[0];k++)
			{
				int tmp = 1<<(k-1);
				if((j&tmp)>0)f[i][j] = max(f[i][j],f[i][j-tmp]);
			}
			if(suma[i]==sumb[j])f[i][j]++;
		}
	}
	printf("%d\n",a[0]+b[0]-2*f[(1<<a[0])-1][(1<<b[0])-1]);
	return 0;
}
Problem2073

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 17;
const int S = 1<<16;
int w[N],t[N],cnt,v[S],f[S];
int gt[S],n,W;
void init()
{
	for(int i = 0;i<1<<n;i++)
	{
		int Gw = 0,Gt = 0;
		for(int j = 0;j<n;j++)
			if(i&(1<<j))
			{
				Gw+=w[j+1];
				Gt = max(Gt,t[j+1]);
			}
		if(Gw<=W)
		{
			gt[++cnt] = Gt;
			v[i] = cnt;
		}
	}
}
int main()
{
	memset(f,0x3f,sizeof(f));
	scanf("%d%d",&W,&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&t[i],&w[i]);
	init();
	f[0] = 0;
	for(int i = 0;i<1<<n;i++)
	{
		for(int k = i;k;k = (k-1)&i)
			if(v[k])
				f[i] = min(f[i],f[i-k]+gt[v[k]]);
	}
	printf("%d\n",f[(1<<n)-1]);
	return 0;
}
Problem2079

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		uni(x,y);
	}
	bool flag = true;
	for(int i = 1;i<= n;i++)
		if(fa[i]==0)
			flag = false;
	if(flag)printf("TAK\n");
	else printf("NIE\n");
	return 0;
}
Problem2084

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int s[N],a[N<<1];
int no[N<<1],p[N<<1];
long long ans;
int maxp,id;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%1d",&s[i]);
	int len = 0;
	for(int i = 1;i<=n;i++)
	{
		a[++len]=s[i];
		no[len]=i;
		if(i!=n)a[++len]=-1;
	}
	maxp = 1,id = 1;
	for(int i = 1;i<= len;i++)
	{
		if(i<=maxp)p[i]=min(p[id*2-i],maxp-i);
		while(i+p[i]<=len&&i-p[i]>=1&&(a[i+p[i]]+a[i-p[i]]==1||a[i+p[i]]+a[i-p[i]]==-2))p[i]++;
		p[i]--;
		if(i+p[i]>maxp){maxp = i+p[i];id = i;}
		ans+=(no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1])-(no[i]?no[i]:no[i+1])+1;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2086

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
int stack[N],top;
int a[N];
LL sum[N];
int main()
{
	int n,m,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	while(m--)
	{
		scanf("%d",&k);
		for(int i = 1;i<= n;i++)
			sum[i] = sum[i-1]+a[i]-k;
		for(int i = 1;i<= n;i++)
			if(sum[i]<sum[stack[top]])
				stack[++top] = i;
		int ans = 0;
		for(int i = n;i>=0;i--)
		{
			while(top&&sum[i]>=sum[stack[top-1]])top--;
			ans = max(ans,i-stack[top]);
		}
		if(m)printf("%d ",ans);
		else printf("%d\n",ans);
	}
	return 0;
}
Problem2095

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2005;
const int EM = 1e6+5;
const int INF = 0x3f3f3f3f;
struct Edge
{
	int x,y,a,b;
	Edge(int x=0,int y=0,int a=0,int b=0):x(x),y(y),a(a),b(b){}
}ed[M];
struct E
{int next,to,f;}e[EM];
int head[N],tot=1,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int fa[N],cnt;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
	cnt--;
}
int dgr[N],S,T;
bool judge(int ans)
{
	memset(fa,0,sizeof(fa));cnt=n;
	memset(head,0,sizeof(head));tot = 1;
	memset(dgr,0,sizeof(dgr));
	for(int i = 1;i<= m;i++)
	{
		if(ed[i].b<=ans)
		{
			uni(ed[i].x,ed[i].y);
			dgr[ed[i].x]++;
			dgr[ed[i].y]--;
			add(ed[i].x,ed[i].y,1);
		}
		else if(ed[i].a<=ans)
		{
			uni(ed[i].x,ed[i].y);
			dgr[ed[i].x]--;
			dgr[ed[i].y]++;
		}
	}
	if(cnt>=2)return false;
	for(int i = 1;i<= n;i++)
	{
		if(dgr[i]&1)return false;
		if(dgr[i]>0)
			add(S,i,dgr[i]>>1);
		else add(i,T,(-dgr[i])>>1);
	}
	dinic(S,T);
	for(int i =head[S];i;i=e[i].next)
		if(e[i].f)
			return false;
	return true;
}
int main()
{
	scanf("%d%d",&n,&m);
	S = 0,T = n+1;
	int x,y,a,b,max_num = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&a,&b);
		if(a>b)swap(a,b),swap(x,y);
		ed[i]=Edge(x,y,a,b);
		max_num = max(max_num,b);
	}
	int l = 1,r = max_num+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(judge(mid))r = mid;
		else l = mid+1;
	}
	if(l!=max_num+1)printf("%d\n",l);
	else printf("NIE\n");
	return 0;
}
Problem2096

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3000005;
int q1[N],q2[N],l1,l2,r1,r2;
int a[N];
int main()
{
	int n,k,ans = 0;
	scanf("%d%d",&k,&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&a[q1[r1]]<a[i])r1--;q1[++r1] = i;
		while(l2<=r2&&a[q2[r2]]>a[i])r2--;q2[++r2] = i;
		while(a[q1[l1]]-a[q2[l2]]>k)
		{
			j++;
			while(l1<=r1&&q1[l1]<j)l1++;
			while(l2<=r2&&q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2097

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int stack[N],cnt,a[N];
bool cmp(int a,int b){return a>b;}
int dp(int x,int fa,int lim)
{
	int top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			a[e[i].to] = dp(e[i].to,x,lim);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			stack[++top] = a[e[i].to];
	sort(stack+1,stack+top+1,cmp);
	int max_dep = 0;
	if(top)
	{
		int i;
		for(i = 1;i<= top;i++)
		{
			if(stack[i]+1>lim)
				cnt++;
			else if(i<top&&stack[i]+stack[i+1]+2>lim)
				cnt++;
			else break;
		}
		if(i<=top)max_dep = stack[i]+1;
	}
	return max_dep;
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	int L = 0,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		cnt = 0;
		dp(1,0,mid);
		if(cnt>k)L = mid+1;
		else R = mid;
	}
	printf("%d\n",L);
	return 0;
}
Problem2115

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2e5+5;
const int N = 5e4+5;
typedef long long ll;
struct E
{
	int to,next;
	ll val;
}e[N<<1];
int head[N],tot;
void add(int x,int y,ll f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
ll sum[N];
void dfs(int x,int f)
{
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=f)
	{
		sum[e[i].to] = sum[x]^e[i].val;
		dfs(e[i].to,x);
	}
}
int st[M],end[M];
ll a[M],p[70],dis[M];
bool on_tree[M];
int father[N];
int getfa(int x)
{
	if(father[x]==x)return x;
	else return father[x] = getfa(father[x]);
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)father[i] = i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%lld",&st[i],&end[i],&dis[i]);
		int fx = getfa(st[i]),fy = getfa(end[i]);
		if(fx==fy)continue;
		add(st[i],end[i],dis[i]);
		on_tree[i] = true;
		father[fx] = fy;
	}
	dfs(1,0);
	ll ans = sum[n];
	int tot = 0;
	for(int i = 1;i<= m;i++)
		if(!on_tree[i])
			a[++tot] = sum[st[i]]^sum[end[i]]^dis[i];
	for(int i = 1;i<= tot;i++)
		for(int j = 63;j>= 0;j--)
			if((a[i]>>j)&1)
			{
				if(!p[j]){p[j] = a[i];break;}
				else a[i]^=p[j];
			}
	for(int i = 63;i>= 0;i--)if((ans^p[i])>ans)ans = ans^p[i];
	printf("%lld\n",ans);
	return 0;
}
Problem2121

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int dp[155][35],f[155],p[155][35],len[35],bin[25],n,m;
bool ok[155][155];
char s[35][25],str[155];

int main()
{
	scanf("%s",str+1);
	m = strlen(str+1);
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s[i]+1);
		len[i] = strlen(s[i]+1);
	}
	bin[0] = 1;
	for(int i = 1;i<= 22;i++)
		bin[i] = bin[i-1]<<1;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= len[j];k++)
				if(str[i]==s[j][k])
					p[i][j]|=bin[k];
	for(int i = m;i;i--)
	{
		for(int j = 1;j<= n;j++)dp[i-1][j] = 1;
		for(int j = i;j<= m;j++)
		for(int k = 1;k<= n;k++)
		{
			dp[j][k]=(dp[j-1][k]<<1)&p[j][k];
            for (int x=i; x<j; x++) if (ok[x+1][j]) dp[j][k]|=dp[x][k];
			if  (dp[j][k]&bin[len[k]]) ok[i][j]=1;
		}
	}
	for(int i = 1;i<= m;i++)
	{
		f[i] = f[i-1]+1;
		for(int j = 1;j<= i;j++)
			if(ok[j][i])
				f[i] = min(f[i],f[j-1]);
	}
	printf("%d\n",f[m]);
	return 0;
}
Problem2124

#include<iostream>  
#include<cstdio>  
#include<cstring>  
#define ll long long  
#define mod 1000000007  
#define N 10005  
using namespace std;  
  
int n,a[N],pw[N];  
struct bit_node
{  
	int c[N];  
	void clr()
	{ memset(c,0,sizeof(c)); }  
	void add(int x)
	{  
		int i; for (i=x; i<=n; i+=i&-i) c[i]=(c[i]+pw[i-x])%mod;  
	}  
	int getsum(int x)
	{  
		int i,t=0; for (i=x; i; i^=i&-i) t=((ll)c[i]*pw[x-i]+t)%mod;  
		return t;  
	}  
	int qry(int x,int y)
	{  
		int p=getsum(x-1),q=getsum(y);  
		return (q-(ll)p*pw[y-x+1]%mod+mod)%mod;  
	}  
}bit1,bit2;  
int main()
{  
	int cas,i;
	scanf("%d",&cas);  
	pw[0]=1;
	for(i=1; i<=10000; i++) 
		pw[i]=(ll)pw[i-1]*12347%mod;  
	while (cas--)
	{  
		scanf("%d",&n); 
		int x;  
		for (i=1; i<=n; i++) 
			scanf("%d",&a[i]);  
		bit1.clr(); bit2.clr();  
		for (i=1; i<=n; i++)
		{  
			x=min(a[i]-1,n-a[i]);  
			if (x && bit1.qry(a[i]-x,a[i]-1)!=bit2.qry(n-a[i]-x+1,n-a[i])) break;  
			bit1.add(a[i]); bit2.add(n-a[i]+1);  
		}  
		puts((i>n)?"N":"Y");  
	}  
	return 0;  
}  
Problem2125

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,m,q;
namespace Cactus
{
	struct E
	{int next,to,val;}e[N];
	int head[N],tot=1;
	int fa[N],dep[N],dfn[N],Dfn;
	bool on_ring[N];
}
namespace RST
{
	struct E
	{
		int next,to,dis,val;
	}e[N];
	int head[N],tot=1,size[N],dis[N],n;
	int fa[N][18],dep[N];
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void getinfo(int x,int pre)
	{
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<= 17;i++)
			fa[x][i] =fa[fa[x][i-1]][i-1];
		if(x<=::n)
		{
			for(int i = head[x];i;i=e[i].next)
				if(i^pre^1)
				{
					if(e[i].to<=::n)e[i].dis = e[i].val = abs(Cactus::dep[e[i].to]-Cactus::dep[x]);
					else e[i].val = e[i].dis = 0;
				}
		}else
		{
			for(int i = head[x];i;i=e[i].next)
				if(i^pre^1)
				{
					e[i].dis = (Cactus::dep[e[i].to]-Cactus::dep[fa[x][0]]+size[x])%size[x];
					e[i].val = min(e[i].dis,size[x]-e[i].dis);
				}
		}
		for(int i = head[x];i;i=e[i].next)
			if(pre^i^1)
			{
				fa[e[i].to][0] = x;
				dis[e[i].to] = dis[x]+e[i].val;
				getinfo(e[i].to,i);
			}
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 17;i>= 0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 17;i>= 0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	int go_up(int x,int d)
	{
		for(int i = 17;i>= 0;i--)
			if((d>>i)&1)x = fa[x][i];
		return x;
	}
	int getans(int x,int y)
	{
		int lca = getlca(x,y);
		if(lca<=::n)return dis[x]+dis[y]-dis[lca]*2;
		else
		{
			int tx = go_up(x,dep[x]-dep[lca]-1);
			int ty = go_up(y,dep[y]-dep[lca]-1);
			int tmp = ((Cactus::dep[tx]-Cactus::dep[ty])%size[lca]+size[lca])%size[lca];
			return dis[x]+dis[y]-dis[tx]-dis[ty]+min(tmp,size[lca]-tmp);
		}
	}
}
namespace Cactus
{
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
	}
	void dfs(int x,int pre)
	{
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)if(i^pre^1)
		{
			if(!dfn[e[i].to])
			{
				fa[e[i].to] = x;
				dep[e[i].to] = dep[x]+e[i].val;
				on_ring[x] = false;
				dfs(e[i].to,i);
				if(!on_ring[x])
					RST::add(x,e[i].to);
			}else
			{
				if(dfn[e[i].to]>dfn[x])
					continue;
				int tmp = x;
				++RST::n;
				while(true)
				{
					RST::add(RST::n,tmp);
					on_ring[tmp] = true;
					if(tmp==e[i].to)break;
					tmp = fa[tmp];
				}
				RST::size[RST::n] = dep[x]-dep[e[i].to]+e[i].val;
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	RST::n = n;
	int x,y,z;
	while(m--)
	{
		scanf("%d%d%d",&x,&y,&z);
		Cactus::add(x,y,z);
	}
	Cactus::dfs(1,0);
	RST::getinfo(1,0);
	while(q--)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",RST::getans(x,y));
	}
	return 0;
}
Problem2130

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int mx[N<<2],lmx[N<<2],rmx[N<<2];
int F[N<<2];
void Push_up(int p)
{
	lmx[p] = lmx[p<<1];
	rmx[p] = rmx[p<<1|1];
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
int sa[N],sb[N],sc[N],a[N],b[N],c[N],pb[N],pc[N],K[N],f[N];
void update(int p,int r,int v)
{
	lmx[p] = rmx[p] = F[p] = v;
	mx[p] = v+sb[r];
}
void build(int p,int l,int r)
{
	F[p] = -1;
	if(l==r)
	{
		lmx[p] = rmx[p] = f[l];
		mx[p] = f[l]+sb[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	Push_up(p);
}
void Update(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b)
	{
		if(lmx[p]<=v)return ;
		if(rmx[p]>=v){update(p,r,v);return ;}
	}
	int mid = (l+r)>>1;
	if(F[p]!=-1)
		update(p<<1,mid,F[p]),update(p<<1|1,r,F[p]),F[p]=-1;
	if(a<=mid)Update(p<<1,l,mid,a,b,v);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,v);
	Push_up(p);
}
int main()
{
	char opt[3];
	scanf("%s",opt);
	int cas,i;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		for(i = 1;i<= n;i++)scanf("%d",&K[i]);
		for(i = 1;i<= n;i++)scanf("%d",&a[i]);
		for(i = 1;i<= n;i++)scanf("%d",&b[i]),pb[b[i]]=i;
		for(i = 1;i<= n;i++)scanf("%d",&c[i]),pc[c[i]]=i;
		for(i = 1;i<= n;i++)scanf("%d",&sa[i]),sa[i]+=sa[i-1];
		for(i = 1;i<= n;i++)scanf("%d",&sb[i]),sb[i]+=sb[i-1];
		for(i = 1;i<= n;i++)scanf("%d",&sc[i]),sc[i]+=sc[i-1];
		f[0] = sc[n];
		for(int i = 1;i<= n;i++)
			if(K[b[i]]==1)
				f[i] = min(f[i-1],sc[pc[b[i]]-1]);
			else
				f[i] = f[i-1];
		build(1,0,n);
		int ans = mx[1];
		for(int i = 1;i<= n;i++)
		{
			if(K[a[i]]==1)
			{
				Update(1,0,n,pb[a[i]],n,-1<<30);
				Update(1,0,n,0,n,sc[pc[a[i]]-1]);
			}else
				Update(1,0,n,pb[a[i]],n,sc[pc[a[i]]-1]);
			ans = max(ans,sa[i]+mx[1]);
		}
		printf("%d",ans);
		puts("");
	}
	return 0;
}
Problem2134

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10000005;
int a[N];
int main()
{
	int n,A,B,C;
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1); 
	for(int i=2;i<=n;i++) 
		a[i] = ((long long)a[i-1]*A+B)%100000001; 
	for(int i=1;i<=n;i++) 
		a[i] = a[i]%C+1; 
	double ans = 1.0/(double)max(a[1],a[n]);
	for(int i = 2;i<= n;i++)
		ans+=1.0/(double)max(a[i],a[i-1]);
	printf("%.3f\n",ans);
	return 0;
}
Problem2141

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->rs)x = x->ls;
		else if(!x->ls)x = x->rs;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int get_less(Treap *x,int y)
{
	int tmp = 0;
	if(!x)return tmp;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return tmp;
	}else if(y<x->val)return get_less(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_less(x->rs,y);
	}
}
int get_lessnqul(Treap *x,int y)
{
	int tmp = 0;
	if(!x)return tmp;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		tmp+=x->cnt;
		return tmp;
	}else if(y<x->val)return get_lessnqul(x->ls,y);
	else 
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_lessnqul(x->rs,y);
	}
}
int get_bigger(int p,int l,int r,int a,int b,int y)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)return r-l+1-get_lessnqul(root[p],y);
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=get_bigger(p<<1,l,mid,a,b,y);
	if(b >mid)ans+=get_bigger(p<<1|1,mid+1,r,a,b,y);
	return ans;
}
int get_smaller(int p,int l,int r,int a,int b,int y)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)return get_less(root[p],y);
	int mid=(l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=get_smaller(p<<1,l,mid,a,b,y);
	if(b >mid)ans+=get_smaller(p<<1|1,mid+1,r,a,b,y);
	return ans;
}
void update(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,a,b);
	else update(p<<1|1,mid+1,r,pos,a,b);
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
int a[N];
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		build(1,1,n,i,a[i]);
	int ans = 0;
	for(int i=1;i<=n;i++)
		ans+=get_bigger(1,1,n,1,i-1,a[i]);
	int x,y;
	scanf("%d",&m);
	while(m--)
	{
		printf("%d\n",ans);
		scanf("%d%d",&x,&y);
		if(a[x]==a[y]||x==y)continue;
		int flag =((x<y&&a[x]>a[y])||(x>y&&a[x]<a[y]));
		ans+=flag;
		ans-=get_bigger(1,1,n,1,x-1,a[x])+get_smaller(1,1,n,x+1,n,a[x]);
		ans-=get_bigger(1,1,n,1,y-1,a[y])+get_smaller(1,1,n,y+1,n,a[y]);
		update(1,1,n,x,a[x],a[y]);update(1,1,n,y,a[y],a[x]);
		swap(a[x],a[y]);
		ans+=get_bigger(1,1,n,1,x-1,a[x])+get_smaller(1,1,n,x+1,n,a[x]);
		ans+=get_bigger(1,1,n,1,y-1,a[y])+get_smaller(1,1,n,y+1,n,a[y]);
		ans-=(1-flag);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2143

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define fir first
#define sec second
#define mp make_pair
#define N 160
#define inf 1000000000

const int dx[4]={-1,1,0,0};
const int dy[4]={0,0,-1,1};
int m,n,len;
int stix1,stix2,stix3,stiy1,stiy2,stiy3,t1,t2,t3;
int a[N][N],b[N][N],dis[N][N][N<<1];
bool vis[N][N][N<<1];
struct node{ int x,y,z,d; };
priority_queue<node> q;
bool operator <(const node &u,const node &v){ return u.d>v.d; }
void solve(int sx,int sy)
{
	while (!q.empty()) q.pop();
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++)
			for (int k=0; k<=len; k++)
			{
				vis[i][j][k]=0; 
				dis[i][j][k]=inf;
			}
	dis[sx][sy][0]=0;
	node u,v; u.x=sx; u.y=sy; u.z=u.d=0; 
	q.push(u);
	while (!q.empty() && !(vis[stix1][stiy1][0] && vis[stix2][stiy2][0] && vis[stix3][stiy3][0]))
	{
		u=q.top(); q.pop();
		if (vis[u.x][u.y][u.z]) continue; vis[u.x][u.y][u.z]=1;
		if (u.z)
		{
			for (int k=0; k<4; k++)
			{
				int i=u.x+dx[k];int j=u.y+dy[k];
				if (i>0 && i<=m && j>0 && j<=n && u.d<dis[i][j][u.z-1])
				{
					dis[i][j][u.z-1]=v.d=u.d;
					v.x=i; v.y=j; v.z=u.z-1; q.push(v);
				}
			}
			v=u; v.z--;
			if (v.d<dis[v.x][v.y][v.z]){ dis[v.x][v.y][v.z]=v.d; q.push(v); }
		} else 
		{
			v=u; v.z=a[v.x][v.y]; v.d+=b[v.x][v.y];
			if (v.d<dis[v.x][v.y][v.z])
			{
				dis[v.x][v.y][v.z]=v.d; q.push(v);
			}
		}
	}
}
int main()
{
	scanf("%d%d",&m,&n);
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++)
		{
			scanf("%d",&a[i][j]); 
			a[i][j]=min(a[i][j],max(i-1,m-i)+max(j-1,n-j)+1);
			len=max(len,a[i][j]);
		}
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++) 
			scanf("%d",&b[i][j]);
	scanf("%d%d%d%d%d%d",&stix1,&stiy1,&stix2,&stiy2,&stix3,&stiy3);
	solve(stix1,stiy1); 
	t2+=dis[stix2][stiy2][0]; t3+=dis[stix3][stiy3][0];
	solve(stix2,stiy2); 
	t1+=dis[stix1][stiy1][0]; t3+=dis[stix3][stiy3][0];
	solve(stix3,stiy3); 
	t1+=dis[stix1][stiy1][0]; t2+=dis[stix2][stiy2][0];
	int ans=min(min(t1,t2),t3);
	if (ans<inf)
	{
		puts((ans==t1)?"X":(ans==t2)?"Y":"Z");
		printf("%d\n",ans);
	} else puts("NO");
	return 0;
}

Problem2146

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
typedef long long ll;
struct P
{
	ll x,y;
	P(){}
	P(ll x,ll y):x(x),y(y){}
	bool operator <(const P &s)const
	{
		if(x!=s.x)
			return x< s.x;
		return y<s.y;
	}
}p[N];
int n;
ll max_y=-INF,min_y=INF,area;
void get_area()
{
	static P *stack[N];
	int i,top=0;
	for(i=1;i<=n;i++)
	{
		if(!top||p[i].y>=stack[top]->y)
			stack[++top] = &p[i];
		if(p[i].y==max_y)
			break;
	}
	for(i++;i<=n;i++)
	{
		while(p[i].y>stack[top]->y)
			stack[top--]=NULL;
		stack[++top] = &p[i];
	}
	for(i = 2;i<= top;i++)
		area+=min(stack[i]->y,stack[i-1]->y)*(stack[i]->x-stack[i-1]->x);
	top = 0;
	for(i=1;i<= n;i++)
	{
		if(!top||p[i].y<=stack[top]->y)
			stack[++top] = &p[i];
		if(p[i].y==min_y)
			break;
	}
	for(i++;i<=n;i++)
	{
		while(p[i].y<stack[top]->y)
			stack[top--]=NULL;
		stack[++top] = &p[i];
	}
	for(i = 2;i<= top;i++)
		area-=max(stack[i]->y,stack[i-1]->y)*(stack[i]->x-stack[i-1]->x);
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld",&p[i].x,&p[i].y);
		max_y = max(max_y,p[i].y);
		min_y = min(min_y,p[i].y);
	}
	sort(p+1,p+n+1);
	printf("%lld\n",(max_y-min_y+p[n].x-p[1].x)<<1);
	get_area();
	printf("%lld\n",area);
	return 0;
}
Problem2152

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 2e4+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool used[N];
int sum,root,size[N],f[N];
void get_root(int x,int fa)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int dep[N];
LL cnt[4];
void get_dep(int x,int fa)
{
	cnt[dep[x]]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		dep[e[i].to] = (dep[x]+e[i].val)%3;
		get_dep(e[i].to,x);
	}
}
LL cal(int x,int now)
{
	dep[x] = now%3;
	cnt[1] = cnt[0] = cnt[2] = 0;
	get_dep(x,0);
	return cnt[1]*cnt[2]*2+cnt[0]*cnt[0];
}
LL ans;
void work(int x)
{
	ans+=cal(x,0);
	used[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		if(used[e[i].to])continue;
		ans-=cal(e[i].to,e[i].val);
		sum = size[e[i].to];
		root = 0;
		get_root(e[i].to,0);
		work(root);
	}
}
LL gcd(LL a,LL b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z),add(y,x,z);
	}
	f[0] = 0x3f3f3f3f;
	sum = n;
	get_root(1,0);
	work(root);
	LL t = gcd(ans,(LL)n*n);
	printf("%lld/%lld\n",ans/t,n*n/t);
	return 0;
}
Problem2154

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
const int mod = 20101009;
int mu[N],prime[N/10],cnt;
bool vis[N];
ll sum[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
				mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = (sum[i-1]+(ll)i*i*mu[i])%mod;
}
ll Sum(ll x)
{
	x %= mod;
	return x*(x+1)%mod*10050505%mod;
}
ll F(int x,int y)
{
	int last;
	ll ans = 0;
	for(int i = 1;i<=x&&i<=y;i=last+1)
	{
		last = min(x/(x/i),y/(y/i));
		(ans+=Sum(x/i)*Sum(y/i)%mod*(sum[last]-sum[i-1]))%=mod;
	}
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int last;
	quick_mu();
	ll ans = 0;
	for(int i = 1;i<= n&&i<= m;i=last+1)
	{
		last = min(n/(n/i),m/(m/i));
		(ans+=F(n/i,m/i)*(Sum(last)-Sum(i-1)))%=mod;
	}
	printf("%lld\n",(ans%mod+mod)%mod);
	return 0;
}
Problem2157

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int INF = 0x3f3f3f3f;
int minn[N<<2],maxn[N<<2],sum[N<<2];
bool f[N<<2];
struct E{int next,to;}e[N<<1];
int w[N],deep[N],son[N],size[N],fa[N],top[N],cnt;
int x[N],y[N],val[N];
int head[N],tot,n;
void add(int x,int y)
{
    e[++tot].to = y;
    e[tot].next = head[x];
    head[x] = tot;
}
bool v[N];
void dfs1(int x,int dep)
{
    v[x] = true;
    deep[x] = dep;
    size[x]++;
    for(int i = head[x];i;i = e[i].next)
    {
        int tmp = e[i].to;
        if(!v[tmp])
        {
            dfs1(tmp,dep+1);
            fa[tmp] = x;
            size[x]+=size[tmp];
            if(size[tmp]>size[son[x]])son[x] = tmp;
        }
    }
}
void dfs2(int x,int tp)
{
    top[x] = tp;
    w[x] = ++cnt;
    if(son[x]!=0)dfs2(son[x],tp);
    for(int i = head[x];i;i = e[i].next)
        if(e[i].to!=fa[x]&&e[i].to!=son[x])
            dfs2(e[i].to,e[i].to);
}
int quan[N];
void push_up(int p)
{
    minn[p] = min(minn[p<<1],minn[(p<<1)+1]);
    maxn[p] = max(maxn[p<<1],maxn[(p<<1)+1]);
    sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
void push_down(int p,int l,int r)
{
    if(l==r){f[p] = 0;return ;}
    f[p<<1] ^=1;
    f[(p<<1)+1] ^=1;
    sum[p<<1] = -sum[p<<1];sum[(p<<1)+1] = -sum[(p<<1)+1];
    swap(minn[p<<1],maxn[p<<1]);swap(minn[(p<<1)+1],maxn[(p<<1)+1]);
    minn[p<<1] = -minn[p<<1];maxn[p<<1] = -maxn[p<<1];
    minn[(p<<1)+1] = -minn[(p<<1)+1];maxn[(p<<1)+1] = -maxn[(p<<1)+1];
    f[p] = false;
}
int getans(int p,int l,int r,int a,int b,int opt)
{
    if(f[p])push_down(p,l,r);
    if(l>=a&&r<=b)
    {
        if(opt==1)return sum[p];
        else if(opt==2)return maxn[p];
        else return minn[p];
    }
    int ans;
    if(opt==1)ans= 0;
    else if(opt==2)ans = -INF;
    else ans = INF;
    int mid = (l+r)>>1;
    if(a<=mid)
    {
        if(opt==1)ans += getans(p<<1,l,mid,a,b,opt);
        else if(opt==2)ans = max(ans,getans(p<<1,l,mid,a,b,opt));
        else ans = min(ans,getans(p<<1,l,mid,a,b,opt));
    }
    if(b>mid)
    {
        if(opt==1)ans += getans((p<<1)+1,mid+1,r,a,b,opt);
        else if(opt==2)ans = max(ans,getans((p<<1)+1,mid+1,r,a,b,opt));
        else ans = min(ans,getans((p<<1)+1,mid+1,r,a,b,opt));
    }
    return ans;
}
void update(int p,int l,int r,int x,int c)
{
    if(f[p])push_down(p,l,r);
    if(l==r)
    {
        minn[p] = maxn[p] = sum[p] = c;
        return ;
    }
    int mid = (l+r)>>1;
    if(x<=mid)update(p<<1,l,mid,x,c);
    else update((p<<1)+1,mid+1,r,x,c);
    push_up(p);
}
void up_N(int p,int l,int r,int a,int b)
{
    if(f[p])push_down(p,l,r);
    if(l>=a&&r<=b)
    {
        f[p]^=1;
        minn[p] = -minn[p];maxn[p] = -maxn[p];sum[p] = -sum[p];
        swap(minn[p],maxn[p]);
        return ;
    }
    int mid = (l+r)>>1;
    if(a<=mid)up_N(p<<1,l,mid,a,b);
    if(b>mid)up_N((p<<1)+1,mid+1,r,a,b);
    push_up(p);
}
int qurey(int x,int y,int opt)
{
    int ans;
    if(opt==1)ans= 0;
    else if(opt==2)ans = -INF;
    else ans = INF;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        if(opt==1)ans += getans(1,1,n,w[top[x]],w[x],opt);
        else if(opt==2) ans = max(ans,getans(1,1,n,w[top[x]],w[x],opt));
        else if(opt==3) ans = min(ans,getans(1,1,n,w[top[x]],w[x],opt));
        else up_N(1,1,n,w[top[x]],w[x]);
        x = fa[top[x]];
    }
    if(x==y)return ans;
    if(deep[x]<deep[y])swap(x,y);
    if(opt==1)ans += getans(1,1,n,w[son[y]],w[x],opt);
    else if(opt==2) ans = max(ans,getans(1,1,n,w[son[y]],w[x],opt));
    else if(opt==3) ans = min(ans,getans(1,1,n,w[son[y]],w[x],opt));
    else up_N(1,1,n,w[son[y]],w[x]);
    return ans;
}
int main()
{
    int m,xx,yy;
    scanf("%d",&n);
    for(int i = 1;i<n;i++)
    {
        scanf("%d%d%d",&x[i],&y[i],&val[i]);
        x[i]++;y[i]++;
        add(x[i],y[i]);
        add(y[i],x[i]);
    }
    dfs1(1,1);
    dfs2(1,1);
    for(int i = 1;i<n;i++)
    {
        if(deep[x[i]]>deep[y[i]])update(1,1,n,w[x[i]],val[i]);
        else update(1,1,n,w[y[i]],val[i]);
    }
    scanf("%d",&m);
    char ju[5];
    for(int i = 1;i<= m;i++)
    {
        scanf("%s%d%d",ju,&xx,&yy);
        if(ju[0]=='C')
        {
            if(deep[x[xx]]>deep[y[xx]])update(1,1,n,w[x[xx]],yy);
            else update(1,1,n,w[y[xx]],yy);
        }else if(ju[0]=='N')
            qurey(xx+1,yy+1,4);
        else if(ju[0]=='S')
            printf("%d\n",qurey(xx+1,yy+1,1));
        else if(ju[1]=='A')
            printf("%d\n",qurey(xx+1,yy+1,2));
        else printf("%d\n",qurey(xx+1,yy+1,3));
    }
    return 0;
}
Problem2163

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e4+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
queue<int>Q;
int d[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int in[N],out[N];
int main()
{
	int node = 0;
	int S = 0,T;
	int n,m,F,sum=0;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)in[i]=++node;
	for(int i = 1;i<= n;i++)out[i]=++node;
	T = ++node;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&F);sum+=F;
		add(S,in[i],F),add(out[i],T,F);
	}
	int u,v;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&u,&v,&F);
		add(in[u],out[v],F);
	}
	printf("%d\n",sum-dinic(S,T));
	return 0;
}
Problem2176

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e7+5;
unsigned char s[N];
int mp(int n)
{
	int i,j,k,N = n<<1;
	i = 1,j = 2;
	while(i<n&&j<n)
	{
		k = 0;
		while(s[i+k]==s[j+k])k++;
		if(k==n)return min(i,j);
		if(s[i+k]>s[j+k])i = max(j+1,i+k+1);
		else j = max(i+1,j+k+1);
	}
	if(i<n)return i;else return j;
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
		s[i+n]=s[i];
	int st = mp(n);
	for(int i = st;i<st+n;i++)
		printf("%c",s[i]);
	return 0;
}
Problem2179

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
typedef double db;
typedef long long ll;
using namespace std;
const int N = 2e5;
const db PI = 3.14159265358979323;
struct cp
{
	db x,y;
	cp(){}
	cp(db x,db y):x(x),y(y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
int ans[N<<1];
void FFT(cp *a,int len,int type)
{
	int t=0;
	for(int i=0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j=len>>1;(t^=j)<j;j>>=1);
	}
	for(int i=2;i<=len;i<<=1)
	{
		cp wn=cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j=0;j<len;j+=i)
		{
			cp t,w(1,0);
			for(int k=0;k<(i>>1);k++,w=w*wn)
			{
				t=w*a[j+k+(i>>1)];
				a[j+k+(i>>1)]=a[j+k]-t;
				a[j+k]=a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i=0;i<len;i++)a[i].x/=len;
}
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i=0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i=0;i<len;i++)
	ans[i]=(int)(c[i].x+0.1);
}
char A[N],B[N];
int Ans[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",A);scanf("%s",B);
	int tmp = 0;
	for(int i = n-1;i>= 0;i--)
		x[n-i-1]=cp(A[i]-'0',0);
	tmp = 0;
	for(int i = n-1;i>=0;i--)
		y[n-i-1]=cp(B[i]-'0',0);
	//n = n*2;
	int t=1;
	while(t<=n)t = t<<1;
	n= t<<1;
	conv(x,y,z,n);
	int len = 0;
	ll x = 0;
	for(int i = 0;i<n;i++)
	{
		x+=ans[i];
		Ans[i]=x%10,x/=10;
	}
	for (;n&&!Ans[n];n--);
	printf("%d",Ans[n--]);
	for (int i=n;i>=0;i--) printf("%01d",Ans[i]);
	puts("");
	return 0;
}
Problem2179

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 4e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(){}
	cp(double x,double y):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y); 
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp&b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int type,int len)
{
	int t=0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp tmp,w = cp(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,1,len);FFT(b,1,len);
	for(int i = 0;i<len;i++)
		c[i] = a[i]*b[i];
	FFT(c,-1,len);
	for(int i = 0;i<len;i++)
		ans[i] = (int)(c[i].x+0.1);
}
int Ans[N];
char s[N],A[N],B[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s);
	for(int i = n-1;i>=0;i--)
		x[n-i-1]=cp(s[i]-'0',0);
	scanf("%s",s);
	for(int i = n-1;i>=0;i--)
		y[n-i-1]=cp(s[i]-'0',0);
	int l;
	for(l=1;l<=n;l=l<<1);
	l =l<<1;
	conv(x,y,z,l);
	long long x = 0;
	for(int i = 0;i<l;i++)
	{
		x = x+ans[i];
		Ans[i] = x%10,x/=10;
	}
	for(;l&&!Ans[l];l--);
	printf("%d",Ans[l--]);
	for(int i = l;i>=0;i--)
		printf("%01d",Ans[i]);
	printf("\n");
	return 0;
}
Problem2186

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int Maxn = 10000000+5; 
long long fac[Maxn],ans[Maxn],rev[Maxn];
int prime[Maxn/10],t_p;
bool v[Maxn];
long long mod;
int n,m;
void quick_prime()
{
	for(int i = 2;i< Maxn;i++)
	{
		if(!v[i])
		{
			t_p++;
			prime[t_p] = i;
		}
		for(int j = 1;j<= t_p&&prime[j]*i<Maxn;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j]==0)
				break;
		}
	}
	fac[1]=1; 
	int i; 
    for(i=2;i<=Maxn;i++)  
        fac[i]=fac[i-1]*i%mod;  
    rev[1]=1;  
    for(i=2;i<=Maxn&&i<mod;i++)  
        rev[i]=(mod-mod/i)*rev[mod%i]%mod;  
    ans[1]=1;  
    for(i=2;i<=Maxn;i++)  
    {  
        if(!v[i])  
            ans[i]=ans[i-1]*(i-1)%mod*rev[i%mod]%mod;  
        else  
            ans[i]=ans[i-1];  
    }
}
int main()
{
	int T;
	scanf("%d%lld",&T,&mod);
	quick_prime();
	while(T--)
	{
		scanf("%d%d",&n,&m);
		long long t_ans = fac[n];
		t_ans = t_ans*ans[m]%mod;
		printf("%lld\n",t_ans);
	}
	return 0;
}
Problem2194

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef double db;
const int N = 4e5+5;
const db PI = 3.14159265358979323;
int ans[N];
struct cp
{
	db x,y;
	cp(){}
	cp(db x,db y):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn=cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp tmp,w(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k]=a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)
		ans[i]=(int)(c[i].x+0.1);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 0;i< n;i++)scanf("%lf%lf",&x[i].x,&y[i].x);
	for(int i = 0;i<n/2;i++)swap(y[i],y[n-i-1]);
	int len = 1;
	while(len<=n)len<<=1;
	len<<=1;
	conv(x,y,z,len);
	for(int i = -1;i<n-1;i++)
		printf("%d\n",ans[i+n]);
	return 0;
}
Problem2213

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Q = 27;
const int N = 1e6+5;
int f[Q][Q],L[Q][Q],tot[Q],C[Q][Q],sec[Q][Q];
char s[N];
int ans;
void update(int x,int y)
{
	if(C[x][y]!=tot[y])ans = max(ans,f[x][y]-L[x][y]);
	else ans = max(ans,f[x][y]-sec[x][y]);
	if(f[x][y]<L[x][y])
	{
		if(C[x][y]==tot[y])L[x][y] = f[x][y];
		else
		{
			sec[x][y] = L[x][y];
			L[x][y] = f[x][y];
			C[x][y] = tot[y];
		}
	}else if(f[x][y]<sec[x][y])
		if(C[x][y]!=tot[y])
			sec[x][y] = L[x][y];
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	memset(sec,0x3f,sizeof(sec));
	for(int i = 1;i<= n;i++)
	{
		s[i] = s[i]-'a';
		tot[s[i]]++;
		for(int j = 0;j<26;j++)
		{
			if(j==s[i])continue;
			f[j][s[i]]--;
			update(j,s[i]);
			f[s[i]][j]++;
			update(s[i],j);
		}
	}
	printf("%d\n",ans);
}
Problem2215

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const int M = 50000050;
inline int p0(int i){return i*2;}
inline int p1(int i){return i*2+1;}
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<1)+(x<<3) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct E
{int next,to;}e[M];
int head[N<<1],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool v[N<<1],ins[N<<1],r[N][N];
int stack[N<<1],top,dep[N<<1],low[N<<1],bel[N<<1],dfn,scc;
void tarjan(int x)
{
	v[x] = true;
	low[x] = dep[x] = ++dfn;
	stack[++top] =x ;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!v[e[i].to])
			{tarjan(e[i].to);low[x] = min(low[x],low[e[i].to]);}
		else if(ins[e[i].to])
			{low[x] = min(low[x],dep[e[i].to]);}
	}
	if(low[x]==dep[x])
	{
		scc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = scc;
		}while(tmp!=x);
	}
}
void Read()
{
	scanf("%d",&n);
	int k,x;
	for(int i = 1;i<= n;i++)
	{
		k = read();
		for(int j = 1;j<= k;j++)
			{x = read();r[i][x] = r[x][i] = true;}
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<i;j++)
		{
			if(r[i][j])add(p1(i),p0(j)),add(p1(j),p0(i));
			else add(p0(i),p1(j)),add(p0(j),p1(i));
		}
}
int ans[N],cnt[N],dir[N],Ans;
void work()
{
	for(int i = 2;i<= 2*n+1;i++)
		if(!v[i])
			tarjan(i);
	for(int i = 1;i<= n;i++)if(bel[p1(i)]==bel[p0(i)])return ;
	int cnt1 = 0,cnt0 = 0;
	for(int i = 1;i<= n;i++)
	{
		ans[i] = (bel[p0(i)]>bel[p1(i)]);
		if(ans[i])cnt1++;else cnt0++;
	}
	Ans = (cnt1&&cnt0);
	int t0 = 0,t1 = 0;
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])
		{
			for(int j = 1;j<= n;j++)
				if(i!=j&&!ans[j]&&!r[i][j])
					cnt[i]++,dir[i] = j;
		}
		else
		{
			for(int j = 1;j<= n;j++)
				if(i!=j&&ans[j]&&r[i][j])
					cnt[i]++,dir[i] = j;
		}
	}
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])
		{
			if(!cnt[i]&&cnt1>1)Ans++;
			if(!cnt[i])t1++;
			if(cnt[i]==1&&((cnt[dir[i]]==1&&dir[dir[i]]==i&&i<dir[i])||!cnt[dir[i]]))
				Ans++;
		}
		else
		{
			if(!cnt[i]&&cnt0>1)Ans++;
			if(!cnt[i])t0++;
			if(cnt[i]==1&&((cnt[dir[i]]==1&&dir[dir[i]]==i&&i<dir[i])||!cnt[dir[i]]))
				Ans++;
		}
	}
	Ans+=t0*t1;
}
int main()
{
	Read();
	work();
	printf("%d\n",Ans);
	return 0;
}
Problem2216

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
struct E
{int l,r,p;}que[N];
int a[N],n;
double f[N],g[N];
double cal(int j,int i)
{
	return a[j]+sqrt(abs(i-j))-a[i];
}
int L,R;
int find(E a,int x)
{
	int l = a.l,r = a.r;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(cal(a.p,mid)>cal(x,mid))l = mid+1;
		else r = mid;
	}
	return l;
}
void work(double *F)
{
	L = 0,R = -1;
	for(int i = 1;i<= n;i++)
	{
		que[L].l++;
		while(L<=R&&que[L].l>que[L].r)L++;
		if(L>R||cal(i,n)>cal(que[R].p,n))
		{
			while(L<=R&&cal(que[R].p,que[R].l)<cal(i,que[R].l))
				R--;
			if(L>R)
				que[++R] = (E){i,n,i};
			else
			{
				int t = find(que[R],i);
				que[R].r = t-1;
				que[++R] = (E){t,n,i};
			}
		}
		F[i] = cal(que[L].p,i);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	work(f);
	for(int i = 1;i<=(n>>1);i++)swap(a[i],a[n-i+1]);
	work(g);
	for(int i = 1;i<= n;i++)
		printf("%d\n",max(0,(int)ceil(max(g[n-i+1],f[i]))));
	return 0;
}
Problem2217

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e6+5;
int ansl[N],ansr[N];
char s[N>>1];
int ex2[N>>1];
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	scanf("%s",s+1);
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		sum+=s[i]=='W'?1:2;
		ansr[sum] = i;
		ansl[sum] = 1;
	}
	for(int i = n;i>=1;i--)
		if(s[i]=='T')
			ex2[i] = ex2[i+1]+1;
	for(int i = 1;i<= 2*n;i++)
	{
		if(i>sum)break;
		if(!ansl[i])
		{
			int tmp = ansr[i+1];
			if(ex2[1]<ex2[tmp])
			{
				ansr[i] = tmp+ex2[1];
				ansl[i] = 2+ex2[1];
				continue;
			}
			if(tmp+ex2[tmp]==n+1)continue;
			ansr[i] = tmp+ex2[tmp];
			ansl[i] = 1+ex2[tmp];
		}
	}
	int x;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&x);
		if(!ansl[x])
			printf("NIE\n");
		else 
			printf("%d %d\n",ansl[x],ansr[x]);
	}
	return 0;
}
Problem2219

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 100005;
const ll INF = 0x7fffffffffffffffll;
int cas,num;
ll A,B,K;
ll prime[10005];
struct Hash
{
	#define mod 100007
	int head[mod],nxt[N],id[N],tot;
	ll val[N];
	void clear()
	{
		tot = 0;
		memset(head,0,sizeof(head));
	}
	int Insert(ll x,int k)
	{
		int tmp = x%mod;
		for(int i = head[tmp];i;i=nxt[i])
			if(val[i]==x)
				return id[i];
		if(k==-1)return -1;
		val[++tot] = x;
		id[tot] = k;
		nxt[tot] = head[tmp];
		head[tmp] = tot;
	}
}hmp;
ll quick_pow(ll x,ll y,ll p=INF)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res = res*x%p;
		x = x*x%p;
		y>>=1;
	}
	return res;
}
bool check(int x,ll p,ll k)
{
	for(int i = 1;i<= num;i++)
		if(quick_pow(x,k/prime[i],p)==1)
			return false;
	return true;
}
void get_fac(ll p)
{
	num = 0;
	for(ll i = 2;i*i<= p;i++)
		if(p%i==0)
		{
			prime[++num] = i;
			while(p%i==0)p/=i;
		}
	if(p>1)prime[++num] = p;
}
ll get_root(ll p,ll x)
{
	get_fac(x);
	for(int i = 2;;i++)
		if(check(i,p,x))return i;
}
void ex_gcd(ll a,ll b,ll &x,ll &y,ll &d)
{
	if(b==0)
	{
		d = a;
		x = 1;
		y = 0;
		return ;
	}
	ex_gcd(b,a%b,y,x,d);
	y-=a/b*x;
}
ll get_inv(ll a,ll b)
{
	ll x,y,d;
	ex_gcd(a,b,x,y,d);
	b/=d;
	return (x%b+b)%b;
}
ll BSGS(ll a,ll g,ll p)
{
	hmp.clear();
	ll m = sqrt(p)+1,tmp=1;
	for(int i = 0;i<m;i++,tmp=tmp*g%p)hmp.Insert(tmp,i);
	ll Inv = get_inv(tmp,p);
	int k;
	for(int i = 0;i<m;i++,a=a*Inv%p)
	{
		k = hmp.Insert(a,-1);
		if(k!=-1)return m*i+k;
	}
}
ll gcd(ll a,ll b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
ll solve(ll a,ll b,ll p,ll t)
{
	ll MOD = quick_pow(p,t),ret=0,phi,g,ind,tmp;
	b = b%MOD;
	if(!b)return quick_pow(p,t-((t-1)/a+1));
	while(b%p==0)ret++,b/=p;
	if(ret%a)return 0;
	t-=ret;
	MOD = quick_pow(p,t);
	phi = MOD-MOD/p;
	g = get_root(MOD,phi);ind = BSGS(b,g,MOD);
	tmp = gcd(a,phi);
	if(ind%tmp)return 0;
	return tmp*quick_pow(p,ret-ret/a);
}
int main()
{
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%lld%lld%lld",&A,&B,&K);
		ll ans = 1;
		K = 2*K+1;
		for(ll i= 2;i*i<= K;i++)
			if(K%i==0)
			{
				int ret = 0;
				while(K%i==0)K/=i,ret++;
				ans*=solve(A,B,i,ret);
			}
		if(K>1&&ans)ans*=solve(A,B,K,1);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem2223

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 1e7+5;
int root[N];
int ls[M],rs[M],sum[M];
int cnt,n,m,lim;
void update(int l,int r,int rt1,int &rt2,int v)
{
	rt2 = ++cnt;
	sum[rt2] = sum[rt1]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[rt2] = ls[rt1],rs[rt2] = rs[rt1];
	if(v<=mid)update(l,mid,ls[rt1],ls[rt2],v);
	else update(mid+1,r,rs[rt1],rs[rt2],v);
}
int ask(int L,int R)
{
	int l,r,tmp = (R-L+1)>>1;
	int rt1 = root[L-1],rt2 = root[R];
	l = 1,r = lim;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[rt2]-sum[rt1]<=tmp)return 0;
		if(sum[ls[rt2]]-sum[ls[rt1]]>tmp)
		{
			r = mid;
			rt1 = ls[rt1],rt2 = ls[rt2];
		}else if(sum[rs[rt2]]-sum[rs[rt1]]>tmp)
		{
			l = mid+1;
			rt1 = rs[rt1],rt2 = rs[rt2];
		}
		else return 0;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&lim);
	for(int i = 1;i<= n;i++)
	{
		int x;
		scanf("%d",&x);
		update(1,lim,root[i-1],root[i],x);
	}
	scanf("%d",&m);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		int tmp = ask(x,y);
		if(tmp!=0)printf("yes %d\n",tmp);
		else printf("no\n");
	}
	return 0;
}
Problem2226

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int phi[1000005],a[100005],tot;
long long f[1000005];
bool not_prime[1000005];
void oula(int n)
{
	for(int i = 2;i<= n;i++)
	{
		if(!not_prime[i])
		{
			a[++tot] = i;
			phi[i] = i-1;
		}
		for(int j = 1;j<= tot&&a[j]*i<=n;j++)
		{
			not_prime[i*a[j]] = true;
			if(i%a[j]==0){phi[i*a[j]] = phi[i]*a[j];break;}
			else phi[i*a[j]] = phi[i]*(a[j]-1);
		}
	}
}
long long ans(int i)
{
	long long re = 0;
	for(int j = 1;j*j<= i;j++)
	{
		if(i%j==0&&j*j!=i)
			{re+=f[i/j]+f[j];}
		else if(j*j==i)
			re+=f[j];
	}
	return re;
}
int main()
{
	int T,x;
	scanf("%d",&T);
	oula(1000001);
	f[1] = 1;
	for(int i = 1;i<= 1000001;i++)
		if(i!=1)f[i] = (long long)i*phi[i]/2;
	for(int i = 1;i<= T;i++)
	{
		scanf("%d",&x);
		printf("%lld\n",ans(x)*x);
	}
	return 0;
}
Problem2229

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200;
const int M = 6005;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot=1,a[N],b[N],d[N],n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f;
}
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int ans[N][N];
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] =-1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
void reset()
{
	for(int i = 2;i<= tot;i+=2)
		e[i].f = e[i^1].f = (e[i].f+e[i^1].f)>>1;
}
bool v[N];
void dfs(int x)
{
	v[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!v[e[i].to])
			dfs(e[i].to);
}
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(v,0,sizeof(v));
	dfs(s);
	for(int i = 1;i<= n;i++)
		if(v[i])
			for(int j = 1;j<= n;j++)
				if(!v[j])
					ans[i][j] = ans[j][i] = min(ans[i][j],tmp);
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(v[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)
		a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 1;
	memset(ans,0x3f,sizeof(ans));
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		int u,v,c;
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)a[i]=i;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d%d",&u,&v,&c);
			add(u,v,c);
		}
		solve(1,n);
		int q;
		scanf("%d",&q);
		for(int i = 1;i<= q;i++)
		{
			scanf("%d",&c);int Ans =0;
			for(int j = 1;j<= n;j++)
				for(int k = j+1;k<= n;k++)
					Ans+=(ans[j][k]<=c);
			printf("%d\n",Ans);
		}
		if(cas)printf("\n");
	}
	return 0;
}
Problem2243

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
struct T
{int lc,rc,num,f;}t[N<<3];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int deep[N],top[N],fa[N],son[N],size[N],w[N],c[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	size[x]++;
	deep[x] =dep;
	for(int i= head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void init(int no,int l,int r)
{
	t[no].f = -1;
	if(l==r)
	{
		t[no].num = 1;
		return ;
	}
	int mid= (l+r)>>1;
	init(no<<1,l,mid);
	init((no<<1)+1,mid+1,r);
	return ;
}
void push_down(int p)
{
	t[p<<1].num = t[(p<<1)+1].num = 1;
	t[p<<1].f = t[(p<<1)+1].f = t[p].f;
	t[p<<1].lc = t[(p<<1)+1].lc = t[p].lc;
	t[p<<1].rc = t[(p<<1)+1].rc = t[p].f;
	t[p].f = -1;
}
void update(int p,int l,int r,int a,int b,int c)
{
	if(t[p].f!=-1)push_down(p);
	if(l>=a&&r<=b)
		{t[p].lc = t[p].rc = t[p].f = c;t[p].num = 1;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)
		update(p<<1,l,mid,a,b,c);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b,c);
	if(t[p<<1].rc==t[(p<<1)+1].lc)t[p].num = t[p<<1].num+t[(p<<1)+1].num-1;
	else t[p].num = t[p<<1].num+t[(p<<1)+1].num;
	t[p].lc = t[p<<1].lc;t[p].rc = t[(p<<1)+1].rc;
}
T getans(int p,int l,int r,int a,int b)
{
	if(t[p].f!=-1)push_down(p);
	if(l>=a&&r<=b)
		return t[p];
	int mid = (l+r)>>1;
	T x,y,c;
	if(b<=mid)
		c = getans(p<<1,l,mid,a,b);
	else if(a>mid)
		c = getans((p<<1)+1,mid+1,r,a,b);
	else
	{
		x = getans(p<<1,l,mid,a,b);y = getans((p<<1)+1,mid+1,r,a,b);
		c.lc = x.lc;c.rc = y.rc;
		c.num = x.num+y.num;
		if(x.rc==y.lc)c.num--;
	}
	return c;
}
int t_ans;
void get_update(int x,int y,int c,int opt)
{
	T ta;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)update(1,1,n,w[top[x]],w[x],c);
		else
		{
			ta = getans(1,1,n,w[top[x]],w[x]);
			t_ans+=ta.num;
			if(ta.lc==getans(1,1,n,w[fa[top[x]]],w[fa[top[x]]]).lc)t_ans--;
		}
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)update(1,1,n,w[y],w[x],c);
	else
	{
		ta = getans(1,1,n,w[y],w[x]);
		t_ans+=ta.num;
	} 
}
int main()
{
	int m,x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	init(1,1,n);
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)get_update(i,i,c[i],1);
	char j[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",j);
		if(j[0]=='C')
		{
			scanf("%d%d%d",&x,&y,&z);
			get_update(x,y,z,1);
		}else
		{
			t_ans = 0;
			scanf("%d%d",&x,&y);
			get_update(x,y,0,0);
			printf("%d\n",t_ans);
		}
	}
	return 0;
}
Problem2251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
int s[N];
int sa[N],q[N],v[N],nv[N],cnt[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i=0;i<lim;i++)cnt[i]=0;
	for(i=0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i=len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim=0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j  =0;
			if(i)j=max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
		scanf("%1d",&s[i]);
	build_sa(n,2);
	build_rank(n);
	build_height(n);
	int l,r;
	for(int i = 0;i< n;i++)
		for(int j = h[i]+1;sa[i]+j-1<n;j++)
		{
			for(l=i;l>=0&&h[l]>=j;l--);
			for(r=i+1;r<n&&h[r]>=j;r++);
			if(r-l>1)printf("%d\n",r-l);
		}
	return 0;
}
Problem2257

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e7+5;
int divs[N];
bool cmp(const int &a,const int &b){return a>b;}
int main()
{
	int n,k,x,top = 0;
	scanf("%d%d",&n,&k);
	while(n--)
	{
		scanf("%d",&x);
		for(int i = 1;i*i<= x;i++)
			if(x%i==0)
			{
				divs[++top] = i;
				if(i*i!=x)divs[++top]=x/i;
			}
	}
	sort(divs+1,divs+top+1,cmp);
	int cnt = 1;
	for(int i = 1;i<= top;i++)
	{
		if(divs[i]!=divs[i-1])cnt=1;
		else cnt++;
		if(cnt>=k){printf("%d\n",divs[i]);break;}
	}
	return 0;
}
Problem2260

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2505;
const int INF = 0x3f3f3f3f;
const double eps = 1e-7;
struct E
{int u,v;double val;}e[M];
int p[N],num[N],pre[N],vis[N],mark[N];
double c[N],in[N];
double work(int root,int n,int m)
{
	double ans = 0;
	while(true)
	{
		for(int i = 1;i<= n;i++)in[i] = INF;
		for(int i = 1;i<= m;i++)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].val<in[v])
			{
				in[v] = e[i].val;
				pre[v] = u;
			}
		}
		for(int i = 1;i<= n;i++)
		{
			if(i==root)continue;
			if(fabs(in[i]-INF)<eps)return -1;
		}
		memset(mark,-1,sizeof(mark));
		memset(vis,-1,sizeof(vis));
		in[root] = 0;int cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			ans+=in[i];
			int v=i;
			while(v!=root&&mark[v]==-1&&vis[v]!=i)
			{
				vis[v] = i;
				v = pre[v];
			}
			if(v!=root&&mark[v]==-1)
			{
				++cnt;
				for(int u = pre[v];u!=v;u = pre[u])
					mark[u] = cnt;
				mark[v] = cnt;
			}
		}
		if(cnt==0)break;
		for(int i = 1;i<= n;i++)
			if(mark[i]==-1)mark[i]=++cnt;
		for(int i = 1;i<=m;i++)
		{
			int u = e[i].u,v = e[i].v;
			e[i].u = mark[u],e[i].v = mark[v];
			if(e[i].u!=e[i].v)
				e[i].val-=in[v];
		}
		n=cnt,root = mark[root];
	}
	return ans;
}
int main()
{
	int n,m=0;
	scanf("%d",&n);
	int tmp = n;n = 1;
	double x;int t;
	for(int i = 1;i<= tmp;i++)
	{
		scanf("%lf%d",&x,&t);
		if(t)
		{
			p[i]=++n;
			e[++m] = (E){1,n,x};
			c[n] = x;num[n] = t;
		}
	}
	int a,b,k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%lf",&a,&b,&x);
		if(p[a]&&p[b])
		{
			e[++m] = (E){p[a],p[b],x};
			c[p[b]] = min(c[p[b]],x);
		}
	}
	double ans = work(1,n,m);
	for(int i = 2;i<= n;i++)
		if(num[i]>1)ans+=c[i]*(num[i]-1);
	printf("%.2f\n",ans);
	return 0;
}
Problem2275

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll f[100];
int main()
{
	ll n;
	scanf("%lld",&n);
	f[0] = 0,f[1] = 1;
	int cnt = 1;
	while(f[cnt]<=n)
	{
		++cnt;
		f[cnt] = f[cnt-1]+f[cnt-2];
	}
	while(cnt)
	{
		if(f[cnt]==n)
			return printf("%lld\n",n),0;
		if(n>f[cnt])
			n-=f[cnt];
		cnt--;
	}
	return 0;
}
Problem2276

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
int q1[N],q2[N],l1,l2,r1,r2;
int m[N],x[N];
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&m[i],&x[i]);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&m[i]>m[q1[r1]])r1--;q1[++r1] = i;
		//while(l2<=r2&&x[i]<x[q2[r2]])r2--;q2[++r2] = i;
		while(m[q1[l1]]>x[i]&&j<=n)
		{
			j++;
			while(l1<=r1&&q1[l1]<j)l1++;
			//while(l2<=r2&&q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2277

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 250005;
LL gcd(LL x,LL y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
LL stack[N],top,a[N],n,k;
int main()
{
	scanf("%lld%lld",&n,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%lld",&a[i]);
		if(i!=k)stack[++top] = gcd(a[i],n);
	}
	sort(stack+1,stack+top+1);
	int tmp = top,top = 0;
	for(int i = 1;i<= tmp;i++)
		if(stack[top]!=stack[i])
			stack[++top] = stack[i];
	LL m = gcd(n,a[k]);
	LL ans = m;
	for(LL i = 1;i*i<=m;i++)
	{
		if(m%i==0)
		{
			int j;
			for(j = 1;j<= top;j++)
				if(stack[j]%i==0)
					break;
			if(j==top+1){ans = min(ans,i);break;}
			LL k = m/i;
			for(j = 1;j<= top;j++)
				if(stack[j]%k==0)
					break;
			if(j==top+1)ans = min(ans,k);
		}
	}
	printf("%lld\n",n/ans);
	return 0;
}
Problem2278

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<cmath>
#include<algorithm>
#include<iomanip>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<queue>
#include<stack>
using namespace std;
#define MAXN 100010
#define MAXM 2000010
#define INF 1000000000
#define MOD 1000000007
#define eps 1e-8
#define ll long long
struct vec{
    int to;
    int fro;
};
vec mp[MAXM];
int tai[MAXN],cnt=1;
bool vis[MAXM];
int st[MAXN],tp;
bool ist[MAXN];
vector<int>ans[MAXM];
int ANS;
int n,m;
int d[MAXN];
inline void be(int x,int y){
    mp[++cnt].to=y;
    mp[cnt].fro=tai[x];
    tai[x]=cnt;
}
inline void bde(int x,int y){
    be(x,y);
    be(y,x);
}
void dfs(int x){
    int y;
    if(ist[x]){
        int t=0;
        ANS++;
        while(t!=x){
            ist[t=st[tp--]]=0;
            ans[ANS].push_back(t);
        }
    }
    for(int &i=tai[x];i;i=mp[i].fro){
        y=mp[i].to;
        if(!vis[i]){
            vis[i]=vis[i^1]=1;
            ist[st[++tp]=x]=1;
            dfs(y);
        }
    }
}
int main(){
    int i,j,x,y,t,tt;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d%d%d%d",&x,&y,&t,&tt);
        if(t^tt){
            bde(x,y);
            d[x]++;
            d[y]++;
        }
    }
    for(i=1;i<=n;i++){
        if(d[i]&1){
            printf("NIE\n");
            return 0;
        }
    }
    for(i=1;i<=n;i++){
        dfs(i);
    }
    printf("%d\n",ANS);
    for(i=1;i<=ANS;i++){
        printf("%d ",ans[i].size());
        for(j=0;j<ans[i].size();j++){
            printf("%d ",ans[i][j]);
        }
        printf("%d\n",ans[i][0]);
    }
    return 0;
}

/*

*/
Problem2278

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2000010;
const int N = 100010;
struct E
{
	int next,to;
}e[M];
int head[N],tot = 1;
vector<int>Ans[M];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[M],ins[N],vis[N];
int stack[M],top,cnt,j;
void dfs(int x)
{
	vis[x] = true;
	if(ins[x])
	{
		cnt++;
		Ans[cnt].push_back(x);
		while(stack[top]!=x)
		{
			Ans[cnt].push_back(stack[top]);
			ins[stack[top]] = false;
			top--;
		}
		ins[stack[top]] = false;
		Ans[cnt].push_back(stack[top]);
		top--;
	}
	for(j = head[x];j;j = head[x])
	{
		head[x] = e[j].next;
		if(!used[j])
		{
			used[j] = used[j^1] = true;
			ins[x] = true;
			stack[++top] = x;
			dfs(e[j].to);
		}
	}
}
int d[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int x,y,u,w;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		if(u==w)continue;
		d[x]++,d[y]++;
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]&1)
		{
			printf("NIE\n");
			return 0;
		}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			dfs(i);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		printf("%d",Ans[i].size()-1);
		for(int k = 0;k<Ans[i].size();k++)
			printf(" %d",Ans[i][k]);
		printf("\n");
	}
	return 0;
}
Problem2278

#include <stdio.h>
#include <cctype>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2000010;
const int N = 100010;
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
inline int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
struct E
{
	int next,to;
}e[M];
int head[N],tot = 1;
vector<int>Ans[M];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[M],ins[N],vis[N];
int stack[M],top,cnt,j;
void dfs(int x)
{
	vis[x] = true;
	if(ins[x])
	{
		cnt++;
		Ans[cnt].push_back(x);
		while(stack[top]!=x)
		{
			Ans[cnt].push_back(stack[top]);
			ins[stack[top]] = false;
			top--;
		}
		ins[stack[top]] = false;
		Ans[cnt].push_back(stack[top]);
		top--;
	}
	for(j = head[x];j;j = head[x])
	{
		head[x] = e[j].next;
		if(!used[j])
		{
			used[j] = used[j^1] = true;
			ins[x] = true;
			stack[++top] = x;
			dfs(e[j].to);
		}
	}
}
int d[N];
int main()
{
	int n,m;
	n = read();m = read();
	int x,y,u,w;
	for(int i = 1;i<= m;i++)
	{
		x = read();y = read();u = read();w = read();
		if(u==w)continue;
		d[x]++,d[y]++;
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]&1)
		{
			printf("NIE\n");
			return 0;
		}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			dfs(i);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		printf("%d",Ans[i].size()-1);
		for(int k = 0;k<Ans[i].size();k++)
			printf(" %d",Ans[i][k]);
		printf("\n");
	}
	return 0;
}
Problem2286

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250010;
typedef long long ll;
struct E
{int next,to,val;};
int dep[N],fa[N][22],dfn[N],Dfn;
vector<int>to[N];
vector<int>val[N];
ll f[N],mn[N];
int stack[N],top,num[N];
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].val=f;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].val=f;
	}
	void dfs(int x,int f,int dp)
	{
		fa[x][0] = f;
		dep[x] = dp;
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=f)
			{
				mn[e[i].to] = min(mn[x],(ll)e[i].val);
				dfs(e[i].to,x,dp+1);
			}
	}
	void init(int n)
	{
		for(int j = 1;j<= 21;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 21;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 21;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
}tree;
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
void add(int x,int y)
{
	if(x==y)return ;
	to[x].push_back(y);
	to[y].push_back(x);
}
void dfs(int x,int ff)
{
	ll tmp = 0;
	int sz = to[x].size();
	f[x] = mn[x];
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
		{
			dfs(t,x);
			tmp+=f[t];
		}
	}
	if(tmp&&tmp<=f[x])f[x]=tmp;
	to[x].clear();
}
int main()
{
	int n,m,k;
	scanf("%d",&n);
	int x,y,c;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		tree.add(x,y,c);
	}
	mn[1]=1ll<<60;
	tree.dfs(1,0,1);
	tree.init(n);
	scanf("%d",&m);
	while(m--)
	{
		scanf("%d",&k);
		for(int i = 1;i<= k;i++)
			scanf("%d",&num[i]);
		sort(num+1,num+k+1,cmp);
		int tmp = k;
		num[k=1] = num[1];
		for(int i = 2;i<= tmp;i++)
			if(tree.getlca(num[k],num[i])!=num[k])
				num[++k]=num[i];
		top = 0;
		stack[++top]=1;
		for(int i = 1;i<= k;i++)
		{
			int v = num[i];
			int lca = tree.getlca(stack[top],v);
			while(true)
			{
				if(dep[lca]>=dep[stack[top-1]])
					{add(lca,stack[top--]);break;}
				add(stack[top-1],stack[top]);
				top--;
			}
			if(stack[top]!=lca)stack[++top]=lca;
			if(stack[top]!=v)stack[++top] = v;
		}
		for(int i = 1;i<=top-1;i++)
			add(stack[i],stack[i+1]);
		dfs(1,0);
		printf("%lld\n",f[1]);
	}
	return 0;
}
Problem2301

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int mu[N],prime[N],cnt,sum[N];
bool vis[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i= 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+mu[i];
}
typedef long long ll;
ll calc(int x,int y)
{
	if(x<0||y<0)return 0;
	ll ans = 0;
	int last = 0;
	for(int i = 1;i<=x&&i<=y;i = last+1)
	{
		last = min(y/(y/i),x/(x/i));
		ans+=(ll)(x/i)*(y/i)*(sum[last]-sum[i-1]);
	}
	return ans;
}
int main()
{
	quick_mu();
	int a,b,c,d,k;
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);
		ll ans = 0;
		ans+=calc(b/k,d/k);
		ans-=calc((a-1)/k,d/k);
		ans-=calc(b/k,(c-1)/k);
		ans+=calc((a-1)/k,(c-1)/k);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem2302

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
typedef long long ll;
int f[N][N];
int cnt[N],sum[N];
int C[N][N],n,m,x,y,mod;
void Init()
{
	memset(f,0,sizeof(f));
	memset(cnt,0,sizeof(cnt));
	memset(sum,0,sizeof(sum));
	C[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		C[i][0] = 1;
		for(int j = 1;j<=i;j++)
			C[i][j] = (C[i-1][j-1]+C[i-1][j])%mod;
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	//init();
	while(cas--)
	{
		scanf("%d%d%d",&n,&m,&mod);
		Init();
		sum[0] = n-m;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			cnt[y]++;
		}
		bool flag = false;
		for(int i = 1;i<= n;i++)
		{
			sum[i] = sum[i-1]+cnt[i];
			if(sum[i]<i)
			{
				puts("NO");
				flag = true;
				break;
			}
		}
		if(flag)continue;
		f[0][0]=1;
		for(int i = 1;i<= n;i++)
			for(int j = i;j<= sum[i];j++)
				for(int k = j-i+1;k>= cnt[i];k--)
					(f[i][j]+=(ll)f[i-1][j-k]*C[sum[i]-cnt[i]-j+k][k-cnt[i]]%mod)%=mod;
		printf("YES %d\n",f[n][n]);
	}
	return 0;
}
Problem2303

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e6+5;
const int mod = 1e9;
int fa[N],g[N];
struct P
{int x,y,z;}p[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	int tmp = getfa(fa[x]);
	g[x]^=g[fa[x]];
	return fa[x] = tmp;
}
int n,m,q;
int calc()
{
	for(int i = 1;i<= n+m;i++)fa[i]=i,g[i]=0;
	fa[m+1] = 1;
	for(int i = 1;i<= q;i++)
	{
		int u= getfa(p[i].x),v = getfa(p[i].y+m);
		int tmp = g[p[i].x]^g[p[i].y+m]^p[i].z;
		if(u!=v){fa[u]=v,g[u]=tmp;}
		else if(tmp)return 0;
	}
	int ans = -1;
	for(int i=1;i<=m+n;i++)
		if(getfa(i)==i)
		{
			if(ans==-1)ans=1;
			else
			{
				ans = ans<<1;
				if(ans>=mod)
					ans-=mod;
			}
		}
	return ans;
}
int main()
{
	scanf("%d%d%d",&m,&n,&q);
	bool f[2] = {true,true};
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&p[i].x,&p[i].y,&p[i].z);
		if(p[i].x==1&&p[i].y==1)
			{f[p[i].z] = false,i--,q--;continue;}
		if(!(p[i].x&1||p[i].y&1))p[i].z^=1;
	}
	int ans = 0;
	if(f[1])ans= calc();
	if(f[0])
	{
		for(int i = 1;i<= q;i++)
			if(p[i].x>1&&p[i].y>1)
				p[i].z^=1;
		ans+=calc();
	}
	if(ans>=mod)ans-=mod;
	printf("%d\n",ans);
	return 0;
}
Problem2306

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
int n,m,s;
double p,ans,f[N][N],g[N][N],a[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%lf",&a[i]);
	scanf("%d%lf",&s,&p);
	memset(f,0xc2,sizeof(f));
	for(int i = 1;i<= n;i++)
		f[i][i] = 0;
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		f[x][y] = a[y];
	}
	double pow = p;
	int T=70;
	while(T--)
	{
		memset(g,0xc2,sizeof(g));
		for(int k = 1;k<= n;k++)
			for(int i = 1;i<= n;i++)
				for(int j= 1;j<= n;j++)
					g[i][j]=max(g[i][j],f[i][k]+f[k][j]*pow);
		memcpy(f,g,sizeof(f));
		pow*=pow;
	}
	ans = 0;
	for(int i = 1;i<= n;i++)
		ans = max(ans,f[s][i]);
	printf("%.1lf",ans*p+a[s]);
	return 0;
}
Problem2314

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int mod = 1032992941;
ll f[N][2],g[N][2],h[N][2];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	f[x][0] = 1,g[x][0] = INF,h[x][0] = 0;
	f[x][1] = g[x][1] = h[x][1] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			int mn = min(f[e[i].to][0],min(g[e[i].to][0],h[e[i].to][0]));
			ll tmp = 0;
			if(f[e[i].to][0]==mn)tmp+=f[e[i].to][1];
			if(g[e[i].to][0]==mn)tmp+=g[e[i].to][1];
			if(h[e[i].to][0]==mn)tmp+=h[e[i].to][1];
			f[x][0]+=mn,f[x][1]=f[x][1]*tmp%mod;

			mn = min(min(g[x][0]+f[e[i].to][0],g[x][0]+g[e[i].to][0]),h[x][0]+f[e[i].to][0]);
			tmp = 0;
			if(g[x][0]+f[e[i].to][0]==mn)tmp+=(g[x][1]*f[e[i].to][1])%mod;
			if(g[x][0]+g[e[i].to][0]==mn)tmp+=(g[x][1]*g[e[i].to][1])%mod;
			if(h[x][0]+f[e[i].to][0]==mn)tmp+=(h[x][1]*f[e[i].to][1])%mod;
			g[x][0] = mn;
			g[x][1] = tmp%mod;

			h[x][0]+=g[e[i].to][0];
			h[x][1] = h[x][1]*g[e[i].to][1]%mod;
		}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	int ans1,ans2=0;
	ans1 = min(f[1][0],g[1][0]);
	if(f[1][0]==ans1)ans2+=f[1][1];
	if(g[1][0]==ans1)ans2+=g[1][1];
	ans2%=mod;
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2329

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct pas_seq
{
	int sum,lmax,rmax,lmin,rmin;
	void exc()
	{
		sum = -sum;
		swap(lmax,lmin);
		swap(rmax,rmin);
		lmax=-lmax,rmax=-rmax;
		lmin=-lmin,rmin=-rmin;
	}
	void rev()
	{
		swap(lmax,rmax);
		swap(lmin,rmin);
	}
	pas_seq(int x,int siz)
	{
		sum =siz*x;
		if(x==1)
			lmax=rmax=sum,lmin=rmin=0;
		else 
			lmin=rmin=sum,lmax=rmax=0;
	}
	friend pas_seq operator+(const pas_seq &a,const pas_seq &b)
	{
		pas_seq res(0,0);
		res.sum = a.sum+b.sum;
		res.lmax = max(a.lmax,a.sum+b.lmax);
		res.rmax = max(b.rmax,b.sum+a.rmax);
		res.lmin = min(a.lmin,a.sum+b.lmin);
		res.rmin = min(b.rmin,b.sum+a.rmin);
		return res;
	}
};
struct Splay
{
	Splay *ls,*rs,*fa;
	int cng,exc,size,val;
	bool rev;
	pas_seq *seq;
	Splay(int x);
	void push_up();
	void push_down();
}*null = new Splay(0),*root=null;
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	cng = exc = rev = 0;
	val = x,size = (val==0?0:1);
	seq = new pas_seq(x,size);
}
void Splay :: push_up()
{
	size = ls->size+(val==0?0:1)+rs->size;
	*seq = (*ls->seq)+pas_seq(val,1)+(*rs->seq);
}
void Splay :: push_down()
{
	if(cng)
	{
		ls->val = ls->cng = cng;
		rs->val = rs->cng = cng;
		*ls->seq = pas_seq(cng,ls->size);
		*rs->seq = pas_seq(cng,rs->size);
		ls->rev = ls->exc = 0;
		rs->rev = rs->exc = 0;
		cng = 0;
	}
	if(rev)
	{
		ls->rev^=1;
		rs->rev^=1;
		ls->seq->rev();
		rs->seq->rev();
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		rev = 0;
	}
	if(exc)
	{
		ls->exc^=1;
		rs->exc^=1;
		ls->val=-ls->val;
		rs->val=-rs->val;
		ls->seq->exc();
		rs->seq->exc();
		exc = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa= x;
	y->push_up();
	if(root==y)root=x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
void Insert(Splay *&x,int y,Splay *z)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = z;
		x->push_up();
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
char s[N];
int main()
{
	int n,m,l,r;
	char opt[10];
	scanf("%d%d",&n,&m);
	scanf("%s",s+1);
	Insert(root,-2,null);
	for(int i = 1;i<= n;i++)
		Insert(root,s[i]=='('?1:-1,null);
	Insert(root,2,null);
	while(m--)
	{
		scanf("%s%d%d",opt,&l,&r);
		find(root,l,null);
		find(root,r+2,root);
		Splay *tmp = root->rs->ls;
		if(opt[0]=='R')
		{
			scanf("%s",opt);
			int v = opt[0]=='('?1:-1;
			tmp->cng = tmp->val = v;
			*tmp->seq = pas_seq(v,tmp->size);
			tmp->exc = tmp->rev = 0;
		}else if(opt[0]=='S')
		{
			tmp->rev^=1;
			swap(tmp->ls,tmp->rs);
			tmp->seq->rev();
		}else if(opt[0]=='I')
		{
			tmp->exc^=1;
			tmp->val=-tmp->val;
			tmp->seq->exc();
		}else
		{
			l=(int)ceil(abs(tmp->seq->lmin)/2.0);
	           	r=(int)ceil(abs(tmp->seq->rmax)/2.0);
            		printf("%d\n",l+r);
		}
	}
	return 0;
}
Problem2333

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int INF = 0x3f3f3f3f;
int n,m,r1,r2;
struct Ask
{
	int o,x,y;
	void scanA()
	{
		char opt[3];
		scanf("%s",opt);
		if(opt[0]=='U')
			o = 1,scanf("%d%d",&x,&y);
		else if(opt[0]=='A')
		{
			if(opt[1]=='1')o = 2,scanf("%d%d",&x,&y);
			else if(opt[1]=='2')o = 3,scanf("%d%d",&x,&y);
			else o = 4,scanf("%d",&x);
		}else
		{
			if(opt[1]=='1')o = 5,scanf("%d",&x);
			else if(opt[1]=='2')o = 6,scanf("%d",&x);
			else o =7;
		}
	} 
}ask[N];
int maxn[N<<2],lazy[N<<2];
int fa[N<<2],ed[N<<2],next[N<<2],w[N<<2],save[N<<2],a[N];
int tot;
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int y)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		maxn[p]+=y;
		lazy[p]+=y;
		return ;
	}
	int mid=(l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,y);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,y);	
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)return maxn[p];
	int mid=(l+r)>>1,ans = -INF;
	if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		maxn[p] = save[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int id;
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		fa[i] = i,ed[i] = i;
	scanf("%d",&m);
	for(int i= 1;i<= m;i++)
	{
		ask[i].scanA();
		if(ask[i].o==1)
		{
			r1 = getfa(ask[i].x),r2 = getfa(ask[i].y);
			if(r1==r2)continue;
			fa[r2] = r1;
			next[ed[r1]] = r2;
			ed[r1] = ed[r2];
		}
	}
	for(int i = 1;i<= n;i++)
		if(getfa(i)==i)
			for(int j = i;j;j = next[j])
			{
				id++;
				w[j] = id;
				save[id] = a[j];
			}
	build(1,1,n);
	for(int i= 1;i<= n;i++)
		fa[i] = i,ed[i] = i;
	for(int i = 1;i<= m;i++)
	{
		if(ask[i].o==1)
		{
			r1=getfa(ask[i].x),r2=getfa(ask[i].y);
			if(r1==r2)continue;
			fa[r2] = r1;
			ed[r1] = ed[r2];
		}
		else if(ask[i].o==2)update(1,1,n,w[ask[i].x],w[ask[i].x],ask[i].y);
		else if(ask[i].o==3)update(1,1,n,w[getfa(ask[i].x)],w[ed[getfa(ask[i].x)]],ask[i].y);
		else if(ask[i].o==4)update(1,1,n,1,n,ask[i].x);
		else if(ask[i].o==5)printf("%d\n",getans(1,1,n,w[ask[i].x],w[ask[i].x]));
		else if(ask[i].o==6)printf("%d\n",getans(1,1,n,w[getfa(ask[i].x)],w[ed[getfa(ask[i].x)]]));
		else printf("%d\n",getans(1,1,n,1,n));
	}
	return 0;
}
Problem2337

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned int UI;
const int N = 105;
const double eps = 1e-8;
int n;
double f[N][N],ans[N],cnt[N];
struct E
{int next,to,val;}e[N*N*2];
int head[N],tot;
void add(int x,int y,int f)
{
	cnt[x]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void work()
{
	for(int i = 1;i< n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(f[xn],f[i]);
		for(int line = i+1;line<= n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = 1;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n-1;i>= 1;i--)
	{
		for(int j = i+1;j<= n;j++)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	int m,x,y;
	UI c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%u",&x,&y,&c);
		add(x,y,c);
		if(x!=y)add(y,x,c);
	}
	double t_ans = 0;
	for(int pos = 0;pos<32;pos++)
	{
		memset(f,0,sizeof(f));
		for(int i = 1;i< n;i++)
			for(int j = head[i];j;j = e[j].next)
			{
				if(e[j].val&(1<<pos))f[i][e[j].to]+=1.0,f[i][n+1]+=1.0;
				else f[i][e[j].to]-=1.0;
			}
		for(int i = 1;i< n;i++)
			f[i][i]+=cnt[i];
		memset(ans,0,sizeof(ans));
		work();
		t_ans+=ans[1]*(1<<pos);
	}
	printf("%.3f\n",t_ans);
	return 0;
}
Problem2338

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1505;
struct Point
{
	ll x,y;
	Point(){}
	Point(ll x,ll y):x(x),y(y){}
	bool operator ==(const Point &a)const
	{
		return (a.x==x&&a.y==y);
	}
	Point operator -(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	ll operator *(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
}poi[N];
struct Line
{
	Point *p1,*p2;
	Point midp;
	ll len;
	bool operator==(const Line &a)const
	{
		return (a.len==len&&a.midp==midp);
	}
	bool operator<(const Line &a)const
	{
		if(a.len==len)
		{
			if(a.midp.x==midp.x)
				return midp.y<a.midp.y;
			return midp.x<a.midp.x;
		}
		return len<a.len;
	}
}line[(N*N)>>1];
ll dis(const Point &p1,const Point &p2)
{
	return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);
}
ll Abs(ll x)
{
	return x>0?x:-x;
}
int tot;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld",&poi[i].x,&poi[i].y);
		for(int j = 1;j<i;j++)
		{
			line[++tot].len = dis(poi[i],poi[j]);
			line[tot].p1 = &poi[i];
			line[tot].p2 = &poi[j];
			line[tot].midp = Point(poi[i].x+poi[j].x,poi[i].y+poi[j].y);
		}
	}
	sort(line+1,line+tot+1);
	int i,j;
	ll ans = 0;
	for(i = 1;i<= tot;i++)
	{
		for(j = i-1;j&&line[j]==line[i];j--)
			ans = max(ans,Abs( ((*line[i].p1)-(*line[j].p1))*((*line[i].p1)-(*line[j].p2)) ) );
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2342

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int p[N],q[N];
char s[N];
set<int>t;
bool cmp(int a,int b)
{
	return a-p[a]<b-p[b];
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	s[0]='#';
	int maxp = 0,id = 0;
	for(int i = 1;i<= n;i++)
	{
		if(maxp>=i)p[i]=min(p[id*2-i],maxp-i);
		else p[i]=0;
		for(;s[i+p[i]+1]==s[i-p[i]];p[i]++);
		if(p[i]+i>maxp)maxp = p[i]+i,id=i;
	}
	for(int i = 1;i<= n;i++)q[i]=i;
	sort(q+1,q+n+1,cmp);
	int now = 1,ans = 0;
	for(int i = 1;i<= n;i++)
	{
		while(now<=n&&q[now]-p[q[now]]<=i)
		{
			t.insert(q[now]);
			now++;
		}
		set<int>::iterator tmp=t.upper_bound(i+p[i]/2);
		if(tmp!=t.begin())
		{
			ans=max(ans,(*--tmp-i)*4);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem2393

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3005;
int t,vis[N];
ll l,r,n,m;
ll a[N];
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
void getnum(ll x,ll y)
{
	if(y>r)
		return ;
	if(x>1)
		a[++m]=y;
	if(x>t)
		return ;
	getnum(x+1,y*10+2);
	getnum(x+1,y*10+9);
}
ll ans;
void dfs(ll x,ll y,ll z)
{
	if(x>n)
	{
		if(y&1)
			ans+=r/z-(l-1)/z;
		else
			if(y)
				ans-=r/z-(l-1)/z;
		return ;
	}
	dfs(x+1,y,z);
	ll next = a[x]*z/gcd(a[x],z);
	if(next<=r)
		dfs(x+1,y+1,next);
	return ;
}
int b[N];
int main()
{
	scanf("%lld%lld",&l,&r);
	t = (int)(log10(r)+1);
	getnum(1,0);
	sort(a+1,a+m+1);
	for(int i = 1;i<= m;i++)
		if(!vis[i])
		{
			b[++n] = a[i];
			for(int j = i+1;j<= m;j++)
				if(a[j]%a[i]==0)
					vis[j] = 1;
		}
	for(int i = 1;i<= n;i++)
		a[n-i+1]=b[i];
	dfs(1,0,1);
	printf("%lld\n",ans);
	return 0;
}
Problem2427

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 505;
struct E
{
	int next,to;
}edge[N],e[N];
int h1[N],h2[N],tot1,tot2,ind[N];
void add1(int x,int y)
{
	edge[++tot1].to = y;
	edge[tot1].next = h1[x];
	h1[x] = tot1;
}
void add2(int x,int y)
{
	ind[y]++;
	e[++tot2].to = y;
	e[tot2].next = h2[x];
	h2[x] = tot2;
}
int dep[N],low[N],dfn,stack[N],top,scc,id[N],W[N],V[N];
int w[N],v[N],n,m;
bool ins[N],vis[N];
void tarjan(int x)
{
	vis[x] = true;
	low[x] = dep[x] = ++dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = h1[x];i;i = edge[i].next)
	{
		if(!vis[edge[i].to])
			{tarjan(edge[i].to);low[x] = min(low[x],low[edge[i].to]);}
		else if(ins[edge[i].to])
			low[x] = min(low[x],dep[edge[i].to]);
	}
	if(low[x]==dep[x])
	{
		scc++;
		int tmp;
		do{
			tmp = stack[top--];
			ins[tmp] = false;
			id[tmp] = scc;
			W[scc]+=w[tmp],V[scc]+=v[tmp];
		}while(tmp!=x);
	}
}
bool map[N][N];
void rebuild()
{
	for(int i = 1;i<= n;i++)
		for(int j = h1[i];j;j = edge[j].next)
			if(id[i]!=id[edge[j].to]&&!map[id[i]][id[edge[j].to]])
			{
				add2(id[i],id[edge[j].to]);
				map[id[i]][id[edge[j].to]] = true;
			}
}
int f[N][M];
void dp(int x,int fa)
{
	if(W[x]<=m)f[x][W[x]] = V[x];
	for(int i = h2[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dp(e[i].to,x);
	for(int i = h2[x];i;i = e[i].next)
		for(int j = m;j>=0;j--)
			for(int k = 0;k<= j;k++)
				if(f[x][j-k]!=-1&&f[e[i].to][k]!=-1)
					f[x][j] = max(f[x][j],f[x][j-k]+f[e[i].to][k]);
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&v[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(x==0)continue;
		add1(x,i);
	}

	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	//printf("warning\n");
	rebuild();
	int root = 0;
	for(int i = 1;i<= scc;i++)
		if(ind[i]==0)
			add2(root,i);
	memset(f,-1,sizeof(f));
	int ans = 0;
	dp(root,-1);
	for(int i = m;i>=0;i--)
		ans = max(f[root][i],ans);
	printf("%d\n",ans);
	return 0;
}
Problem2434

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 1e5+5;
char s[N];
struct Gragh
{int next,to;}e[N<<1];
int head[N],tot,Dfn;
void add(int x,int y)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;}
struct P
{int no,x;};
int dfn[N],end[N];
void dfs(int x)
{
	dfn[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	end[x] = Dfn;
}
int c[N],id[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
vector<P>ask[N];
int ans[N];
struct AC_Machine
{
	int ch[N][26],sum[N],fail[N],from[N];
	int q[N],h,t,cnt;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i] = 1;
	}
	void insert()
	{
		scanf("%s",s);
		int now = 1,i = 0,num = 0;
		while(s[i])
		{
			if(s[i]=='P')
			{
				num++;
				id[num] = now;
				sum[now]++;i++;continue;
			}
			if(s[i]=='B'){now = from[now];i++;continue;}
			if(!ch[now][s(i)])
				{ch[now][s(i)]=++cnt;from[cnt]=now;}
			now = ch[now][s(i)];
			i++;
		}
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1,fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				q[++t] = to;
				add(fail[to],to);
			}
		}
	}
}AC;
int main()
{
	AC.insert();
	AC.build();
	dfs(1);
	int m,x,y;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		ask[y].push_back((P){i,x});
	}
	int num = 0,n = strlen(s)-1,now = 1;
	for(int i =0;i<=n;i++)
	{
		if(s[i]=='P')
		{
			num++;
			int sz = ask[num].size();
			for(int j = 0;j<sz;j++)
			{
				int x = id[ask[num][j].x];
				ans[ask[num][j].no] = getans(end[x])-getans(dfn[x]-1);
			}
			continue;
		}
		if(s[i]=='B'){update(dfn[now],-1);now = AC.from[now];continue;}
		now = AC.ch[now][s(i)];
		update(dfn[now],1);
	}
	for(int i = 1;i<= m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem2442

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long LL;
LL sum[N],f[N];
int line[N],l,r;
int main()
{
	int n,k,x;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		sum[i] = sum[i-1]+x;
	}
	line[0] = 0;
	for(int i = 1;i<= n+1;i++)
	{
		while(l<=r&&i-line[l]-1>k)l++;
		if(l<=r)
			f[i] = max(f[i],f[line[l]]-sum[line[l]]+sum[i-1]);
		while(l<=r&&f[i]-sum[i]>f[line[r]]-sum[line[r]])
			r--;
		line[++r] = i;
	}
	printf("%lld\n",f[n+1]);
	return 0;
}
Problem2453

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int C = 1e6+5;
const int INF = 0x3f3f3f3f;
int n,m;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2],*col[C];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_less(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_less(x->ls,y);
	else
	{
		if(x->ls)tmp+=x->ls->size;
		tmp+=x->cnt;
		get_less(x->rs,y);
	}
}
void get_less(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_less(root[p],y);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_less(p<<1,l,mid,a,b,y);
	if(b >mid)get_less(p<<1|1,mid+1,r,a,b,y);
}
int tt;
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)get_pre(x->ls,y);
	else
	{
		tt = max(tt,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)get_sub(x->rs,y);
	else
	{
		tt = min(tt,x->val);
		get_sub(x->ls,y);
	}
}
int pre[N],last[C],color[N];
void build(int p,int l,int r,int pos,int val)
{
	Insert(root[p],val);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,val);
	else build(p<<1|1,mid+1,r,pos,val);
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int main()
{
	scanf("%d%d",&n,&m);
	int cc = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&color[i]);
		pre[i] = last[color[i]];
		last[color[i]] = i;
		Insert(col[color[i]],i);
		cc = max(cc,color[i]);
	}
	for(int i = 1;i<= n;i++)
		build(1,1,n,i,pre[i]);
	for(int i=1;i<=1000000;i++)
		Insert(col[i],0),Insert(col[i],n+1);
	char opt[2];
	int x,y;
	while(m--)
	{
		scanf("%s%d%d",opt,&x,&y);
		if(opt[0]=='Q'){tmp = 0;get_less(1,1,n,x,y,x);printf("%d\n",tmp);}
		else
		{
			tt = INF;get_sub(col[color[x]],x);
			int nextA = tt;
			tt = 0;get_pre(col[y],x);
			int lastB = tt;
			tt = INF;get_sub(col[y],x);
			int nextB = tt;
			if(nextA!=n+1)change(1,1,n,nextA,x,pre[x]);
			change(1,1,n,x,pre[x],lastB);
			if(nextB!=n+1)change(1,1,n,nextB,lastB,x);
			Delete(col[color[x]],x);Insert(col[y],x);
			color[x] = y;
			if(nextA!=n+1)pre[nextA] = pre[x];
			pre[x] =lastB;
			if(nextB!=n+1)pre[nextB] = x;
		}
	}
	return 0;
}
Problem2460

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
typedef long long ll;
struct B
{
	ll no,val;
	bool operator <(const B &s)const
	{
		return val>s.val;
	}
}stone[N];
ll a[N],p[70];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		ll x,y;
		scanf("%lld%lld",&x,&y);
		stone[i].no = x,stone[i].val = y;
	}
	sort(stone+1,stone+1+n);
	for(int i = 1;i<= n;i++)a[i]=stone[i].no;
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 63;j>=0;j--)
			if((a[i]>>j)&1)
			{
				if(!p[j]){p[j] = a[i];break;}
				else a[i]^=p[j];
			}
		if(a[i])ans+=stone[i].val;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2467

#include <stdio.h>
int ans[]={0,4,40,300,2000,458,741,1981,1285,1458,518,842,1491,1888,1675,1662,836,929,432,1165,850,1452,1298,764,1281,1738,1411,765,473,1661,771,304,1828,645,890,803,1836,292,1174,426,1001,1367,687,793,790,117,1490,1940,213,1798,613,1320,1889,1946,333,841,85,1902,839,980,867,226,655,900,653,86,591,1753,748,1788,1187,1289,1278,625,391,327,1523,1034,363,1864,1537,882,500,1013,1644,1150,505,384,1250,893,1764,1336,1372,390,1712,1349,795,316,1348,1566,23};
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		printf("%d\n",ans[n]);
	}
	return 0;
}
Problem2500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
LL f[N],t[N],hap[N];
int Q1[N],Q2[N],f_no[N],l1,l2,r1,r2;
struct E
{
	int next,to,val;
}e[N];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		if(f[e[i].to]+e[i].val>f[x])
		{
			t[x] = f[x];
			f[x] = f[e[i].to]+e[i].val;
			f_no[x] = e[i].to;
		}else if(f[e[i].to]+e[i].val>t[x])
			t[x] = f[e[i].to]+e[i].val;
	}
}
void redfs(int x,LL v)
{
	hap[x] = max(f[x],v);
	for(int i = head[x];i;i = e[i].next)
	{
		LL tmp = f_no[x]==e[i].to?t[x]:f[x];
		redfs(e[i].to,max(v,tmp)+e[i].val);
	}
}
int main()
{
	int n,m,x,y,ans = 0;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		//if(x==i)root = i;
		add(x,i,y);
	}
	dfs(1);
	redfs(1,0);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&hap[i]>hap[Q1[r1]])r1--;
		Q1[++r1] = i;
		while(l2<=r2&&hap[i]<hap[Q2[r2]])r2--;
		Q2[++r2] = i;
		while(hap[Q1[l1]]-hap[Q2[l2]]>m)
		{
			j++;
			while(l1<=r1&&Q1[l1]<j)l1++;
			while(l2<=r2&&Q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
LL f[N],t[N],hap[N];
int Q1[N],Q2[N],f_no[N],l1,l2,r1,r2;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
struct E
{
	int next,to,val;
}e[N];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		if(f[e[i].to]+e[i].val>f[x])
		{
			t[x] = f[x];
			f[x] = f[e[i].to]+e[i].val;
			f_no[x] = e[i].to;
		}else if(f[e[i].to]+e[i].val>t[x])
			t[x] = f[e[i].to]+e[i].val;
	}
}
void redfs(int x,LL v)
{
	hap[x] = max(f[x],v);
	for(int i = head[x];i;i = e[i].next)
	{
		LL tmp = f_no[x]==e[i].to?t[x]:f[x];
		redfs(e[i].to,max(v,tmp)+e[i].val);
	}
}
int main()
{
	int n,m,x,y,ans = 0;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		x = read();y = read();
		//if(x==i)root = i;
		add(x,i,y);
	}
	dfs(1);
	redfs(1,0);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&hap[i]>hap[Q1[r1]])r1--;
		Q1[++r1] = i;
		while(l2<=r2&&hap[i]<hap[Q2[r2]])r2--;
		Q2[++r2] = i;
		while(hap[Q1[l1]]-hap[Q2[l2]]>m)
		{
			j++;
			while(l1<=r1&&Q1[l1]<j)l1++;
			while(l2<=r2&&Q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2525

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int f[N],sta[N],cnt,ans,d[N],n,m;
void dfs(int x,int fa)
{
	int nf = -1,fw= d[x]-1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			if(sta[e[i].to]==0)
				nf = max(nf,f[e[i].to]-1);
			else if(sta[e[i].to]==1)
				fw = max(fw,f[e[i].to]+1);
		}
	if(nf<fw)
	{
		if(fw==ans)
		{
			cnt++;
			f[x] = ans;
			sta[x] = 0;
		}else
		{
			f[x] = fw;
			sta[x] = 1;
		}
	}else if(nf!=-1)
	{
		f[x] = nf;
		sta[x] = 0;
	}else
	{
		f[x] = 0;
		sta[x] = 2;
	}
}
int check()
{
	int l = 0,r = n+1;
	while(l<r)
	{
		ans = (l+r)>>1;
		memset(f,0,sizeof(f));
		memset(sta,-1,sizeof(sta));
		cnt = 0;
		dfs(1,0);
		if(sta[1]==1)cnt++;
		if(cnt>m)l = ans+1;
		else r = ans;
	}
	return l;
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&d[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	printf("%d\n",check());
	return 0;
}
Problem2527

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
typedef long long LL;
struct E
{int next,to;}e[N],k[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int pos[N],Cnt,n,m,K;
void Add(int x,int y)
{
	k[++Cnt].to = y;
	k[Cnt].next = pos[x];
	pos[x] = Cnt;
}
struct A
{int l,r,mid;}ask[N];
LL c[N];
struct R
{int s,t,a;}rain[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
LL getans(int x)
{
	LL ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void UP(int i)
{
	if(rain[i].s>rain[i].t)
	{
		update(1,rain[i].a);update(rain[i].t+1,-rain[i].a);
		update(rain[i].s,rain[i].a);update(m+1,-rain[i].a);
	}else
		update(rain[i].s,rain[i].a),update(rain[i].t+1,-rain[i].a);
}
LL p[N];
void check()
{
	memset(c,0,sizeof(c));
	memset(head,0,sizeof(head));
	tot = 0;
	for(int i = 1;i<= n;i++)
	{
		ask[i].mid = (ask[i].l+ask[i].r)>>1;
		add(ask[i].mid,i);
	}
	for(int i = 1;i<= K;i++)
	{
		UP(i);
		for(int j = head[i];j;j = e[j].next)
		{
			LL ans = 0;
			for(int t = pos[e[j].to];t;t = k[t].next)
			{
				ans+=getans(k[t].to);
				if(ans>p[e[j].to])break;
			}
			if(ans<p[e[j].to])
				ask[e[j].to].l = ask[e[j].to].mid+1;
			else
				ask[e[j].to].r = ask[e[j].to].mid;
		}
	}
}
int main()
{
	//freopen("met.in","r",stdin);
	//freopen("met.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int x;
		scanf("%d",&x);
		Add(x,i);
	}
	for(int i = 1;i<= n;i++)
		scanf("%lld",&p[i]);
	scanf("%d",&K);
	for(int i = 1;i<= K;i++)
		scanf("%d%d%d",&rain[i].s,&rain[i].t,&rain[i].a);
	for(int i = 1;i<= n;i++)
		ask[i].l = 1,ask[i].r = K+1;
	for(int i = 1;i<= 20;i++)
		check();
	for(int i = 1;i<= n;i++)
	{
		if(ask[i].mid<=K)
			printf("%d\n",ask[i].mid);
		else printf("NIE\n");
	}
	return 0;
}
Problem2529

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
struct S
{int lth,col;}stick[N],a[4];
bool cmp(S a,S b)
{
	return a.lth<b.lth;
}
int main()
{
	int k,x,tot = 0;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&x);
		for(int j = 1;j<= x;j++)
		{
			tot++;
			scanf("%d",&stick[tot].lth);
			stick[tot].col = i;
		}
	}
	sort(stick+1,stick+tot+1,cmp);
	for(int i = 1;i<= tot;i++)
	{
		int j;
		for(j = 1;j<= 3;j++)
			if(stick[i].col==a[j].col)
				{a[j] = stick[i];break;}
		if(j==4)a[1] = stick[i];
		sort(a+1,a+4,cmp);
		if(a[1].col!=0)
			if(a[1].lth+a[2].lth>a[3].lth)
			{
				printf("%d %d %d %d %d %d\n",a[1].col,a[1].lth,a[2].col,a[2].lth,a[3].col,a[3].lth);
				return 0;
			}
	}
	printf("NIE\n");
	return 0;
}
Problem2530

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
bool map[N][N];
bool v[N];
int main()
{	
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y] = map[y][x] = true;
	}
	int cnt = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i])
			for(int j = i+1;j<= n;j++)
				if(!v[j]&&!map[i][j])
				{
					v[i] = v[j] = true;
					break;
				}
	for(int i = 1;i<= n;i++)
	{
		if(!v[i])
			printf("%d%c",i,++cnt==n/3?' ':'\n');
		if(cnt==n/3)break;
	}
	return 0;
}
Problem2539

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
typedef long long ll;
const int maxm=100000,inf=1061109567;
const ll mod=1000000007;
map<ll,int>id;  char str[30];   ll hash[100];
int h[100],p[maxm],c[maxm],cost[maxm],n1[maxm],q[maxm],sp[100],inq[100];
int D,n,S,T,TT,An=0,path[maxm],w[100][100],pre[100],tot=0,px[100],py[100];
inline void ae(int a,int b,int cc,int co)
{
	p[tot]=b; c[tot]=cc; cost[tot]=co;  n1[tot]=h[a]; h[a]=tot++;
	p[tot]=a; c[tot]=0;  cost[tot]=-co; n1[tot]=h[b]; h[b]=tot++;
}
inline int spfa()
{
	memset(sp,63,sizeof(sp));   
	memset(inq,0,sizeof(inq));
	int head=0,tail=1; 
	sp[S]=0; q[0]=S; 
	inq[S]=1; pre[S]=-1;
	while(head!=tail)
	{
		int u=q[head++]; 
		if(head>=maxm) 
			head-=maxm; 
		inq[u]=0;
		for(int i=h[u];~i;i=n1[i])
			if(c[i]>0&&sp[p[i]]>sp[u]+cost[i])
			{
				path[p[i]]=i, pre[p[i]]=u, sp[p[i]]=sp[u]+cost[i];
				if(!inq[p[i]])
				{ 
					inq[p[i]]=1, q[tail++]=p[i]; 
					if(tail>=maxm) 
						tail-=maxm;
				}
			}
	}
	return sp[T]!=inf;
}
inline int aug()
{
	int delta=inf,  flow=0;
	for(int i=T;pre[i]!=-1;i=pre[i]) delta=min(delta,c[path[i]]);
	for(int i=T;pre[i]!=-1;i=pre[i])
	{
		c[path[i]]-=delta, c[path[i]^1]+=delta;
		flow+=cost[path[i]]*delta;
	}
	return flow;
}
inline int cf()
{
	int ret=0; 
	while(spfa()) 
		ret+=aug(); 
	return ret;
}
inline ll gethash(char *str)
{
	ll tmp=0; int len=strlen(str);
	for(int j=0;j<len;j++) 
		if(str[j]>='A' && str[j]<='Z') 
			str[j]=str[j]+32; 
	for(int j=0;j<len;j++)
	{
		tmp=tmp*29+str[j];
		if(tmp>=mod) tmp%=mod;
	}
	return tmp;
}
inline int ok(int u,int v)
{
	if((px[u]-px[v])*(px[u]-px[v])+(py[u]-py[v])*(py[u]-py[v])>D*D) return 0;
	for(int i=1;i<=n<<1;i++)
	{
		if(i==u||i==v) continue;
		if((px[i]-px[u])*(px[i]-px[v])>0) continue;
		if((py[i]-py[u])*(py[i]-py[v])>0) continue;
		if((px[i]-px[u])*(py[v]-py[i])==(py[i]-py[u])*(px[v]-px[i])) return 0;
	}
	return 1;
}
int main()
{
	scanf("%d%d",&D,&n);
	S=0;TT=n<<1|1;T=TT+1;
	memset(h,0xff,sizeof(h));
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%s",&px[i],&py[i],str);
		px[i]+=50;py[i]+=50;
		id[hash[i]=gethash(str)]=i;
		ae(S,i,1,0);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%s",&px[n+i],&py[n+i],str);
		px[n+i]+=50;py[n+i]+=50;
		id[hash[n+i]=gethash(str)]=n+i;
		ae(n+i,T,1,0);
	}
	int u,v;
	for(int i=1;i<=n<<1;i++) 
		for(int j=1;j<=n<<1;j++) 
			w[i][j]=1;
	while(1)
	{
		scanf("%s",str);    
		if(!strcmp("End",str)) break;   
		u=id[gethash(str)];
		scanf("%s",str);    v=id[gethash(str)];
		scanf("%d",&w[u][v]);   w[v][u]=w[u][v];
	}
	for(int i=1;i<=n;i++) 
		for(int j=n+1;j<=n<<1;j++) 
			if(ok(i,j)) 
				ae(i,j,1,-w[i][j]);
	printf("%d\n",-cf()); 
	return 0;
}
Problem2547

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define vx v.x
#define ux u.x
#define vy v.y
#define uy u.y
const int N = 115;
const int INF = 0x3f3f3f3f;
int h[N][N],dis[N][N],n,m,par[N],tot,mp[N][N],cnt,pt;
struct P
{
	int x,y;
	P(int x=0,int y=0):x(x),y(y){}
}a[N],b[N];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
bool vis[N][N],bo[N];
queue<P>Q;
void spfa(int sx,int sy,int p)
{
	memset(dis,0x3f,sizeof(dis));
	dis[sx][sy]=0;
	vis[sx][sy]=true;
	Q.push(P(sx,sy));
	P u,v;
	int t;
	while(!Q.empty())
	{
		u = Q.front();
		Q.pop();
		vis[ux][uy]=false;
		for(int i = 0;i<4;i++)
		{
			vx = ux+dx[i],vy=uy+dy[i];
			if(vx<=0||vy<=0||vx>n||vy>m)continue;
			if(p^(dis[ux][uy]&1))
				{if(h[vx][vy]<=h[ux][uy])t=0;else t=1;}
			else
				{if(h[vx][vy]>=h[ux][uy])t=0;else t=1;}
			if(dis[ux][uy]+t<dis[vx][vy])
			{
				dis[vx][vy]=dis[ux][uy]+t;
				if(!vis[vx][vy])
				{
					Q.push(P(vx,vy));
					vis[vx][vy]=true;
				}
			}
		}
	}
}
bool get_partner(int x,int lim)
{
	for(int i = 1;i<= tot;i++)
		if(bo[i]&&mp[x][i]<=lim)
		{
			bo[i]=false;
			if(!par[i]||get_partner(par[i],lim))
			{
				par[i]=x;
				return true;
			}
		}
	return false;
}
bool check(int x)
{
	int tmp = 0;
	memset(par,0,sizeof(par));
	for(int i= 1;i<= cnt<<1;i++)
	{
		memset(bo,1,sizeof(bo));
		if(get_partner(i,x))tmp++;
	}
	return tmp+x>=(cnt<<1);
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&cnt,&pt);
	int x,y,t;
	for(int i = 1;i<=(cnt<<1|1);i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	for(int i = 1;i<=pt;i++)
	{
		scanf("%d%d%d",&x,&y,&t);
		while(t--)
			b[++tot].x=x,b[tot].y=y;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&h[i][j]);
	for(int i = 1;i<= cnt<<1;i++)
	{
		if(i<=cnt)spfa(a[i].x,a[i].y,0);
		else spfa(a[i].x,a[i].y,1);
		for(int j = 1;j<= tot;j++)mp[i][j]=dis[b[j].x][b[j].y];
	}
	int l = 0,r = cnt*2;
	while(l<r)
	{
		int mid =(l+r)>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem2553

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
#define s(no,i) s[no][i]-'a'
typedef long double ld;
const int P = 81;
int n,L,k;
struct Matrix
{
	int w,h;
	ld d[P][P];
	Matrix(){}
	Matrix(int _w,int _h):w(_w),h(_h){}

	void operator*=(const Matrix &S)
	{
		Matrix res(w,S.h);
		for(int i = 0;i<res.w;i++)
			for(int j = 0;j<res.h;j++)
			{
				res.d[i][j] = 0;
				for(int k = 0;k<h;k++)
					res.d[i][j]+=d[i][k]*S.d[k][j];
			}
		*this = res;
	}
};
int len[6];
char s[6][20];
bool cover(int a,int b)
{
	if(len[a]<len[b])return false;
	for(int i = 1;i+len[b]-1<=len[a];i++)
	{
		bool flag = true;
		for(int j = 1;j<= len[b];j++)
			if(s[a][i+j-1]!=s[b][j])
				{flag=false;break;}
		if(flag)return true;
	}
	return false;
}
struct AC_Machine
{
	int ch[P][26],fail[P];
	int cnt,q[P],h,t;
	bool end[P];
	void insert(int no)
	{
		int now = 0,i = 1;
		while(s[no][i])
		{
			if(!ch[now][s(no,i)])ch[now][s(no,i)] = ++cnt;
			now = ch[now][s(no,i)];
			i++;
		}
		end[now]=true;
	}
	void build()
	{
		h = 0,t = -1;
		for(int i = 0;i<k;i++)
			if(ch[0][i])
				q[++t] = ch[0][i];
		while(h<=t)
		{
			int x=q[h++];
			for(int i = 0;i<k;i++)
			{
				int j = ch[x][i];
				if(j)
				{
					q[++t] = j;
					int r = fail[x];
					while(r&&!ch[r][i])r = fail[r];
					fail[j] = ch[r][i];
					end[j]|=end[fail[j]];
				}
				else ch[x][i] = ch[fail[x]][i];
			}
		}
	}
}AC;
bool covered[6];
int main()
{
	scanf("%d%d%d",&n,&L,&k);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	for(int i = 1;i<= n;i++)
		len[i] = strlen(s[i]+1);
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			if(cover(i,j))
				covered[i] = true;
	bool a_c = true;
	for(int i = 1;i<= n;i++)
		if(!covered[i])a_c = false;
	if(a_c)covered[1] = false;
	AC.cnt = 0;
	for(int i = 1;i<= n;i++)
		if(!covered[i])
			AC.insert(i);
	AC.build();
	int cnt = AC.cnt;
	Matrix res(1,cnt+2);
	res.d[0][0] = 1;
	Matrix add(cnt+2,cnt+2);add.d[cnt+1][cnt+1] = 1;
	for(int i = 0;i<=cnt;i++)
		for(int j = 0;j<k;j++)
			if(AC.end[AC.ch[i][j]])add.d[i][cnt+1]+=(ld)1/(ld)k,add.d[i][0]+=(ld)1/(ld)k;
			else add.d[i][AC.ch[i][j]]+=(ld)1/(ld)k;
	for(;L;L>>=1,add*=add)if(L&1)res*=add;
	double ans = res.d[0][cnt+1];
	printf("%.6lf\n",ans);
	return 0;
}
Problem2555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1200005;
char s[N];
int mask;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,add_mark;
	Splay();
	void push_down();
	void Add(int x);
}*null = new Splay;
Splay :: Splay ()
{
	ls = rs = fa = null;
	val = add_mark = 0;
}
void Splay :: push_down()
{
	if(fa->ls==this||fa->rs==this)
		fa->push_down();
	if(add_mark)
	{
		ls->Add(add_mark);
		rs->Add(add_mark);
		add_mark = 0;
	}
}
void Splay :: Add(int x)
{
	val+=x;
	add_mark+=x;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa= x;
}
void splay(Splay *x)
{
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
}
void Access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		y = x,x = x->fa;
	}
}
void Cut(Splay *x)
{
	Access(x);
	splay(x);
	x->ls->fa = null;
	x->ls = null;
}
void Link(Splay *x,Splay *y)
{
	Cut(x);
	x->fa = y;
}
struct SAM
{
	int trs[N][26],fa[N],len[N];
	int cnt,last;
	Splay *tree[N];
	void init(){cnt=last=1;tree[1] = new Splay;}
	void insert(int x)
	{
		int p,newp,q,newq;
		p = last,newp = ++cnt,last = cnt;
		tree[cnt] = new Splay;
		len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)
		{
			fa[newp] = 1;
			Link(tree[newp],tree[1]);
		}
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)
			{
				fa[newp] = q;
				Link(tree[newp],tree[q]);
			}
			else
			{
				newq = ++cnt;
				tree[newq] = new Splay;
				fa[newq] = fa[q];
				Link(tree[newq],tree[fa[q]]);
				memcpy(trs[newq],trs[q],sizeof(trs[q]));
				len[newq] = len[p]+1;
				fa[newp] = fa[q] = newq;
				Link(tree[q],tree[newq]);
                Link(tree[newp],tree[newq]);
                tree[q]->push_down();
                tree[newq]->val = tree[q]->val;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = newq;
			}
		}
		Access(tree[newp]);
        splay(tree[newp]);
        tree[newp]->Add(1);
	}
	void Insert()
	{
		for(int i = 1;s[i];i++)
			insert(s[i]-'A');
	}
	int Query(char *s)
    {
        int p = 1;
        for(;p;p=trs[p][(*s++)-'A'])
            if(!*s) return tree[p]->push_down(),tree[p]->val;
        return 0;
    }
}sam;
void Decode(char s[],int mask)
{
    int i,n=strlen(s);
    for(i=0;i<n;i++)
    {
        mask=(mask*131+i)%n;
        swap(s[i],s[mask]);
    }
}
int main()
{
	int q;
	char opt[10];
	sam.init();
	scanf("%d",&q);
	scanf("%s",s+1);
	sam.Insert();
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%s",opt,s+1);
		Decode(s+1,mask);
		if(opt[0]=='A')sam.Insert();
		else
		{
			int tmp = sam.Query(s+1);
			mask^=tmp;
			printf("%d\n",tmp);
		}
	}
	return 0;
}
Problem2557

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1e6+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[N],pass[N];
int fa[N];
bool dfs(int x)
{
	for(int i=head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			used[e[i].to] = true;
			if(!fa[e[i].to]||dfs(fa[e[i].to]))
			{
				fa[e[i].to] = x;
				return true;
			}
		}
	return false;
}
int main()
{
	int n,m,r,t,k,x,y;
	scanf("%d%d%d%d%d",&n,&m,&r,&t,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	int ans1 = 0,ans2 = 0;
	for(int j = r;j<=t;j = j+r)
	{
		for(int i = 1;i<= n;i++)
			if(!pass[i])
			{
				memset(used,0,sizeof(used));
				if(dfs(i))ans1++,ans2+=j;
				else pass[i] = true;
			}
	}
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem2560

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<16;
const int mod = 1e9+7;
int c[20][20];
int f[S],g[S],n;
int main()
{
	int now;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
		for(int j = 0;j<n;j++)
			scanf("%d",&c[i][j]);
	int end = 1<<n;
	for(int i = 1;i<end;i++)
	{
		g[i] = 1;
		for(int j = 0;j<n;j++)if(i&(1<<j))
			for(int k = j+1;k<n;k++)if(i&(1<<k))
				g[i] = (ll)g[i]*(c[j][k]+1)%mod;
		for(int j = n-1;j>= 0;j--)
			if(i&(1<<j)){now = j;break;}
		f[i] = g[i];
		now = i^(1<<now);
		for(int j = now;j;j=(j-1)&now)
			(f[i]+=mod-(ll)g[j]*f[i^j]%mod)%=mod;
	}
	printf("%d\n",f[end-1]);
	return 0;
}
Problem2563

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 1e5+5;
struct E
{int next,to,val;}e[M<<1];
int head[N],tot,w[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
struct data
{
	int id,val;
	bool operator <(const data &s)const
	{
		return val>s.val;
	}
}p[N];
int main()
{
	long long ans = 0;
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]),ans-=w[i];
	int a,b,c;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c),ans-=c;
	}
	for(int i = 1;i<= n;i++)
	{
		p[i].id = i;
		p[i].val = 2*w[i];
		for(int j = head[i];j;j=e[j].next)
			p[i].val+=e[j].val;
	}
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i+=2)
		ans+=p[i].val;
	printf("%lld\n",ans);
	return 0;
}
Problem2588

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 8000005;
typedef long long ll;
struct E
{int next,to;}e[N<<1];
inline int read() 
{
	int f = 1; ll x = 0; char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) f = ch == '-' ? -1 : 1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';
	return f * x;
}
int head[N],tot,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N][20],dep[N],line[N],tail;
int cnt,root[N],ls[M],rs[M];
int sum[M],val[N],pos[N],top,ans;
int getpos(int x)
{
	int l = 1,r = top+1;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void init()
{
	for(int j = 1;j<= 18;j++)
		for(int i = 1;i<=n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 18;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 18;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void update(int &p,int l,int r,int pos,int val,int pre)
{
	p = ++cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)
		update(ls[p],l,mid,pos,val,ls[pre]);
	else
		update(rs[p],mid+1,r,pos,val,rs[pre]);
	//sum[p] = sum[ls[p]]+sum[rs[p]];
}
int a[N],b[N];
void build(int &p,int l,int r)
{
	p = ++cnt;
	if(l==r)return ;
	int mid = (l+r)>>1;
	build(ls[p],l,mid);
	build(rs[p],mid+1,r);
}
void dfs(int x)
{
	update(root[x],1,n,a[x],1,root[fa[x][0]]);
	dep[x] = dep[fa[x][0]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			fa[e[i].to][0] = x;
			dfs(e[i].to);
		}
}
void solve(int x,int y,int k)
{
	int u = getlca(x,y);
	int v = fa[u][0];
	int l = 1,r = n,ret;
	x = root[x],y = root[y],u = root[u],v = root[v];
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(sum[ls[x]]+sum[ls[y]]-sum[ls[u]]-sum[ls[v]]>=k)
		{
			x = ls[x],y = ls[y];
			u = ls[u],v = ls[v];
			r = mid;
		}else
		{
			k-=sum[ls[x]]+sum[ls[y]]-sum[ls[u]]-sum[ls[v]];
			x = rs[x],y = rs[y];
			u = rs[u],v = rs[v];
			l = mid+1;
		}
	}
	ans = b[l];
	printf("%d",ans);
}
int main()
{
	n = read();m = read();
	for(int i = 1;i<= n;i++){a[i] = read();b[i] = a[i];}
	sort(b+1,b+n+1);
	for(int i = 1;i<= n;i++)
		a[i] = lower_bound(b+1,b+n+1,a[i])-b;
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		x = read();y = read();
		add(x,y),add(y,x);
	}
	build(root[0],1,n);
	dfs(1);
	init();
	for(int i = 1;i<= m;i++)
	{
		x = read();y = read();z = read();
		x = x^ans;
		//if(x==y){ans = val[x];printf("%d",ans);}
		solve(x,y,z);
		if(i!=m)printf("\n");
	}
	return 0;
}
Problem2595

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 11;
const int S = 1<<10;
const int INF = 0x3f3f3f3f;
#define f(i,j,s1,s2) f[i][j][s1]+f[i][j][s2]
int f[N][N][S],a[N][N],n,m,K;;
struct Pair{int x,y;};
struct Tele{int x,y,s;};
int dx[4] = {0,0,1,-1};
int dy[4] = {1,-1,0,0};
Tele pre[N][N][S];
queue <Pair>Q;
bool v[N][N];
void spfa(int sta)
{
	while(!Q.empty())
	{
		Pair t = Q.front();
		Q.pop();
		v[t.x][t.y] = false;
		for(int i = 0;i<4;i++)
		{
			int xx = t.x+dx[i],yy = t.y+dy[i];
			if(xx<0||yy<0||xx>n||yy>m)continue;
			if(f[xx][yy][sta]>f[t.x][t.y][sta]+a[xx][yy])
			{
				f[xx][yy][sta] = f[t.x][t.y][sta]+a[xx][yy];
				pre[xx][yy][sta] = (Tele){t.x,t.y,sta};
				if(!v[xx][yy])
				{
					Q.push((Pair){xx,yy});
					v[xx][yy] = true;
				}	
			}
		}
	}
}
bool used[N][N];
void dfs(int x,int y,int sta)
{
	if(x>=INF||pre[x][y][sta].s==0)return ;
	used[x][y] = true;
	Tele t = pre[x][y][sta];
	dfs(t.x,t.y,t.s);
	if(t.x==x&&t.y==y)dfs(x,y,sta-t.s);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&a[i][j]);
			if(!a[i][j])K++;
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			for(int s = 0;s<1<<K;s++)
				f[i][j][s] = pre[i][j][s].x = INF;
	K = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(!a[i][j])
				{f[i][j][1<<K] = 0;K++;}
	for(int sta = 0;sta<1<<K;sta++)
	{
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= m;j++)
			{
				for(int s = sta&(sta-1);s;s = sta&(s-1))
					if(f(i,j,s,sta-s)-a[i][j]<f[i][j][sta])
					{
						f[i][j][sta] = f(i,j,s,sta-s)-a[i][j];
						pre[i][j][sta] = (Tele){i,j,s};
					}
				if(f[i][j][sta]<INF)
					{Q.push((Pair){i,j});v[i][j] = true;}
			}
		spfa(sta);
	}
	int x,y;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(!a[i][j])
				{x = i,y = j;break;}
	dfs(x,y,(1<<K)-1);
	printf("%d\n",f[x][y][(1<<K)-1]);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= m;j++)
		{
			if(!a[i][j])printf("x");
			else if(used[i][j])printf("o");
			else printf("_");
		}
		printf("\n");
	}
	return 0;
}
Problem2599

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int K = 1e6+5;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,t[K];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
bool used[N];
int sum,root,size[N],f[N],n,k;
void get_root(int x,int fa)
{
	size[x] = 1;f[x] = 0;
	for(int i = head[x];i;i =e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int dis[N],dep[N];
int ans = INF;
void get_ans(int x,int fa)
{
	if(dis[x]<=k)ans = min(ans,dep[x]+t[k-dis[x]]);
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		dep[e[i].to] = dep[x]+1;
		dis[e[i].to] = dis[x]+e[i].val;
		get_ans(e[i].to,x);
	}
}
void init(int x,int fa,int opt)
{
	if(dis[x]<=k)
	{
		if(opt)t[dis[x]] = min(t[dis[x]],dep[x]);
		else t[dis[x]] = INF;
	}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			init(e[i].to,x,opt);
}
void work(int x)
{
	used[x] = true,t[0] = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			dep[e[i].to] = 1,dis[e[i].to] = e[i].val;
			get_ans(e[i].to,0);
			init(e[i].to,0,1);
		}
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
			init(e[i].to,0,0);
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			root = 0,sum = size[e[i].to];
			get_root(e[i].to,0);
			work(root);
		}
}
int main()
{
	int x,y,z;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= k;i++)t[i]=n;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		x++,y++;
		add(x,y,z);
	}
	ans = sum = f[0] = n;
	get_root(1,0);
	work(root);
	if(ans<n)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem2600

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
int n,x;
LL p;
LL pos[N];
bool check(int len)
{
	int i,l,r,mid;
	LL now=0;
	l=1,r=len,mid=(l+r)>>1;
	for(i=l;i<mid;i++)now+=(pos[mid]-pos[i]);
	for(i=mid+1;i<=r;i++)now+=(pos[i]-pos[mid]);
	if(now<=p)return true;
	for(;r<n;)
	{
		now-=(pos[mid]-pos[l++]);
		now+=(pos[++r]-pos[mid]);
		mid=(l+r)>>1;
		now+=(pos[mid]-pos[mid-1])*(mid-l);
		now-=(pos[mid]-pos[mid-1])*(r-mid+1);
		if(now<=p)return true;
	}
	return false;
}
int main()
{
	scanf("%d%d%lld",&n,&x,&p);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&pos[i]);
	int L = 0,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(check(mid))L = mid+1;
		else R = mid;
	}
	L--;
	printf("%d\n",L);
	return 0;
}
Problem2618

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 510;
const double eps = 1e-7;
struct Point
{
	double x,y;
	Point(){}
	Point(double x,double y):x(x),y(y){}
	Point operator+(const Point &a)const
	{
		return Point(x+a.x,y+a.y);
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	double operator*(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
	Point operator*(const double &s)const
	{
		return Point(x*s,y*s);
	}
	void getp()
	{
		scanf("%lf%lf",&x,&y);
	}
}poi[N];
struct Line
{
	Point p,v;
	double alpha;
	Line(){}
	Line(const Point &a,const Point &b):p(a),v(b-a)
	{
		alpha = atan2(v.y,v.x);
	}
	bool operator<(const Line &a)const
	{
		return alpha<a.alpha;
	}
}line[N];
int n,m,tot,r,h;
Line *q[N];
double ans;
bool on_left(const Point &p,const Line &l)
{
	return (l.p-p)*l.v>=0;
}
Point get_its(const Line &l1,const Line &l2)
{
	Point u = l1.p-l2.p;
	double tmp = (l2.v*u)/(l1.v*l2.v);
	return l1.p+l1.v*tmp;
}
void Get_hpits()
{
	for(int i = 1;i<= tot;i++)
	{
		while(r-h>=2&& !on_left(get_its(*q[r],*q[r-1]),line[i]))
			q[r--]=NULL;
		if(r-h>=1&&fabs(line[i].v*q[r]->v)<=0)
			q[r] = on_left(line[i].p,*q[r])?&line[i]:q[r];
		else q[++r]=&line[i];
	}
	while(true)
	{
		if(r-h>=2&& !on_left(get_its(*q[h+1],*q[h+2]),*q[r]))
			q[++h]=NULL;
		else if(r-h>=2&& !on_left(get_its(*q[r],*q[r-1]),*q[h+1]))
			q[r--]=NULL;
		else break;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		Point fir,p1,p2;
		scanf("%d",&m);
		fir.getp();p2 = fir;
		for(int j = 2;j<= m;j++)
		{
			p1 = p2;p2.getp();
			line[++tot]=Line(p1,p2);
		}
		line[++tot] = Line(p2,fir);
	}
	sort(line+1,line+tot+1);
	Get_hpits();
	if(r-h<=2)
		return printf("0.000\n"),0;
	tot = 0;
	for(int i = h+2;i<= r;i++)
		poi[++tot] = get_its(*q[i],*q[i-1]);
	poi[++tot]=get_its(*q[r],*q[h+1]);
	for(int i = 2;i<= tot;i++)
		ans+=poi[i-1]*poi[i];
	ans+=poi[tot]*poi[1];
	printf("%.3lf\n",ans/2.0);
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
const int mod = 51061;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,sum,add,size,times;
	bool rev;
	Splay(int x);
	void push_up();
	void push_down();
	void reverse();
	void Add(int x);
	void Times(int x);
}*null = new Splay(0),*tree[N];
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	val = sum = x;
	if(x)size = 1;else size = 0;
	add = 0;rev = false;times = 1;
}
void Splay :: reverse()
{
	if(this==null)return ;
	swap(ls,rs);
	rev ^= 1;
}
void Splay :: Add(int x)
{
	if(this==null)return ;
	(val+=x)%=mod;
	(sum+=(LL)x*size%mod)%=mod;
	(add+=x)%=mod;
}
void Splay :: Times(int x)
{
	if(this==null)return ;
	times=(LL)times*x%mod;
    val=(LL)val*x%mod;
    add=(LL)add*x%mod;
    sum=(LL)sum*x%mod;
}
void Splay :: push_up()
{
	if(this==null)return ;
	size = ls->size+rs->size+1;
	sum = (ls->sum+rs->sum+val)%mod;
}
void Splay :: push_down()
{
	if(this==null)return ;
	if(this==fa->ls||fa->rs==this)
		fa->push_down();
	if(times^1)
	{
		ls->Times(times);
		rs->Times(times);
		times = 1;
	}
	if(add)
	{
		ls->Add(add);
		rs->Add(add);
		add = 0;
	}if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = false;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	//y->push_down();
	//x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	//y->push_down();
	//x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	if(x==null)return ;
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
void link(Splay *x,Splay *y)
{
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	x->fa = null;
	y->ls = null;
	y->push_up();
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
queue<int>Q;
int fa[N];
void bfs(int x)
{
	Q.push(x);
	while(!Q.empty())
	{
		int t = Q.front();
		Q.pop();
		tree[t] = new Splay(1);
		if(fa[t])
			tree[t]->fa=tree[fa[t]];
		for(int i = head[t];i;i = e[i].next)
		{
			if(e[i].to==fa[t])continue;
			Q.push(e[i].to);
			fa[e[i].to] = t;
		}
	}
}
int main()
{
	int n,q,x,y,a,b,c;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	bfs(1);
	char opt[3];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='+')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			tree[y]->Add(c);
		}else if(opt[0]=='-')
		{
			scanf("%d%d%d%d",&x,&y,&a,&b);
			cut(tree[x],tree[y]);
			link(tree[a],tree[b]);
		}else if(opt[0]=='*')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			tree[y]->Times(c);
		}else
		{
			scanf("%d%d",&x,&y);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			printf("%d\n",tree[y]->sum);
		}
	}
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 51061;
int son[N][2],fa[N],val[N],add[N],mul[N],size[N],sum[N];
bool rev[N];
bool is_root(int p)
{
	return son[fa[p]][0]!=p&&son[fa[p]][1]!=p;
}
void init(int p,int v = 0)
{
	son[p][0]=son[p][1]=fa[p]=0;
	val[p] = sum[p] = v;
	add[p] = 0,mul[p] = 1;
}
void Add(int p,int a)
{
	if(!p)return ;
	sum[p] = (sum[p]+(ll)size[p]*a%mod)%mod;
	add[p] = (add[p]+a)%mod;
	val[p] = (val[p]+a)%mod;
}
void reverse(int p)
{
	rev[p]^=1;
	swap(son[p][0],son[p][1]);	
}
void Multi(int p,int m)
{
	if(!p)return ;
	sum[p] = (ll)sum[p]*m%mod;
	val[p] = (ll)val[p]*m%mod;
	add[p] = (ll)add[p]*m%mod;
	mul[p] = (ll)mul[p]*m%mod;
}
void Push_up(int p)
{
	if(!p)return ;
	size[p] = size[son[p][0]]+size[son[p][1]]+1;
	sum[p] = (sum[son[p][0]]+sum[son[p][1]]+val[p])%mod;
}
void Push_down(int p)
{
	if(!is_root(p))
		Push_down(fa[p]);
	if(mul[p]^1)
	{
		Multi(son[p][0],mul[p]);
		Multi(son[p][1],mul[p]);
		mul[p] = 1;
	}
	if(add[p])
	{
		Add(son[p][0],add[p]);
		Add(son[p][1],add[p]);
		add[p] = 0;
	}
	if(rev[p])
	{
		reverse(son[p][0]),reverse(son[p][1]);
		rev[p] = false;
	}
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(son[z][0]==y)son[z][0] = x;
		else son[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[son[x][d^1]] = y;
	son[y][d] = son[x][d^1],son[x][d^1] = y;
	Push_up(y);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)^(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		son[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;
	son[y][0] = 0;
	Push_up(y);
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void adde(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
queue<int>Q;
int father[N];
void bfs(int rt)
{
	Q.push(rt);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		fa[x] = father[x];
		for(int i = head[x];i;i=e[i].next)
			if(father[x]!=e[i].to)
			{
				Q.push(e[i].to);
				father[e[i].to] = x;
			}
	}
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	int u,v;
	for(int i = 1;i<= n;i++)init(i,1);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		adde(u,v);
	}
	bfs(1);
	char opt[3];
	int x,y,a,b,c;
	while(q--)
	{
		scanf("%s",opt);
		if(opt[0]=='+')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(x);
			access(y);splay(y);
			Add(y,c);
		}else if(opt[0]=='-')
		{
			scanf("%d%d%d%d",&x,&y,&a,&b);
			cut(x,y);
			link(a,b);
		}else if(opt[0]=='*')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(x);
			access(y),splay(y);
			Multi(y,c);
		}else
		{
			scanf("%d%d",&x,&y);
			move_to_root(x);
			access(y),splay(y);
			printf("%d\n",sum[y]);
		}
	}
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 51061;
int ch[N][2],add[N],mul[N],size[N],fa[N],val[N],sum[N];
bool rev[N];
bool is_root(int p)
{
	return ch[fa[p]][0]!=p&&ch[fa[p]][1]!=p;
}
void init(int p,int v)
{
	ch[p][0]=ch[p][1]=fa[p]=0;
	size[p]=1;
	mul[p] = 1,add[p]=0,rev[p]=false;
	sum[p]=val[p]=v;
}
void Multiply(int p,int c)
{
	if(!p)return ;
	mul[p] = (ll)mul[p]*c%mod;
	sum[p] = (ll)sum[p]*c%mod;
	val[p] = (ll)val[p]*c%mod;
	add[p] = (ll)add[p]*c%mod;
}
void Add(int p,int c)
{
	if(!p)return ;
	(add[p]+=c)%=mod;
	(val[p]+=c)%=mod;
	(sum[p]+=(ll)size[p]*c%mod)%=mod;
}
void Reverse(int p)
{
	rev[p]^=1;
	swap(ch[p][0],ch[p][1]);
}
void Push_down(int p)
{
	if(!is_root(p))Push_down(fa[p]);
	if(mul[p]!=1)
	{
		Multiply(ch[p][0],mul[p]);
		Multiply(ch[p][1],mul[p]);
		mul[p] = 1;
	}
	if(add[p])
	{
		Add(ch[p][0],add[p]);
		Add(ch[p][1],add[p]);
		add[p] = 0;
	}
	if(rev[p])
	{
		Reverse(ch[p][0]);
		Reverse(ch[p][1]);
		rev[p] = false;
	}
}
void Push_up(int p)
{
	if(!p)return ;
	size[p] = size[ch[p][0]]+1+size[ch[p][1]];
	sum[p] = (sum[ch[p][0]]+val[p]+sum[ch[p][1]])%mod;
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		if(ch[z][1]==y)ch[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y),Push_up(x);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[y][0]==x)^(ch[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	Reverse(x);
}
void Link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void Cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;ch[y][0] = 0;
	Push_up(y);
}
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void adde(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
queue<int>Q;
void bfs()
{
	Q.push(1);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				Q.push(e[i].to);
			}
	}
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)init(i,1);
	int u,v;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		adde(u,v);
	}
	bfs();
	char opt[3];
    int x,y,a,b,c;
    while(q--)
    {
        scanf("%s",opt);
        if(opt[0]=='+')
        {
            scanf("%d%d%d",&x,&y,&c);
            move_to_root(x);
            access(y);splay(y);
            Add(y,c);
        }else if(opt[0]=='-')
        {
            scanf("%d%d%d%d",&x,&y,&a,&b);
            Cut(x,y);
            Link(a,b);
        }else if(opt[0]=='*')
        {
            scanf("%d%d%d",&x,&y,&c);
            move_to_root(x);
            access(y),splay(y);
            Multiply(y,c);
        }else
        {
            scanf("%d%d",&x,&y);
            move_to_root(x);
            access(y),splay(y);
            printf("%d\n",sum[y]);
        }
    }
	return 0;
}
Problem2654

#include<iostream>
#include<set>
#include<map>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<vector>
#include<queue>
#include<algorithm>
#include<cmath>
#define inf 1000000000
#define pa pair<int,int>
#define ll long long 
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,cnt,tot,ned;
int sumv;
int u[100005],v[100005],w[100005],c[100005];
int fa[100005];
struct edge{
	int u,v,w,c;
}e[100005];
bool operator<(edge a,edge b)
{
	return a.w==b.w?a.c<b.c:a.w<b.w;
}
int find(int x)
{
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
bool check(int x)
{
	tot=cnt=0;
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		e[i].u=u[i],e[i].v=v[i],e[i].w=w[i];e[i].c=c[i];
		if(!c[i])e[i].w+=x;
	}
	sort(e+1,e+m+1);
	for(int i=1;i<=m;i++)
	{
		int p=find(e[i].u),q=find(e[i].v);
		if(p!=q)
		{
			fa[p]=q;
			tot+=e[i].w;
			if(!e[i].c)cnt++;
		}
	}
	return cnt>=ned;
}
int main()
{
	n=read();m=read();ned=read();
	for(int i=1;i<=m;i++)
	{
		u[i]=read(),v[i]=read(),w[i]=read(),c[i]=read();
		u[i]++;v[i]++;
	}
	int l=-105,r=105;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))l=mid+1,sumv=tot-ned*mid;
		else r=mid-1;
	}
	printf("%d",sumv);
	return 0;
}
Problem2657

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
int cnt;
struct E
{int x,y,id;}edge[N<<2];
void insert(int a,int b,int i)
{
	edge[++cnt].x = a;
	edge[cnt].y = b;
	edge[cnt].id = i; 
}
bool cmp(E a,E b)
{
	if(a.x!=b.x)
		return a.x<b.x;
	return a.y<b.y;
}
struct Edge
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int max_dep,end;
void dfs(int x,int fa,int dep)
{
	if(dep>max_dep)
	{
		max_dep = dep;
		end = x;
	}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,dep+1);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n-2;i++)
	{
		int a[4];
		scanf("%d%d%d",&a[1],&a[2],&a[3]);
		sort(a+1,a+4);
		insert(a[1],a[2],i);insert(a[1],a[3],i);insert(a[2],a[3],i);
	}
	sort(edge+1,edge+cnt+1,cmp);
	for(int i = 2;i<= cnt;i++)
		if(edge[i].x==edge[i-1].x&&edge[i].y==edge[i-1].y)add(edge[i].id,edge[i-1].id);
	dfs(1,0,1);
	dfs(end,0,1);
	printf("%d\n",max_dep);
	return 0;
}
Problem2671

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int mu[N],prime[N],cnt;
bool v[N];
ll n,stack[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
		{
			mu[i] = -1;
			prime[++cnt] = i;
		}
		for(int j=1;j<= cnt&&i*prime[j]<N;j++)
		{
			v[prime[j]*i]=true;
			if(i%prime[j])mu[i*prime[j]]=-mu[i];
			else 
			{
				mu[i*prime[j]]=0;
				break;
			}
		}
	}
}
void get_fac(ll x)
{
	stack[0]=0;
	for(ll i = 1;i*i<=x;i++)
		if(x%i==0)
		{
			stack[++stack[0]] = i;
			if(i*i!=x)stack[++stack[0]]=x/i;
		}
	sort(stack+1,stack+stack[0]+1);
}
ll calc()
{
	ll a,b,k,last,ans=0;
	for(b=1;b*(b+1)<=n;b++)
	{
		get_fac(b);
		for(a=1;a<b&&b*(a+b)<=n;a=last+1)
		{
			last=min(n/(n/b/(a+b))/b-b,b-1);
			ll cnt = 0;
			for(k=1;stack[k]<=last;k++)
				cnt+=(ll)mu[stack[k]]*(last/stack[k]-(a-1)/stack[k]);
			ans+=n/b/(a+b)*cnt;
		}
	}
	return ans;
}
int main()
{
	scanf("%lld",&n);
	quick_mu();
	printf("%lld\n",calc());
	return 0;
}
Problem2683

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 500005;
struct P
{int x,y,num,opt,no;}p[N<<2],np[N<<2];
int ans[N];
bool cmp(const P &a,const P &b)
{
	if(a.x==b.x)
	{
		if(a.y==b.y)return a.no<b.no;
		return a.y<b.y;
	}
	return a.x<b.x;
}
int c[M];
void update(int x,int y)
{
	for(int i = x;i<M;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void clear(int x)
{
	for(int i = x;i<M;i+=i&(-i))
		c[i] = 0;
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)return ;
	for(int i = l;i<= r;i++)
	{
		if(p[i].no<=mid&&p[i].opt==0)
			update(p[i].y,p[i].num);
		else if(p[i].no>mid&&p[i].opt!=0)
		{
			ans[p[i].num]+=p[i].opt*getans(p[i].y);
		}
	}
	for(int i = l;i<=r;i++)
		if(p[i].no<=mid&&p[i].opt==0)
			update(p[i].y,-p[i].num);
	int t1 = l,t2 = mid+1;
	for(int i = l;i<= r;i++)
		if(p[i].no<=mid)np[t1++] = p[i];
		else np[t2++] = p[i];
	for(int i = l;i<= r;i++)
		p[i]=np[i];
	CDQ(l,mid);CDQ(mid+1,r);
}
int main()
{
	int n,opt,x,y,a,b,cnt = 0,ask = 0;
	scanf("%d",&n);
	while(scanf("%d",&opt))
	{
		if(opt==3)break;
		else if(opt==1)
		{
			scanf("%d%d%d",&x,&y,&a);
			++cnt;p[cnt] = (P){x,y,a,0,cnt};
		}else
		{
			ask++;
			scanf("%d%d%d%d",&x,&y,&a,&b);
			++cnt;p[cnt] = (P){a,b,ask,1,cnt};
			if(y!=1){++cnt;p[cnt] = (P){a,y-1,ask,-1,cnt};}
			if(x!=1){++cnt;p[cnt] = (P){x-1,b,ask,-1,cnt};}
			if(x!=1&&y!=1){++cnt;p[cnt] = (P){x-1,y-1,ask,1,cnt};}
		}
	}
	sort(p+1,p+cnt+1,cmp);
	CDQ(1,cnt);
	for(int i=1;i<= ask;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem2687

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int N = 1e6+5;
typedef long long ll;
using namespace std;
struct aa{int l, r;}a[N], b[N];
int n, now, mxp, l, flag[N];
ll ans;
bool cmp(aa a, aa b)
{
    if(a.l!=b.l)return a.l<b.l;
    return a.r>b.r;
}
ll get(int i, int j)
{
    if(b[i].r<b[j].l)return 0;
    return (ll)(b[i].r-b[j].l+1)*(b[j].r-b[i].l+1);
}
int main()
{
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
    {
    	scanf("%d%d",&a[i].l,&a[i].r);
    	a[i].r--;
    }
    sort(a+1, a+1+n, cmp);
    now=mxp=ans=0;
    for(int i=1; i<=n; i++)
    {
        if(a[i].r<=now)
        {
            flag[i]=mxp;
            ans=max(ans, (ll)(a[i].r-a[i].l+1)*(a[mxp].r-a[mxp].l+1));
        }
        else flag[i]=0;
        if(now<a[i].r){now=a[i].r; mxp=i;}
    }
    l=0;
    for(int i=1; i<=n; i++)if(!flag[i])b[++l]=a[i];
    now=2;
    for(int i=1; i<=l-1; i++)
    {
        if(now==i)now++;
        while(now<=l-1&&get(i, now)<get(i, now+1))now++;
        ans=max(ans, get(i, now));
    }
    printf("%lld", ans);
    return 0;
}
Problem2705

#include<stdio.h>
#include<math.h>
typedef long long LL;
int main()
{
	 LL n;
	 while(scanf("%lld",&n)!=EOF)
	 {
	 	LL ans = n,tmp,q,cnt;
	 	tmp = (int)sqrt(n);
	 	for(int i = 2;i<= tmp;i++)
	 	{
	 		if(n%i==0)
	 		{
	 			cnt = 0;
	 			q = i;
	 			while(n%q==0)
	 			{
	 				cnt++;
	 				n = n/q;
	 			}
	 			ans = ans+ans*cnt*(q-1)/q;
	 		}
	 	}
	 	if(n!=1) ans = ans+ans*(n-1)/n;
	 	printf("%lld\n",ans);
	 }
	 return 0;
}
Problem2708

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
int a[55],f[55];
int calc(int x,int y)
{
	for(int k = 1;k<= y-x+1;k++)
	{
		for(int j = x;j<= y-k;j++)
			if(abs(a[j]-a[j+k])>1)return k-1;
		if(abs(a[x+k-1]-a[y-k+1])<=1)return k-1;
	}
	return y-x+1;
}
int main()
{
	int n;
	while(scanf("%d",&n)!=EOF)
	{
		for(int i = 1;i<= n;i++)
			scanf("%d",&a[i]);
		sort(a+1,a+n+1);
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
			for(int j = 0;j<i;j++)
				f[i] = max(f[i],f[j]+calc(j+1,i));
		printf("%d\n",f[n]);
	}
	return 0;
}
Problem2716

#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll long long
#define inf 1000000000 
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,root,D;
struct P{
	int d[2],mn[2],mx[2],l,r;
	int& operator[](int x){return d[x];}
	P(int x=0,int y=0)
		{l=0,r=0;d[0]=x,d[1]=y;}  
}p[500005];
bool operator<(P a,P b)
{
	return a[D]<b[D];
}
inline int dis(P a,P b)
{
	return abs(a[0]-b[0])+abs(a[1]-b[1]);
}
struct kdtree{
	int ans;
	P t[1000005],T;
	void update(int k){
		P l=t[t[k].l],r=t[t[k].r];
		for(int i=0;i<2;i++)
		{
			if(t[k].l)t[k].mn[i]=min(t[k].mn[i],l.mn[i]),t[k].mx[i]=max(t[k].mx[i],l.mx[i]);
			if(t[k].r)t[k].mn[i]=min(t[k].mn[i],r.mn[i]),t[k].mx[i]=max(t[k].mx[i],r.mx[i]);
		}
	}
	int build(int l,int r,int now){
		D=now;
		int mid=(l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid]=p[mid];
		for(int i=0;i<2;i++)
			t[mid].mn[i]=t[mid].mx[i]=t[mid][i];
		if(l<mid)t[mid].l=build(l,mid-1,now^1);
		if(r>mid)t[mid].r=build(mid+1,r,now^1);
		update(mid);
		return mid;
	}
	int get(int k,P p){
		int tmp=0;
		for(int i=0;i<2;i++)
			tmp+=max(0,t[k].mn[i]-p[i]);
		for(int i=0;i<2;i++)
			tmp+=max(0,p[i]-t[k].mx[i]);
		return tmp;
	}
	void insert(int k,int now){
		if(T[now]>=t[k][now])
		{
			if(t[k].r)insert(t[k].r,now^1);
			else 
			{
				t[k].r=++n;t[n]=T;
				for(int i=0;i<2;i++)
					t[n].mn[i]=t[n].mx[i]=t[n][i];
			}
		}
		else 
		{
			if(t[k].l)insert(t[k].l,now^1);
			else 
			{
				t[k].l=++n;t[n]=T;
				for(int i=0;i<2;i++)
					t[n].mn[i]=t[n].mx[i]=t[n][i];
			}
		}
		update(k);
	}
	void query(int k,int now){
		int d,dl=inf,dr=inf;
		d=dis(t[k],T);
		ans=min(ans,d);
		if(t[k].l)dl=get(t[k].l,T);
		if(t[k].r)dr=get(t[k].r,T);
		if(dl<dr)
		{
			if(dl<ans)query(t[k].l,now^1);
			if(dr<ans)query(t[k].r,now^1);
		}
		else
		{
			if(dr<ans)query(t[k].r,now^1);
			if(dl<ans)query(t[k].l,now^1);
		}
	}
	int query(P p){
		ans=inf;T=p;query(root,0);
		return ans;
	}
	void insert(P p){
		T=p;insert(root,0);
	}
}kd;
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)p[i][0]=read(),p[i][1]=read();
	root=kd.build(1,n,0);
	while(m--)
	{
		int opt=read(),x=read(),y=read();
		if(opt==1)kd.insert(P(x,y));
		else printf("%d\n",kd.query(P(x,y)));
	}
	return 0;
}
Problem2721

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int mod = 1e9+7;
int prime[N],cnt;
bool v[N];
void quick_prime(int n)
{
	for(int i = 2;i<= n;i++)
	{
		if(!v[i])
			prime[++cnt]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	int n;
	long long ans = 1;
	scanf("%d",&n);
	quick_prime(n);
	for(int i = 1;i<= cnt;i++)
	{
		int tmp = n;
		long long cnt = 0;
		while(tmp)
		{
			cnt+=tmp/prime[i];
			tmp/=prime[i];
		}
		cnt = (cnt<<1|1)%mod;
		ans = ans*cnt%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2730

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1005;
struct E
{int next,to;}e[M];
int head[N],tot = 1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int stack[N],low[N],dfn[N],dcc,cnt,top,m,n;
bool ins[N],v[N];
int bel[N];
int ans1;
long long ans2;
void init()
{
	memset(v,0,sizeof(v));
	memset(head,0,sizeof(head));
	tot = 1,cnt = 0,dcc = 0,top = 0,n = 0;
	ans1 = 0;ans2 = 1;
	memset(bel,0,sizeof(bel));
}
void tarjan(int x,int l)
{
	dfn[x] = low[x] = ++cnt;
	//stack[++top] = x;
	v[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(v[e[i].to])low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			if(low[e[i].to]>=dfn[x])
				bel[x]++;
		}
	}
}
void tarjan1(int x,int l)
{
	dfn[x] = low[x] = ++cnt;
	stack[++top] = x;
	ins[x] = v[x] = true;
	int temp,size;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(v[e[i].to])low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan1(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			if(low[e[i].to]>=dfn[x])
			{
				temp = size = 0;
				int tmp;
				do
				{
					tmp = stack[top--];
					ins[tmp] = false;
					if(bel[tmp]>=2)
						temp++;
					size++;
				}while(tmp!=e[i].to);
				tmp = x;
				if(bel[tmp]>=2)
					temp++;
				size++;
				if(!temp)
					ans1+=2,ans2*=size*(size-1)/2;
				else if(temp==1) 
					ans1++,ans2*=size-1;
			}
		}
	}
}
int main()
{
	int x,y,T = 0;
	while(scanf("%d",&m)&&m!=0)
	{
		T++;
		init();
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
			n = max(n,max(x,y));
		}
		for(int i = 1;i<= n;i++)
			if(!v[i])
				tarjan(i,-1);
			else bel[i]++;
		memset(v,0,sizeof(v));
		cnt = 0;
		for(int i = 1;i<= n;i++)
			if(!v[i])
				tarjan1(i,-1);
		printf("Case %d: %d %lld\n",T,ans1,ans2);
	}
	return 0;
}
Problem2733

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Q = 300005;
const int N = 100005;
int root[N],ls[N*20],rs[N*20],sum[N*20],num[N],seg;
void update(int &p,int l,int r,int x)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		sum[p] = 1;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(ls[p],l,mid,x);
	else update(rs[p],mid+1,r,x);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int p,int l,int r,int x,int s)
{
	if(!p)return -1;
	if(l==r)
		return l;
	int mid = (l+r)>>1;
	if(sum[ls[p]]+s<x)
		return getans(rs[p],mid+1,r,x,sum[ls[p]]+s);
	else return getans(ls[p],l,mid,x,s);
}
int merge(int x,int y)
{
	if(!x)return y;
	if(!y)return x;
	ls[x] = merge(ls[x],ls[y]);
	rs[x] = merge(rs[x],rs[y]);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
int fa[N],rnk[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else
	{ 
		int tmp = getfa(fa[x]);
		//root[x] = merge(root[tmp],root[x]);
		return fa[x] = tmp;
	}
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx==fy)return ;
	if(rnk[fx]>rnk[fy])
	{
		fa[fy] = fx;
		root[fx] = merge(root[fx],root[fy]);
	}
	else
	{
		fa[fx] = fy,rnk[fy]+=rnk[fx]==rnk[fy];
		root[fy] = merge(root[fy],root[fx]);
	}
}
int imc[N],bri[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&imc[i]);
		bri[imc[i]] = i;
		update(root[i],1,n,imc[i]);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		uni(x,y);
	}
	int q;
	scanf("%d",&q);
	char ju[3];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",ju);
		scanf("%d%d",&x,&y);
		if(ju[0]=='B')uni(x,y);
		else
		{
			int fx = getfa(x);
			int tmp = getans(root[fx],1,n,y,0);
			if(tmp==-1)printf("-1\n");
			else printf("%d\n",bri[tmp]);
		}
	}
	return 0;
}
Problem2734

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int M = 1<<12;
const int INF = 1e8;
const LL mod = 1000000001;
bool v[N];
int a[20][13],b[20],p2[20],n;
int f[20][M];
LL calc(int x)
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	a[1][1] = x;
	for(int i = 2;i<= 18;i++)
	{
		if((a[i-1][1]<<1)<=n)
			a[i][1] = a[i-1][1]<<1;
		else a[i][1] = INF;
	}
	for(int i = 1;i<= 18;i++)
		for(int j = 2;j<= 12;j++)
		{
			if(a[i][j-1]*3<=n)
				a[i][j] = a[i][j-1]*3;
			else a[i][j] = INF;
		}
	for(int i = 1;i<= 18;i++)
		for(int j = 1;j<= 12;j++)
			if(a[i][j]<=n)
			{
				v[a[i][j]] = true;
				b[i]+=p2[j-1];
			}
	memset(f,0,sizeof(f));
	f[0][0] = 1;
	for(int i = 1;i<= 18;i++)
		for(int j = 0;j<=b[i-1];j++)
		{
			if(((j<<1)&j)||((j>>1)&j))continue;
			for(int k = 0;k<= b[i];k++)
			{
				if(((k<<1)&k)||((k>>1)&k)||(j&k))continue;
				f[i][k]=(f[i][k]+f[i-1][j])%mod;
			}
		}
	long long ans = 0;
	for(int i = 0;i<=b[18];i++)
		ans = (ans+f[18][i])%mod;
	return ans;
}
int main()
{
	for(int i = 0;i<=18;i++)
		p2[i] = 1<<i;
	scanf("%d",&n);
	LL ans = 1;
	for(int i = 1;i<= n;i++)
		if(!v[i])ans = ans*calc(i)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem2744

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
struct E
{int next,to;}e[N*N>>2];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to =y;
	e[tot].next =head[x];
	head[x]=tot;
}
int res[N],sta[N],ban[N],dfn[N];
int a[N],b[N],A,B,m,n,ans,T1,T2;
bool map[N][N];
int cnt(int x)
{
	int ans = 0;
	while(x)
		x-=x&(-x),ans++;
	return ans;
}
bool get_partner(int x)
{
	if(ban[x]==T1)return false;
	for(int i = head[x];i;i=e[i].next)
		if(ban[e[i].to]!=T1&&sta[e[i].to]!=T2)
		{
			sta[e[i].to]=T2;
			if(!res[e[i].to]||dfn[e[i].to]!=T1||get_partner(res[e[i].to]))
			{
				dfn[e[i].to]=T1;
				res[e[i].to]=x;
				return true;
			}
		}
	return false;
}
int getans(int x=0,int y=0)
{
	T1++;
	int ans = 0;
	for(int i = 1;i<= B;i++)
		if(map[x][i]||map[y][i])
			ban[i]=T1,ans++;
	for(int i = 1;i<= B;i++)
		if(b[i]&1)
		{
			++T2;
			if(get_partner(i))
				ans++;
		}
	return B-ans;
}
int main()
{
	scanf("%d%d%d",&A,&B,&m);
	for(int i = 1;i<= A;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= B;i++)scanf("%d",&b[i]);
	memset(map,true,sizeof(map));
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y]=false;
	}
	for(int i = 1;i<= B;i++)
		if(b[i]&1)
			for(int j = 1;j<= B;j++)
				if(~b[j]&1)
					if(~cnt(b[i]|b[j])&1)
						add(i,j);
	int ans;
	for(int i = 1;i<=B;i++)map[0][i]=0;
	ans=getans();
	for(int i = 1;i<=A;i++)
		ans=max(ans,getans(i)+1);
	for(int i = 1;i<= A;i++)
		if(a[i]&1)
			for(int j = 1;j<= A;j++)
				if(~a[j]&1)
					ans = max(ans,getans(i,j)+2);
	printf("%d\n",ans);
	return 0;
}
Problem2754

#include <stdio.h>
#include <map>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int s[N];
vector<int>a[20005],st[N],V,M;
bool vis[N],mark[N];
int ans1[N],ans2[N];
struct AC_Machine
{
	map<int,int>ch[N];
	int fail[N];bool end[N];
	int cnt,q[N],h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i=-1;i<=10000;i++)
            ch[0][i]=1;
        fail[1]=0;
	}
	void insert(int len,int id)
	{
		int now = 1;
		for(int i = 1;i<=len;i++)
		{
			if(!ch[now][s[i]])ch[now][s[i]]=++cnt;
			now = ch[now][s[i]];
		}
		st[now].push_back(id);
	}
	void build()
	{
		h = 0,t = -1;
		q[++t]=1,fail[0] =1;
		while(h<=t)
		{
			int x = q[h++];
			map<int,int>::iterator it;
			for(it=ch[x].begin();it!=ch[x].end();it++)
			{
				int i = it->first;
				int to = it->second;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				q[++t]=to;
			}
		}
	}
	void get(int id,int x)
	{
		for(int i = x;i;i=fail[i])
			if(!vis[i])
			{
				vis[i] = true;V.push_back(i);
				for(int j= 0;j<st[i].size();j++)
					if(!mark[st[i][j]])
					{
						mark[st[i][j]]=true;
						M.push_back(st[i][j]);
						ans1[st[i][j]]++;
						ans2[id]++;
					}
			}
			else break;
	}
	void solve(int x)
	{
		int now = 1;
		int sz = a[x].size();
		for(int i = 0;i<sz;i++)
		{
			int t = a[x][i];
			while(!ch[now][t])now = fail[now];
			now = ch[now][t],get(x,now);
		}
		for(int i= 0;i<V.size();i++)vis[V[i]] = false;
		for(int i= 0;i<M.size();i++)mark[M[i]] = false;
		V.clear();M.clear();
	}
}AC;
int main()
{
	int n,m,l;
	scanf("%d%d",&n,&m);
	for(int i= 1;i<= n;i++)
	{
		int x;
		scanf("%d",&l);
		for(int j = 1;j<= l;j++)
		{
			scanf("%d",&x);
			a[i].push_back(x);
		}
		a[i].push_back(-1);
		scanf("%d",&l);
		for(int j = 1;j<= l;j++)
		{
			scanf("%d",&x);
			a[i].push_back(x);
		}
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&l);
		for(int k =1;k<= l;k++)
			scanf("%d",&s[k]);
		AC.insert(l,i);
	}
	AC.build();
	for(int i= 1;i<= n;i++)
		AC.solve(i);
	for(int i = 1;i<= m;i++)printf("%d\n",ans1[i]);
	for(int i = 1;i<= n;i++)
	{
		printf("%d",ans2[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem2759

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
struct data
{
	int k,b;
	data(int _k=1,int _b=0):k(_k%mod),b(_b%mod){}
	data operator +(const data &s)const
	{
		data res;
		res.k = k*s.k%mod;
		res.b = (b*s.k+s.b)%mod;
		return res;
	}
	int cal(int x){x%=mod;return (k*x+b)%mod;}
};
void ex_gcd(int a,int b,int &x,int &y)
{
	if(!b)y=0,x=1;
	else
	{
		ex_gcd(b,a%b,y,x);
		y-=a/b*x;
	}
}
const int N = 6e4+5;
int ch[N][2],fa[N],sp_fa[N],size[N];
data sum[N],val[N];
bool vis[N],ins[N];
void dfs(int x)
{
	ins[x] = vis[x] = true;
	int v = fa[x];
	if(ins[v])
	{
		sp_fa[x] = v;
		fa[x] = 0;
	}
	if(!vis[v])dfs(v);
	ins[x] = false;
}
bool is_root(int x)
{
	return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;
}
void Push_up(int x)
{
	sum[x] = sum[ch[x][0]]+val[x]+sum[ch[x][1]];
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		else ch[z][1] = x;
	}
	fa[y] = x;fa[x] = z;fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y);
}
void splay(int x)
{
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[y][0]==ch[x][0])^(ch[z][0]==ch[y][0]))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
int Find_root(int x)
{
	access(x);
	splay(x);
	int rot = x;
	while(ch[rot][0])rot = ch[rot][0];
	splay(rot);return rot;
}
int Getans(int x)
{
	access(x);
	splay(x);
	data v1 = sum[x];
	int rot = Find_root(x),f = sp_fa[rot];
	access(f);splay(f);
	data v2 = sum[f];
	if(v2.k==1)return v2.b?-1:-2;
	if(v2.k==0)return v1.cal(v2.b);
	int X,Y;
	ex_gcd(v2.k-1,mod,X,Y);
	int tmp = (mod-X)%mod*v2.b%mod;
	return v1.cal(tmp);
}
void Cut(int x)
{
	access(x);
	splay(x);
	fa[ch[x][0]] = 0;
	ch[x][0] = 0;
	Push_up(x);
}
void Link(int x,int y)
{
	access(x);splay(x);
	fa[x] = y;
}
bool in_circle(int x,int rot)
{
	int f = sp_fa[rot];
	if(x==f)return true;
	access(f);
	splay(f);splay(x);
	return !is_root(f);
}
void update(int u,int f,int k,int b)
{
    access(u);
    splay(u);
    val[u]=data(k,b);
    Push_up(u);
    int ro=Find_root(u);
    if(u==ro)
    {
        int rf=Find_root(f);
        if(rf==ro)sp_fa[u]=f;
        else
        {
            sp_fa[u]=0;
            Link(u,f);
        }
    }else
    {
        if(in_circle(u,ro))
        {
            Cut(u);
            Link(ro,sp_fa[ro]);
            sp_fa[ro]=0;
            int rf=Find_root(f);
            if(rf==u)sp_fa[u]=f;
            else Link(u,f);
        }else
        {
            Cut(u);
            int rf=Find_root(f);
            if(rf==u)sp_fa[u]=f;
            else Link(u,f);
        }   
    }
}
int main()
{
	int n,k,b;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&k,&fa[i],&b);
		val[i] = sum[i] = data(k,b);
	}
	for(int i = 1;i<= n;i++)if(!vis[i])dfs(i);
	int q,x,f;
	char opt[3];
	scanf("%d",&q);
	while(q--)
	{
		scanf("%s%d",opt,&x);
		if(opt[0]=='A')printf("%d\n",Getans(x));
		else
		{
			scanf("%d%d%d",&k,&f,&b);
			update(x,f,k,b);
		}
	}
	return 0;
}
Problem2780

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int id[N],Dfn,in[N],out[N];
int c[N];
struct E
{int next,to;};
struct Gragh
{
	E e[N];
	int head[N],tot;
	void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
	void dfs(int x)
	{
		id[++Dfn] = x;
		in[x] = Dfn;
		for(int i = head[x];i;i=e[i].next)
			dfs(e[i].to);
		out[x] = Dfn;
	}
}g1,g2;
int trs[N][26],len[N],fa[N],lastins[N],ans[N];
int cnt,last;
int insert(int x)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	return last;
}
void init(){last=cnt=1;}
void build()
{
	for(int i = 1;i<= cnt;i++)
		g1.add(fa[i],i);
	g1.dfs(1);
}
struct Ask
{
	int l,r,no;
	bool operator<(const Ask &S)const
	{
		return r<S.r;
	}
}ask[N];
void update(int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
char s[360005];
int main()
{
	int n,q;
	init();
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1);
		last = 1;
		for(int j = 1;j<= l;j++)
		{
			int tmp = insert(s[j]-'a');
			g2.add(tmp,i);
		}
	}
	build();
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1),p=1;
		bool find = true;
		for(int j=1;j<=l;j++)
			if(!trs[p][s[j]-'a']){find = false;break;}
			else p = trs[p][s[j]-'a'];
		if(find)
			ask[i] = (Ask){in[p],out[p],i};
		else ask[i] = (Ask){-1,-1,i};
	}
	sort(ask+1,ask+q+1);
	int noww;
	int k=1;
	while(k<=q&&ask[k].l==-1)
		k++;
	for(int i=1;i<=cnt;i++)
	{
		for(int j=g2.head[id[i]];j;j=g2.e[j].next)
		{
			noww=g2.e[j].to;
			update(i,1);
			if(lastins[noww])
				update(lastins[noww],-1);
			lastins[noww]=i;
		}
		for(;ask[k].r==i;k++)
			ans[ask[k].no]=getans(ask[k].r)-getans(ask[k].l-1);
	}
	for(int i = 1;i<= q;i++)printf("%d\n",ans[i]);
	return 0;
}
Problem2783

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,a[N],sum[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int line[N],h,t,cnt,n,s;
multiset<int>Q;
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		sum[e[i].to] = sum[x]+a[e[i].to];
		if(Q.find(sum[e[i].to]-s)!=Q.end())cnt++;
		Q.insert(sum[e[i].to]);
		dfs(e[i].to);
		Q.erase(Q.find(sum[e[i].to]));
	}
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	Q.insert(0);
	sum[1] = a[1];
	Q.insert(sum[1]);
	dfs(1);
	printf("%d\n",cnt);
	return 0;
}
Problem2788

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 605;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool ins[N],v[N];
int dep[N],low[N],stack[N],dfn,top,bel[N],scc;
int map[N][N];
void tarjan(int x)
{
	v[x] = ins[x] = true;
	stack[++top] = x;
	dep[x] = low[x] = ++dfn;
	for(int i = head[x];i;i = e[i].next)
	{
		if(!v[e[i].to])
			{tarjan(e[i].to);low[x] = min(low[e[i].to],low[x]);}
		else if(ins[e[i].to])
			{low[x] = min(low[x],dep[e[i].to]);}
	}
	if(dep[x]==low[x])
	{
		scc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] =false;
			bel[tmp] = scc;
		}while(tmp!=x);
	}
}
int main()
{
	int n,m1,m2;
	scanf("%d%d%d",&n,&m1,&m2);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			map[i][j] = -INF;
	for(int i = 1;i<= n;i++)map[i][i] = 0;
	int x,y;
	for(int i = 1;i<= m1;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,1),add(y,x,-1);
		map[x][y] = max(map[x][y],1);
		map[y][x] = max(map[y][x],-1);
	}
	for(int i = 1;i<= m2;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,0);
		map[x][y] = max(map[x][y],0);
	}
	for(int i = 1;i<= n;i++)
		if(!v[i])
			tarjan(i);
	int t_ans = 0;
	for(int t = 1;t<= scc;t++)
	{
		for(int k = 1;k<= n;k++)
		{
			if(bel[k]!=t)continue;
			for(int i = 1;i<= n;i++)
			{
				if(bel[i]!=t||map[i][k]==-INF)continue;
				for(int j = 1;j<= n;j++)
				{
					if(bel[j]!=t||map[k][j]==-INF)continue;
					map[i][j] = max(map[i][j],map[i][k]+map[k][j]);
				}
			}
		}
		int ans = 0;
		for(int i = 1;i<= n;i++)
			if(bel[i]==t)
				for(int j = 1;j<= n;j++)
					if(bel[j]==t)
						ans = max(ans,abs(map[i][j]));
		t_ans += ans+1;
	}
	for(int i = 1;i<= n;i++)
		if(map[i][i])
		{
			printf("NIE\n");
			return 0;
		}
	printf("%d\n",t_ans);
	return 0;
}
Problem2789

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int last[30],next[N],val[N],c[N];
char s1[N],s2[N];
queue <int>Q[30];
void update(int x,int t)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=t;
}
int getans(int x)
{
	int sum = 0;
	for(int i = x;i>0;i-=i&(-i))
		sum+=c[i];
	return sum;
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s1+1);
	scanf("%s",s2+1);
	for(int i = 1;i<= n;i++)
		Q[s1[i]-'A'].push(i);
	for(int i = 1;i<= n;i++)
	{
		val[i] = Q[s2[i]-'A'].front();
		Q[s2[i]-'A'].pop();
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans+=getans(n)-getans(val[i]);
		update(val[i],1);
	}
	printf("%lld",ans);
	return 0;
}
Problem2790

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
int f[M],a[N],pre[M],sec[M];
int prime[N],cnt,v[M];
void init(int x)
{
	for(int i = 2;i<= x;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			f[i] = 1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<= x;j++)
		{
			v[prime[j]*i]= true;
			f[i*prime[j]] = f[i]+1;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	//freopen("odl.in","r",stdin);
	//freopen("odl.out","w",stdout);
	f[0] = INF;
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	init(1000000);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j*j<= a[i];j++)
		{
			if(a[i]%j==0)
			{
				if(f[a[i]]<f[a[pre[j]]])sec[j] = pre[j],pre[j] = i;
				else if(f[a[i]]<f[a[sec[j]]])sec[j] = i;
				if(f[a[i]]<f[a[pre[a[i]/j]]])sec[a[i]/j] = pre[a[i]/j],pre[a[i]/j] = i;
				else if(f[a[i]]<f[a[sec[a[i]/j]]]&&pre[a[i]/j]!=i)sec[a[i]/j] = i;
			}
		}
	}
	
	for(int i = 1;i<= n;i++)
	{
		int ans1 = 0x3f3f3f3f,ans2 = 0;
		for(int j = 1;j*j<= a[i];j++)
		{
			if(a[i]%j==0)
			{
				if(pre[j]&&sec[j]&&f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]]<ans1)
				{
					ans1 = f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]];
					ans2 = pre[j]==i?sec[j]:pre[j];
				}else if(f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]]==ans1)
					ans2 = min(ans2,pre[j]==i?sec[j]:pre[j]);
				if(pre[a[i]/j]&&sec[a[i]/j]&&f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]]<ans1)
				{
					ans1 = f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]];
					ans2 = pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j];
				}else if(f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]]==ans1)
					ans2 = min(ans2,pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]);
			}
		}
		printf("%d\n",ans2);
	}
	return 0;
}
Problem2791

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int fa[N][20];
int a[N],on_ring[N],v[N],pos[N],size[N],root[N],dep[N],n;
void dfs(int x,int id)
{
	v[x] = id;
	if(v[a[x]]==v[x])
	{
		int tmp = 1;
		for(int i = x;i!=x||tmp==1;i = a[i],tmp++)
			on_ring[i] = id,pos[i] = tmp,root[i] = i;
		size[id] = --tmp;
		return ;
	}
	if(!v[a[x]])
		dfs(a[x],id);
	if(!on_ring[x])
	{
		fa[x][0] = a[x];
		dep[x] = dep[a[x]]+1;
		root[x] = root[a[x]];
	}
}
void init()
{
	for(int j = 1;j<= 19;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 19;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 19;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int dist(int x,int y,int p)
{
	return (y-x+p)%p;
}
void solve(int x,int y)
{
	if(on_ring[root[x]]!=on_ring[root[y]])
	{
		printf("-1 -1\n");
		return ;
	}
	if(root[x]==root[y])
	{
		int lca = getlca(x,y);
		printf("%d %d\n",dep[x]-dep[lca],dep[y]-dep[lca]);
		return ;
	}
	int fx = root[x],fy = root[y];
	int x1=dep[x]+dist(pos[fx],pos[fy],size[on_ring[fx]]),y1=dep[y];
	int x2=dep[x],y2=dep[y]+dist(pos[fy],pos[fx],size[on_ring[fy]]);
	if(max(x1,y1)!=max(x2,y2))
	{
		if(max(x1,y1)<max(x2,y2))printf("%d %d\n",x1,y1);
		else printf("%d %d\n",x2,y2);
		return ;
	}
	if(min(x1,y1)!=min(x2,y2))
	{
		if(min(x1,y1)<min(x2,y2))printf("%d %d\n",x1,y1);
		else printf("%d %d\n",x2,y2);
		return ;
	}
	printf("%d %d\n",max(x1,y1),min(x1,y1));
}
int main()
{
	int q,x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int rings = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i])
		{
			rings++;
			dfs(i,rings);
		}
	init();
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&x,&y);
		solve(x,y);
	}
	return 0;
}
Problem2792

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 1e6+5;
int x[M];
int c[M];
long long l[M],r[M];
int n;
LL m;
int check(int p)
{
	memcpy(c,x,sizeof(x));
	memset(l,0,sizeof(l));
	memset(r,0,sizeof(r));
	LL tot = 0;
	for(int i = 1;i<= n-1;i++)
		if(c[i+1]-c[i]>=p)
		{
			tot+=c[i+1]-c[i]-p;
			c[i+1] = c[i]+p;
		}
	//if(c[1]>c[2]+p){tot+=c[1]-c[2]-p;c[1] = c[2]+p;}
	if(tot>m)return -1;
	for(int i = n;i>= 2;i--)
		if(c[i-1]-c[i]>=p)
		{
			tot+=c[i-1]-c[i]-p;
			c[i-1] = c[i]+p;
		}
	//if(c[n]>c[n-1]+p){tot+=c[n]-c[n-1]-p;c[n] = c[n-1]+p;}
	if(tot>m)return -1;
	LL sum =0;
	int j = 1;
	for(int i = 1;i<= n;i++)
	{
		while((i-j)*p>c[j]&&j<i)
			{sum-=c[j];j++;}
		l[i]=sum-(LL)(i-j)*(i-j+1)/2*p;
		sum+=c[i];
	}
	sum =0,j = n;
	for(int i = n;i>= 1;i--)
	{
		while((j-i)*p>c[j]&&j>i)
			{sum-=c[j];j--;}
		r[i]=sum-(LL)(j-i)*(j-i+1)/2*p;
		sum+=c[i];
	}
	for(int i = 1;i<= n;i++)
		if(tot+l[i]+r[i]+c[i]<=m)
			return i;
	return -1;
}
int main()
{
	//freopen("stu.in","r",stdin);
	//freopen("stu.out","w",stdout);
	int maxn = 0;
	scanf("%d%lld",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x[i]);
		maxn = max(maxn,x[i]);
	}
	int L = 0,R = maxn+1;
	int ans = 1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		int tmp = check(mid);
		if(tmp==-1)L = mid+1;
		else {ans = tmp;R = mid;}
	}
	printf("%d %d\n",ans,L);
	return 0;
}
Problem2793

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 1e6;
bool is_luck[N],v[N];
int mn[N],cnt;
long long ans[N];
int main()
{
	int m,x;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&x);
		is_luck[x] = true;
	}
	int n;
	long long tot = 0;
	scanf("%d",&n);
	v[0] = true;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		for(int j = 1;j<= x;j++)
		{
			while(mn[x]*x<=INF&&v[mn[x]*x])mn[x]++;
			if(mn[x]*x>INF)break;
			v[mn[x]*x] = true;
			if(is_luck[mn[x]*x])ans[++cnt] = tot+j;
		}
		tot+=x;
	}
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem2794

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int Q = 1e6+5;
const int M = 1e5+5;
struct A
{int l,r,v,id;}w[N],ask[Q];
bool cmp(A a,A b)
{
	return a.l<b.l;
}
int f[M],ans[Q];
int main()
{
	int n,q;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&w[i].v,&w[i].l,&w[i].r);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].l,&ask[i].v,&ask[i].r);
		ask[i].r+=ask[i].l;
		ask[i].id = i;
	}
	sort(w+1,w+n+1,cmp);
	sort(ask+1,ask+1+q,cmp);
	f[0] = 1e9;
	int j = 1;
	for(int i = 1;i<= q;i++)
	{
		while(w[j].l<=ask[i].l&&j<=n)
		{
			for(int k = M-5;k>= w[j].v;k--)
				f[k] = max(f[k],min(f[k-w[j].v],w[j].r));
			j++;
		}
		if(f[ask[i].v]>ask[i].r)
			ans[ask[i].id] = 1;
	}
	for(int i = 1;i<= q;i++)
	{
		if(ans[i])printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem2795

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int MOD = 23333333;
const int SED = 37;
const int N = 500005;
int nxt[N],pow[N],n;
int sum[N][26];
void init()
{
	pow[0] = 1;
	for(int i = 1;i<= n;i++)
		pow[i] = (LL)pow[i-1]*SED%MOD;
}
char s[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
int gethash(int a,int b)
{
	int lth = b-a+1;
	return (LL)(nxt[a]-(LL)nxt[b+1]*pow[lth]%MOD+MOD)%MOD;
}
int main()
{
	int a,b;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<26;j++)
			sum[i][j] = sum[i-1][j]+(s[i]==j+'a');
	for(int i = n;i>=1;i--)
		nxt[i] = ((LL)nxt[i+1]*SED+s[i]-'a')%MOD;
	init();
	int q;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&a,&b);
		int tmp = b-a+1;
		int lth = tmp;
		for(int j = 0;j<26;j++)
			tmp = gcd(tmp,sum[b][j]-sum[a-1][j]);
		int ans = lth;
		for(int j = 1;j*j<= tmp;j++)
		{
			if(tmp%j==0)
			{
				if(gethash(a,b-lth/j)==gethash(a+lth/j,b))
					ans = min(ans,lth/j);
				if(gethash(a,b-lth/(tmp/j))==gethash(a+lth/(tmp/j),b))
					ans = min(ans,lth/(tmp/j));
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem2796

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL f[100];
int solve(LL x)
{
	if(!x)return 0;
	int i = 1;
	while(f[i]<x)i++;
	if(f[i]==x)return 1;
	return solve(min(f[i]-x,x-f[i-1]))+1;
}
int main()
{
	f[1] = f[2] = 1;
	for(int i = 3;i<= 95;i++)f[i] = f[i-1]+f[i-2];
	int T;
	scanf("%d",&T);
	while(T--)
	{
		LL n;
		scanf("%lld",&n);
		printf("%d\n",solve(n));
	}
	return 0;
}
Problem2797

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
multiset<int>m;
int ans[305][305];
int t_ans[305];
int sum[90005],n,tot,cnt;
void getans(int sum3)
{
	m.clear();
	for(int i = 3;i<= tot;i++)
		m.insert(sum[i]);
	if((sum[1]+sum[2]+sum3)&1)return ;
	t_ans[1] = (sum[1]+sum[2]-sum3)>>1;
	t_ans[2] = (sum[1]+sum3-sum[2])>>1;
	t_ans[3] = (sum[2]+sum3-sum[1])>>1;
	if(t_ans[1]<=0||t_ans[2]<=0||t_ans[3]<=0)return ;
	m.erase(m.find(sum3));
	for(int i = 4;i<= n;i++)
	{
		t_ans[i] = *m.begin()-t_ans[1];
		if(t_ans[i]<=0)return ;
		for(int j = 1;j<i;j++)
		{
			int tmp = t_ans[j]+t_ans[i];
			if(m.find(tmp)==m.end())return ;
			m.erase(m.find(tmp));
		}
	}
	for(int i = 2;i<= n;i++)
		if(t_ans[i-1]>=t_ans[i])return ;
	cnt++;
	for(int i = 1;i<= n;i++)
		ans[cnt][i] = t_ans[i];
}
int main()
{
	scanf("%d",&n);
	tot = n*(n-1)/2;
	for(int i = 1;i<=tot;i++)
		scanf("%d",&sum[i]);
	sort(sum+1,sum+tot+1);
	for(int i = 3;i<= n;i++)
		if(i==3||sum[i]!=sum[i-1])
			getans(sum[i]);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = 1;j<=n;j++)
			printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
Problem2799

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int p[N],z[N],mn[N],fa[N],num[N],id[N],sum[N],cnt;
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void dfs(int x)
{
	if(mn[x])return ;
	dfs(p[x]);
	mn[x] = getfa(mn[p[x]]-1);
	if(++num[mn[x]]==1)
		id[mn[x]] = x;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)fa[i] = i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&p[i],&z[i]);
		if(p[i]==i)z[i] = n;
		if(z[i])
		{
			fa[z[i]] = z[i]-1;
			mn[i] = z[i];
		}
	}
	for(int i = 1;i<= n;i++)
		if(!mn[i])dfs(i);
	for(int i = 1;i<= n;i++)
		sum[i] = sum[i-1]+(fa[i]==i);
	for(int i = 1;i<= n;i++)
		if(num[i])
		{
			if(num[i]==1&&sum[i]==cnt+1)
				z[id[i]] = i,cnt++;
			else if(num[i]+cnt==sum[i])
				cnt = sum[i]; 
			else num[i+1]+=num[i];
		}
	for(int i = 1;i<= n;i++)
		printf("%d\n",z[i]);
	return 0;
}
Problem2801

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 500005;
const int M = 3000005;
char BB[1<<15],*K=BB,*T=BB;
#define getc() (K==T&&(T=(K=BB)+fread(BB,1,1<<15,stdin),K==T)?0:*K++)
inline long long read()
{
    long long x=0;char ch=getc();
    while(ch<'0'||ch>'9')ch=getc();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getc();
    return x;
}
struct F
{
	LL k,c;
	F()
	{k = c = 0;}
	void operator -=(const F &S)
	{k-=S.k;c-=S.c;}
}f[N];
struct E
{int next,to,val;}e[M<<1];
int head[N],tot;
LL p[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
bool v[N];
LL l,r;
LL O,V,X;
int line[N],h,t;
int dfs(int s)
{
	O = V= 0;
	h = 0,t = -1;
	l = 0,r = p[s];
	line[++t] = s;
	v[s] = true;
	f[s].k = 1,f[s].c = 0;
	while(h<=t)
	{
		int x = line[h++];
		O-=f[x].k,V+=p[x]-f[x].c;
		for(int i = head[x];i;i = e[i].next)
		{
			int j = e[i].to;
			if(!v[j])
			{
				line[++t] = j;
				v[j] = true;
				f[j].k = -f[x].k;
				f[j].c = e[i].val-f[x].c;
				if(f[e[i].to].k==1)
				{
					r=min(r,p[j]-f[j].c);
					l=max(l,-f[j].c);
				}
				else
				{
					r=min(r,f[j].c);
					l=max(l,f[j].c-p[j]);
				}
				if(r<l)return -1;
			}else
			{
				if(f[j].k==f[x].k)
				{
					X = f[j].c+f[x].c-e[i].val;
					if(X%2!=0)return -1;
					r = min(r,(e[i].val-f[x].c-f[e[i].to].c)/2/f[x].k);
					l = max(l,(e[i].val-f[x].c-f[e[i].to].c)/2/f[x].k);
					if(r<l)return -1;
				}else
				{
					if(e[i].val!=f[x].c+f[j].c)
						return -1;
				}
			}
		}
	}
	return 0;
}
int main()
{
	//freopen("bez.in","r",stdin);
	//freopen("bez.out","w",stdout);
	long long n,m,x,y,z;
	n = read(),m = read();
	for(int i = 1;i<= n;i++)
		p[i] = read();
	for(int i = 1;i<= m;i++)
	{
		x = read(),y = read(),z = read();
		add(x,y,z),add(y,x,z);
	}
	LL minn = 0,maxn = 0;
	for(int i = 1;i<= n;i++)
	{
		if(!v[i])
		{
			int tmp = dfs(i);
			if(tmp==-1){printf("NIE\n");return 0;}
			else if(O>0)
				minn+=l*O+V,maxn+=r*O+V;
			else minn+=r*O+V,maxn+=l*O+V;
		}
	}
	printf("%lld %lld\n",minn,maxn);
	return 0;
}
Problem2802

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250005;
typedef long long LL;
struct H
{int no,val;}heap[N];
LL a[N];
int ans[N],cnt;
bool cmp(H a,H b)
{
	return a.val<b.val;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		int b;
		scanf("%d",&b);
		a[i]+=a[i-1];
		if(b<=a[i])
		{
			a[i]-=b;
			heap[++cnt].val = b;
			heap[cnt].no = ++ans[0];
			ans[ans[0]] = i;
			push_heap(heap+1,heap+cnt+1,cmp);
		}else if(cnt)
		{
			int tmp = heap[1].val,pos = heap[1].no;
			if(a[i]+tmp-b>=0&&tmp>b)
			{
				pop_heap(heap+1,heap+cnt+1,cmp);
				cnt--;
				a[i] = a[i]+tmp-b;
				ans[pos] = i;
				heap[++cnt].val = b;
				heap[cnt].no = pos;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
	}
	printf("%d\n",ans[0]);
	for(int i = 1;i< ans[0];i++)
		printf("%d ",ans[i]);
	if(ans[0])printf("%d\n",ans[ans[0]]);
	return 0;
}
Problem2803

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
const int SED = 37;
int MOD[2] = {23333333,99824435};
int pre[2][N],pow[2][N],n;
char s[N];
void init()
{
	for(int i = 1;i<= n;i++)
	{
		pre[0][i] = ((LL)pre[0][i-1]*SED+s[i]-'a')%MOD[0];
		pre[1][i] = ((LL)pre[1][i-1]*SED+s[i]-'a')%MOD[1];
	}
	pow[0][0] = pow[1][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		pow[0][i] = ((LL)pow[0][i-1]*SED)%MOD[0];
		pow[1][i] = ((LL)pow[1][i-1]*SED)%MOD[1];	
	}
}
int gethash(int l,int r,int no)
{
	int lth = r-l+1;
	return (pre[no][r]-(LL)pre[no][l-1]*pow[no][lth]%MOD[no]+MOD[no])%MOD[no];
}
bool check(int l1,int r1,int l2,int r2)
{
	return gethash(l1,r1,0)==gethash(l2,r2,0)&&gethash(l1,r1,1)==gethash(l2,r2,1);
}
int main()
{
	scanf("%d",&n);
	scanf("%s",s+1);
	init();
	int ans = 0;
	for(int i = n>>1,j = 0;i>0;i--,j = min(j+2,n/2-i))
		if(check(1,i,n-i+1,n))
			for(;~j;j--)
				if(check(i+1,i+j,n-i-j+1,n-i))
				{
					ans = max(ans,i+j);
					break;
				}
	printf("%d\n",ans);
	return 0;
}
Problem2806

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2300000+5;
char s[N];
int trs[N][2],len[N],fa[N];
int cnt,last,maxlen;
void insert(int x)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
}
int mtc[N];
void match(int n)
{
	int tmp = 0,p = 1;
	for(int i = 1;i<= n;i++)
	{
		int x = s[i]-'0';
		if(trs[p][x])p=trs[p][x],tmp++;
		else
		{
			while(p&&!trs[p][x])p=fa[p];
			if(!p)tmp = 0,p=1;
			else tmp = len[p]+1,p = trs[p][x];
		}
		mtc[i] = tmp;
	}
}
int Q[N],H,T,f[N],tmp[N];
bool check(int x,int n)
{
	f[0] = 0;
	H = 0,T = -1;
	//for(int i=1;i<=n;i++)tmp[i]=i-mtc[i];
	for(int i = 1;i<= n;i++)
	{
		f[i] = f[i-1];
		int p = i-x;  
        while(p>=0&&H<=T&&f[p]-p>f[Q[H]]-Q[H])
        	H++;
		if(p>=0)Q[++T] = p;
        while(H<=T&&i-mtc[i]>Q[H])H++;  
        if(H<=T)f[i] = max(f[i], f[Q[H]]+i-Q[H]);
	}
	return f[n]*10>=n*9;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	cnt = 1;
	for(int i = 1;i<= m;i++)
	{
		last = 1;
		scanf("%s",s+1);int lth = strlen(s+1);
		maxlen = max(maxlen,lth);
		for(int j = 1;j<= lth;j++)
			insert(s[j]-'0');
	}
	while(n--)
	{
		scanf("%s",s+1);
		int lth = strlen(s+1);
		match(lth);
		int l = 0,r = lth,ans=0;
		while(l<=r)
		{
			int mid = (l+r)>>1;
			if(check(mid,lth))l=mid+1,ans = mid;
			else r=mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem2809

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
int n,tot_root,b;
long long m;
struct Heap{
	Heap *ls,*rs;
	int key;
	Heap(int f)
	{
		ls = rs = NULL;
		key = f;
	}
};
Heap* Merge(Heap *x,Heap *y)
{
	if(!x)return y;
	if(!y)return x;
	if(y->key>x->key)
		swap(x,y);
	if(rand()%2==1)
		x->ls = Merge(x->ls,y);
	else 
		x->rs = Merge(x->rs,y);
	return x;
}
struct e
{int next,to;}edge[100005];
int head[100005],tot;
long long c[100005],l[100005],tc[100005],tp[100005];
Heap *h[100005];
void add(int x,int y)
{
	edge[++tot].to = y;
	edge[tot].next = head[x];
	head[x] = tot;
}
long long ans = 0;
void dfs(int x)
{
	Heap *root = new Heap(c[x]);
	tc[x]+=c[x];tp[x]++;
	for(int i = head[x];i;i = edge[i].next)
	{
		dfs(edge[i].to);
		root = Merge(root,h[edge[i].to]);
		tc[x]+=tc[edge[i].to];
		tp[x]+=tp[edge[i].to];
	}
	while(tc[x]>m)
	{
		tc[x]-=root->key;
		root = Merge(root->ls,root->rs);
		tp[x]--;
	}
	ans = max(ans,(long long)tp[x]*l[x]);
	h[x] = root;
}
int main()
{
	scanf("%d%lld",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%lld%lld",&b,&c[i],&l[i]);
		if(b==0)tot_root = i;
		else add(b,i);
	}
	dfs(tot_root);
	printf("%lld",ans);
	return 0;
}
Problem2813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e7+5;
const int mod = 1e9+7;
bool v[N];
int f[N],g[N],prime[N],e[N],d[N],cnt;
int main()
{
	int q1,a,b,c;
	int q;
	scanf("%d%d%d%d%d",&q,&q1,&a,&b,&c);
	f[1] = g[1] = 1;
	for(int i = 2;i<= c;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			e[i] = d[i] = 1;
			g[i] = 2;
			f[i]=((LL)i*i+1)%mod;
		}
		int k;
		for(int j = 1;j<= cnt&&(k=i*prime[j])<=c;j++)
		{
			v[k] = true;
			if(i%prime[j]==0)
			{
				e[k] = e[i]+1;
				g[k] = (g[i]/e[k])*(e[k]+1);
				d[k] = d[i];
				f[k] = ((LL)f[i]*prime[j]%mod*prime[j]%mod+f[d[i]])%mod;
			}else
			{
				e[k] = 1;
				d[k] = i;
				g[k] = g[i]*2;
				f[k] = (LL)f[i]*((LL)prime[j]*prime[j]%mod+1)%mod;
			}
		}
	}
	int ans1 = 0,ans2 = 0;
	for(int i = 1;i<= q;i++)
	{
		(ans1+=g[q1]+(q1&1))%=mod;
		(ans2+=f[q1]+4*(q1&1))%=mod;
		q1 = ((LL)q1*a+b)%c+1;
	}
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e7+5;
const int mod = 1e9+7;
bool v[N];
int f[N],g[N],prime[N],e[N],d[N],cnt;
int main()
{
	int q1,a,b,c;
	int q;
	scanf("%d%d%d%d%d",&q,&q1,&a,&b,&c);
	f[1] = g[1] = 1;
	for(int i = 2;i<= c;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			e[i] = d[i] = 1;
			g[i] = 2;
			f[i]=((LL)i*i+1)%mod;
		}
		int k;
		for(int j = 1;j<= cnt&&(k=i*prime[j])<=c;j++)
		{
			v[k] = true;
			if(i%prime[j]==0)
			{
				e[k] = e[i]+1;
				g[k] = (g[i]/e[k])*(e[k]+1);
				d[k] = d[i];
				f[k] = ((LL)f[i]*prime[j]%mod*prime[j]%mod+f[d[i]])%mod;
				break;
			}else
			{
				e[k] = 1;
				d[k] = i;
				g[k] = g[i]*2;
				f[k] = (LL)f[i]*((LL)prime[j]*prime[j]%mod+1)%mod;
			}
		}
	}
	int ans1 = 0,ans2 = 0;
	for(int i = 1;i<= q;i++)
	{
		(ans1+=g[q1]+(q1&1))%=mod;
		(ans2+=f[q1]+4*(q1&1))%=mod;
		q1 = ((LL)q1*a+b)%c+1;
	}
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2815

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 65534+5;
struct E
{int next,to;}e1[N<<4],e2[N<<1],ef[N<<4];
int he[N],ht[N],hf[N],tote,tott,fa[N][17],ind[N],dep[N];
void adde(int x,int y)
{
	ind[y]++;
	e1[++tote].to = y;
	e1[tote].next = he[x];
	he[x] = tote;
	ef[tote].to = x;
	ef[tote].next = hf[y];
	hf[y] = tote;
}
void addt(int x,int y)
{
	e2[++tott].to = y;
	e2[tott].next = ht[x];
	ht[x] = tott;
	e2[++tott].to = x;
	e2[tott].next = ht[y];
	ht[y] = tott;
}
queue <int>Q;
int line[N],cnt,n;
void addleaf(int x,int y)
{
	dep[x] = dep[y]+1;fa[x][0] = y;
	for(int i = 1;i<17;i++)
		fa[x][i] = fa[fa[x][i-1]][i-1];
}
int getlca(int x,int y)
{
	if(x<0)return y;
	if(dep[x]<dep[y])swap(x,y);
	for(int j = 16;j>=0;j--)
		if(dep[fa[x][j]]>=dep[y])
			x = fa[x][j];
	if(x==y)return x;
	int re;
	for(int j = 16;j>=0;j--)
	{
		if(fa[x][j]!=fa[y][j])
		{
			x = fa[x][j];
			y = fa[y][j];
		}else re = fa[x][j];
	}
	return re;
}
void topo()
{
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i),addt(0,i),dep[i] = 1;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = he[x];i;i = e1[i].next)
		{
			--ind[e1[i].to];
			if(!ind[e1[i].to])
			{
				Q.push(e1[i].to);
				line[++cnt] = e1[i].to;
			}
		}
	}
}
void build(int x)
{
	int tmp = -1;
	for(int i = hf[x];i;i = ef[i].next)
		tmp = getlca(tmp,ef[i].to);
	addt(tmp,x);
	addleaf(x,tmp);
}
int size[N];
void dfs(int x,int fa)
{
	size[x]++;
	for(int i = ht[x];i;i = e2[i].next)
		if(e2[i].to!=fa)
		{
			dfs(e2[i].to,x);
			size[x]+=size[e2[i].to];
		}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		int x;
		while(scanf("%d",&x))
		{
			if(x==0)break;
			adde(x,i);
		}
	}
	topo();
	for(int i = 1;i<= cnt;i++)
		build(line[i]);
	dfs(0,-1);
	for(int i = 1;i<= n;i++)
		printf("%d\n",size[i]-1);
	return 0;
}
Problem2818

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long sum_oula[10000005];
long long oula[10000005];
int prime[1000005],t_p,n;
bool v[10000005];
void quick_oula()
{
	oula[1] = 1;
	for(int i = 2;i<= n;i++)
	{
		if(!v[i])
		{
			t_p++;
			prime[t_p] = i;
			oula[i] = i - 1;
		}
		for(int j = 1;j<= t_p&&i*prime[j]<=n;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j]==0)
			{
				oula[i*prime[j]] = oula[i]*prime[j];
				break;
			}
			else 
				oula[i*prime[j]] = oula[i]*(prime[j]-1);
		}
	}
	for(int i = 1;i<= n;i++)
		sum_oula[i] = sum_oula[i-1]+oula[i];
}
int main()
{
	memset(prime,0x3f,sizeof(prime));
	scanf("%d",&n);
	quick_oula();
	int j = 1;long long ans = 0;
	while(prime[j]<=n)
	{
		ans +=sum_oula[n/prime[j]];
		j++;
	}
	ans = ans*2-j+1;
	printf("%lld",ans);
	return 0;
}
Problem2820

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int prime[N/10],mu[N],sum[N],g[N],cnt;
bool vis[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<=cnt;i++)
		for(int j = 1;j*prime[i]<N;j++)
			g[j*prime[i]]+=mu[j];
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+g[i];
}
void solve(int n,int m)
{
	ll ans = 0;
	int last;
	for(int i = 1;i<=n&&i<=m;i = last+1)
	{
		last = min(m/(m/i),n/(n/i));
		ans+=(ll)(n/i)*(m/i)*(sum[last]-sum[i-1]);
	}
	printf("%lld\n",ans);
}
int main()
{
	int t;
	scanf("%d",&t);
	quick_mu();
	while(t--)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		solve(x,y);
	}
	return 0;
}
Problem2879

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 3e6+5;
const int INF = 0x3f3f3f3f;
int p[45],P,m,n,from[N];
int t[45][105];
struct E
{int next,to,c,f,from;}e[M];
int head[N],tot=1,st,end;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f;e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0;e[tot].c=-c;
	e[tot-1].from=x;e[tot].from=y;
}
int dis[N];bool v[N];
queue<int>Q;
bool spfa()
{
	memset(dis,0x3f,sizeof(dis));
	Q.push(st);
	dis[st]=0,v[st]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].c&&e[i].f)
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[end]!=INF;
}
int ans;
void mcf()
{
	int x = INF,a,b,y;
	for(int i = from[end];i;i=from[e[i].from])
	{
		x = min(x,e[i].f);
		if(e[i].from==0)
		{
			y = e[i].to;
			a = (y-1)/P+1;b = y%P+1;
		}
	}
	for(int i = from[end];i;i=from[e[i].from])
	{
		e[i].f-=x;e[i^1].f+=x;ans+=e[i].c*x;
	}
	for(int i = 1;i<= m;i++)
		add((a-1)*P+b,n*P+i,1,b*t[i][a]);
}
int main()
{
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&p[i]);
		P+=p[i];
	}
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			scanf("%d",&t[i][j]);
	st = 0,end = n*P+m+1;
	for(int i = 1;i<= n*P;i++)
		add(st,i,1,0);
	for(int i = 1;i<= m;i++)
		add(n*P+i,end,p[i],0);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			add((i-1)*P+1,n*P+j,1,t[j][i]);
	while(spfa())mcf();
	printf("%d\n",ans);
	return 0;
}
Problem2888

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 40005;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,ans,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int son[N][2],sum[N],fa[N],size[N],lazy[N],val[N],s[N],d[N];
bool rev[N];
inline bool is_root(int x)
{
	return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;
}
inline void reverse(int x)
{
	rev[x]^=1;
	swap(son[x][0],son[x][1]);
}
inline void init(int x,int f)
{
	fa[x] = f;
	son[x][0] = son[x][1] = val[x] = lazy[x] = 0;
	sum[x] = s[x] = d[x] = 0;size[x] = 1;
}
inline void Push_up(int x)
{
	if(!x)return ;
	size[x] =size[son[x][0]]+1+size[son[x][1]];
}
inline void Add(int x,int y)
{
	if(!x)return ;
	val[x]+=y;
	lazy[x]+=y;
}
inline void update(int x,int S,int D)
{
	if(!x)return ;
	sum[x]+=S+size[son[x][1]]*D;
	s[x]+=S,d[x]+=D;
}
inline void Push_down(int x)
{
	int ls = son[x][0],rs = son[x][1];
	if(rev[x])
	{
		reverse(ls);
		reverse(rs);
		rev[x] = 0;
	}
	if(lazy[x])
	{
		Add(ls,lazy[x]),Add(rs,lazy[x]);
		lazy[x] = 0;
	}
	if(d[x])
	{
		update(ls,s[x]+(size[rs]+1)*d[x],d[x]);
		update(rs,s[x],d[x]);
		s[x] = d[x] = 0;
	}
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(y==son[z][0])son[z][0] = x;
		else son[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[son[x][d^1]] = y;
	son[y][d] = son[x][d^1],son[x][d^1] = y;
	Push_up(x),Push_up(y);
}
int stack[N],top;
void splay(int x)
{
	top = 0;
	stack[++top] = x;
	for(int i = x;!is_root(i);i = fa[i])stack[++top] = fa[i];
	while(top)Push_down(stack[top--]);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)!=(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		son[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
int find(int x)
{
	access(x);
	splay(x);
	while(son[x][0])
		x = son[x][0];
	return x;
}
void insert(int f,int x)
{
	init(x,f);
	f = find(f);access(x);splay(f);
	Add(f,1);
	update(f,0,1);
	x = son[f][1];
	while(son[x][0])
		x = son[x][0];
	splay(x);
	int v1 = val[f],v2= val[x];
	if(v2*2>v1)
	{
		val[x] = v1,val[f]-=v2;
		sum[f]-=sum[x]+v2;sum[x]+=sum[f]+v1-v2;
		access(x);splay(f);
		son[f][0] = x;son[f][1] = 0;
	}
}
void dfs(int x,int f)
{
	insert(f,x);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=f)dfs(e[i].to,x);
}
void Link(int x,int y)
{
	add(x,y),add(y,x);
	int p = find(x),q = find(y);
	ans-=sum[p]+sum[q];
	if(val[p]<val[q])swap(x,y);
	dfs(y,x);
	ans+=sum[find(x)];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)val[i]=size[i]=1;
	char opt[3];
	int a,b;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='A'){scanf("%d%d",&a,&b);Link(a,b);}
		else printf("%d\n",ans);
	}
	return 0;
}
Problem2929

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int M = 8e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].flow = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].flow = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow&&d[e[i].to]==d[s]-1)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF))!=0)
			ans+=nowflow;
	return ans;
}
int main()
{
	int n,m,x;
	scanf("%d",&n);
	int st = 1,end = n;
	for(int i = 1;i< n;i++)
	{
		scanf("%d",&m);
		if(i==1)
			while(m--)
			{
				scanf("%d",&x);
				add(1,x,1);
			}
		else
			while(m--)
			{
				scanf("%d",&x);
				if(x!=n)add(i,x,INF);
				else add(i,n,1);
			}
	}
	printf("%d\n",dinic(st,end));
	return 0;
}
Problem2938

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int s[N];char str[N];
bool ins[N],vis[N];
struct AC_Machine
{
	int ch[N][2],fail[N];bool end[N];
	int cnt,q[N],h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<2;i++)
			ch[0][i] = 1;
	}
	void insert(int len)
	{
		int now = 1;
		for(int i = 1;i<=len;i++)
		{
			if(!ch[now][s[i]])ch[now][s[i]]=++cnt;
			now = ch[now][s[i]];
		}
		end[now] = true;
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1,fail[0] = 1;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<2;i++)
			{
				int j = ch[x][i];
				if(!j)
				{
					ch[x][i]=ch[fail[x]][i];
					continue;
				}
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[j] = ch[k][i];
				end[j]|=end[fail[j]];
				q[++t]=j;
			}
		}
	}
	bool dfs(int x)
	{
		ins[x] = true;
		for(int i = 0;i<2;i++)
		{
			int v = ch[x][i];
			if(ins[v])return true;
			if(vis[v]||end[v])continue;
			vis[v] = true;
			if(dfs(v))return true;
		}
		ins[x] = false;
		return false;
	}
}AC;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",str+1);
		int len = strlen(str+1);
		for(int j = 1;j<= len;j++)
			s[j] = str[j]-'0';
		AC.insert(len);
	}
	AC.build();
	if(AC.dfs(1))printf("TAK\n");
	else printf("NIE\n");
	return 0;
}
Problem2960

#include <stdio.h>
#include <set>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e4+5;
struct Point 
{
	int x,y;
	Point(int _x=0,int _y=0):x(_x),y(_y){}
	void read(){scanf("%d%d",&x,&y);}
	int operator *(const Point &s)const
	{
		return x*s.y-y*s.x;
	}
}p[N];
struct E
{
	int x,y;
	double alp;
	E(int _x=0,int _y=0):x(_x),y(_y)
	{
		alp = atan2(p[_y].x-p[_x].x,p[_y].y-p[_x].y);
	}
}e[N];
struct Edge
{
	int x,y,v;
	Edge(int _x=0,int _y=0,int _v=0):x(_x),y(_y),v(_v){}
}ed[N];
int bel[N],cnt,tp=1;
int w[N];
struct Pic_to_Gra
{
	struct cmp
	{
		bool operator()(const int &a,const int &b)
			{return e[a].alp<e[b].alp;}
	};
	set<int,cmp>g[N];
	set<int>::iterator it;
	bool del[N];
	int q[N];
	void Insert(int x,int y){g[x].insert(y);}
	void work()
	{
		int t,j;
		for(int i = 2;i<=tp;i++)
			if(!del[i])
			{
				t = 1;
				q[t] = j = i;
				while(true)
				{
					it = g[e[j].y].find(j^1);
					it++;
					if(it==g[e[j].y].end())it = g[e[j].y].begin();
					if(*it==i)break;
					q[++t] = j = *it;
				}
				int s= 0;
				for(j=1;j<=t;j++)s+=p[e[q[j]].x]*p[e[q[j]].y];
				++cnt;
				for(j=1;j<=t;j++)del[q[j]]=true,bel[q[j]]=cnt;
			}
	}
}p2g;
struct Minimum_Tree_Gragh
{
	int pre[N],id[N],in[N],vis[N];
	int work(int root,int n,int m)
	{
		int tn,tm,ans = 0;
		while(true)
		{
			for(int i = 1;i<= n;i++)in[i]=INF,pre[i]=0;
			for(int i = 1;i<= m;i++)
				if(ed[i].v<in[ed[i].y])
				{
					in[ed[i].y] = ed[i].v;
					pre[ed[i].y] = ed[i].x;
				}
			tn = tm = in[root] = 0;
			for(int i = 1;i<= n;i++)id[i]=vis[i] = 0;
			for(int v,i = 1;i<= n;i++)
			{
				ans+=in[v=i];
				while(vis[v]!=i&&!id[v]&&v!=root)vis[v]=i,v=pre[v];
				if(v!=root&&!id[v])
				{
					id[v] = ++tn;
					for(int u = pre[v];u!=v;u=pre[u])id[u]=tn;
				}
			}
			if(!tn)break;
			for(int i = 1;i<= n;i++)if(!id[i])id[i]=++tn;
			for(int i = 1;i<= m;i++)
				if(id[ed[i].x]!=id[ed[i].y])
					ed[++tm] = Edge(id[ed[i].x],id[ed[i].y],ed[i].v-in[ed[i].y]);
			n = tn,m = tm,root = id[root];
		}
		return ans;
	}
	void solve()
	{
		int n = cnt+1,root = cnt+1,m=0,sum = 0;
		for(int i = 2;i<= tp;i++)
			if(bel[i]&&bel[i^1]&&w[i])
			{
				ed[++m] = Edge(bel[i],bel[i^1],w[i]);
				sum+=w[i];
			}
		for(int i = 1;i<= cnt;i++)ed[++m] = Edge(root,i,sum);
		printf("%d\n",work(root,n,m)-sum);
	}
}mtg;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)p[i].read();
	for(int i = 1;i<= m;i++)
	{
		int u,v;
		scanf("%d%d%d%d",&u,&v,&w[i*2],&w[i*2+1]);
		e[++tp] = E(u,v),p2g.Insert(u,tp);
		e[++tp] = E(v,u),p2g.Insert(v,tp);
	}
	p2g.work();
	mtg.solve();
	return 0;
}
Problem2961

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const double INF = 1e11;
const int N = 5e5+500;
struct Point
{
	double x,y;
	Point(){}
	Point(double _x,double _y):x(_x),y(_y){}
};
struct Qurey
{
	int type,id;
	Point a;
	double k;
	Qurey(){}
	Qurey(int _type,double _x,double _y,int _id):type(_type),id(_id)
	{
		a.x = _x,a.y = _y;
		if(fabs(a.y)<eps)
			k = INF;
		else 
			k = -a.x/a.y;
	}
	bool operator <(const Qurey &s)const
	{
		return k<s.k;
	}
}q[N],nq[N];
double Distance(const Point &a,const Point &b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
double Slope(const Point &a,const Point &b)
{
	if(fabs(a.x-b.x)<eps)
		return INF;
	return (b.y-a.y)/(b.x-a.x);
}
int n,cnt,stk1[N],stk2[N];
bool ap[N];
void solve(int l,int r)
{
	if(l==r)return ;
	int mid = (l+r)>>1;
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
	{
		if(q[i].id<=mid)
			nq[l1++]=q[i];
		else 
			nq[l2++]=q[i];
	}
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	solve(l,mid);
	int top1 = 0,top2 = 0;
	for(int i = l;i<= mid;i++)
	{
		if(q[i].type==1)continue;
		while(top1>1 && Slope(q[stk1[top1-1]].a,q[i].a)+eps>Slope(q[stk1[top1-1]].a,q[stk1[top1]].a))
			top1--;
		stk1[++top1] = i;
		while(top2>1 && Slope(q[stk2[top2-1]].a,q[i].a)<Slope(q[stk2[top2-1]].a,q[stk2[top2]].a)+eps)
			top2--;
		stk2[++top2] = i;
	}
	int j = 1;
	for(int i = mid+1;i<= r;i++)
	{
		if(q[i].type==0)continue;
		if(q[i].a.y<eps)
		{
			while(top1>1&&Slope(q[stk1[top1-1]].a,q[stk1[top1]].a)<q[i].k)
				top1--;
			if(top1>0&&Distance(q[stk1[top1]].a,q[0].a)<Distance(q[stk1[top1]].a,q[i].a))
				ap[q[i].id]=false;
		}else
		{
			while (j<top2 && Slope(q[stk2[j]].a,q[stk2[j+1]].a)<q[i].k)
				j++;
            if (j<=top2 && Distance(q[stk2[j]].a,q[0].a)<Distance(q[stk2[j]].a,q[i].a)) 
            	ap[q[i].id]=false;
		}
	}
	solve(mid+1,r);
	l1 = l,l2 = mid+1;
	for (int i = l;i<= r;i++)
        if (l1<=mid && q[l1].a.x<q[l2].a.x || l2>r)
        	nq[i]=q[l1++]; 
        else nq[i]=q[l2++];
    for (int i=l; i<=r; i++) q[i]=nq[i];
}
bool cmp(const Qurey &a,const Qurey &b)
{
	return a.id<b.id;
}
int main()
{
	int type;
	double x,y;
	scanf("%d",&n);
	bool flag = false;
	q[0].a = Point(0,0);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%lf%lf",&type,&x,&y);
		q[i] = Qurey(type,x,y,i);
		if(!q[i].type)flag = true;
		ap[i]=flag;
	}
	sort(q+1,q+n+1);
	solve(1,n);
	sort(q+1,q+n+1,cmp);
	for(int i = 1;i<= n;i++)
		if(q[i].type)
			puts(ap[i]?"Yes":"No");
	return 0;
}
Problem2962

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int mod = 19940417;
const int nmd = 17091780;
const int N = 50050;
const int INF = 1e9+5;
int fac[N],env[N];
int calc[N][25];
void init()
{
	calc[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		calc[i][0] = 1;
		for(int j = 1;j<= 20;j++)
			calc[i][j] = (calc[i-1][j-1]+calc[i-1][j])%mod;
	}
	return ;
}
int f[N<<2][21],la[N<<2],lf[N<<2];
void push_up(int p,int l,int r)
{
	int len = (r-l+1);
	int end = min(len,20);
	for(int i = 1;i<= end;i++)
	{
		f[p][i] = 0;
		for(int j = 0;j<=i;j++)
			(f[p][i]+=((LL)f[p<<1][j]*f[p<<1|1][i-j])%mod+mod)%=mod;
	}
}
int powx[21];
void push_down(int p,int l,int r)
{
	if(l==r||(lf[p]==0&&la[p]==0))return ;
	int mid = (l+r)>>1;
	if(lf[p])
	{
		for(int i = 1;i<=19;i+=2)
		{
			f[p<<1][i] = (mod-f[p<<1][i])%mod;
			f[p<<1|1][i] = (mod-f[p<<1|1][i])%mod;
		}
		lf[p<<1] = lf[p<<1]^lf[p],lf[p<<1|1] = lf[p<<1|1]^lf[p];
		la[p<<1] = (mod-la[p<<1])%mod,la[p<<1|1] = (mod-la[p<<1|1])%mod;
	}
	if(la[p])
	{
		powx[0] = 1;
		for(int i = 1;i<= 20;i++)
			powx[i] = (LL)powx[i-1]*la[p]%mod;
		for(int i = 20;i>= 1;i--)
			for(int j = 1;j<= i;j++)
			{
				(f[p<<1][i] += (LL)f[p<<1][i-j]*powx[j]%mod*calc[mid-l+1-i+j][j]%mod+mod)%=mod;
				(f[p<<1|1][i] += (LL)f[p<<1|1][i-j]*powx[j]%mod*calc[r-mid-i+j][j]%mod+mod)%=mod;
			}
		la[p<<1] += la[p],la[p<<1|1]+=la[p];
	}
	
	lf[p] = la[p] = 0;
	return ;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		if(c==INF)
		{
			for(int i = 1;i<=19;i+=2)
				f[p][i] = mod-f[p][i];
			lf[p] = lf[p]^1;
		}else
		{
			int end = min(20,(r-l+1));
			powx[0] = 1;
			for(int i = 1;i<= end;i++)
				powx[i] = (LL)powx[i-1]*c%mod;
			for(int i = end;i>= 1;i--)
				for(int j = 1;j<= i;j++)
					(f[p][i] += (LL)f[p][i-j]*powx[j]%mod*calc[r-l+1-i+j][j]%mod+mod)%=mod;
			la[p]+=c;
		}
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,c);
	push_up(p,l,r);
}
struct E
{int t[21];};
E getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		E a;
		a.t[0] =1;
		for(int i = 1;i<= 20;i++)
			a.t[i] = f[p][i];
		return a;
	}
	int mid=(l+r)>>1;
	if(b<=mid)
		return getans(p<<1,l,mid,a,b);
	else if(a>mid)
		return getans(p<<1|1,mid+1,r,a,b);
	else
	{
		E A = getans(p<<1,l,mid,a,mid);
		E B = getans(p<<1|1,mid+1,r,mid+1,b);
		E C;
		int len = (b-a+1);
		int end = min(len,20);
		C.t[0] = 1;
		for(int i = 1;i<= end;i++)
		{
			C.t[i] = 0;
			for(int j = 0;j<=i;j++)
				if(j<=mid-a+1&&i-j<=b-mid)(C.t[i]+=((LL)A.t[j]*B.t[i-j])%mod+mod)%=mod;
		}
		return C;
	}
}
void build(int p,int l,int r)
{
	la[p] = lf[p] = 0;
	f[p][0] =1;
	if(l==r)
	{
		scanf("%d",&f[p][1]);
		f[p][1] = (f[p][1]%mod+mod)%mod;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p,l,r);
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	init();
	build(1,1,n);
	char opt[3];
	int a,b,c;
	for(int i =1;i<= q;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d%d%d",&a,&b,&c);
			update(1,1,n,a,b,c);
		}else if(opt[0]=='R')
		{
			scanf("%d%d",&a,&b);
			update(1,1,n,a,b,INF);
		}else
		{
			scanf("%d%d%d",&a,&b,&c);
			E t = getans(1,1,n,a,b);
			printf("%d\n",t.t[c]%mod);
		}
	}
	return 0;
}
Problem3004

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1200005;
int fa[N],size[N],f[N],ind[N];
int Div[2200],cnt;
void getdiv(int x)
{
	for(int i = 1;i*i<= x;i++)
	{
		if(i*i==x)
			Div[++cnt] = i;
		else if(x%i==0)
			Div[++cnt] = i,Div[++cnt] = x/i;
	}
	return ;
}
queue<int>Q;
int main()
{
	int n;
	scanf("%d",&n);
	getdiv(n);
	sort(Div+1,Div+cnt+1);
	for(int id = 1;id<= 10;id++)
	{
		memset(ind,0,sizeof(ind));
		if(id==1)
			for(int i = 2;i<= n;i++)
			{
				if(i==n)scanf("%d",&fa[i]);
				else scanf("%d,",&fa[i]);
				ind[fa[i]]++;
			}
		else
			for(int i = 2;i<= n;i++)
				{fa[i] = (fa[i]+19940105)%(i-1)+1;ind[fa[i]]++;}
		memset(size,0,sizeof(size));
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
			if(!ind[i])
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			size[x]++;
			ind[fa[x]]--;
			size[fa[x]]+=size[x];
			if(!ind[fa[x]])
				Q.push(fa[x]);
		}
		for(int i = 1;i<= n;i++)
			f[size[i]]++;
		printf("Case #%d:\n",id);
		for(int i = 1;i<= cnt;i++)
		{
			int num = 0;
			for(int j = Div[i];j<=n;j+=Div[i])
				num+=f[j];
			if(num==n/Div[i])
				printf("%d\n",Div[i]);
		}
	}
	return 0;
}
Problem3028

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
char s[1005];
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{	
	int d,n=0;
	scanf("%s",s+1);
	for(int i = 1;s[i];i++)
		n = (n*10+s[i]-'0')%mod;
	int ans = n*(n+1)%mod*(n+2)%mod;
	ans = ans*quick_pow(6,mod-2)%mod;
	printf("%d\n",ans);
	return 0;
}
Problem3029

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 201;
double f[2][N][N<<1];
int w[N];
double p[N];
int main()
{
	int n,l,K;
	scanf("%d%d%d",&n,&l,&K);
	if(K>n)K = n;
	f[0][0][K+200] = 1;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf",&p[i]);
		p[i]/=100.0;
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&w[i]);
	for(int i = 0;i< n;i++)
	{
		int next = (i+1)&1,now = i&1;
		for(int j = 0;j<=i;j++)
			for(int k = -i;k<= n;k++)
			{
				f[next][j][k+200] += (1.0-p[i+1])*f[now][j][k+200];
				int tmp = k+w[i+1];
				if(tmp>n)tmp = n;
				f[next][j+1][tmp+200] += p[i+1]*f[now][j][k+200];
			}
		memset(f[now],0,sizeof(f[now]));
	}
	double ans = 0;
	for (int i=0;i<=n;i++) 
	  for (int j=l;j<=n;j++) 
	    ans+=f[n&1][j][i+200];
	printf("%.6f\n",ans);
	return 0;
}
Problem3037

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,a[N],edge;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool v[N];
int p;
void dfs(int x)
{
	v[x] = true;
	if(v[a[x]]){p = x;return ;}
	dfs(a[x]);
}
int g[N],f[N];
void dp(int x,int fa)
{
	f[x] = 1,g[x] = INF,v[x] = true;
	if(x==edge)g[x]= 0;
	for(int i = head[x];i;i= e[i].next)
	{
		if(e[i].to!=fa&&e[i].to!=p)
		{
			dp(e[i].to,x);
			g[x] += min(g[e[i].to],f[e[i].to]);
			g[x] = min(g[x],f[x]+f[e[i].to]-1);
			f[x] += min(g[e[i].to],f[e[i].to]); 
		}
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		add(a[i],i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
	{
		if(v[i])continue;
		dfs(i);
		edge = a[p];
		dp(p,0);int tmp = f[p];
		edge = 0;
		dp(p,0);
		ans+=min(tmp,g[p]);
	}
	printf("%d\n",n-ans);
	return 0;
}
Problem3038

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long LL;
LL sum[N<<2];
LL a[N];
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void update(int p,int l,int r,int x,LL c)
{
	if(l==r)
		{sum[p] = c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,c);
	else update(p<<1|1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
LL getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans = ans+getans(p<<1,l,mid,a,b);
	if(b>mid)ans = ans+getans(p<<1|1,mid+1,r,a,b);
	return ans;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = a[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	build(1,1,n);
	for(int i = 1;i<= n;i++)
	{
		if(a[i]>1)fa[i] = i;
		else fa[i] = i+1;
	}
	fa[n+1] = n+1;
	int x,y,opt;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt,&x,&y);
		if(x>y)swap(x,y);
		if(opt==0)
		{
			for(int t = getfa(x);t<= y;t= getfa(t))
			{
				a[t] = sqrt(a[t]);
				update(1,1,n,t,a[t]);
				if(a[t]<=1)
					fa[t] = t+1;
				t = t+1;
			}
		}else
			printf("%lld\n",getans(1,1,n,x,y));
	}
	return 0;
}
Problem3039

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
bool map[N][N];
int l[N][N],r[N][N],h[N][N];
char s[3];
int ans = 0,n,m;
void work()
{
	for(int i = 1;i<= n;i++)
	{
		int t = 1;
		for(int j = 1;j<= m;j++)
			if(map[i][j])l[i][j] = t;
			else l[i][j] = 1,t = j+1;
		t = m;
		for(int j = m;j>=1;j--)
			if(map[i][j])r[i][j] = t;
			else r[i][j] = m,t = j-1;
	}
	for(int j = 1;j<= m;j++)l[0][j] = 1,r[0][j] = m;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(map[i][j])
			{
				h[i][j] = h[i-1][j]+1;
				l[i][j] = max(l[i-1][j],l[i][j]);
				r[i][j] = min(r[i-1][j],r[i][j]);
				ans = max(ans,(r[i][j]-l[i][j]+1)*h[i][j]);
			}
	printf("%d\n",ans*3);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<=m;j++)
		{
			scanf("%s",s);
			map[i][j] = s[0]=='F';
		}
	}
	work();
	return 0;
}
Problem3053

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int INF = 1e9+1;
typedef double db;
int n,k,t,m,root;
struct P
{
	int mx[6],mn[6],d[6],l,r;
	int& operator[](int x){return d[x];}
	void clear()
	{
		for(int i = 0;i<6;i++)
			mx[i] = mn[i] = d[i] = 0;
	}
}p[N];
struct data
{int no,dis;}ans[15];
int top;
bool cmp(const data &a,const data &b)
{
	return a.dis<b.dis;
}
int D;
bool operator<(P a,P b)
{
	return a[D]<b[D];
}
inline int getdis(P a,P b)
{
	int ans = 0;
	for(int i = 0;i< k;i++)
		ans+=(a[i]-b[i])*(a[i]-b[i]);
	return ans;
}
struct KD_tree
{
	P t[N],T;
	int cnt;
	void clear()
	{
		for(int i = 0;i<N;i++)
			t[i].clear();
		T.clear();
		cnt = 0;
	}
	void update(int o)
	{
		P l = t[t[o].l],r = t[t[o].r];
		for(int i = 0;i< k;i++)
		{
			if(t[o].l)t[o].mn[i] = min(t[o].mn[i],l.mn[i]),t[o].mx[i] = max(t[o].mx[i],l.mx[i]);
			if(t[o].r)t[o].mn[i] = min(t[o].mn[i],r.mn[i]),t[o].mx[i] = max(t[o].mx[i],r.mx[i]);
		}
		return ;
	}
	int build(int l,int r,int now)
	{
		D = now;
		int mid = (l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid] = p[mid];
		for(int i = 0;i<k;i++)
			t[mid].mn[i]=t[mid].mx[i] = t[mid][i];
		if(l<mid)t[mid].l = build(l,mid-1,(now+1)%k);
		if(r>mid)t[mid].r = build(mid+1,r,(now+1)%k);
		update(mid);
		return mid;
	}
	int getmindis(int o,P p)
	{
		int ans = 0;
		for(int i = 0;i<k;i++)
		{
			if(p[i]<t[o].mn[i])
				ans+=(t[o].mn[i]-p[i])*(t[o].mn[i]-p[i]);
			if(p[i]>t[o].mx[i])
				ans+=(p[i]-t[o].mx[i])*(p[i]-t[o].mx[i]);
		}
		return ans;
	}
	void query(int o,int now)
	{
		int d,dl = INF,dr = INF;
		d = getdis(t[o],T);
		if(d<ans[1].dis)
		{
			pop_heap(ans+1,ans+top+1,cmp);
			ans[top] = (data){o,d};
			push_heap(ans+1,ans+top+1,cmp);
		}
		if(t[o].l)dl = getmindis(t[o].l,T);
		if(t[o].r)dr = getmindis(t[o].r,T);
		if(dl<dr)
		{
			if(dl<ans[1].dis)query(t[o].l,(now+1)%k);
			if(dr<ans[1].dis)query(t[o].r,(now+1)%k);
		}else
		{
			if(dr<ans[1].dis)query(t[o].r,(now+1)%k);
			if(dl<ans[1].dis)query(t[o].l,(now+1)%k);
		}
	}
	void getans(P p,int num)
	{
		for(int i = 1;i<= num;i++)
			ans[i] = (data){0,INF};
		top = num;
		T = p;
		query(root,0);
	}
}KD;
void init()
{
	KD.clear();
	top = t = 0;
	memset(ans,0,sizeof(ans));
}
void work()
{
	int x;
	init();
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<k;j++)
		{
			scanf("%d",&x);
			p[i][j] = x;
		}
	root = KD.build(1,n,0);
	P tmp;
	scanf("%d",&t);
	for(int i =1;i<= t;i++)
	{
		for(int j = 0;j<k;j++)
		{
			scanf("%d",&x);
			tmp[j] = x;
		}
		scanf("%d",&m);
		KD.getans(tmp,m);
		printf("the closest %d points are:\n",m);
		sort(ans+1,ans+m+1,cmp);
		for(int j = 1;j<=m;j++)
		{
			for(int tt = 0;tt<k-1;tt++)
				printf("%d ",p[ans[j].no][tt]);
			printf("%d\n",p[ans[j].no][k-1]);
			//printf("%d ",ans[1].no);
			//pop_heap(ans+1,ans+top+1,cmp);
			//top--;
		}
	}
}
int main()
{
	while(scanf("%d%d",&n,&k)!=EOF)
		work();
	return 0;
}
Problem3053

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e9+1;
int n,k,D,root;
struct Point
{
	int mx[6],mn[6],d[6],l,r;
	int& operator[](int x){return d[x];}
	void clear()
	{
		for(int i = 0;i<6;i++)
			mx[i]=mn[i]=d[i]=0;
	}
}p[N];
bool operator <(Point a,Point b)
{
	return a[D]<b[D];
}
int getdis(Point a,Point b)
{
	int ans = 0;
	for(int i = 0;i<k;i++)
		ans = ans+(a[i]-b[i])*(a[i]-b[i]);
	return ans;
}
int top;
struct Heap
{
	int o,dis;
	Heap(int _o=0,int _dis=INF):o(_o),dis(_dis){}
	bool operator <(const Heap &s)const
	{
		return dis<s.dis;
	}
}ans[15];
struct KD_tree
{
	Point t[N],target;
	int cnt;
	void clear()
	{
		for(int i = 0;i<N;i++)
			t[i].clear();
		target.clear();
		cnt = 0;
	}
	void Push_up(int p)
	{
		Point l = t[t[p].l],r = t[t[p].r];
		for(int i = 0;i<k;i++)
		{
			if(t[p].l)t[p].mx[i]=max(t[p].mx[i],l.mx[i]),t[p].mn[i]=min(t[p].mn[i],l.mn[i]);
			if(t[p].r)t[p].mx[i]=max(t[p].mx[i],r.mx[i]),t[p].mn[i]=min(t[p].mn[i],r.mn[i]);
		}
	}
	int getmindis(int x,Point p)
	{
		int ans = 0;
		for(int i = 0;i<k;i++)
		{
			if(p[i]>t[x].mx[i])
				ans = ans+(p[i]-t[x].mx[i])*(p[i]-t[x].mx[i]);
			if(p[i]<t[x].mn[i])
				ans = ans+(t[x].mn[i]-p[i])*(t[x].mn[i]-p[i]);
		}
		return ans;
	}
	int build(int l,int r,int now)
	{
		D = now;
		int mid = (l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid] = p[mid];
		for(int i = 0;i<k;i++)
			t[mid].mx[i]=t[mid].mn[i]=t[mid][i];
		if(l<mid)t[mid].l = build(l,mid-1,(now+1)%k);
		if(r>mid)t[mid].r = build(mid+1,r,(now+1)%k);
		Push_up(mid);
		return mid;
	}
	void getans(int o)
	{
		int d,dl = INF,dr = INF;
		d = getdis(target,t[o]);
		if(d<ans[1].dis)
		{
			pop_heap(ans+1,ans+top+1);
			ans[top] = Heap(o,d);
			push_heap(ans+1,ans+top+1);
		}
		if(t[o].l)dl = getmindis(t[o].l,target);
		if(t[o].r)dr = getmindis(t[o].r,target);
		if(dl<dr)
		{
			if(dl<ans[1].dis)getans(t[o].l);
			if(dr<ans[1].dis)getans(t[o].r);
		}else
		{
			if(dr<ans[1].dis)getans(t[o].r);
			if(dl<ans[1].dis)getans(t[o].l);
		}
	}
	void Getans(const Point &o,int num)
	{
		for(int i = 1;i<=num;i++)
			ans[i] = Heap(0,INF);
		top = num;
		target = o;
		getans(root);
	}
}kd;
void init()
{
	kd.clear();
	top = 0;
	for(int i = 0;i<15;i++)
		ans[i]=Heap(0,INF);
}
void work()
{
	init();
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<k;j++)
			scanf("%d",&p[i].d[j]);
	root = kd.build(1,n,0);
	int m,num;Point t;
	scanf("%d",&m);
	while(m--)
	{
		for(int i = 0;i<k;i++)
			scanf("%d",&t.d[i]);
		scanf("%d",&num);
		kd.Getans(t,num);
		printf("the closest %d points are:\n",num);
		sort(ans+1,ans+num+1);
		for(int j = 1;j<=num;j++)
		{
			for(int tt = 0;tt<k-1;tt++)
				printf("%d ",p[ans[j].o][tt]);
			printf("%d\n",p[ans[j].o][k-1]);
		}
	}
}
int main()
{
	while(scanf("%d%d",&n,&k)!=EOF)
		work();
	return 0;
}
Problem3060

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2e6+5;
const int N = 1e6+5;
int fa[N],rnk[N];
int a[M],b[M];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(rnk[x]>rnk[y])
		fa[y] = x;
	else
	{
		fa[x] = y;
		rnk[y]+=rnk[x]==rnk[y];
	}
}
int main()
{
	int n,m,k,x,y,cnt = 0;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		if(x<=k||y<=k)
		{
			a[++cnt] = x;
			b[cnt] = y;
		}else uni(x,y);
	}
	int ans = 0;
	for(int i = 1;i<= cnt;i++)
	{
		int fx = getfa(a[i]),fy = getfa(b[i]);
		if(fx==fy)ans++;
		else uni(a[i],b[i]);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3065

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double beta = 0.75;
const int N = 7e4;
const int M = 1e7+5;
struct seg
{int l,r,sum;}a[M];
vector<int>rec,T,P;
int root[140005],ls[140005],rs[140005],v[140005],dfn[140005];
int n,m,size,lastans,tmp,Root;
int newnode()
{
	if(!rec.size())return ++size;
	else
	{
		int k = rec.back();rec.pop_back();
		return k;
	}
}
void Free(int &x)
{
	if(!x)return ;
	rec.push_back(x);
	Free(a[x].l),Free(a[x].r);
	a[x].sum =0;x = 0;
}
void Insert(int &p,int l,int r,int pos,int num)
{
	if(!p)p = newnode();
	if(l==r){a[p].sum+=num;return ;}
	int mid=(l+r)>>1;
	if(pos<=mid)Insert(a[p].l,l,mid,pos,num);
	else Insert(a[p].r,mid+1,r,pos,num);
	a[p].sum = a[a[p].l].sum+a[a[p].r].sum;
	if(!a[p].sum)Free(p);
}
void build(int &p,int l,int r)
{
	if(l>r)return ;
	if(l==r)
	{
		p = dfn[l];
		Insert(root[p],0,N,v[p],1);
		return ;
	}
	int mid=(l+r)>>1;
	p = dfn[mid];
	build(ls[p],l,mid-1);build(rs[p],mid+1,r);
	for(int i = l;i<=r;i++)
		Insert(root[p],0,N,v[dfn[i]],1);
}
void del(int &x)
{
	if(!x)return ;
	Free(root[x]);
	del(ls[x]);P.push_back(x);del(rs[x]);
	x = 0;
}
void rebuild(int &x)
{
	del(x);
	int s1 = P.size();
	for(int i = 1;i<= s1;i++)dfn[i] = P[i-1];
	build(x,1,s1);
	P.clear();
}
int update(int p,int x,int val)
{
	Insert(root[p],0,N,val,1);
	int t,lsize = a[root[ls[p]]].sum;
	if(x==lsize+1){t=v[p];v[p] = val;}
	else if(lsize>=x)t=update(ls[p],x,val);
	else t=update(rs[p],x-lsize-1,val);
	Insert(root[p],0,N,t,-1);
	return t;
}
void getans(int p,int l,int r)
{
	int L = a[root[ls[p]]].sum,R = a[root[p]].sum;
	if(l==1&&R==r){T.push_back(root[p]);return ;}
	if(l<=L+1&&r>=L+1)P.push_back(v[p]);
	if(r<=L)getans(ls[p],l,r);
	else if(l>L+1)getans(rs[p],l-L-1,r-L-1);
	else
	{
		if(l<=L)getans(ls[p],l,L);
        if(R>L+1)getans(rs[p],1,r-L-1);
	}
}
int Getans(int L,int R,int K)
{
	getans(Root,L,R);
	K--;
	int l = 0,r = N;
	int s1=T.size(),s2 = P.size();
	while(l<r)
	{
		int mid = (l+r)>>1,sum=0;
		for(int i = 0;i<s1;i++)sum+=a[a[T[i]].l].sum;
		for(int i = 0;i<s2;i++)
			if(P[i]>=l&&P[i]<=mid)
				sum++;
		if(K<sum)
		{
			for(int i = 0;i<s1;i++)T[i]=a[T[i]].l;
			r=mid;
		}else
		{
			for(int i = 0;i<s1;i++)T[i]=a[T[i]].r;
			l = mid+1;K-=sum;
		}
	}
	T.clear();P.clear();
	return l;
}
void Insert(int &p,int x,int val)
{
	if(!p)
	{
		p=++n;
		Insert(root[p],0,N,val,1);
		v[p] =val;
		return ;
	}
	Insert(root[p],0,N,val,1);
	int lsize = a[root[ls[p]]].sum;
	if(x<=lsize)Insert(ls[p],x,val);
	else Insert(rs[p],x-lsize-1,val);
	if(a[root[p]].sum*beta>max(a[root[ls[p]]].sum,a[root[rs[p]]].sum))
	{
		if(tmp)
		{
			if(ls[p]==tmp)rebuild(ls[p]);
			else rebuild(rs[p]);
			tmp = 0;
		}
	}else tmp = p;  
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&v[i]);
	for(int i = 1;i<= n;i++)dfn[i] = i;
	build(Root,1,n);
	scanf("%d",&m);
	int x,y,K;char opt[3];
	while(m--)
	{
		scanf("%s%d%d",opt,&x,&y);
		x = x^lastans,y = y^lastans;
		switch(opt[0])
		{
			case 'Q':scanf("%d",&K);K = K^lastans;lastans = Getans(x,y,K);printf("%d\n",lastans);break;
			case 'M':update(Root,x,y);break;
			case 'I':tmp = 0;Insert(Root,x-1,y);if(tmp){tmp = 0;rebuild(Root);}break;
		}
		//printf("%d %d ",x,y);
		//if(opt[0]=='Q')printf("%d\n",K);
		//else printf("\n");
	}
	return 0;
}
Problem3083

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E{int next,to;}e[N<<1];
int head[N],tot,n,m,logx[N],root;
long long f[N<<2];
long long minn[N<<2];
long long INF;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int deep[N],top[N],fa[N],son[N],w[N],size[N],end[N],cnt;
int anc[18][N];
bool v[N];
void init()
{
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<=n;i++)
			anc[j][i] = anc[j-1][anc[j-1][i]];
}
void dfs1(int x,int dep)
{
	deep[x] = dep;
	v[x] = true;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	end[x] = cnt;
}
void push_down(int p)
{
	f[p<<1] = f[p];
	f[(p<<1)+1] = f[p];
	minn[p<<1] = f[p];
	minn[(p<<1)+1] = f[p];
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b,long long c)
{
	if(l>=a&&r<=b)
		{f[p] = c;minn[p] = c;return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update((p<<1)+1,mid+1,r,a,b,c);
	minn[p] = min(minn[p<<1],minn[(p<<1)+1]);
	return ;
}
long long getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return minn[p];
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	long long ans = INF;
	if(a<=mid)
		ans = min(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)
		ans = min(ans,getans((p<<1)+1,mid+1,r,a,b));
	return ans;
}
void get_update(int x,int y,long long c)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		update(1,1,n,w[top[x]],w[x],c);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	update(1,1,n,w[y],w[x],c);
}
long long Ask(int x)
{
	if(w[root]<w[x]||w[root]>end[x])
		return getans(1,1,n,w[x],end[x]);
	else if(root==x)
		return minn[1];
	else
	{
		int tmp = root;
		for(int j = 17;j>=0;j--)
			if(deep[fa[anc[j][tmp]]]>=deep[x])
				tmp = anc[j][tmp];
		long long ans = INF;
		ans = min(ans,getans(1,1,n,1,w[tmp]-1));
		ans = min(ans,getans(1,1,n,end[tmp]+1,n));
		return ans;
	}
}
int main()
{
	memset(minn,0x3f,sizeof(minn));
	INF = minn[0];
	int x,y;long long z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	long long tmp;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&tmp);
		update(1,1,n,w[i],w[i],tmp);
		anc[0][i]= fa[i];
	}
	init();
	scanf("%d",&root);
	int opt;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1){scanf("%d",&x);root = x;}
		else if(opt==2){scanf("%d%d%lld",&x,&y,&z);get_update(x,y,z);}
		else {scanf("%d",&x);printf("%lld\n",Ask(x));}
	}
	return 0;
}
Problem3100

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+2;
ll a[N];
int last[N];
int i,n,ans,mx,wz;
void calc()
{
	int j,l;
	ans = max(ans,1);
	mx = 1;
	l = last[a[i]-a[i-1]];
	last[a[i]-a[i-1]] = i;
	wz = l+1;
	for(j = i+1;j<= n+1;j++)
	{
		if(j>n||a[j]-a[j-1]==1)break;
		l = last[a[j]-a[j-1]];
		last[a[j]-a[j-1]] = j;
		wz = max(wz,l);
		mx = max(mx,int(a[j]-a[j-1]));
		if(wz<=j-mx+1)
			if(a[j]-a[j-mx]==(ll)mx*(mx+1)/2)
				ans = max(ans,mx);
	}
	i = j;
}
int main()
{
	scanf("%d",&n);
	for(i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	for(i = 1;i<= n;i++)a[i]+=a[i-1];
	for(i = 1;i<= n;i++)
	{
		if(a[i]-a[i-1]==1)break;
		last[a[i]-a[i-1]]=i;
	}
	while(i<=n)calc();
	for(i = n;i>= 1;i--)a[i]-=a[i-1];
	for(i = 1;i<= n/2;i++)swap(a[i],a[n-i+1]);
	for(i = 1;i<= n;i++)a[i]+=a[i-1];
	for(i = 1;i<= n;i++)last[i]=0;
	for(i = 1;i<= n;i++)
	{
		if(a[i]-a[i-1]==1)break;
		last[a[i]-a[i-1]]=i;
	}
	while(i<=n)calc();
	printf("%d\n",ans);	
	return 0;
}
Problem3110

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
typedef long long ll;
using namespace std;
const int N = 5e4+5;
const int M = 2e7+5;
int root[N<<2];
int ls[M],rs[M],lazy[M];
ll sum[M];
int tot,n,m;
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	if(!ls[p])ls[p] = ++tot;
	if(!rs[p])rs[p] = ++tot;
	lazy[ls[p]]+=lazy[p];
	lazy[rs[p]]+=lazy[p];
	int mid = (l+r)>>1;
	sum[ls[p]]+=(mid-l+1)*lazy[p];
	sum[rs[p]]+=(r-mid)*lazy[p];
	lazy[p] = 0;
}
void update(int &p,int l,int r,int a,int b)
{
	if(!p)p = ++tot;
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sum[p]+=r-l+1;
		lazy[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(ls[p],l,mid,a,b);
	if(b >mid)update(rs[p],mid+1,r,a,b);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
ll getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	push_down(p,l,r);
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1;ll ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
void insert(int a,int b,int c)
{
	int l = 1,r = n,p = 1;
	while(l!=r)
	{
		int mid=(l+r)>>1;
		update(root[p],1,n,a,b);
		if(c<=mid)r = mid,p = p<<1;
		else l = mid+1,p = p<<1|1;
	}
	update(root[p],1,n,a,b);
}
int solve(int a,int b,ll c)
{
	int l = 1,r = n,p = 1;
	while(l!=r)
	{
		int mid = (l+r)>>1;
		ll tmp = getans(root[p<<1],1,n,a,b);
		if(tmp>=c)r = mid,p = p<<1;
		else l = mid+1,p = p<<1|1,c-=tmp;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	int opt,a,b,c;
	for(int i= 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&opt,&a,&b,&c);
		if(opt==1)
			insert(a,b,n-c+1);
		else
			printf("%d\n",n-solve(a,b,c)+1);
	}
	return 0;
}
Problem3122

#include <stdio.h>
#include <map>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll x,y;
ll ex_gcd(ll a,ll b)
{
	if(b==0)
	{
		x = 1,y = 0;
		return a;
	}
	ll ans = ex_gcd(b,a%b);
	ll c = x;
	x = y;
	y = c-a/b*y;
	return ans;
}
ll getenv(ll X,ll c)
{
	ex_gcd(X,c);
	ll tmp = x;
	tmp = (tmp%c+c)%c;
	return tmp;
}
map<int,int>Pow;
int powA[100005];
ll A,B,C;
ll work()
{
	Pow.clear();
	//scanf("%lld%lld%lld",&A,&C,&B);
	if(A%C==0&&B!=0)return -1;
	ll D = 1;
	ll tmp = 1;
	for(int i = 0;i<=50;i++)
	{
		if((tmp%=C)==B)return i;
		tmp = tmp*A%C;
	}
	ll k = 0,gcd = ex_gcd(A,C);
	while(gcd!=1)
	{
		k++;
		if(B%gcd!=0)return -1;
		B/=gcd,C/=gcd,D*=A/gcd;
		D%=C;
		gcd = ex_gcd(A,C);
	}
	B*=getenv(D,C),B%=C;
	int m = ceil(sqrt(C)+1e-5);
	powA[0] = 1;Pow[1] = 0;
	for(int i = 1;i<= m;i++)
	{
		powA[i] = powA[i-1]*A%C;
		if(powA[i]==B)return i+k;
		Pow[powA[i]] = i;
	}
	D = 1;
	for(int i = 0;i<= m;i++)
	{
		ex_gcd(D,C);
		x = (x*B%C+C)%C;
		if(Pow.find(x)!=Pow.end())
			return (ll)i*m+k+Pow[x];
		D=D*powA[m]%C;
	}
	return -1;
}
ll solve()
{
	ll p,a,b,x1,t,tmp;
	scanf("%lld%lld%lld%lld%lld",&p,&a,&b,&x1,&t);
	if(x1==t)return 1;
	if(!a)return b==t?2:-1;
	if(a==1)
	{
		t+=p-x1,t%=p;
		tmp = ex_gcd(b,p);
		if(t%tmp)return -1;
		b/=tmp,p/=tmp,t/=tmp;
		ex_gcd(b,p);
		tmp = (x*t%p+p)%p;
		return tmp+1;
	}
	ll Y = (a*x1-x1+b)%p;
	ll Z = (a*t-t+b)%p;
	tmp = ex_gcd(Y,p);
	if(Z%tmp)return -1;
	Z/=tmp,Y/=tmp,p/=tmp;
	C = p;
	B = Z*getenv(Y,C)%p;
	A = a;
	tmp = work();
	if(tmp==-1)return -1;
	else return tmp+1;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		printf("%lld\n",solve());
	return 0;
}
Problem3123

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
const int M = 32*17*N;
struct E
{int next,to;}e[N<<2];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int fa[N][18];
int sz[M],ls[M],rs[M],root[N];
int q[N],a[N],T[N],F[N],dep[N],size[N];
int cnt;
void update(int &p,int pre,int l,int r,int x)
{
	p = ++cnt;
	ls[p] = ls[pre],rs[p] = rs[pre];
	sz[p] = sz[pre]+1;
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(x<=mid)
		update(ls[p],ls[pre],l,mid,x);
	else update(rs[p],rs[pre],mid+1,r,x);
}
int getans(int l,int r,int k,int x,int y,int u,int v)
{
	if(l==r)return T[l];
	int mid = (l+r)>>1;
	if(sz[ls[x]]+sz[ls[y]]-sz[ls[u]]-sz[ls[v]]>=k)
		return getans(l,mid,k,ls[x],ls[y],ls[u],ls[v]);
	else return getans(mid+1,r,k-(sz[ls[x]]+sz[ls[y]]-sz[ls[u]]-sz[ls[v]]),rs[x],rs[y],rs[u],rs[v]);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void init(int x)
{
	for(int j = 1;j<= 17;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
}
int top;
void DFS(int x)
{
    int l = 1, r = 0;
    q[++r] = x;
    while(l<=r)
    {
        int tt = q[l++]; 
        init(tt);
        update(root[tt],root[fa[tt][0]],1,top,a[tt]);
        for(int i=head[tt];i;i=e[i].next)
            if(e[i].to!=fa[tt][0])
            {
                fa[e[i].to][0] = tt;
                dep[e[i].to] = dep[tt]  + 1;
                q[++r] = e[i].to;
            }
    }
}
int find(int x)
{
	if(F[x]==x||!F[x])return F[x] = x;
	else return F[x] = find(F[x]);
}
int main()
{
	int p;
	scanf("%d",&p);
	int n,m,t;
	scanf("%d%d%d",&n,&m,&t);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		T[i] = a[i];
	}
	sort(T+1,T+n+1);
	for(int i = 1;i<= n;i++)
		if(T[i]!=T[i-1])
			T[++top] = T[i];
	for(int i = 1;i<= n;i++)
		a[i] = lower_bound(T+1,T+top+1,a[i])-T;
	for(int i = 1;i<= n;i++)size[i] = 1;
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		int fx = find(x),fy = find(y);
		if(fx==fy)continue;
		if(size[fx]<size[fy])swap(fx,fy);
		size[fx]+=size[fy];
		F[fy] = fx;
	}
	for(int i = 1;i<= n;i++)
		if(!root[i])
		{
			dep[i] = 1;
			DFS(i);
		}
	char opt[3];
	int ans=0;
	for(int i = 1;i<= t;i++)
	{
		scanf("%s%d%d",opt,&x,&y);
		x = x^ans,y = y^ans;
		if(opt[0]=='L')
		{
			add(x,y);
			int fx = find(x),fy = find(y);
			if(size[fx]<size[fy])
				swap(fx,fy),swap(x,y);
			F[fy] = fx;size[fx]+=size[fy];
			fa[y][0] = x;dep[y] = dep[x]+1;
			DFS(y);
		}else
		{
			scanf("%d",&z);z = z^ans;
			int u = getlca(x,y);int v = fa[u][0];
			printf("%d\n",ans = getans(1,top,z,root[x],root[y],root[u],root[v]));
		}
	}
	return 0;
}
Problem3132

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2049;
struct T
{
	int a[N][N];
	T()
	{memset(a,0,sizeof(a));}
	void update(int x,int y,int c)
	{
		for(int i = x;i<N;i+=i&(-i))
			for(int j = y;j<N;j+=j&(-j))
				a[i][j]+=c;
	}
	int getans(int x,int y)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			for(int j = y;j>0;j-=j&(-j))
				ans+=a[i][j];
		return ans;
	}
}A,B,C,D;
void update(int x1,int x2,int y1,int y2,int d)
{
	A.update(x1,y1,d),A.update(x2+1,y1,-d);
	A.update(x1,y2+1,-d),A.update(x2+1,y2+1,d);

	B.update(x1,y1,d*x1),B.update(x2+1,y1,-d*(x2+1));
	B.update(x1,y2+1,-d*x1),B.update(x2+1,y2+1,d*(x2+1));

	C.update(x1,y1,d*y1),C.update(x2+1,y1,-d*y1);
	C.update(x1,y2+1,-d*(y2+1)),C.update(x2+1,y2+1,d*(y2+1));

	D.update(x1,y1,d*x1*y1),D.update(x2+1,y1,-d*(x2+1)*y1);
	D.update(x1,y2+1,-d*x1*(y2+1)),D.update(x2+1,y2+1,d*(x2+1)*(y2+1));
}
int getb(int x,int y)
{
	return (x+1)*(y+1)*A.getans(x,y)-(x+1)*C.getans(x,y)-(y+1)*B.getans(x,y)+D.getans(x,y);
}
int main()
{
	int n,m,a,b,c,d,z;
	char ju[3];
	scanf("%s",ju);
	scanf("%d%d",&n,&m);
	while(scanf("%s",ju)!=EOF)
	{
		if(ju[0]=='k')
		{
			scanf("%d%d%d%d",&a,&b,&c,&d);
			int ans = 0;
			ans += getb(c,d)-getb(a-1,d)-getb(c,b-1)+getb(a-1,b-1);
			printf("%d\n",ans);
		}
		else
		{
			scanf("%d%d%d%d%d",&a,&b,&c,&d,&z);
			update(a,c,b,d,z);
		}
	}
	return 0;
}
Problem3143

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 505;
const double eps = 1e-8;
struct E
{int next,to;}e[N*N];
int head[N],tot,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double f[N][N],cnt[N];
double Ans[N*N],ans[N];
void work()
{
	for(int i = 1;i< n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(xn,i);
		for(int line = i+1;line<= n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = 1;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n-1;i>= 1;i--)
	{
		for(int j = i+1;j<= n;j++)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
		cnt[u]+=1.0;cnt[v]+=1.0;
	}
	for(int i = 1;i< n;i++)
	{
		for(int j = head[i];j;j = e[j].next)
			f[i][e[j].to] += 1.0/cnt[e[j].to];
		f[i][i]-=1.0;
	}
	f[1][n+1]-=1.0;
	work();
	int tmp = 0;
	for(int i = 1;i< n;i++)
	{
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to>i)
				Ans[++tmp] = ans[i]/cnt[i]+ans[e[j].to]/cnt[e[j].to];
	}
	sort(Ans+1,Ans+tmp+1);
	double t_ans = 0;
	for(int i = 1;i<= tmp;i++)
		t_ans+=Ans[i]*(m-i+1);
	printf("%.3f\n",t_ans);
	return 0;
}
Problem3155

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long LL;
LL sum[N<<2],lazy[N<<2];
LL pre[N],a[N];
void build(int p,int l,int r)
{
	if(l==r){sum[p] = pre[l];return ;}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
void push_down(int p,int l,int r)
{
	if(l==r){lazy[p] = 0;return ;}
	int mid = (l+r)>>1;
	lazy[p<<1] += lazy[p];
	lazy[p<<1|1] +=lazy[p];
	sum[p<<1] += lazy[p]*(mid+1-l);
	sum[p<<1|1]+=lazy[p]*(r-mid);
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,LL dec)
{
	if(lazy[p])push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=dec;
		sum[p] = sum[p]+dec*(r-l+1);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,dec);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,dec);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
LL get_ans(int p,int l,int r,int a,int b)
{
	if(lazy[p])push_down(p,l,r);
	if(l>=a&&r<=b)
		return sum[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans+=get_ans(p<<1,l,mid,a,b);
	if(b>mid)ans+=get_ans(p<<1|1,mid+1,r,a,b);
	//sum[p] = sum[p<<1]+sum[p<<1|1];
	return ans;
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&a[i]);
		pre[i] = pre[i-1]+a[i];
	}
	build(1,1,n);
	char ju[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",ju);
		if(ju[0]=='M')
		{
			scanf("%d%d",&x,&y);
			LL dec = y-a[x];
			update(1,1,n,x,n,dec);
			a[x] = y;
		}else
		{
			scanf("%d",&x);
			printf("%lld\n",get_ans(1,1,n,1,x));
		}
	}
	return 0;
}
Problem3156

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
int a[N],line[N],l,r;
LL f[N];
double calc(int j,int k)
{
	return ((double)(f[j]-f[k])*2+(double)j*(j+1)-(double)k*(k+1))/(double)(j-k);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		while(l<r&&calc(line[l+1],line[l])<2*i)l++;
		if(l<=r)f[i] = f[line[l]]+(LL)(i-line[l]-1)*(i-line[l])/2+a[i];
		while(l<r&&calc(line[r],line[r-1])>calc(i,line[r]))r--;
		line[++r] = i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem3160

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 8e5+5;
typedef double db;
typedef long long ll;
const int mod = 1e9+7;
const db PI = 3.14159265358979323;
char s[N];
struct cp
{
	db x,y;
	friend cp operator+(const cp &a,const cp &b)
	{
		return (cp){a.x+b.x,a.y+b.y};
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return (cp){a.x-b.x,a.y-b.y};
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return (cp){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};
	}
}a[M],b[M],c[M];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i= 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn = (cp){cos(2*PI*type/i),sin(2*PI*type/i)};
		for(int j = 0;j<len;j+=i)
		{
			cp w = (cp){1,0},tmp;
			for(int k = 0;k<(i>>1);k++,w = w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[M];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i] = a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)
		ans[i] += (int)(c[i].x+0.1);
}
int pow2[N<<1];
void init()
{
	pow2[0] = 1;
	for(int i = 1;i<N*2;i++)
		pow2[i] = pow2[i-1]*2%mod;
}
char tt[N<<1];int p[N<<1],no[N<<1];
ll tot,Ans;
void manacher(int n)
{
	int lth = 0;
	int maxp = 1,id = 1;
	for(int i = 0;i<n;i++)
	{
		tt[++lth] = s[i];
		no[lth] = i+1;
		if(i!=n-1)tt[++lth]='^';
	}
	for(int i = 1;i<= lth;i++)
	{
		if(maxp>i)p[i] = min(p[id*2-i],maxp-i);
		else p[i] = 0;
		while(i+p[i]<=lth&&i-p[i]>=1&&tt[i+p[i]]==tt[i-p[i]])p[i]++;
		p[i]--;
		if(i+p[i]>maxp)maxp = i+p[i],id = i;
		tot+=(no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1])-(no[i]?no[i]:no[i+1])+1;
	}
}
int main()
{
	init();
	scanf("%s",s);
	int n = strlen(s);
	for(int i = 0;i<n;i++)
	{
		a[i].x = (s[i]=='b')?0:1;
		b[i].x = a[i].x;
		a[i].y = b[i].y = 0;
	}
	int len = 1,m= 2*n;
	while(len<=m)len = len<<1;
	len = len<<1;
	conv(a,b,c,len);
	//for(int i = 0;i<len;i++)
	//	printf("%d ",ans[i]);
	//printf("\n");
	for(int i = 0;i<len;i++)
	{
		if(i<n)a[i].x = (s[i]=='a')?0:1;
		else a[i].x = 0;
		b[i].x = a[i].x;
		a[i].y = b[i].y = c[i].x = c[i].y = 0;
	}
	conv(a,b,c,len);
	//for(int i = 0;i<m-1;i++)
	//	printf("%d ",ans[i]);
	for(int i = 0;i<m;i++)
	{
		int tmp = (ans[i]+1)>>1;
		(Ans+=pow2[tmp]-1)%=mod;
	}
	manacher(n);
	Ans = ((Ans-tot)%mod+mod)%mod;
	printf("%lld\n",Ans);
	return 0;
}
Problem3162

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int mod = 1e9+7;
const int sed = 377;
const int N = 5e5+5;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot=1,n,rot,cgs[2];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	//e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],stack[N];
ull hash[N];
ll f[N][2],inv[N];
void Init()
{
	inv[1] = 1;
	for(int i = 2;i<= n;i++)
		inv[i] = (ll)(mod-mod/i)*inv[mod%i]%mod;
}
ll C(ll n,ll m)
{
	ll res = 1;
	n%=mod;
	for(int i = 1;i<= m;i++)
		(res*=(ll)(n-i+1)*inv[i]%mod)%=mod;
	return res;
}
bool cmp(int x,int y)
{
	return hash[x]<hash[y];
}
void dfs(int x,int fa)
{
	bool flag = true;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa)
	{
		dfs(e[i].to,x);
		size[x]+=size[e[i].to];
		if(size[e[i].to]<<1>n)
			flag = false;
	}
	if((n-size[x])<<1>n)
		flag = false;
	if(flag)
		(cgs[0]?cgs[1]:cgs[0])=x;
}
void DP(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			DP(e[i].to,x);
	int top = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			stack[++top] = e[i].to;
	sort(stack+1,stack+top+1,cmp);
	hash[x] = sed;
	f[x][0]=f[x][1]=1;
	int j;
	for(int i = 1;i<= top;i=j)
	{
		for(j = i+1;j<=top&&hash[stack[i]]==hash[stack[j]];j++);
		(f[x][0]*=C(j-i+f[stack[i]][0]+f[stack[i]][1]-1,j-i))%=mod,
		(f[x][1]*=C(j-i+f[stack[i]][0]-1,j-i))%=mod;
	}
	for(int i = 1;i<= top;i++)
	{
		hash[x] = hash[x]*sed+hash[stack[i]];
		hash[x] = (hash[x]^hash[stack[i]])+hash[stack[i]];
	}
}
int main()
{
	scanf("%d",&n);
	Init();
	int x,y;
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs(1,0);
	if(cgs[1])
	{
		for(int i = head[cgs[0]];i;i=e[i].next)
			if(e[i].to==cgs[1])
			{
				e[i].to = e[i^1].to = rot = n+1;
				break;
			}
		add(n+1,cgs[0]);
		add(n+1,cgs[1]);
	}else rot = cgs[0];
	DP(rot,0);
	ll ans = 0;
	if(!cgs[1])
		ans = (f[rot][0]+f[rot][1])%mod;
	else
	{
		x=cgs[0];y=cgs[1];
        if(hash[x]!=hash[y])
            ans=(f[x][0]*f[y][0]%mod+f[x][1]*f[y][0]%mod+f[x][0]*f[y][1]%mod)%mod;
        else
            ans=(f[x][0]*f[y][1]+C(f[x][0]+1,2) )%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3166

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int M = 35*N;
const int INF = 1e9+1;
int root[N];
set<int>q;
struct Data{int pos,val;}a[N];
bool operator<(Data a,Data b)
{
	return a.val>b.val;
}
struct Trie
{
	int ch[M][2],cnt,sum[M];
	int insert(int x,int num)
	{
		int tmp,y;
		tmp=y=++cnt;
		for(int i=30;i>=0;i--)
		{
			int t = num&(1<<i);t=t>>i;
			ch[y][0] = ch[x][0];
			ch[y][1] = ch[x][1];
			x = ch[x][t];
			y = ch[y][t] = ++cnt;
			sum[y]=sum[x]+1;
		}
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 30;i>= 0;i--)
		{
			int t = val&(1<<i);t=t>>i;
			if(sum[ch[r][t^1]]-sum[ch[l][t^1]]>0)
				l=ch[l][t^1],r = ch[r][t^1],ans+=(1<<i);
			else l = ch[l][t],r = ch[r][t];
		}
		return ans;
	}
}trie;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d",&a[i].val);
		a[i].pos = i;
	}
	for(int i = 1;i<= n;i++)
		root[i] = trie.insert(root[i-1],a[i].val);
	q.insert(-2),q.insert(-1),q.insert(INF),q.insert(INF+1);
	sort(a+1,a+n+1);
	q.insert(a[1].pos);
	int ans = 0;
	for(int i = 2;i<= n;i++)
	{
		int l = a[i].pos,r = a[i].pos,x = a[i].pos;
		set<int>::iterator t,p;
		p=q.lower_bound(x);
		t = p;
		r = *t;t++;r = *t-1;
		l = *--p;p--;l=*p+1;
		l = max(1,l),r = min(r,n);
		if(l!=r)ans = max(ans,trie.getans(root[l-1],root[r],a[i].val));
		q.insert(x);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3170

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct P
{
	ll x,y;
	P(){}
	P(ll x,ll y):x(x+y),y(x-y){}

}p[N];
int n;
ll X[N],Y[N],ans = 1e18;
ll sumx[N],sumy[N];
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		p[i]=P(x,y);
		X[i] = p[i].x,Y[i] = p[i].y;
	}
	sort(X+1,X+n+1);
	sort(Y+1,Y+n+1);
	for(int i = 1;i<= n;i++)
	{
		sumx[i] = sumx[i-1]+X[i];
		sumy[i] = sumy[i-1]+Y[i];
	}
	ll tmp=0;
	int pos;
	for(int i = 1;i<= n;i++)
	{
		tmp = 0;
		pos = lower_bound(X+1,X+n+1,p[i].x)-X;
		tmp+=(p[i].x*pos-sumx[pos])+((sumx[n]-sumx[pos])-p[i].x*(n-pos));
		pos = lower_bound(Y+1,Y+n+1,p[i].y)-Y;
		tmp+=(p[i].y*pos-sumy[pos])+((sumy[n]-sumy[pos])-p[i].y*(n-pos));
		ans = min(ans,tmp);
	}
	printf("%lld\n",ans>>1);
	return 0;
}
Problem3171

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int nxt,to,fr,f,c;}e[M];
int head[N],tot=1;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].nxt=head[x];head[x]=tot;
	e[tot].f=f,e[tot].c=c;e[tot].fr=x;
	e[++tot].to=x;e[tot].nxt=head[y];head[y]=tot;
	e[tot].f=0,e[tot].c=-c;e[tot].fr=y;
}
int from[N],dis[N],S,T;
bool v[N];
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	dis[S] = 0,v[S] = true;
	Q.push(S);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].nxt)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans,mxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	mxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int id[20][20][2];
int map[20][20];
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
int main()
{
	int cnt = 0;
	int l,r;
	char s[20];
	scanf("%d%d",&l,&r);
	for(int i = 1;i<= l;i++)
	{
		scanf("%s",s+1);
		for(int j=1;j<= r;j++)
		{
			if(s[j]=='U')map[i][j]=0;
			else if(s[j]=='D')map[i][j]=1;
			else if(s[j]=='L')map[i][j]=2;
			else map[i][j]=3;
		}
	}
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			for(int k = 0;k<2;k++)
				id[i][j][k]=++cnt;
	S = 0,T =cnt+1;
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			for(int d = 0;d<4;d++)
			{
				int nx = i+dx[d],ny = j+dy[d];
				if(nx<1)nx=l;if(ny<1)ny=r;
				if(nx>l)nx=1;if(ny>r)ny=1;
				if(map[i][j]==d)add(id[i][j][0],id[nx][ny][1],1,0);
				else add(id[i][j][0],id[nx][ny][1],1,1);
			}
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			add(S,id[i][j][0],1,0),add(id[i][j][1],T,1,0);
	while(spfa())mcf();
	printf("%d\n",ans);
	return 0;
}
Problem3172

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int LEN = 1e6+5;
const int N = 205;
int pos[N];
char s[LEN];
#define s(i) (s[i]-'a')
struct AC_Machine
{
	int ch[LEN][26],sum[LEN],fail[LEN],q[LEN];
	int cnt,h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i]=1;
	}
	void insert(int &pos)
	{
		int i = 0,now = 1;
		while(s[i])
		{
			if(!ch[now][s(i)])
				ch[now][s(i)] = ++cnt;
			now = ch[now][s(i)];
			sum[now]++;
			i++;
		}
		pos = now;
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1;fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k=fail[k];
				fail[to]=ch[k][i];
				q[++t] = to;
			}
		}
		for(int i = t;i>=0;i--)
			sum[fail[q[i]]]+=sum[q[i]];
	}
}AC;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		AC.insert(pos[i]);
	}
	AC.build();
	for(int i = 1;i<= n;i++)
		printf("%d\n",AC.sum[pos[i]]);
	return 0; 
}
Problem3172

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+500;
char s[N];
int size[N<<1],pos[205];
queue<int>q;
struct SAM
{
	int trs[N<<1][27],fa[N<<1],len[N<<1],ind[N<<1],size[N<<1];
	int cnt,last;
	int end[N<<1];
	void init(){cnt=last=1;}
	int insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np]=len[p]+1;
		size[np]++;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
		return np;
	}
	void build()
	{
		for(int i=1;i<=cnt;i++)ind[fa[i]]++;
		for(int i=1;i<=cnt;i++)
			if(!ind[i])q.push(i);
		while(!q.empty())
		{
			int t=q.front();q.pop();
			if((--ind[fa[t]])==0)q.push(fa[t]);
			size[fa[t]]+=size[t];
		}
	}
}sam;
int beg[205],lth[205];
int main()
{
	int n,ll=0;
	sam.init();
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+ll+1);
		beg[i] = ll+1;
		ll+=(lth[i]=strlen(s+ll+1));
		s[++ll]='a'-1;
	}
	for(int i=1;i<=ll;i++)
        sam.insert(s[i]-'a'+1);
    sam.build();
	for(int i=1;i<=n;i++)
    {
        int now=1;
        for(int j=beg[i];j<=beg[i]+lth[i]-1;j++)
            now=sam.trs[now][s[j]-'a'+1];
        printf("%d\n",sam.size[now]);
    }
	return 0;
}
Problem3191

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int n,m;
double f[55][55];
int a[55];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i= 1;i<= m;i++)scanf("%d",&a[i]);
	f[1][1] = 1;
	for(int i = 2;i<= n;i++)
	{
		for(int j = 1;j<= i;j++)
		{
			for(int k = 1;k<= m;k++)
			{
				int tmp = a[k]%i;
				if(tmp==0)tmp = i;
				if(tmp==j)continue;
				if(tmp>j)tmp = i-tmp+j;
				else tmp = j-tmp;
				f[i][j] += f[i-1][tmp]/(double)m;
			}
		}
	}
	for(int i = 1;i< n;i++)
		printf("%.2lf%c ",f[n][i]*100.0,'%');
	printf("%.2lf%c",f[n][n]*100.0,'%');
	return 0;
}
Problem3192

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct P
{
    int tt,no,ss;
}num[100005];
int pos[100005],c[100005],lim;
bool cmp1(P a,P b){return a.tt<b.tt;}
bool cmp2(P a,P b){return a.no<b.no;}
void update(int x)
{
    for(int i = x;i<=lim;i+=(i&(-i)))
        c[i]--;
}
int check(int x)
{
    int ans = 0;
    for(int i = x;i>0;i-=(i&(-i)))
        ans+=c[i];
    return ans;
}
int main()
{
    //freopen("all.in", "r", stdin);
    //freopen("all.out", "w", stdout);
    int n,m,x;
    scanf("%d%d",&n,&m);
    lim = n+m;
    int cnt = 0;
    for(int i = 1;i<=n;i++)
    {
        scanf("%d",&x);
        cnt++;num[cnt].tt = x;num[cnt].no = n-i;
    }
    for(int i = 1;i<= m;i++)
    {
        scanf("%d",&x);
        cnt++;num[cnt].tt = x;num[cnt].no = n+i;
    }
    sort(num+1,num+cnt+1,cmp1);
    for(int i = 1;i<= cnt;i++)
        num[i].ss = i;
    sort(num+1,num+cnt+1,cmp2);
    for(int i = 1;i<= cnt;i++)
        pos[num[i].ss] = i;
    //p_n为n与n+1之间的
    for(int i = 1;i<= lim;i++)
        c[i] = i&(-i);
    int p = n;int now = n+m;long long ans = 0;
    while(now>0)
    {
        int tmp = check(p);
        if(pos[now]>p)
        {
            ans += check(pos[now]-1)-tmp;
            p = pos[now]-1;
            update(pos[now]);
        }else
        {
            ans += tmp-check(pos[now]);
            p = pos[now];
            update(pos[now]);
        }
        now--;
    }
    printf("%lld",ans);
    return 0;
}
Problem3195

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<9;
const int M = 31;
const int mod = 1000000007;
int f[M+1][M][N][10];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int end = (1<<(k+1))-1;
	f[2][0][0][0] = 1;
	for(int i = 2;i<= n;i++)
	{
		for(int j = 0;j<= m;j++)
		{
			for(int sta = 0;sta<=end;sta++)
			{
				for(int l = 0;l<k;l++)
				{
					(f[i][j][sta][l+1]+=f[i][j][sta][l])%=mod;
					if(j<m&&i-k+l>0)
						(f[i][j+1][sta^(1<<k)^(1<<l)][l]+=f[i][j][sta][l])%=mod;
				}
				if(!(sta&1))(f[i+1][j][sta>>1][0]+=f[i][j][sta][k])%=mod;
			}
		}
	}
	printf("%d\n",f[n+1][m][0][0]);
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(200037);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:scanf("%d%d%d",&l,&r,&k);tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:scanf("%d%d%d",&l,&r,&k);get_number(l,r,k);break;
			case 3:scanf("%d%d",&l,&k);change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:scanf("%d%d%d",&l,&r,&k);tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:scanf("%d%d%d",&l,&r,&k);tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<3)+(x<<1) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(200037);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i] = read();
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:l=read();r=read();k=read();tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:l=read();r=read();k=read();get_number(l,r,k);break;
			case 3:l=read();k=read();change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:l=read();r=read();k=read();tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:l=read();r=read();k=read();tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<3)+(x<<1) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(237);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i] = read();
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:l=read();r=read();k=read();tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:l=read();r=read();k=read();get_number(l,r,k);break;
			case 3:l=read();k=read();change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:l=read();r=read();k=read();tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:l=read();r=read();k=read();tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int INF = 1e8+1;
int a[N],n,m;
struct Treap
{
	Treap *ls,*rs;
	int val,key,cnt,size;
	Treap();
	Treap(int v);
	void Push_up();
}*root[N<<2];
Treap :: Treap()
{
	ls = rs = NULL;
	val = 0;
	key = rand();
	cnt = size = 0;
}
Treap :: Treap(int v)
{
	ls = rs = NULL;
	val = v;
	key = rand();
	cnt = size = 1;
}
void Treap :: Push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->Push_up();
	x->Push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->Push_up();
	x->Push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x=new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->Push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->Push_up();
}
int rnk;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)rnk+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		rnk+=x->cnt;
		if(x->ls)rnk+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_rank(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,v);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,v);
}
void Insert(int p,int l,int r,int pos,int v)
{
	Insert(root[p],v);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Insert(p<<1,l,mid,pos,v);
	else Insert(p<<1|1,mid+1,r,pos,v);
}
void Delete(int p,int l,int r,int pos,int v)
{
	Delete(root[p],v);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Delete(p<<1,l,mid,pos,v);
	else Delete(p<<1|1,mid+1,r,pos,v);
}
int pre,sub;
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)get_pre(x->ls,y);
	else
	{
		pre = max(pre,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)get_sub(x->rs,y);
	else
	{
		sub = min(sub,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_pre(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,v);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,v);
}
void get_sub(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_sub(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,v);
	if(b >mid)get_sub(p<<1|1,mid+1,r,a,b,v);
}
void Get_rank(int l,int r,int k)
{
	rnk = 1;
	get_rank(1,1,n,l,r,k);
	printf("%d\n",rnk);
}
void Get_sub(int l,int r,int k)
{
	sub = INF;
	get_sub(1,1,n,l,r,k);
	printf("%d\n",sub);
}
void Get_pre(int l,int r,int k)
{
	pre = -INF;
	get_pre(1,1,n,l,r,k);
	printf("%d\n",pre);
}
void Get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		rnk = 1;
		get_rank(1,1,n,x,y,mid);
		if(rnk<=c){l=mid+1,ans=mid;}
		else {r = mid-1;}
	}
	printf("%d\n",ans);
}
void update(int pos,int c)
{
	Delete(1,1,n,pos,a[pos]);
	Insert(1,1,n,pos,c);
	a[pos] = c;
}
int main()
{
	srand(200037);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)Insert(1,1,n,i,a[i]);
	while(m--)
	{
		int opt,l,r,x,pos;
		scanf("%d",&opt);
		if(opt==3){scanf("%d%d",&pos,&x);}
		else {scanf("%d%d%d",&l,&r,&x);}
		if(opt==1)Get_rank(l,r,x);
		else if(opt==2)Get_number(l,r,x);
		else if(opt==3)update(pos,x);
		else if(opt==4)Get_pre(l,r,x);
		else Get_sub(l,r,x);
	}
	return 0;
}
Problem3197

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int sed = 237;
const int mul = 213;
const int N = 705;
const int INF = 0x3f3f3f3f;
int f[N][N],f1[N],f2[N],root,cg[2],n;
ull hash[N];
bool cmp(int x,int y)
{
	return hash[x]<hash[y];
}
namespace Tree
{
	struct E
	{int next,to;}e[N<<1];
	int head[N],tot,size[N],fa[N];
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void Get_G(int x,int father)
	{
		size[x] = 1;int F=0;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=father)
			{
				Get_G(e[i].to,x);
				size[x]+=size[e[i].to];
				F = max(F,size[e[i].to]);
			}
		F = max(F,n-size[x]);
		if(!(F<<1>n))
		{
			if(cg[0])cg[1] = x;
			else cg[0] = x;
		}
	}
	int dep[N];
	void Get_Hash(int x)
	{
		dep[x] = dep[fa[x]]+1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				Get_Hash(e[i].to);
			}
		static int stack[N],top;
		top = 0;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
				stack[++top] = e[i].to;
		sort(stack+1,stack+top+1,cmp);
		hash[x] = sed;
		for(int i = 1;i<= top;i++)
		{
			hash[x] = hash[x]*mul+hash[stack[i]];
			hash[x] = hash[x]^hash[stack[i]];
			hash[x] = hash[x]+hash[stack[i]];
		}
	}
}
namespace Flow
{
	struct E
	{int next,to,f,c,from;}e[N*N<<1];
	int head[N<<1],tot,ans,from[N<<1];
	void add(int x,int y,int f,int c)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].from = x;
		e[tot].f = f;e[tot].c = c;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].from = y;
		e[tot].f = 0;e[tot].c = -c;
	}
	void init()
	{
		memset(head,0,sizeof(head));
		tot = 1;ans = 0;
	}
	int dis[N<<1];bool vis[N<<1];
	queue<int>Q;
	bool spfa(int S,int T)
	{
		for(int i = S;i<= T;i++)dis[i] = INF;
		dis[S] = 0;vis[S] = true;
		Q.push(S);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			vis[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
				{
					dis[e[i].to] = dis[x]+e[i].c;
					from[e[i].to] = i;
					if(!vis[e[i].to])
					{
						Q.push(e[i].to);
						vis[e[i].to] = true;
					}
				}
		}
		return dis[T]!=INF;
	}
	void mcf(int S,int T)
	{
		int x = INF;
		for(int i = from[T];i;i=from[e[i].from])
			x = min(x,e[i].f);
		for(int i = from[T];i;i=from[e[i].from])
			ans+=x*e[i].c,e[i].f-=x,e[i^1].f+=x;
	}
	int getmcf(int S,int T)
	{
		while(spfa(S,T))mcf(S,T);
		return ans;
	}
}
int solve(int x,int y)
{
	static int stack1[N],stack2[N];
	int top1 = 0,top2 = 0;
	for(int i = Tree::head[x];i;i=Tree::e[i].next)
		if(Tree::e[i].to!=Tree::fa[x])
			stack1[++top1]=Tree::e[i].to;
	for(int i = Tree::head[y];i;i=Tree::e[i].next)
		if(Tree::e[i].to!=Tree::fa[y])
			stack2[++top2]=Tree::e[i].to;
	sort(stack1+1,stack1+1+top1,cmp);
	sort(stack2+1,stack2+1+top2,cmp);
	Flow::init();
	int j;
	for(int i = 1;i<= top1;i=j)
	{
		for(j=i+1;j<=top1&&hash[stack1[i]]==hash[stack1[j]];j++);
		for(int k=i;k<j;k++)
			for(int l=i;l<j;l++)
				Flow::add(k,top1+l,1,f[stack1[k]][stack2[l]]);
	}
	int S = 0,T = 2*n+1;
	for(int i = 1;i<= top1;i++)
	{
		Flow::add(S,i,1,0);
		Flow::add(i+top1,T,1,0);
	}
	return Flow::getmcf(S,T)+(f1[x]^f2[y]);
}
pair<pair<int,ull>,int> sorter[N]; 
int main()
{
	int x,y;
	scanf("%d",&n);
	Tree::tot = 1;
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		Tree::add(x,y);
	}
	for(int i = 1;i<= n;i++)scanf("%d",&f1[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&f2[i]);
	Tree::Get_G(1,0);
	if(cg[1])
	{
		root = ++n;
		for(int i = Tree::head[cg[1]];i;i=Tree::e[i].next)
			if(Tree::e[i].to==cg[0])
			{
				Tree::e[i].to = Tree::e[i^1].to = n;
				break;
			}
		Tree::add(root,cg[0]);
		Tree::add(root,cg[1]);
	}else root = cg[0];
	Tree::Get_Hash(root);
	for(int i = 1;i<= n;i++)
		sorter[i] = make_pair(make_pair(-Tree::dep[i],hash[i]),i);
	sort(sorter+1,sorter+n+1);
	int j;
	for(int i = 1;i<= n;i=j)
	{
		for(j=i+1;j<=n&&sorter[i].first==sorter[j].first;j++);  
        for(int x=i;x<j;x++)  
            for(int y=i;y<j;y++)  
                f[sorter[x].second][sorter[y].second]=solve(sorter[x].second,sorter[y].second);  
	}
	printf("%d\n",f[root][root]);
	return 0;
}
Problem3198

#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>

#define md 1234567
#define ll long long
#define inf (int) 1e9
#define eps 1e-8
#define N 1234590
#define cg 23333LL
#define M 500010
using namespace std;
int n;
int a[N][6],c[10][10];
ll ans[7];
bool same(int x,int y,int opt)
{
	for (int i=0;i<=5;i++) if ((opt&(1<<i))&&a[x][i]!=a[y][i]) return 0;
	return 1;
}
	
struct ha
{
	ll a[N];
	int q[N],is[N];
	int sz;
	ll clear()
	{
		ll ans=0;
		for (int i=1;i<=sz;i++)
		{
			int x=q[i];
			ans+=a[x]*(a[x]-1)/2;
			a[x]=is[x]=0;
		}
		sz=0;
		return ans;
	}
	void insert(int k,int x,int opt)
	{
		int pos=k;
		while (a[pos]&&(!same(x,is[pos],opt))) pos=(pos+1)%md; 
		if (!a[pos]) q[++sz]=pos,is[pos]=x;
		a[pos]++;
	}
} hash;

ll solve(int opt)
{
	for (int i=1;i<=n;i++)
	{
		ll ha=0;
		for (int j=0;j<=5;j++)
		{
			ha=ha*cg%md;
			if (opt&(1<<j)) { ha=(ha+a[i][j]+1)%md;}
		}
		hash.insert(ha,i,opt);
	}
	return hash.clear();
}
int cal(int i)
{
	int sum=0;
	for (int j=0;j<=5;j++) sum+=(i>>j)&1;
	return sum;
}
int main()
{
	int k;
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++)
		for(int j=0;j<=5;j++)
			scanf("%d",&a[i][j]);
	for (int i=0;i<=63;i++) ans[cal(i)]+=solve(i);
	c[0][0]=1;
	for (int i=1;i<=6;i++)
		for (int j=0;j<=i;j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j];
	for (int i=6;i>=k;i--)
		for (int j=0;j<i;j++)
			ans[j]-=ans[i]*c[i][j];
	printf("%lld\n",ans[k]);
	return 0;
}
Problem3207

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
const int N = 100005;
const int M = 8e6+5;
int num[N],n,m,k,Num,cnt;
ull a[N],T[N];
int find(ull x)
{
	int l = 1,r = Num+1;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(T[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int root[N],ls[M],rs[M],sum[M];
void init()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&num[i]);
	for(int i=1;i+k-1<=n;i++)
	{
		for(int j = i;j<=i+k-1;j++)
			a[i] = (a[i]<<31)+num[j];
		T[++Num] = a[i];
	}
	sort(T+1,T+Num+1);
}
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)
		update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
void Find(int x,int y,int k)
{
	if(x>y){printf("Yes\n");return ;}
	int l = 1,r = Num;
	x = root[x],y = root[y];
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(k<=mid)
		{
			x = ls[x],y = ls[y];
			r = mid;
		}else
		{
			x = rs[x],y = rs[y];
			l = mid+1;
		}
	}
	if(sum[y]-sum[x]>0)printf("No\n");
	else printf("Yes\n");
}
ull hash()
{
	int tmp[25];
	ull t = 0;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&tmp[i]);
		t = (t<<31)+tmp[i];
	}
	return t;
}
int main()
{
	init();
	for(int i =1;i<= Num;i++)
		update(root[i],root[i-1],1,Num,find(a[i]));
	int x,y;
	while(m--)
	{
		scanf("%d%d",&x,&y);
		ull t = hash();
		int tmp = find(t);
		if(T[tmp]!=t)printf("Yes\n");
		else
			Find(x-1,y-k+1,tmp);
	}
	return 0;
}
Problem3209

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL mod = 10000007;
LL c[55][55];
LL x,y;
LL quick_pow(LL x,LL y)
{
    if(y==0)return 1;
    LL tmp = quick_pow(x,y/2);
    if(y&1)return tmp*tmp%mod*x%mod;
    else return tmp*tmp%mod;
}
int main()
{
    c[1][0] = c[1][1] = 1;
    for(int i = 2;i<= 53;i++)
    {
        c[i][0] = 1;
        for(int j = 1;j<= 53;j++)
            c[i][j] = c[i-1][j-1]+c[i-1][j];
    }
    LL n,ans = 1,cnt = 0;
    scanf("%lld",&n);
    for(int i = 53;i>=1;i--)
    {
        if((n&((LL)1<<(i-1)))!=0)
        {
            ans = ans*(cnt+1)%mod;
            for(int j = i-1;j>=1;j--)
                ans = ans*quick_pow(j+cnt,c[i-1][j])%mod;
            cnt++;
        }
    }
    printf("%lld",ans);
    return 0;
}
Problem3217

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1100005;
const int M = 35000005;
const int mod = 1048576;
double alpha = 0.81;
int stack[305],top,a[N],n,m,n0;
struct Trie
{
	int ch[M][2],num[M],cnt;
	queue<int>Q;
	int Addpoint()
	{
		if(!Q.empty())
		{
			int tmp = Q.front();Q.pop();
			ch[tmp][0] = ch[tmp][1] = 0;
			num[tmp] = 0;
			return tmp;
		}
		return ++cnt;
	}
	void Delete(int x)
	{
		if(!x)return ;
		Q.push(x);
		Delete(ch[x][0]);Delete(ch[x][1]);
	}
	void Insert(int &now,int v,int dep,int top)
	{
		if(!now)now = Addpoint();
		num[now]+=top;
		if(dep<0)return ;
		if(v>>dep&1)Insert(ch[now][1],v,dep-1,top);
		else Insert(ch[now][0],v,dep-1,top);
	}
	int merge(int x,int y)
	{
		if(!x&&!y)return 0;
		int ret = Addpoint();
		ch[ret][0] = merge(ch[x][0],ch[y][0]);
		ch[ret][1] = merge(ch[x][1],ch[y][1]);
		num[ret] = num[x]+num[y];
		return ret;
	}
	int getans(int x,int dep)
	{
		if(dep<0)return 0;
		int tmp = x>>dep&1,sum = 0;
		for(int i = 1;i<= top;i++)
			sum+=num[ch[stack[i]][tmp^1]];
		for(int i = 1;i<= top;i++)
			stack[i] = ch[stack[i]][sum ? tmp^1 : tmp];
		return getans(x,dep-1)+(sum?1<<dep:0);
	}
}trie;
struct Node
{
	int mx,sx;
	Node(){}
	Node(int mx,int sx):mx(mx),sx(sx){}
	void ins(int x)
	{
		if(x>mx)sx = mx,mx = x;
		else if(x>sx)sx = x;
	}
};
Node merge(Node r1,Node r2)
{
	Node ret = r1;
	ret.ins(r2.mx),ret.ins(r2.sx);
	return ret;
}
struct Balanced_Tree
{
	queue<int>Q;
	int ch[N][2],root[N],fa[N],size[N],val[N],sz[N],b[N];
	int cnt,Root,fre,pre,tar;
	Node n1,v[N];
	int Addpoint()
	{
		if(!Q.empty())
		{
			int t = Q.front();Q.pop();
			ch[t][0]=ch[t][1]=root[t]=fa[t]=size[t]=val[t]=b[t]=0;
			v[t] = Node(0,0);
			return t;
		}
		return ++cnt;
	}
	int NewNode(int x)
	{
		int ret = Addpoint();
		b[ret] = 1;
		val[ret] = x;
		size[ret] = sz[ret] = 1;
		v[ret] = Node(x,0);
		trie.Insert(root[ret],x,20,1);
		return ret;
	}
	void Push_up(int x)
	{
		size[x] = size[ch[x][0]]+size[ch[x][1]];
		sz[x] = size[x]+1;
		root[x] = trie.merge(root[ch[x][0]],root[ch[x][1]]);
		v[x] = merge(v[ch[x][0]],v[ch[x][1]]);
		fa[ch[x][0]] = fa[ch[x][1]] = x;
	}
	int Build(int l,int r)
	{
		if(l>r)return 0;
		if(l==r)return NewNode(a[l]);
		int mid = (l+r)>>1,ret = Addpoint();
		ch[ret][0] = Build(l,mid);
		ch[ret][1] = Build(mid+1,r);
		Push_up(ret);
		return ret;
	}
	void dfs(int x)
	{
		if(!x)return ;
		Q.push(x);
		trie.Delete(root[x]);
		if(b[x]){a[++n] = val[x];return ;}
		dfs(ch[x][0]),dfs(ch[x][1]);
	}
	void Rebuild(int x)
	{
		trie.Delete(root[x]);
		n = 0;
		dfs(ch[x][0]),dfs(ch[x][1]);
		int tmp = Build(1,n);
		if(x==Root)Root = tmp;
		fa[tmp] = fa[x];
		ch[fa[x]][ch[fa[x]][1]==x]=tmp;
	}
	void Insert(int &now,int x,int y)
	{
		if(size[now]==1||!now)
		{
			int t = NewNode(y),ret = Addpoint();
			fa[ret] = pre;
			ch[ret][0] = t,ch[ret][1] = now;
			Push_up(ret);
			now = ret;
			return ;
		}
		pre=now;
		if(size[ch[now][0]]>=x)Insert(ch[now][0],x,y);
		else Insert(ch[now][1],x-size[ch[now][0]],y);
		trie.Insert(root[now],y,20,1);
		v[now].ins(y);
		size[now]++;sz[now]+=2;
		fa[ch[now][0]] = fa[ch[now][1]] = now;
		if(max(sz[ch[now][0]],sz[ch[now][1]])>sz[now]*alpha)
			fre = now;
	}
	void Delete(int &now,int x)
	{
		if(b[now])
		{
			Q.push(now);
			tar = val[now];
			now = 0;
			return ;
		}
		if(size[ch[now][0]]>=x)Delete(ch[now][0],x);
		else Delete(ch[now][1],x-size[ch[now][0]]);
		trie.Insert(root[now],tar,20,-1);
		v[now] = merge(v[ch[now][0]],v[ch[now][1]]);
		size[now]--;sz[now]--;
		fa[ch[now][0]] = fa[ch[now][1]] = now;
		if(max(sz[ch[now][0]],sz[ch[now][1]])>sz[now]*alpha)
			fre = now;
	}
	void Insert(int x,int y)
	{
		fre = 0;
		Insert(Root,x,y);
		if(fre)
			Rebuild(fre);
	}
	void Delete(int x)
	{
		fre = 0;
		Delete(Root,x);
		if(fre)
			Rebuild(fre);
	}
	void Find(int now,int pre,int x,int y)
	{
		if(pre+1>=x&&pre+size[now]<=y)
		{
			stack[++top] = root[now];
			n1 = merge(n1,v[now]);
			return ;
		}
		if(pre+size[ch[now][0]]>=x)
			Find(ch[now][0],pre,x,y);
		if(pre+size[ch[now][0]]<y)
			Find(ch[now][1],pre+size[ch[now][0]],x,y);
	}
	Node Find(int x,int y)
	{
		top = 0;
		n1 = Node(0,0);
		Find(Root,0,x,y);
		return n1;
	}
}sheep;
int main()
{
	int lastans = 0;
	scanf("%d%d",&n,&m);n0=n;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	sheep.Root=sheep.Build(1,n);
	int x,y;
	char opt[3];
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%mod;
			n0++;
			sheep.Insert(x,y);
		}else if(opt[0]=='D')
		{
			scanf("%d",&x);
			x = (x+lastans)%n0+1;n0--;
			sheep.Delete(x);
		}else if(opt[0]=='C')
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%mod;
			sheep.Delete(x);
			sheep.Insert(x,y);
		}else
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%n0+1;
			Node tmp = sheep.Find(x,y);
			lastans = trie.getans(tmp.sx,20);
			printf("%d\n",lastans);
		}
		//printf("Ask:%c %d %d\nAns = %d\n",opt[0],x,y,lastans);
	}
	return 0;
}
Problem3219

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N=100005;
int to[N<<1],ne[N<<1],val[N<<1],v[N<<1];
int fi[N],V[N],num[N],mx[N],fa[N],dep[N],f[N],g[N];
int q[N],d[N],n,L,R,tot=0,cur,rt;
bool u[N];
inline int read() 
{
    int x=0,f=1;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f=-1;ch = getchar();}
    while(ch >='0' && ch <='9'){x=(x<<1)+(x<<3)+ch-'0';ch = getchar();}
    return x*f;
}
void add(int x,int y,int z)
{
	to[++tot]=y;val[tot]=z;ne[tot]=fi[x];fi[x]=tot;
}
void findrt(int x)
{
	num[x]=1;mx[x]=0;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]] && to[i]!=fa[x])
	{
		fa[to[i]]=x;
		findrt(to[i]);
		num[x]+=num[to[i]];
		mx[x]=std::max(mx[x],num[to[i]]);
	}
	mx[x]=std::max(mx[x],cur-num[x]);
	if (mx[x]<mx[rt]) rt=x;
}
bool work(int x,int sum)
{
	if (sum<=L) return 0;
	cur=sum;rt=0;
	findrt(x);u[x=rt]=1;
	int maxdep=0;f[0]=0;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]])
	{
		int s=1,t=1,head=1,tail=0;
		for (int j=maxdep;j>=L;j--)
		{
			for (;head<=tail && f[d[tail]]<=f[j];tail--);
			d[++tail]=j;
		}
		fa[q[1]=to[i]]=x;dep[to[i]]=1;g[to[i]]=v[i];
		for (;s<=t;s++)
		{
			for (;head<=tail && d[head]+dep[q[s]]>R;head++);
			if (dep[q[s]]<=L)
			{
				for (;head<=tail && f[d[tail]]<=f[L-dep[q[s]]];tail--);
				d[++tail]=L-dep[q[s]];
			}
			if (head<=tail && f[d[head]]+g[q[s]]>=0) return 1;
			if (dep[q[s]]>=R) continue;
			for (int j=fi[q[s]];j;j=ne[j])
			if (!u[to[j]] && to[j]!=fa[q[s]])
			{
				fa[q[++t]=to[j]]=q[s];
				dep[to[j]]=dep[q[s]]+1;
				g[to[j]]=g[q[s]]+v[j];
			}
		}
		maxdep=std::max(maxdep,dep[q[t]]);
		for (int j=1;j<=t;j++) f[dep[q[j]]]=std::max(f[dep[q[j]]],g[q[j]]);
	}
	for (int i=0;i<=maxdep;i++) f[i]=-n;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]])
	{
		if (num[to[i]]>num[x]) num[to[i]]=sum-num[x];
		if (work(to[i],num[to[i]])) return 1;
	}
	return 0;
}
bool check(int mid)
{
	for (int i=1;i<=tot;i++)
		if (val[i]<mid) v[i]=-1;else v[i]=1;
	for (int i=0;i<=n;i++) u[i]=false,fa[i]=0,f[i]=-n;
	mx[0]=n;
	return work(1,n);
}
int main()
{
	n = read();
	L = read();
	R = read();
	for (int i=1;i<n;i++)
	{
		int x,y,z;
		x = read();y = read();z = read();
		add(x,y,z);add(y,x,z);V[i]=z;
	}
	std::sort(V+1,V+n);
	int m=std::unique(V+1,V+n)-V-1;
	V[0]=-1;
	int l=1,r=m,ans=0,mid;
	for (;l<=r;)
	{
		mid=(l+r)>>1;
		if (check(V[mid])) ans=mid,l=mid+1;
			else r=mid-1;
	}
	printf("%d\n",V[ans]);
}
Problem3223

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct S{
	S *son[2],*fa;
	int val,size,flag;
	S(){}
	void reverse()
	{
		flag ^=1;
		swap(son[0],son[1]);
	}
	void push_down()
	{
		if(flag==1)
		{
			son[0]->reverse();
			son[1]->reverse();
			flag = 0;
		}
	}
	void push_up()
	{
		size = son[0]->size+son[1]->size+1;
	}
	void Combine(S *a,bool dir) 
	{
        son[dir] = a;
        a->fa = this;
    }
    bool Check() {
        return fa->son[1] == this;
    }
}none,*nil = &none,*root = nil;
int n,m;
S* Newnode(S *now,int x)
{
	S *re = new S();
	re->val = x;
	re->son[0] = re->son[1]  = nil;
	re->size = 1; re->flag = 0;
	re->fa = now;
	return re;
}
S* build(int l,int r)
{
	if(l>r)return nil;
	int mid = (l+r)>>1;
	S *re = nil;
	re = Newnode(re,mid);
	re->Combine(build(l,mid - 1),false);
    re->Combine(build(mid + 1,r),true);
	re->push_up();
	return re;
}
void Rotate(S *a,bool dir)
{
    S *f = a->fa;
    f->push_down(),a->push_down();
    f->son[!dir] = a->son[dir];
    f->son[!dir]->fa = f;
    a->son[dir] = f;
    a->fa = f->fa;
    f->fa->son[f->Check()] = a;
    f->fa = a;
    f->push_up();
    if(root == f)   root = a;
}
 
void Splay(S *a,S *aim)
{
    while(a->fa != aim) {
        if(a->fa->fa == aim) 
            Rotate(a,!a->Check());
        else if(!a->fa->Check()) {
            if(!a->Check()) {
                Rotate(a->fa,true);
                Rotate(a,true);
            }
            else {
                Rotate(a,false);
                Rotate(a,true);
            }
        }
        else {
            if(a->Check()) {
                Rotate(a->fa,false);
                Rotate(a,false);
            }
            else {
                Rotate(a,true);
                Rotate(a,false);
            }
        }
    }
    a->push_up();
}
S* find_rank(S *now,int x)
{
	now->push_down();
	if(x<=now->son[0]->size)return find_rank(now->son[0],x);
	x = x-now->son[0]->size;
	if(x==1)return now;
	return find_rank(now->son[1],x-1);
}
void work(int x,int y)
{
	x++;y++;
	Splay(find_rank(root,x-1),nil);
	Splay(find_rank(root,y+1),root);
	root->son[1]->son[0]->reverse();
}
void print(S *now)
{
	if(now==nil)return ;
	now->push_down();
	print(now->son[0]);
	if(now->val&&now->val!=n+1)
		printf("%d ",now->val);
	print(now->son[1]);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	root = build(0,n+1);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		work(x,y);
	}
	print(root);
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <time.h>
using namespace std;
struct Treap
{
	Treap *ls,*rs;
	int val,key,cnt,size;
	Treap(int f)
	{
		ls = rs = NULL;
		val = f;
		key = rand();
		cnt = size = 1;
	}
	void push_up()
	{
		size = cnt;
		if(ls) 
			size+=ls->size;
		if(rs)
			size+=rs->size;
	}
};
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key > x->key)
			go_right(x);
	}else
	{
		insert(x->rs,y);
		if(x->rs->key > x->key)
			go_left(x);
	}
	x->push_up();
}
void dele(Treap *&x,int y)
{
	if(y<x->val)
		dele(x->ls,y);
	else if(y>x->val)
		dele(x->rs,y);
	else
	{
		if(x->cnt>1)
			x->cnt--;
		else if(!x->ls)
			x = x->rs;
		else if(!x->rs)
			x = x->ls;
		else
		{
			go_left(x);
			dele(x->ls,y);
			if(x->ls && x->ls->key > x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int query_rank(Treap *x,int y)
{
    if(!x)return 0;
    int tmp;
    if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(x->val==y)return tmp+1;
	else if(y>x->val)
		return tmp+x->cnt+query_rank(x->rs,y);
	else return query_rank(x->ls,y);
}
int query_num(Treap *x,int y)
{
    if(!x)return 0;
    int tmp;
    if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(y<=tmp)
		return query_num(x->ls,y);
    else if(y>tmp+x->cnt)
		return query_num(x->rs,y-tmp-x->cnt);
    else return x->val;
}
/*int getrank(Treap *x,int y,int tr)
{
	if((y<x->val&&x->ls!=NULL)||(y>x->val&&!x->ls))
		return getrank(x->ls,y,tr);
	else if(y>x->val&&x->rs!=NULL)
		return getrank(x->rs,y,tr+x->ls->size);
	else
	{
		if(!x->ls)return tr+1;
		else return tr+x->ls->size+1;
	}
}
int getnum(Treap *x,int y,int ts)
{
	if(y>=ts&&y<=ts+x->cnt)
		return x->val;
	else if(y < x->size+ts&&x->ls!=NULL)
		return getnum(x->ls,y);
	else
		return getnum(x->rs,y);
}*/
int b,q;
/*void getb(Treap *x,int y)
{
	if(x->val<y)b = max(b,x->val);
	if(y<=x->val&&x->ls!=NULL)
		getb(x->ls,y);
	else if(y>x->val&&x->rs!=NULL)
		getb(x->rs,y);
	else return ;
}
void getq(Treap *x,int y)
{
	if(x->val>y)q = min(q,x->val);
	if(y<x->val&&x->ls!=NULL)
		getb(x->ls,y);
	else if(y>=x->val&&x->rs!=NULL)
		getb(x->rs,y);
	else return ;
}*/
int ans;
void query_pro(Treap *x,int y)
{
    if(!x)return;
    if(x->val<y)
	{
		ans=max(ans,x->val);query_pro(x->rs,y);
	}
    else query_pro(x->ls,y);
}
void query_sub(Treap *x,int y)
{
	if(!x)return;
	if(x->val>y)
	{
		ans=min(ans,x->val);query_sub(x->ls,y);
	}
	else query_sub(x->rs,y);
}
int main()
{
	//srand(time(NULL));
	int n,opt,x;
	scanf("%d",&n);
	Treap *root = NULL;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)insert(root,x);
		else if(opt==2)dele(root,x);
		else if(opt==3)printf("%d\n",query_rank(root,x));
		else if(opt==4)printf("%d\n",query_num(root,x));
		else if(opt==5)
			{ans = 0;query_pro(root,x);printf("%d\n",ans);}
		else {ans = 0x3f3f3f3f;query_sub(root,x);printf("%d\n",ans);}
	}
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct S{
	S *son[2],*fa;
	int val,size,cnt;
	S(){}
	int compare(int x)
	{
		if(x==val)return -1;
		else return x>val;
	}
	void push_up()
	{
		size = cnt;
		size+=son[0]->size;
		size+=son[1]->size;
	}
}none,*nil = &none,*root = nil;
S* newnode(S *now,int x)
{
	S *re = new S();
    re->cnt = re->size = 1;
    re->val = x;
    re->son[0] = re->son[1] = nil;
    re->fa = now;
    return re;
}
void go_right(S *x)
{
	S *y = x->fa;
	y->son[0] = x->son[1];
	x->son[1]->fa = y;
	x->son[1] = y;
	x->fa = y->fa;
	if(y==y->fa->son[0])
		y->fa->son[0] = x;
	else if(y==y->fa->son[1])
		y->fa->son[1] = x;
	y->fa = x;
	y->push_up();
	x->push_up();
	if(root == y)
		root = x;
}
void go_left(S *x)
{
	S *y = x->fa;
	y->son[1] = x->son[0];
	x->son[0]->fa = y;
	x->son[0] = y;
	x->fa = y->fa;
	
	if(y==y->fa->son[0])
		y->fa->son[0] = x;
	else if(y==y->fa->son[1])
		y->fa->son[1] = x;
	y->fa = x;
	y->push_up();
	x->push_up();
	if(root == y)
		root = x;
}
void Update(S* now)
{
    now->push_up();
    if(now != root)
        Update(now->fa);
}
void Splay(S *x,S *target)
{
	while(true)
	{
		S *y = x->fa;
		S *z = y->fa;
		if(y==target)
			break;
		if(z==target)
		{
			if(x==y->son[0])go_right(x);
			else go_left(x);
			break;
		}
		else if(x==y->son[0])
		{
			if(y==z->son[0]){go_right(y);go_right(x);}
			else {go_right(x);go_left(x);}
		}else
		{
			if(y==z->son[1]){go_left(y);go_left(x);}
			else {go_left(x);go_right(x);}
		}
	}
	x->push_up();
}
void Insert(int x)
{
	if(root==nil)
	{
		root = newnode(nil,x);return ;
	}
	S *now = root;
	while(1)
	{
		int dir = now->compare(x);
		if(dir==-1)
		{
			now->cnt++;
			Update(now);
			break ;
		}else if(now->son[dir]!=nil)
			now = now->son[dir];
		else
		{
			now->son[dir] = newnode(now,x);
			Update(now);
			Splay(now->son[dir],nil);break ;
		}
	}
}
void Delete(S *&now,int x)
{
	int dir = now->compare(x);
	if(dir!=-1)
		Delete(now->son[dir],x);
	else 
	{
		if(now->cnt>1)now->cnt--;
		else
		{
			if(now->son[0]==nil){now->son[1]->fa = now->fa;now = now->son[1];}
			else if(now->son[1]==nil){now->son[0]->fa = now->fa;now = now->son[0];}
			else 
			{
				go_right(now->son[0]);
				Delete(now->son[1],x);
			}
		}
	}
	if(now!=nil)now->push_up();
}
int get_rank(S *now,int x)
{
	int re = now->son[0]->size;
	int dir = now->compare(x);
	if(dir==-1)return re+1;
	else if(dir==0)return get_rank(now->son[0],x);
	return re+now->cnt+get_rank(now->son[1],x);
}
int get_num(S *now,int x)
{
	if(x<=now->son[0]->size)return get_num(now->son[0],x);
	x = x-now->son[0]->size;
	if(x<=now->cnt)return now->val;
	x = x-now->cnt;
	return get_num(now->son[1],x);
}
int get_pre(S* now,int x)
{
	if(now==nil)return -0x3f3f3f3f;
	else if(x<=now->val)return get_pre(now->son[0],x);
	else return max(now->val,get_pre(now->son[1],x));
}
int get_suc(S* now,int x)
{
	if(now==nil)return 0x3f3f3f3f;
	else if(x>=now->val)return get_suc(now->son[1],x);
	else return min(now->val,get_suc(now->son[0],x));
}
int main()
{
	int n,x,opt;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&opt,&x);
		switch(opt)
		{
			case 1:Insert(x);break;
			case 2:Delete(root,x);break;
			case 3:printf("%d\n",get_rank(root,x));break;
			case 4:printf("%d\n",get_num(root,x));break;
			case 5:printf("%d\n",get_pre(root,x));break;
			case 6:printf("%d\n",get_suc(root,x));break;
		}
	}
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 1e8+1;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,size,key;
	Treap(int x);
	void push_up();
};
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size =cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(x==NULL)
		x = new Treap(y);
	else if(x->val==y)
		x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(x==NULL)return ;
	else if(x->val==y)
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x= x->rs;
		else if(!x->rs)x= x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}else if(y<x->val)
		Delete(x->ls,y);
	else Delete(x->rs,y);
	if(x)x->push_up();
}
int get_rank(Treap *x,int y)
{
	if(x==NULL)return 0;
	if(x->val==y)
	{
		if(x->ls)return x->ls->size;
		else return 0;
	}else if(y<x->val)
		return get_rank(x->ls,y);
	else
	{
		int tmp = x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_rank(x->rs,y);
	}
}
int get_num(Treap *x,int y)
{
    if(!x)return 0;
    int tmp = 0;
    if(x->ls)tmp+=x->ls->size;
	if(y<=tmp)
		return get_num(x->ls,y);
    else if(y>tmp+x->cnt)
		return get_num(x->rs,y-tmp-x->cnt);
    else return x->val;
}
int pre,sub;
void get_pre(Treap *x,int y)
{
	if(x==NULL)return ;
	else if(y<=x->val)get_pre(x->ls,y);
	else
	{
		pre = max(pre,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(x==NULL)return ;
	else if(y<x->val)
	{
		sub = min(sub,x->val);
		get_sub(x->ls,y);
	}else get_sub(x->rs,y);
}
int main()
{
	int n,opt,x;
	scanf("%d",&n);
	Treap *root = NULL;
	while(n--)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)Insert(root,x);
		else if(opt==2)Delete(root,x);
		else if(opt==3)printf("%d\n",get_rank(root,x)+1);
		else if(opt==4)printf("%d\n",get_num(root,x));
		else if(opt==5)pre = -INF,get_pre(root,x),printf("%d\n",pre);
		else sub = INF,get_sub(root,x),printf("%d\n",sub);
	}
	return 0;
}
Problem3230

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long ll;
char s[N];
int cnt[N],sa[N],v[N],nv[N],q[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim=0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i= 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j=max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
int st[18][N];
int log_2[N];
void build_st(int len)
{
	for(int i = 1;i<len;i++)
		st[0][i]=h[i];
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i+(1<<(j-1))<len;i++)
			st[j][i]=min(st[j-1][i],st[j-1][i+(1<<(j-1))]);
	for(int i = 2;i<N;i++)
		log_2[i]=log_2[i>>1]+1;
}
int getans(int l,int r,int n)
{
	l=rnk[l],r=rnk[r];
	if(l>r)swap(l,r);
	l++;
	if(l>r)return n-sa[r];
	int lth = log_2[r-l+1];
	return min(st[lth][l],st[lth][r-(1<<lth)+1]); 
}
ll sum[N];
struct Ask
{int l,r,p,q,a,b;ll ans;}ask[N];
int find(ll x,int n)
{
	int l = 0,r = n,ans=-1;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(sum[mid]<x)l=mid+1;
		else r = mid-1,ans=mid;
	}
	return ans;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	scanf("%s",s);
	build_sa(n,256);
	build_rank(n);
	build_height(n);
	build_st(n);
	for(int i = 0;i<n;i++)
		sum[i]=n-sa[i]-h[i];
	for(int i = 1;i< n;i++)
		sum[i]+=sum[i-1];
	ll x,y;
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld%lld",&x,&y);
		int l = find(x,n),p=find(y,n);
		if(l==-1||p==-1){ask[i].ans=-1;continue;}
		ask[i].l=sa[l],ask[i].p=sa[p];
		if(l>=1)ask[i].r=x-sum[l-1]+ask[i].l+h[l]-1;
		else ask[i].r=ask[i].l+x-1;
		if(p>=1)ask[i].q=y-sum[p-1]+ask[i].p+h[p]-1;
		else ask[i].q=ask[i].p+y-1;
		ask[i].a=min(min(ask[i].r-ask[i].l+1,ask[i].q-ask[i].p+1),getans(ask[i].l,ask[i].p,n));
	}
	for(int i = 0;i<n/2;i++)swap(s[i],s[n-i-1]);
	build_sa(n,256);
	build_rank(n);
	build_height(n);
	build_st(n);
	for(int i = 1;i<= q;i++)
	if(ask[i].ans!=-1)
	{
		ask[i].b=min(min(ask[i].r-ask[i].l+1,ask[i].q-ask[i].p+1),getans(n-ask[i].r-1,n-ask[i].q-1,n));
		ask[i].ans=(ll)ask[i].a*ask[i].a+(ll)ask[i].b*ask[i].b;
	}
	for(int i = 1;i<= q;i++)
		printf("%lld\n",ask[i].ans);
	return 0;
}
Problem3232

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const int N = 105;
const int S = 8e4+5;
int sl[N][N],sr[N][N];
struct E
{int next,to;double dis,a,b;}e[S];
int head[S],tot;
void add(int x,int y,double a,double b)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].a = a,e[tot].b = b;
}
bool inq[S];
double dis[S];
bool dfs(int x)
{
	inq[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(dis[e[i].to]>dis[x]+e[i].dis)
		{
			dis[e[i].to]=dis[x]+e[i].dis;
			if(inq[e[i].to])return true;
			if(dfs(e[i].to))return true;
		}
	inq[x] = false;
	return false;
}
int cnt,id[N][N];
bool check(double mid)
{
	memset(dis,0,sizeof(dis));
	memset(inq,0,sizeof(inq));
	for(int i = 1;i<= tot;i++)
		e[i].dis = -(e[i].a-mid*e[i].b);
	for(int i = 1;i<= cnt;i++)
		if(dfs(i))return true;
	return false;
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			sl[i][j] = sl[i][j-1]+x;
			sr[i][j] = sr[i-1][j]+x;
		}
	for(int i = 0;i<= n;i++)
		for(int j = 0;j<= m;j++)
			id[i][j] = ++cnt;
	for(int i = 0;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			add(id[i][j-1],id[i][j],sr[i][j],x);
			add(id[i][j],id[i][j-1],-sr[i][j],x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<= m;j++)
		{
			scanf("%d",&x);
			add(id[i-1][j],id[i][j],-sl[i][j],x);
			add(id[i][j],id[i-1][j],sl[i][j],x);
		}
	double l = 0,r = 1e9;
	while(fabs(l-r)>eps)
	{
		double mid = (l+r)/2;
		if(check(mid))l=mid;
		else r = mid;
	}
	printf("%.3lf\n",l/2);
	return 0;
}
Problem3233

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5;
int n,a[55];
int f[N+5],prime[N],cnt;
bool vis[N+5];
void quick_prime()
{
	for(int i = 2;i<= N;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<=N;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	quick_prime();
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	memset(f,0x3f,sizeof(f));
	f[1] = 0;
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= N;i++)
	{
		for(int j = 1;j<= cnt&&i*prime[j]<=N;j++)
		{
			int val = i*prime[j];
			ll tmp = 0;
			for(int k = 1;k<= n;k++)
				tmp+=a[k]%val/i;
			if(tmp<=0x3f3f3f3f)
				f[val] = min(f[val],f[i]+(int)tmp);
		}
		ll tmp = f[i];
		for(int k = 1;k<= n;k++)
			tmp+=a[k]/i;
		if(tmp<=0x3f3f3f3f)
			ans = min(ans,(int)tmp);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3238

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
typedef long long ll;
char s[N];
int val[N],newval[N],sa[N],cnt[N],q[N],rank[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rank[sa[i]] = i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
	if(rank[i])
	{
		int j = 0;
		if(i)j=max(0,h[rank[i-1]]-1);
		while(i+j<len&&sa[rank[i]-1]+j<len&&s[i+j]==s[sa[rank[i]-1]+j])j++;
		h[rank[i]] = j;
	}
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]-'a']++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[val[i]]] = i;
	for(int d=1;;d++)
	{
		int id = 0,hl = 1<<(d-1);
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++]=sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]]=q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)newval[sa[k]] = lim;
		}
		for(i = 0;i<len;i++)val[i]=newval[i];
		if(lim==len)break;
	}
}
struct Data
{
	int val,num;
}stack[N];
int main()
{
	scanf("%s",s);
	int n = strlen(s);
	build_sa(n,26);
	build_rank(n);
	build_height(n);
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=(ll)(i+1+n)*(n-i)/2+(ll)i*(n-i);
	int top = 0;
	ll nowans = 0;int nowcnt = 0;
	for(int i = 1;i<n;i++)
	{
		nowcnt = 1;
		while(top>=1&&h[i]<=stack[top].val)
		{
			nowcnt+=stack[top].num;
			nowans-=(ll)stack[top].num*stack[top].val;
			top--;
		}
		stack[++top]=(Data){h[i],nowcnt};
		nowans+=(ll)h[i]*nowcnt;
		ans-=nowans*2;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3238

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 500005;
struct E{int next,to;};
char s[N];
ll ans;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1],size[N<<1],f[N<<1],ct[N<<1],rnk[N<<1];
	int cnt,last;
	bool end[N<<1];
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np] = len[p]+1;
		end[np] = true;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[q] = fa[np] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	void getans(int n)
	{
		ans=0;
		for(int i = 1;i<= cnt;i++)f[i]=size[i]=end[i];
		for(int i=1;i<=cnt;i++) ct[len[i]]++;
		for(int i=1;i<=n;i++) ct[i]+=ct[i-1];
		for(int i=1;i<=cnt;i++) rnk[ct[len[i]]--]=i;
		for(int i=cnt;i;i--) f[fa[rnk[i]]]+=f[rnk[i]];
		for(int i=1;i<=cnt;i++)
		{
			ans+=(ll)size[fa[i]]*f[i]*len[fa[i]];
			size[fa[i]]+=f[i];
		}
	}
}sam;
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	sam.init();
	for(int i = n;i>0;i--)
		sam.insert(s[i]-'a');
	sam.getans(n);
	ans = -2*ans;
	for(int i = 1;i<= n;i++)ans+=(ll)(n-1)*i;
	printf("%lld\n",ans);
	return 0;
}
Problem3251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N=100005;
long long a[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,q,fa[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int dep[N];
void dfs(int x,int f)
{
	fa[x] = f;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
}
long long stack[100];
int top;
bool getans(int x,int y)
{
	top = 0;
	if(dep[y]>dep[x])swap(x,y);
	while(dep[x]>dep[y])
	{
		stack[++top] = a[x];
		if(top>=55)return true;
		x = fa[x];
	}
	while(x!=y)
	{
		stack[++top] = a[x];
		stack[++top] = a[y];
		if(top>=55)return true;
		x = fa[x],y = fa[y];
	}
	stack[++top] = a[x];
	sort(stack+1,stack+top+1);
	for(int i = 1;i<= top-2;i++)
		if(stack[i]+stack[i+1]>stack[i+2])
			return true;
	return false;
}
int main()
{
	//freopen("tree.in","r",stdin);
	//freopen("tree.out","w",stdout);
	int x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%I64d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	int ju;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ju,&x,&y);
		if(ju==0)
		{
			if(getans(x,y))printf("Y\n");
			else printf("N\n");
		}else
			a[x] = y;
	}
	return 0;
}
Problem3254

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int n,m;
const int N = 10;
const int M = 1e4+5;
const ll INF = 1e18;
int E1[M][N],E2[M][N];
int A[M][N],B[M][N],a[M][N];
ll f[M][1<<5],trs[M][1<<5][1<<5];
ll calc(int line,int sta)
{
	ll res = 0;
	int d[10]={0};
	for(int i = 1;i<= n;i++)
		d[i] = (sta>>(i-1))&1;
	for(int i = 1;i<= n;i++)
		res+=(d[i]^a[line][i])*B[line][i];
	for(int i = 1;i<= n;i++)
		res+=(d[i]^d[i%n+1])*E1[line][i];
	return res;
}
int main()
{
	int maxx=0;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&A[j][i]),maxx = max(maxx,A[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&B[j][i]),maxx = max(maxx,B[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 2;j<=m;j++)
			scanf("%d",&E2[j][i]),maxx = max(maxx,E2[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&E1[j][i]),maxx = max(maxx,E1[j][i]);
	int l = 1,cnt=0;
	while(l<=maxx)l<<=1,cnt++;
	//cnt--;
	ll Ans = 0;
	for(int j = 2;j<= m;j++)
		for(int sta = 0;sta<1<<n;sta++)
		{
			for(int pre = 0;pre<1<<n;pre++)
			{
				ll sum = 0;
				for(int i = 0;i< n;i++)
					if(((sta>>i)&1)^((pre>>i)&1))
						sum+=E2[j][i+1];
				trs[j][sta][pre] = sum;
			}
		}
	for(int s = 0;s<cnt;s++)
	{
		for(int j = 1;j<= m;j++)
			for(int i = 1;i<= n;i++)
				a[j][i]=(A[j][i]>>s)&1;
		for(int sta = 0;sta<1<<n;sta++)
			f[1][sta] = calc(1,sta);
		for(int j = 2;j<= m;j++)
			for(int sta = 0;sta<1<<n;sta++)
			{
				f[j][sta] = INF;
				ll tmp = calc(j,sta);
				for(int pre = 0;pre<1<<n;pre++)
					f[j][sta] = min(f[j][sta],f[j-1][pre]+trs[j][sta][pre]+tmp);
			}
		ll tmp = INF;
		for(int i = 0;i<1<<n;i++)
			tmp = min(tmp,f[m][i]);
		Ans += tmp*(1<<s);
	}
	printf("%lld\n",Ans);
	return 0;
}
Problem3261

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 600005;
const int INF = 0x3f3f3f3f;
struct Trie
{
	int cnt;
	int s[N*24][2],sum[N*24];
	int insert(int x,int val)
	{
		int tmp,y;tmp=y=++cnt;
		for(int i = 23;i>=0;i--)
		{
			s[y][0] = s[x][0];
			s[y][1] = s[x][1];
			sum[y]= sum[x]+1;
			int t = val&(1<<i);t = t>>i;
			x=s[x][t];
			s[y][t] = ++cnt;
			y = s[y][t];
		}
		sum[y]=sum[x]+1;
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 23;i>= 0;i--)
		{
			int t = val&(1<<i);t = t>>i;
			if(sum[s[r][t^1]]-sum[s[l][t^1]])
				ans+=(1<<i),r = s[r][t^1],l = s[l][t^1];
			else r = s[r][t],l = s[l][t];
		}
		return ans;
	}
}trie;
int a[N],b[N],root[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);n++;
	for(int i = 2;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)b[i] = b[i-1]^a[i];
	for(int i = 1;i<= n;i++)
		root[i]=trie.insert(root[i-1],b[i]);
	char opt[3];
	int l,r,x;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='A')
		{
			n++;
			scanf("%d",&a[n]);
			b[n] = b[n-1]^a[n];
			root[n] = trie.insert(root[n-1],b[n]);
		}else
		{
			scanf("%d%d%d",&l,&r,&x);
			printf("%d\n",trie.getans(root[l-1],root[r],b[n]^x));
		}
	}
	return 0;
}
Problem3262

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct Treap
{
	Treap *ls,*rs;
	int cnt,size,val,key;
	Treap(int x);
	void push_up();
}*root[N];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	cnt = size = 1;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y>x->val)
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}else
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	x->push_up();
}
int get_rank(Treap *x,int y)
{
	if(!x)return 0;
	int tmp;
	if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(x->val==y)return tmp+x->cnt;
	else if(y>x->val)return tmp+x->cnt+get_rank(x->rs,y);
	else return get_rank(x->ls,y);
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		Insert(root[i],y);
}
int getans(int x,int y)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=get_rank(root[i],y);
	return ans;
}
struct F
{int s,c,m,no;}flower[N];
bool cmp1(const F &a,const F &b)
{
	return a.s<b.s;
}
int id[N],cnt;
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int ans[N],no[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&flower[i].s,&flower[i].c,&flower[i].m);
		id[i] = flower[i].c;
		flower[i].no = i;
	}
	sort(flower+1,flower+n+1,cmp1);
	cnt = 0;
	sort(id+1,id+n+1);
	for(int i = 1;i<= n;i++)
		if(id[i]!=id[cnt])
			id[++cnt] = id[i];
	int st,end;
	for(int i = 1;i<= n;i=end+1)
	{
		st = i,end = i;
		while(flower[end].s==flower[st].s&&end<=n)end++;
		end--;
		for(int j = st;j<=end;j++)
		{
			int pos = find(flower[j].c);
			update(pos,flower[j].m);
		}
		for(int j = st;j<= end;j++)
		{
			int pos = find(flower[j].c);
			int rank = getans(pos,flower[j].m)-1;
			ans[rank]++;
			no[flower[j].no] = rank;
		}
		/*int pos = find(flower[i].c);
		int rank = getans(pos,flower[i].m);
		ans[rank]++;
		update(pos,flower[i].m);*/
	}
	//for(int i= 1;i<= n;i++)
	//	printf("%d : %d\n",i,no[i]);
	for(int i = 0;i< n;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3270

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 25;
const int M = N*N;
const double eps = 1e-8;
struct E{int next,to;}e[2*M];
int id[N][N],Cnt,tot,head[N],n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double f[M][M],cnt[N],p[N],ans[M];
void work()
{
	for(int i = 1;i<= n*n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(f[xn],f[i]);
		for(int line = i+1;line<= n*n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = i;j<=n*n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n*n;i>= 1;i--)
	{
		for(int j = i+1;j<= n*n;j++)
			f[i][n*n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n*n+1]/f[i][i];
	}
}
int main()
{
	int x,y,a,b;
	scanf("%d%d%d%d",&n,&m,&a,&b);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
		cnt[x]+=1.0,cnt[y]+=1.0;
	}
	for(int i = 1;i<= n;i++)
		scanf("%lf",&p[i]);
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<= n;j++)
			id[i][j] = ++Cnt;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= n;j++)
		{
			if(i!=j)
			{
				f[id[i][j]][id[i][j]] -= p[i]*p[j];
				for(int t = head[i];t;t = e[t].next)
					f[id[i][j]][id[e[t].to][j]] -= p[j]*(1-p[i])/cnt[i];
				for(int t = head[j];t;t = e[t].next)
					f[id[i][j]][id[i][e[t].to]] -= p[i]*(1-p[j])/cnt[j];
				for(int t1 = head[i];t1;t1 = e[t1].next)
					for(int t2 = head[j];t2;t2 = e[t2].next)
						f[id[i][j]][id[e[t1].to][e[t2].to]] -= (1-p[i])*(1-p[j])/cnt[i]/cnt[j];
			}
		}
	}
	for(int i = 1;i<= n*n;i++)
		for(int j=1;j<i;j++)
			swap(f[i][j],f[j][i]);
	for(int i = 1;i<= n*n;i++)
		f[i][i]+=1;
	f[id[a][b]][n*n+1] = 1;
	work();
	for(int i = 1;i<= n;i++)
		printf("%.6f ",ans[id[i][i]]);
	return 0;
}
Problem3275

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans=0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF))!=0)
			ans+=nowflow;
	return ans;
}
int a[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
bool check(int x,int y)
{
	if(gcd(x,y)!=1)return false;
	int tmp = x*x+y*y;
	if(((int)sqrt(tmp))*((int)sqrt(tmp))==tmp)return true;
	return false;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int st = 0,end = n+1;
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		if(a[i]&1)add(st,i,a[i]);
		else add(i,end,a[i]);
		sum+=a[i];
	}
	for(int i = 1;i<= n;i++)
		if(a[i]&1)
			for(int j = 1;j<= n;j++)
				if(!(a[j]&1))
					if(check(a[i],a[j]))
						add(i,j,INF);
	int ans = dinic(st,end);
	printf("%d\n",sum-ans);
	return 0;
}
Problem3280

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 1e7+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,fr,f,c;}e[M];
int head[N],tot = 1,from[N];
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f,e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0,e[tot].c=-c;
	e[tot-1].fr=x,e[tot].fr=y;
}
bool v[N];
int dis[N],S,T;
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	Q.push(S);
	v[S] = true;dis[S] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans =0,maxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	maxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(from,0,sizeof(from));
	tot = 1;
	ans=0,maxf=0;
}
int a[N],l[N],p[N],d[N],q[N];
void work()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int sum = 0;
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),sum+=a[i];
	for(int i = 1;i<= m;i++)
		scanf("%d%d",&l[i],&p[i]);
	for(int i = 1;i<= k;i++)
		scanf("%d%d",&d[i],&q[i]);
	S = 0,T = 2*n+m+1;
	for(int i = 1;i<= m;i++)
		add(S,i,l[i],0);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			add(j,m+n+i,INF,p[j]);
	for(int i = 1;i<= n;i++)
	{
		add(m+n+i,T,a[i],0);
		if(i<n)add(m+n+i,m+n+i+1,INF,0);
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= k;j++)
		{
			int to = i+d[j]+1;
			if(to<=n)add(m+i,m+n+to,INF,q[j]);
		}
	for(int i = 1;i<= n;i++)
		add(S,m+i,a[i],0);
	while(spfa())mcf();
	if(maxf==sum)printf("%d\n",ans);
	else printf("impossible\n");
}
int main()
{
	int cas;
	scanf("%d",&cas);
	for(int i = 1;i<= cas;i++)
	{
		printf("Case %d: ",i);
		init();
		work();
	}
	return 0;
}
Problem3282

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,sum;
	bool rev;
	Splay(int x);
	void reverse();
	void push_up();
	void push_down();
}*null = new Splay(0),*tree[N];
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	val = x;sum = x;
	rev = false;
}
void Splay :: reverse()
{
	swap(ls,rs);
	rev ^=1;
}
void Splay :: push_down()
{
	if(this==fa->ls||this==fa->rs)
		fa->push_down();
	if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = 0;
	}
}
void Splay :: push_up()
{
	sum = ls->sum ^ rs->sum ^ val;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	Splay *y,*z;
	x->push_down();
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
Splay* find_root(Splay *x)
{
	while(x->fa!=null)x = x->fa;
	return x;
}
void link(Splay *x,Splay *y)
{
	if(find_root(x)==find_root(y))return ;
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	if(x==y||find_root(x)!=find_root(y))return ;
	move_to_root(x);
	access(y);
	splay(y);
	if(y->ls!=x)return ;
	x->fa = null;
	y->ls = null;
	y->push_up();
}
void change(Splay *x,int y)
{
	splay(x);
	x->val = y;
	x->push_up();
}
void qurey(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	printf("%d\n",y->sum);
}
int main()
{
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		tree[i] = new Splay(x);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&c,&x,&y);
		switch(c)
		{
			case 0:qurey(tree[x],tree[y]);break;
			case 1:link(tree[x],tree[y]);break;
			case 2:cut(tree[x],tree[y]);break;
			case 3:change(tree[x],y);break;
		}
	}
	return 0;
}
Problem3295

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 50005;
int n,m,cnt[N],a[N],b[N],c[N],tim[N],f[M],tot;
long long ans;
void update(int x,int flag)
{
	for(int i = x;i&&i<N;i+=flag*(i&-i))
	{
		if(tim[i]!=tot)
			c[i] = 0,tim[i] = tot;
		c[i]++;
	}
}
int getans(int x,int flag)
{
	int ans = 0;
	for(int i = x;i&&i<N;i+=flag*(i&-i))
		if(tim[i]==tot)
			ans+=c[i];
	return ans;
}
struct A
{
	int x,y,pos;
	bool operator <(const A &b)const
	{return y<b.y;}
}q[N],nq[N];
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)
	{
		printf("%lld\n",ans);
		ans-=cnt[q[mid].y];
		ans+=f[mid];
		return ;
	}
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if(q[i].pos<=mid)
			nq[l1++]=q[i];
		else 
			nq[l2++]=q[i];
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	CDQ(l,mid);
	tot++;int j = l;
	for(int i = mid+1;i<= r;i++)
	{
		for(;j<=mid&&q[j].y<q[i].y;j++)
			update(q[j].x,-1);
		f[q[i].pos]+=getans(q[i].x,1);
	}
	tot++,j = mid;
	for(int i = r;i>=mid+1;i--)
	{
		for(;j>=l&&q[j].y>q[i].y;j--)
			update(q[j].x,1);
		f[q[i].pos]+=getans(q[i].x,-1);
	}
	CDQ(mid+1,r);
	l1=l;l2=mid+1;
    for(int i=l;i<=r;i++)
        if((q[l1]<q[l2]||l2>r)&&l1<=mid)
            nq[i]=q[l1++];
        else
            nq[i]=q[l2++];
    memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		b[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
	{
		cnt[i] = getans(a[i],1);
		update(a[i],-1);
		ans+=cnt[i];
	}
	tot++;
	for(int i = n;i;i--)
	{
		cnt[i] += getans(a[i],-1);
		update(a[i],1);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&q[i].x);
		q[i].y = b[q[i].x];
		q[i].pos = i;
	}
	sort(q+1,q+m+1);
	CDQ(1,m);
	return 0;
}
Problem3307

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 6000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N][25],dep[N],cnt;
void dfs(int x,int f)
{
	fa[x][0] = f;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i =e[i].next)
		if(e[i].to!=fa[x][0])
			dfs(e[i].to,x);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 22;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 22;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int maxn[M],ls[M],rs[M],seg,maxno[M],root[N],n,m;
void update(int &p,int l,int r,int x,int c)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		maxn[p] += c;
		maxno[p] = l;
		if(!maxn[p])maxno[p] =0;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(ls[p],l,mid,x,c);
	else update(rs[p],mid+1,r,x,c);
	if(maxn[ls[p]]>=maxn[rs[p]])
		maxn[p] = maxn[ls[p]],maxno[p] = maxno[ls[p]];
	else 
		maxn[p] = maxn[rs[p]],maxno[p] = maxno[rs[p]];
	if(!maxn[p])maxno[p] =0;
}
int merge(int x,int y,int l,int r)
{
	if(!x||!y)return x+y;
	if(l==r)
	{
		maxn[x] = maxn[x]+maxn[y];
		maxno[x] = l;
		if(!maxn[x])maxno[x] =0;
		return x;
	}
	int mid = (l+r)>>1;
	ls[x] = merge(ls[x],ls[y],l,mid);
	rs[x] = merge(rs[x],rs[y],mid+1,r);
	if(maxn[ls[x]]>=maxn[rs[x]])
		maxn[x] = maxn[ls[x]],maxno[x] = maxno[ls[x]];
	else 
		maxn[x] = maxn[rs[x]],maxno[x] = maxno[rs[x]];
	if(!maxn[x])maxno[x] =0;
	return x;
}
int kind[N],Cnt,ans[N];
int find(int x)
{
	int l = 1,r = Cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(kind[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
struct O
{int x,y,d;}opt[N];
void solve(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa[x][0])
		{
			solve(e[i].to);
			root[x] = merge(root[x],root[e[i].to],1,Cnt);
		}
	}
	ans[x] = kind[maxno[root[x]]];
}
void init()
{
	for(int j= 1;j<= 19;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	init();
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt[i].x,&opt[i].y,&opt[i].d);
		kind[++Cnt] = opt[i].d;
	}
	sort(kind+1,kind+Cnt+1);
	int tmp = Cnt;Cnt = 0;
	for(int i = 1;i<= tmp;i++)
		if(kind[i]!=kind[Cnt])
			kind[++Cnt] = kind[i];
	for(int i = 1;i<= m;i++)
	{
		int pos = find(opt[i].d);
		int lca = getlca(opt[i].x,opt[i].y);
		update(root[opt[i].x],1,Cnt,pos,1);
		update(root[opt[i].y],1,Cnt,pos,1);
		update(root[lca],1,Cnt,pos,-1);
		update(root[fa[lca][0]],1,Cnt,pos,-1);
	}
	solve(1);
	for(int i = 1;i<= n;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3309

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int g[N],last[N],t[N],prime[N/10],cnt;
bool vis[N];
int sum[N];
void quick_mu()
{
	for(int i =2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			g[i] = last[i] = t[i] = 1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			int x = i*prime[j];
			vis[x] = true;
			if(i%prime[j]==0)
			{
				last[x] = last[i];
				t[x] = t[i]+1;
				if(last[x]==1)g[x] = 1;
				else g[x] = (t[last[x]]==t[x]?-g[last[x]]:0);
				break;
			}
			last[x] = i;t[x] = 1;
			g[x] = (t[i]==1?-g[i]:0);
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+g[i];
}
ll getans(int x,int y)
{
	int last;
	ll ans = 0;
	for(int i = 1;i<=x&&i<= y;i = last+1)
	{
		last = min(x/(x/i),y/(y/i));
		ans+=(ll)(x/i)*(y/i)*(sum[last]-sum[i-1]);
	}
	return ans;
}
int main()
{
	int t,n,m;
	scanf("%d",&t);
	quick_mu();
	while(t--)
	{
		scanf("%d%d",&n,&m);
		printf("%lld\n",getans(n,m));
	}
	return 0;
}
Problem3329

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL mod = 1e9+7;
LL f[65][2],ans;
struct Martix
{
	int h,w;
	LL map[4][4];
	Martix(int x,int y)
	{
		h = x;
		w = y;
		memset(map,0,sizeof(map));
	}
	Martix()
	{
		h = w = 0;
		memset(map,0,sizeof(map));
	}
	Martix operator*(const Martix &S)const
	{
		Martix ans(S.w,h);
        for(int i = 1;i<= ans.h;i++)
            for(int j = 1;j<= ans.w;j++)
                for(int k = 1;k<= S.h;k++)
                    (ans.map[i][j]+=map[i][k]*S.map[k][j])%=mod;
		return ans;
	}
};
Martix quick_pow(LL y,const Martix &S) 
{
	if(y==0)
	{
		Martix one(3,3);
		for(int i = 0;i<= 3;i++)
			one.map[i][i] = 1;
		return one;
	}
	Martix tmp = quick_pow(y/2,S);
	if(y&1)return tmp*tmp*S;
	else return tmp*tmp;	
}
void init()
{
	f[1][1] = 1,f[1][0] = 1;
	for(int j = 2;j<= 63;j++)
	{
		f[j][0] = f[j-1][0]+f[j-1][1];
		f[j][1] = f[j-1][0];
	}
}
void work(LL n)
{
	//LL tmp = n;
	int cnt = 63;
    while(n < ((LL)1<<(cnt-1))) cnt--;
	for(int i = 1;i < cnt;i++)
        ans += f[i][1];
	int cur = n / ((LL)1<<(cnt-1));
    int pre = cur;
    n %= ((LL)1<<(cnt-1));
	for(int j = cnt-1;j>=1;j--)
	{
		cur = n/((LL)1<<(j-1));
		if(cur)
			ans+=f[j][0];
		if(cur&&pre)break;
		pre = cur;
		n%=((LL)1<<(j-1));
	}
}
int main()
{
	init();
	int T;
	scanf("%d",&T);
	LL n;
	while(T--)
	{
		scanf("%lld",&n);
		ans = 0;
		work(n+1);
		Martix sta(1,2);
		sta.map[1][1] = 1;sta.map[1][2] = 1;
		Martix go(2,2);
		go.map[1][1] = go.map[1][2] = go.map[2][1] = 1;
		sta = sta*quick_pow(n,go);
		printf("%lld\n%lld\n",ans,sta.map[1][1]);
	}
	return 0;
}
Problem3339

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
int sg[N<<2],lazy[N<<2],fa[N],a[N],fs[N],next[N],last[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
struct A
{int l,r,no,ans;}ask[N];
bool cmp(A a,A b){return a.l<b.l;}
bool fir(A a,A b){return a.no<b.no;}
void build(int p,int l,int r)
{
	lazy[p] = INF;
	if(l==r)
	{
		sg[p] = fs[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sg[p] = max(sg[p<<1],sg[p<<1|1]);
}
void push_down(int p,int l,int r)
{
	if(lazy[p]==INF||l==r)return ;
	sg[p<<1] = min(sg[p<<1],lazy[p]);
	sg[p<<1|1] = min(sg[p<<1|1],lazy[p]);
	lazy[p<<1] = min(lazy[p<<1],lazy[p]);
	lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
	lazy[p] = INF;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sg[p] = min(sg[p],c);
		lazy[p] = min(lazy[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	sg[p] = max(sg[p<<1],sg[p<<1|1]);
}
int getans(int p,int l,int r,int x)
{
	push_down(p,l,r);
	if(l==r)return sg[p];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int main()
{
	int n,q,maxn = 0;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		maxn = max(maxn,a[i]);
		next[last[a[i]]] = i;
		last[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
		if(!next[i])next[i] = n+1;
	for(int i = 1;i<= maxn;i++)
		fa[i] = i;
	fa[maxn+1] = maxn+1;
	for(int i = 1;i<= n;i++)
	{
		fa[a[i]] = a[i]+1;
		fs[i] = getfa(0);
	}
	build(1,1,n);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].no = i;
	}
	sort(ask+1,ask+q+1,cmp);
	ask[0].l = 1;
	for(int i = 1;i<= q;i++)
	{
		for(int j = ask[i-1].l;j<ask[i].l;j++)
			update(1,1,n,j,next[j]-1,a[j]);
		ask[i].ans = getans(1,1,n,ask[i].r);
	}
	sort(ask+1,ask+q+1,fir);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ask[i].ans);
	return 0;
}
Problem3413

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
char s[N],b[N];
int ch[N][10],len[N],fa[N],n,m,fl,cnt=1,last=1,rt[N],pp;
struct E{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int in[N],out[N],dfn,id[N],to[N];
void dfs(int x)
{
	in[x] = ++dfn;
	if(to[x])id[dfn] = n-len[x];
	else id[dfn] = -1;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	out[x] = dfn;
}
int L[N*20],R[N*20],sz[N*20],ID;
void update(int &x,int y,int l,int r,int k)
{
	sz[x = ++ID] = sz[y]+1;
	L[x]=L[y],R[x]=R[y];
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(k<=mid)update(L[x],L[y],l,mid,k);
	else update(R[x],R[y],mid+1,r,k);
}
int getans(int k,int l,int r,int x)
{
	if(!k)return 0;
	if(r<=x)return sz[k];
	int mid = (l+r)>>1;
	int ans = getans(L[k],l,mid,x);
	if(x>mid)ans+=getans(R[k],mid+1,r,x);
	return ans;
}
int getm(int x,int y)
{
	int l = 0,r = n,mid;
	while(l<r)
	{
		mid = (l+r)>>1;
		if(sz[L[y]]-sz[L[x]])
			x = L[x],y = L[y],r = mid;
		else x = R[x],y=R[y],l=mid+1;
	}
	return l;
}
void insert(int x,int y)
{
	int p = last,np = ++cnt,q,nq;
	last = np;len[np] = len[p]+1;
	for(;p&&!ch[p][x];p=fa[p])ch[p][x] = np;
	if(!p)fa[np] = 1;
	else
	{
		q = ch[p][x];
		if(len[q]==len[p]+1)fa[np] = q;
		else
		{
			fa[nq=++cnt]=fa[q];
			len[nq] = len[p]+1;
			memcpy(ch[nq],ch[q],sizeof(ch[q]));
			fa[np] = fa[q] = nq;
			for(;p&&ch[p][x]==q;p=fa[p])ch[p][x] = nq;
		}
	}
	to[last] = y;
}
bool match(int lenb)
{
	int w = 1,ff = 1,i,j;pp = 1;
	for(fl = 0;w<=lenb&&ff;)
		for(ff = 0,i = head[pp];i;i=e[i].next)
			if(s[e[i].val]==b[w])
			{
				int tt = e[i].to;
				for(fl=j=0;j<min(len[tt]-len[pp],lenb-w+1);fl++,j++)
					if(s[e[i].val+j]!=b[w+j])
						return pp=tt,0;
				w+=len[tt]-len[pp];pp=tt;ff=1;break;
			}
	return ff;
}
int v[N];
int main()
{
	scanf("%d%s",&n,s+1);
	for(int i = n;i>=1;i--)
		insert(s[i]-'0',i);
	int p,i,j;
	for(v[1] = 1,i = 1;i<=cnt;i++)
		if(to[i])
			for(p = n,j = i;!v[j];j=fa[j])
				p-=len[j]-len[fa[j]],v[j]=true,add(fa[j],j,p+1);
	dfs(1);
	for(i = 1;i<= dfn;i++)
		if(id[i]>=0)
			update(rt[i],rt[i-1],0,n,id[i]);
		else rt[i] = rt[i-1];
	scanf("%d",&m);
	int ans,w;
	while(m--)
	{
		scanf("%s",b+1);
		int lenb = strlen(b+1);
		ans = w = match(lenb)?getm(rt[in[pp]-1],rt[out[pp]]):n;
		for(ans+=fl*(getans(rt[out[pp]],0,n,w)-getans(rt[in[pp]-1],0,n,w)),pp=fa[pp];pp;pp=fa[pp])
            ans+=(len[pp]-len[fa[pp]])*(getans(rt[out[pp]],0,n,w)-getans(rt[in[pp]-1],0,n,w));
        printf("%d\n",ans);
	}
	return 0;
}
Problem3414

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
int er[N],la[N],beg[N],lef[N],now[N];
int who[N],when[N],how[N],n,m;
bool check(int e)
{
	memset(er,0x3f,sizeof(er));
	memset(la,0,sizeof(la));
	memset(beg,0,sizeof(beg));
	memset(lef,0,sizeof(lef));
	memset(now,0,sizeof(now));
	int maxn = 0;
	for(int i=1;i<= e;i++)
	{
		er[who[i]] = min(er[who[i]],when[i]);
		la[who[i]] = max(la[who[i]],when[i]);
		maxn = max(maxn,when[i]);
		if(!now[when[i]]||now[when[i]]==how[i]+1)now[when[i]] = how[i]+1;
		else return false;
	}
	for(int i = 1;i<= n;i++)
		if(er[i]!=INF)
			beg[er[i]]++,lef[la[i]]++;
	int tot=0,peop = 0,ended = 0,notbegin = 0;
	for(int i=1;i<=maxn;i++)
	if(now[i])
	{
		peop+=beg[i];
		if(peop>now[i])return false;
		if(beg[i]<=notbegin)notbegin-=beg[i];
		else tot+=beg[i]-notbegin,notbegin = 0;
		if(peop+notbegin+ended<now[i])tot += now[i]-peop-notbegin-ended,notbegin = now[i]-peop-ended;
		else
		{
			if(peop+notbegin>now[i])notbegin=now[i]-peop,ended=0;
			else ended=now[i]-peop-notbegin;
		}
		peop-=lef[i];ended+=lef[i];
	}
	if(tot>n)return false;
	return true;
}
void work()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&when[i],&who[i],&how[i]);
	int l = 1,r = m+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(mid))l = mid+1;
		else r = mid;
	}
	printf("%d\n",l-1);
}	
int main()
{
	int c;
	scanf("%d",&c);
	while(c--)
		work();
	return 0;
}
Problem3416

#include <stdio.h>
#include <vector>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
bool last[N<<1];
char in[N];
int a[N],q[N],t;
vector<int>ans[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	scanf("%s",in+1);
	for(int i = 1;i<= n;i++)
	{
		if(in[i]=='c')a[i] = a[i-1]-k;
		else a[i] = a[i-1]+1;
	}
	int cnt = 0;
	last[n] = true;
	for(int i = 1;i<= n;i++)
	{
		a[i]+=n;
		if(last[a[i]])
		{
			cnt++;
			for(int j = t-k+1;j<= t;j++)
				ans[cnt].push_back(q[j]),last[a[q[j]]] = false;
			ans[cnt].push_back(i);
			t-=k;
		}else
		{
			t++;
			q[t] = i;
			last[a[i]] =true;
		}
	}
	for(int i = cnt;i>=1;i--)
	{
		for(unsigned int j = 0;j<ans[i].size();j++)
			printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
Problem3417

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const int K = 1e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct A
{int s,t,k,no,ans;}ask[K];
bool cmp1(A a,A b){return a.s<b.s;}
bool cmp2(A a,A b){return a.no<b.no;}
queue<int>Q;
int f[N],g[N];
bool v[N];
void spfa(int s)
{
	memset(f,0x3f,sizeof(f));
	memset(g,0x3f,sizeof(g));
	Q.push(s);
	f[s] = 0;
	v[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i = e[i].next)
		{
			if(f[x]+1<g[e[i].to]||g[x]+1<f[e[i].to])
			{
				f[e[i].to] = min(f[e[i].to],g[x]+1);
				g[e[i].to] = min(g[e[i].to],f[x]+1);
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
			else if(e[i].to==s)
			{
				if(f[s]==0)f[s] = g[x]+1,g[s] = f[x]+1;
				else f[s] = min(g[x]+1,f[s]),g[s] = min(f[x]+1,g[s]);
			}
		}
	}
	if(f[s]==0)f[s] = 0x3f3f3f3f;
}
int main()
{
	int n,m,k,x,y;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%d",&ask[i].s,&ask[i].t,&ask[i].k);
		ask[i].no = i;
	}
	sort(ask+1,ask+k+1,cmp1);
	int j = 0;
	for(int i = 1;i<= k;i++)
	{
		if(ask[i].s!=j)
		{
			spfa(ask[i].s);
			j = ask[i].s;
		}
		if(ask[i].k%2==1)
			{if(g[ask[i].t]<=ask[i].k)ask[i].ans = 1;}
		else {if(f[ask[i].t]<=ask[i].k)ask[i].ans = 1;}
	}
	sort(ask+1,ask+k+1,cmp2);
	for(int i = 1;i<= k;i++)
	{
		if(ask[i].ans)printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem3419

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 500005;
LL a[N];
bool cmp(LL a,LL b)
{
	return a>b;
}
int main()
{
	//freopen("tak.in","r",stdin);
	//freopen("tak.out","w",stdout);
	int n;
	LL m,d;
	scanf("%lld%lld%d",&m,&d,&n);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	sort(a+1,a+n+1,cmp);
	if(a[1]>=m+d){printf("1\n");return 0;}
	int sec = 0;
	for(int i = 1;i<= n;i++)
		if(a[i]>=m-d)sec = i;
	if(sec==0){printf("0\n");return 0;}
	int ans = 1;
	LL back = 0;
	for(int i=1;i<=n;i++)
	{
		if(i==sec) continue;
		if(back>=d||m-back+d-back<=a[sec]) break;
		if(a[i]<=d-back) {puts("0");return 0;}
		ans++;
		back+=a[i]-(d-back);
		if(back>=m) {ans--;break;}
	}
	if(m-back+d-back>a[sec]) puts("0");
	else printf("%d\n",ans);
	return 0;
}
Problem3420

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N =300005;
typedef long long LL;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
LL f[N];
bool is_leaf[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int ans;
void dfs(int x,int fa)
{
	is_leaf[x] = true;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			is_leaf[x] = false;
			dfs(e[i].to,x);
			f[x]+=f[e[i].to]+1;
		}
	f[x]-=ans;
	f[x] = max(f[x],(LL)0);
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	int l = 0,r = n-1;
	while(l<r)
	{
		ans = (l+r)>>1;
		memset(f,0,sizeof(f));
		dfs(1,0);
		if(f[1]!=0)l = ans+1;
		else r = ans;
	}
	printf("%d\n",l);
	return 0;
}
Problem3425

#include <stdio.h>
#include <bitset>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 250005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
bitset<N>F;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int size[N],tb[N];
int root,dirr,n;
LL ans;
void dfs(int x,int fa)
{
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(fa!=e[i].to)
		{
			dfs(e[i].to,x);
			size[x]+=size[e[i].to];
			tb[x] = max(tb[x],size[e[i].to]);
		}
	}
	tb[x] = max(tb[x],n-size[x]);
	if(tb[x]<tb[root])
	{
		root = x;
		dirr = fa;
	}
}
int ts[N];
void getpre(int x,int fa,int dep)
{
	ans+=dep;
	ts[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			getpre(e[i].to,x,dep+1);
			ts[x]+=ts[e[i].to];
		}
	}
}
void solve1(int x)
{
	F[0] = 1;
	for(int i = head[x];i;i = e[i].next)
		F |= F<<ts[e[i].to];
	LL tmp = 0;
	for(int i = 1;i<= n;i++)
		if(F[i])
			tmp = max(tmp,(LL)i*(n-i-1));
	ans+=tmp;
}
int heap[N],cnt;
void solve2(int x)
{
	for(int i = head[x];i;i =e[i].next)
	{
		heap[++cnt] = ts[e[i].to];
		push_heap(heap+1,heap+cnt+1);
	}
	while(cnt>=2)
	{
		int t1 = heap[1];
		pop_heap(heap+1,heap+cnt+1);cnt--;
		int t2 = heap[1];
		pop_heap(heap+1,heap+cnt+1);cnt--;
		heap[++cnt] = abs(t1-t2);
		push_heap(heap+1,heap+cnt+1);
	}
	ans+=(LL)((n-1+heap[1])/2)*((n-1-heap[1])/2);
}
int d[N];
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		d[x]++;d[y]++;
	}
	tb[0] = INF;
	dfs(1,0);
	getpre(root,0,0);
	if(d[root]<=800)
		solve1(root);
	else solve2(root);
	printf("%d %lld\n",n-1,ans);
	return 0;
}
Problem3426

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const int M = 1000005;
struct E
{int next,to;}e[M<<1];
int head[N],tot;
bool u1[N],u2[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void cover2(int x)
{
	u1[x] = true;
	for(int i = head[x];i;i = e[i].next)
		u1[e[i].to] = true;
	return ;
}
void cover1(int x)
{
	u1[x] = u2[x] = true;
	for(int i = head[x];i;i =e[i].next)
	{
		if(u2[e[i].to])continue;
		u2[e[i].to] = true;
		cover2(e[i].to);
	}
	return ;
}
int ans[N],cnt;
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(!u1[i])
		{
			ans[++cnt] = i;
			cover1(i);
		}
	printf("%d\n",cnt);
	for(int i = 1;i<cnt;i++)
		printf("%d ",ans[i]);
	printf("%d",ans[cnt]);
	return 0;
}
Problem3427

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int INF = 707185547;
int f[N][3];
int a[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	f[1][0] = f[1][1] = f[1][2] = INF;
	if(a[1]==-1)f[1][0] = 0;
	else if(a[1]==0)f[1][1] = 0;
	else f[1][2] = 0;
	for(int i = 2;i<= n;i++)
	{
		f[i][0] = f[i-1][0]+a[i]+1;
		if(a[i]==-1)
		{
			if(a[i-1]==1)f[i][1] = min(f[i-1][1],f[i-1][0])+1;
			else f[i][1] = INF;
		}else if(a[i]==0)f[i][1] = min(f[i-1][1],f[i-1][0]);
		else
		{
			if(a[i-1]==-1)f[i][1] = min(f[i-1][1],f[i-1][0])+1;
			else f[i][1] = f[i-1][0]+1;
		}
		if(a[i]==-1)
		{
			if(a[i-1]==1)f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+2;
			else f[i][2] = f[i-1][2]+2;
		}else if(a[i]==0)
		{
			if(a[i-1]==1)f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+1;
			else f[i][2] = f[i-1][2]+1;
		}else f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
	}
	int ans = min(f[n][0],min(f[n][1],f[n][2]));
	if(ans>=INF)printf("BRAK\n");
	else printf("%d\n",ans);
	return 0;
}
Problem3438

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e3+5;
const int M = 5e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot = 1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].flow = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].flow = 0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int a[N],b[N],c1[N],c2[N];
int main()
{
	int n;
	scanf("%d",&n);
	int st = 0,end = n+1;
	int id = n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	int m,k,x,ans = 0;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&k,&c1[i],&c2[i]);
		ans+=c1[i]+c2[i];
		add(st,id+1,c1[i]),add(id+2,end,c2[i]);
		for(int j = 1;j<=k;j++)
		{
			scanf("%d",&x);
			add(id+1,x,INF);add(x,id+2,INF);
		}
		id+=2;
	}
	for(int i = 1;i<= n;i++)add(st,i,a[i]),ans+=a[i];
	for(int i = 1;i<= n;i++)add(i,end,b[i]),ans+=b[i];
	ans-=dinic(st,end);
	printf("%d\n",ans);
	return 0;
}
Problem3439

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int ch[N][26],tot=1;
char s[N];
vector<int>end[N];
void insert(int no)
{
	int i = strlen(s+1),p = 1;
	while(i)
	{
		if(!ch[p][s[i]-'a'])ch[p][s[i]-'a'] = ++tot;
		p = ch[p][s[i]-'a'];
		i--;
	}
	end[p].push_back(no);
}
int ls[N*20],rs[N*20],root[N],sum[N*20],cnt;
int a[N],in[N],out[N],Dfn;
void dfs(int x)
{
	int num = Dfn;
	for(int i= 0;i<end[x].size();i++)a[++Dfn] = end[x][i];
	for(int i = 0;i<26;i++)
		if(ch[x][i])
			dfs(ch[x][i]);
	for(int i = 0;i<end[x].size();i++)
		in[end[x][i]] = num,out[end[x][i]] = Dfn;
}
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p] = sum[pre]+1;
		return ;
	}
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int x,int y,int l,int r,int k)
{
	int mid = (l+r)>>1;
	if(l==r)return l;
	if(sum[y]-sum[x]<k)return -1;
	if(sum[ls[y]]-sum[ls[x]]>=k)return getans(ls[x],ls[y],l,mid,k);
	else return getans(rs[x],rs[y],mid+1,r,k-sum[ls[y]]+sum[ls[x]]);
}
int main()
{
	int n,k;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		insert(i);
	}
	dfs(1);
	root[0]=ls[0]=rs[0]=sum[0]=0;
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],1,n,a[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		printf("%d\n",getans(root[in[i]],root[out[i]],1,n,k));
	}
	return 0;
}
Problem3450

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
char m[N];
double l[N],f[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",m+1);
	for(int i = 1;i<= n;i++)
	{
		if(m[i]=='o')
		{
			l[i] = l[i-1]+1;
			f[i] = f[i-1]+2*l[i-1]+1;
		}else if(m[i]=='x')
		{
			l[i] = 0;
			f[i] = f[i-1];
		}else
		{
			l[i] = 0.5*(l[i-1]+1);
			f[i] = 0.5*(f[i-1])+0.5*(f[i-1]+2*l[i-1]+1);
		}
	}
	printf("%.4f\n",f[n]);
	return 0;
}
Problem3456

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<18;
typedef long long ll;
const int mod = 1004535809;
int fac[N],env[N],cnt;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y = y>>1;
	}
	return res;
}
int a[N],b[N],c[N];
void NTT(int *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = (len>>1);(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		int wn = quick_pow(3,(mod-1)/i);
		for(int j = 0;j<len;j+=i)
		{
			int w = 1,tmp;
			for(int k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
			{
				tmp = (ll)a[j+k+(i>>1)]*w%mod;
				a[j+k+(i>>1)]=(a[j+k]-tmp+mod)%mod;
				a[j+k] = (a[j+k]+tmp)%mod;
			}
		}
	}
	if(type==-1)
	{
		for(int i = 1;i<(len>>1);i++)
			swap(a[i],a[len-i]);
		int Inv = quick_pow(len,mod-2);
		for(int i = 0;i<len;i++)
			a[i] = (ll)a[i]*Inv%mod;
	}
	/*printf("#case %d:",++cnt);
	for(int i = 0;i<len;i++)
		printf("%d ",a[i]);
	printf("\n");*/
}
void Get_Inv(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = quick_pow(a[0],mod-2);
		return ;
	}
	Get_Inv(a,b,len>>1);
	static int tmp[N];
	memcpy(tmp,a,sizeof(int)*len);
	memset(tmp+len,0,sizeof(int)*len);
	NTT(tmp,len<<1,1);
	NTT(b,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i]=(ll)b[i]*(2-(ll)b[i]*tmp[i]%mod+mod)%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(int)*len);
}
int C(int n)
{
	return ((ll)n*(n-1)>>1)%(mod-1);
}
int main()
{
	int n,m=1;
	scanf("%d",&n);
	for(m=1;m<=n;m<<=1);
	fac[0]=1,env[0]=1;
	for(int i =1;i<=m;i++)
		fac[i] = (ll)fac[i-1]*i%mod;
	env[m] = quick_pow(fac[m],mod-2);
	for(int i = m-1;i>=1;i--)
		env[i] = (ll)env[i+1]*(i+1)%mod;
	for(int i = 0;i< m;i++)
		b[i] = (ll)quick_pow(2,C(i))*env[i]%mod;
	for(int i = 1;i< m;i++)
		c[i] = (ll)quick_pow(2,C(i))*env[i-1]%mod;
	static int tmp[N];
	memset(tmp,0,sizeof(tmp));
	Get_Inv(b,tmp,m);
	NTT(c,m<<1,1);
	NTT(tmp,m<<1,1);
	for(int i = 0;i<m<<1;i++)a[i]=(ll)c[i]*tmp[i]%mod;
	NTT(a,m<<1,-1);
	printf("%lld\n",(ll)a[n]*fac[n-1]%mod);
	return 0;
}
Problem3460

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,m,key;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int top[N],size[N],son[N],fa[N],dep[N],q[N],rk[N],a[N];
void dfs(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
	}
}
int seq[N],Dfn,in[N],out[N];
void dfs2(int x,int tp)
{
	top[x] = tp;
	in[x] = ++Dfn;seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	out[x] = ++Dfn;seq[Dfn] = x;
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	else return y;
}
struct data
{
	int x,y,k;
	data(int _x=0,int _y=0,int _k=0):x(_x),y(_y),k(_k){}
}b[N];
int cnt;
ll c[N],ans[N],res;
bool vis[N];
void Add(int x,ll y)
{
	for(int i = x;i<=n;i+=i&(-i))
		c[i]+=y;
}
ll Getans(int x)
{
	ll ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void Insert(int x,int y)
{
	int lca = getlca(x,y);
	if(in[x]>in[y])swap(x,y);
	cnt++;
	b[cnt] = data(lca==x?in[x]:out[x],in[y],cnt+1);
}
int per;
void update(int y)
{
	int x = rk[y];
	vis[y]^=1;
	if(vis[y])
	{
		per++;
		Add(x,(ll)a[y]*n+1);
		ll z = Getans(x)-1;
		res+=(ll)a[y]*(per-z%n-1)+z/n;
	}else
	{
		ll z = Getans(x)-1;
		res-=(ll)a[y]*(per-z%n-1)+z/n;
		per--;
		Add(x,-((ll)a[y]*n+1));
	}
}
int bl;
bool cmp1(int x,int y)
{
	return a[x]<a[y];
}
bool cmp2(const data &a,const data &b)
{
	if(a.x/bl==b.x/bl)return a.y<b.y;
	return a.x/bl<b.x/bl;
}
int main()
{
	int root =0;
	scanf("%d%d%d",&n,&m,&key);
	bl = sqrt(2*n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),q[i]=i;
	sort(q+1,q+n+1,cmp1);
	for(int i=1;i<= n;i++)rk[q[i]]=i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&fa[i]);
		if(fa[i])add(fa[i],i);
		else root = i;
	}
	dfs(root);dfs2(root,root);
	int x=1,y;char opt[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s%d",opt,&y);
		if(opt[0]=='C')x=y;
		else
		{
			Insert(x,y%n+1);
			Insert(x,(y+key)%n+1);
		}
	}
	sort(b+1,b+cnt+1,cmp2);
	int l = 1,r = 0;res = 0;
	for(int i = 1;i<= cnt;i++)
	{
		while(l<b[i].x)update(seq[l]),l++;
		while(b[i].x<l)l--,update(seq[l]);
		while(r<b[i].y)r++,update(seq[r]);
		while(b[i].y<r)update(seq[r]),r--;
		x=seq[l]; y=seq[r]; int z=getlca(x,y);
		if (x!=z) update(z); 
		ans[b[i].k]=res; 
		if (x!=z) update(z);
	}
	ll tmp = 0;
	for(int i = 1;i<= cnt>>1;i++)
	{
		tmp = ans[i<<1|(tmp&1)];
		printf("%lld\n",tmp);
	}
	return 0;
}
Problem3473

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
char s[N];
struct E{int next,to;};
int id[N],in[N],out[N],Dfn,num[N],n,k,to[N];
ll ans[N];
int last,cnt;
int trs[N][26],fa[N],len[N];
vector<int>ed[N];
bool v[N];
struct Gragh
{
	E e[N];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}
	void dfs(int x)
	{
		id[++Dfn] = x;
		in[x] = Dfn;
		for(int i = head[x];i;i=e[i].next)
			dfs(e[i].to);
		out[x] = Dfn;
	}
	void getans(int x,ll Ans)
	{
		if(num[x]>=k)Ans+=len[x]-len[fa[x]];
		for(int i = 0;i<ed[x].size();i++)
			ans[ed[x][i]]+=Ans;
		for(int i = head[x];i;i=e[i].next)
			getans(e[i].to,Ans);
	}
}g1,g2;
void init(){last=cnt=1;}
int insert(int x,int y)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq] = len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
			}
		}
	}
	ed[last].push_back(y);
	return last;
}
void build()
{
	for(int i = 1;i<= cnt;i++)
		g1.add(fa[i],i);
	g1.dfs(1);
}
int c[N];
void update(int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int lst[N];
struct Ask
{
	int l,r,no;
	bool operator<(const Ask &s)const
	{
		return r<s.r;
	}
}ask[N];
int pos[N];
int main()
{
	scanf("%d%d",&n,&k);
	init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1);
		last = 1;
		for(int j = 1;j<= l;j++)
		{
			int tmp=insert(s[j]-'a',i);
			g2.add(tmp,i);
		}
	}
	build();
	for(int i = 1;i<=cnt;i++)
		ask[i] = (Ask){in[i],out[i],i};
	sort(ask+1,ask+cnt+1);
	int tt = 1;
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = g2.head[id[i]];j;j=g2.e[j].next)
		{
			int p = g2.e[j].to;
			if(lst[p])update(lst[p],-1);
			update(i,1);
			lst[p] = i;
		}
		for(;ask[tt].r==i;tt++)
			num[ask[tt].no]=getans(ask[tt].r)-getans(ask[tt].l-1);
	}
	g1.getans(1,0);
	for(int i = 1;i<= n;i++)
		printf("%lld ",ans[i]);
	printf("\n");
	return 0;
}
Problem3489

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stack>
#include <algorithm>
#define Maxn 200010
#define l(x) ch[x][0]
#define r(x) ch[x][1]
#define lc(x) c[x][0]
#define rc(x) c[x][1]
using namespace std;
int n,m,tot=0,_tot=0,tree[Maxn]={0};
int a[Maxn],last[Maxn],pos[Maxn],next[Maxn],N,rank[Maxn];
int maxt[40000005],ch[40000010][2];
int c[2000010][2],root[2000010];
stack<int> _mL,mL;
int get()
{
	if(mL.empty()) return ++tot;
	int tp=mL.top();
	mL.pop();
	return tp;
}
int _get()
{
	if(_mL.empty()) return ++_tot;
	int tp=_mL.top();
	_mL.pop();
	return tp;
}
int _change(int o,int l,int r,int qx,int qv)
{
    int x=++_tot; maxt[x]=max(maxt[o],qv);
    l(x)=l(o); r(x)=r(o);
    if(l==r) return x;
    int mid=(l+r)>>1;
    if(qx<=mid) l(x)=_change(l(x),l,mid,qx,qv);
    else r(x)=_change(r(x),mid+1,r,qx,qv);
    return x;
}
int _query(int o,int l,int r,int ql,int qr)
{
	if(!o) return 0;
    if(ql<=l&&r<=qr) return maxt[o];
    int mid=(l+r)>>1,res=0;
    if(ql<=mid) res=max(res,_query(l(o),l,mid,ql,qr));
    if(mid<qr) res=max(res,_query(r(o),mid+1,r,ql,qr));
    return res;
}
int query(int o,int l,int r,int ql,int qr,int qa,int qb)
{
    if(ql<=l&&r<=qr) return _query(root[o],1,n,qa,qb);
    int mid=(l+r)>>1,res=0;
    if(ql<=mid) res=max(res,query(lc(o),l,mid,ql,qr,qa,qb));
    if(mid<qr) res=max(res,query(rc(o),mid+1,r,ql,qr,qa,qb));
    return res;
}
int change(int o,int l,int r,int qx,int qy,int qv)
{
    int x=++tot;
    lc(x)=lc(o); rc(x)=rc(o);
    root[x]=_change(root[o],1,n,qy,qv);
    if(l==r) return x;
    int mid=(l+r)>>1;
    if(qx<=mid) lc(x)=change(lc(o),l,mid,qx,qy,qv);
    else rc(x)=change(rc(o),mid+1,r,qx,qy,qv);
    return x;
}
bool cmp(const int &a,const int &b){return last[a]<last[b];}
int main()
{
    scanf("%d%d",&n,&m);
    memset(last,0,sizeof(last));
    for(int i=1;i<=n;i++) pos[i]=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        last[i]=pos[a[i]],pos[a[i]]=i;
    }
    memset(next,0,sizeof(next));
    for(int i=1;i<=n;i++) pos[i]=n+1;
    for(int i=n;i>=1;i--)
    {
        rank[i]=i;
        next[i]=pos[a[i]],pos[a[i]]=i;
    }
    sort(rank+1,rank+n+1,cmp);
    int j=1,ans=0,l,r;
    for(int i=0;i<n;i++)
    {
        if(i) tree[i]=tree[i-1];
        while(j<=n&&last[rank[j]]==i)
        {
            tree[i]=change(tree[i],0,n+1,next[rank[j]],rank[j],a[rank[j]]);
            j++;
        }
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&l,&r);
        l=(l+ans)%n+1;
        r=(r+ans)%n+1;
        if(l>r) swap(l,r);
        ans=query(tree[l-1],0,n+1,r+1,n+1,l,r);
        printf("%d\n",ans);
    }
    return 0;
}
Problem3505

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
int gcd(int x,int y)
{
	if(x==0)return y;
	return gcd(y%x,x);
}
int main()
{
	LL n,m;
	scanf("%lld%lld",&n,&m);
	n++;m++;
	LL ans = n*m*(n*m-1)*(n*m-2);
	ans = ans/(LL)6;
	for(int i = 0;i< n;i++)
	{
		for(int j = 0;j< m;j++)
		{
			LL len = min(i,j);
			if(!i)len = j-1;
			if(!j)len = i-1;
			if(i&&j)len = gcd(i,j)-1;
			len = max(0ll,len);
			if(len==0)continue;
			if(i&&j)ans-=len*(n-i)*(m-j)*2;
			else ans-=len*(n-i)*(m-j);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3509

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mxs = 30005;
const int N = 1e5+5;
const int size = 1800;
const double PI = 3.14159265358979323;
int n;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}a[524299],b[524299];

int num[N],pos[N],L[N],R[N];
int st[N],end[N],tot,lim;
int cnt[400][60005];
int cnt_nxt[60005],cnt_pre[60005];
ll ans[N];

void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*2*type/i),sin(PI*2*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = a[j+k+(i>>1)]*w;
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}	
	if(type==-1)
		for(int i = 0;i<len;i++)a[i].x/=len*4,a[i].y/=len;
}

void conv(int len)
{
	memset(a,0,sizeof(cp)*(len+1));
	memset(b,0,sizeof(cp)*(len+1));
	for(int i = 0;i<=lim;i++)a[i] = cp(L[i]+R[i],L[i]-R[i]);
	FFT(a,len,1);
	for(int i = 0;i<len;i++)b[i]=a[i]*a[i];
	FFT(b,len,-1);
	for(int i = 0;i<len;i++)ans[i] = (ll)(b[i].x+0.5);
}

void div_block()
{
	for(int i = 1;i<= n;i++)pos[i] = (i-1)/size+1;
	tot = pos[n];
	for(int i = 1;i<= tot;i++)st[i] = (i-1)*size+1,end[i] = i*size;
	end[tot] =n;
	for(int i = 1;i<= tot;i++)
		for(int j = st[i];j<=end[i];j++)
			cnt[i][num[j]]++;
}
int len;
void init()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&num[i]);
	for(int i = 1;i<= n;i++)lim=max(lim,num[i]);
	len = 1;
	for(;len<=2*lim;len<<=1);
}

ll res;
void calc(int p)
{
	int t = num[p]<<1;
	int cur = pos[p];
	for(int i = st[cur];i<p;i++)if(t>=num[i])res+=R[t-num[i]];
	for(int i = p+1;i<= end[cur];i++)
		if(t>=num[i])
		{
			res+=cnt_pre[t-num[i]];
			res+=L[t-num[i]];
			if (cur == 1) continue;
		}
	if (p <= end[1] || p >= st[tot]) return;
    res += ans[t];
}

void solve()
{
	for(int i = 1;i<= n;i++)R[num[i]]++;
	for(int i = 1;i<= tot;i++)
	{
		memset(cnt_pre,0,sizeof(int)*(lim+1));
		for(int j = st[i];j<=end[i];j++)cnt_nxt[num[j]]++;
		for(int j = 0;j<= lim;j++)R[j]-=cnt[i][j];
		if(i!=1&&i!=tot)conv(len);
		for(int j = st[i];j<= end[i];j++)
		{
			cnt_nxt[num[j]]--;
			calc(j);
			cnt_pre[num[j]]++;
		}
		for(int j = 0;j<= lim;j++)L[j]+=cnt[i][j];
		//printf("%lld\n",res);
	}
	printf("%lld\n",res);
}
int main()
{
	//freopen("3509.in","r",stdin);
	//freopen("3509.out","w",stdout);
	init();
	div_block();
	solve();
	return 0;
}
Problem3521

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 0x3f3f3f3f;
int v[N],stack[N],top,nxt[N],fv[N],b[N],pre[N];
char s[N];
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
	{
		if(s[i]=='p')pre[i] = pre[i-1]+1;
		else pre[i] = pre[i-1]-1;
	}
	for(int i = 1;i<= n;i++)
	{
		while(top>0&&pre[i]-pre[stack[top]-1]<0)
		{
			nxt[stack[top]] = i-1;
			top--;
		}
		if(top)fv[i] = stack[1];
		else if(pre[i]-pre[i-1]==1)fv[i] = i;
		else fv[i] = INF;
		if(pre[i]-pre[i-1]==1)stack[++top] = i;
	}
	while(top>0)
	{
		nxt[stack[top]] = n;
		top--;
	}
	int L,R,mid,head = 0;
	for(int i = n;i>= 1;i--)
	{
		while(top>0&&pre[stack[top]]-pre[i-1]<0)
		{
			L = 2,R = head+1;
			while(L<R)
			{
				mid = (L+R)>>1;
				if(nxt[b[mid]]>=stack[top])L = mid+1;
				else R = mid;
			}
			ans = max(ans,stack[top]-max(fv[stack[top]]-1,b[L-1]-1));
			top--;
		}
		if(pre[i]-pre[i-1]==1)
		{
			stack[++top] = i;
			while(head&&nxt[b[head]]<=nxt[i])head--;
			b[++head] = i;
		}
	}
	while(top>0)
	{
		L = 2,R = head+1;
		while(L<R)
		{
			mid = (L+R)>>1;
			if(nxt[b[mid]]>=stack[top])L = mid+1;
			else R = mid;
		}
		ans = max(ans,stack[top]-max(fv[stack[top]]-1,b[L-1]-1));
		top--;
	}
	printf("%d\n",ans);
	return 0;
}
Problem3522

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
typedef long long LL;
struct E
{int next,to;}e[N<<1];
int head[N],tot,tmp[N],g[N],f[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa,int dep)
{
	tmp[dep]++;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,dep+1);
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	LL ans = 0;
	for(int rt = 1;rt<= n;rt++)
	{
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		for(int i = head[rt];i;i = e[i].next)
		{
			memset(tmp,0,sizeof(tmp));
			dfs(e[i].to,rt,1);	
			for(int j = 1;j<= n;j++)
			{
				ans+=(LL)g[j]*tmp[j];
				g[j]+=f[j]*tmp[j];
				f[j]+=tmp[j];
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3523

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
struct H
{
	int col,num,se;
}heap[N];
bool cmp(H a,H b)
{
	if(a.num!=b.num)
		return a.num<b.num;
	return a.se<b.se;
}
int a[N],ans[N],cnt;
int main()
{
	int n,s,t;
	scanf("%d%d%d",&n,&s,&t);
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum = sum+a[i];
	}
	if(sum==1&&s==t)
		{printf("%d\n",1);return 0;}
	else if(sum==1){printf("0\n");return 0;}
	for(int i = 1;i<= n;i++)
	{
		if(a[i]-(i==s)-(i==t)>0)
		{
		heap[++cnt].col = i;
		heap[cnt].num = a[i]-(i==s)-(i==t);
		heap[cnt].se = i==t;
		push_heap(heap+1,heap+cnt+1,cmp);
		}else if(a[i]-(i==s)-(i==t)<0)
		{printf("0\n");return 0;}
	}
	int i;
	ans[1] = s,ans[sum] = t; 
	for(i = 2;i< sum;i++)
	{
		H x = heap[1];
		pop_heap(heap+1,heap+1+cnt,cmp);
		cnt--;
		if(x.col==ans[i-1]&&cnt!=0)
		{
			H tmp = x;
			x = heap[1];
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			ans[i] = x.col;
			x.num--;
			if(x.num)
			{
				heap[++cnt] = x;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
			heap[++cnt] = tmp;
			push_heap(heap+1,heap+cnt+1,cmp);
			continue;
		}
		else if(x.col!=ans[i-1])
		{
			ans[i] = x.col;
			x.num--;
			if(x.num)
			{
				heap[++cnt] = x;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
		if(!cnt&&ans[i]==0)
			{printf("0\n");return 0;}
	}
	if(ans[sum]!=ans[sum-1]||sum==1)
	{
		for(i = 1;i< sum;i++)
			printf("%d ",ans[i]);
		printf("%d\n",ans[sum]);
	}
	else printf("0\n");
	return 0;
}
Problem3524

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 1e7+5;
int root[N];
int ls[M],rs[M],sum[M];
int cnt,n,m;
void update(int l,int r,int rt1,int &rt2,int v)
{
	rt2 = ++cnt;
	sum[rt2] = sum[rt1]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[rt2] = ls[rt1],rs[rt2] = rs[rt1];
	if(v<=mid)update(l,mid,ls[rt1],ls[rt2],v);
	else update(mid+1,r,rs[rt1],rs[rt2],v);
}
int ask(int L,int R)
{
	int l,r,tmp = (R-L+1)>>1;
	int rt1 = root[L-1],rt2 = root[R];
	l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[rt2]-sum[rt1]<=tmp)return 0;
		if(sum[ls[rt2]]-sum[ls[rt1]]>tmp)
		{
			r = mid;
			rt1 = ls[rt1],rt2 = ls[rt2];
		}else if(sum[rs[rt2]]-sum[rs[rt1]]>tmp)
		{
			l = mid+1;
			rt1 = rs[rt1],rt2 = rs[rt2];
		}
		else return 0;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		int x;
		scanf("%d",&x);
		update(1,n,root[i-1],root[i],x);
	}
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",ask(x,y));
	}
	return 0;
}
Problem3527

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double x=0,double y=0):x(x),y(y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int len,int type)
{
	int t=0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*type*2/i),sin(PI*type*2/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w = cp(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
double ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<=len;i++)
		c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<=len;i++)
		ans[i]=c[i].x;
}
int main()
{
	int n;
	scanf("%d",&n);
	n--;
	for(int i = 0;i<= n;i++)scanf("%lf",&x[i].x);
	for(int i = 0;i<n;i++)
		y[i].x = (-1.0)/((double)(n-i)*(n-i));
	for(int i = n+1;i<=2*n;i++)
		y[i].x = -y[2*n-i].x;
	int m = 4*n,L = 1,nn = n;
	for(n=1;n<=m;n=n<<1)L++;
	conv(x,y,z,n);
	//for(int i = 0;i<= m;i++)ans[i] = c[i].x;
	for(int i = nn;i<= 2*nn;i++)printf("%.5lf\n",ans[i]);
	return 0;
}
Problem3529

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
const ll mod = (1ll<<31)-1;
bool vis[N];
int mu[N],prime[N],cnt;
ll G[N],g[N];
struct To
{int no;ll val;}g_no[N];
bool cmp(const To &a,const To &b){return a.val<b.val;}
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] =i;
			mu[i] = -1;
		}
		for(int j = 1;j<=cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		for(int j = 1;j*i<N;j++)
			g[i*j]=(g[i*j]+i)&mod;
	for(int i = 1;i<N;i++)
		g_no[i].val = g[i],g_no[i].no = i;
	sort(g_no+1,g_no+N,cmp);
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		G[i]=(G[i]+y)&mod;
}
ll getans(int x)
{
	ll ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans=(ans+G[i])&mod;
	return ans;
}
struct A
{int a,no,n,m;}ask[N];
bool cmpask(const A &a,const A &b){return a.a<b.a;}
ll ans_no[N];
void solve(int n,int m,int no)
{
	ll ans = 0;
	int last;
	for(int i = 1;i<=n&&i<=m;i =last+1)
	{
		last = min(n/(n/i),m/(m/i));
		ans = (ans+(ll)(n/i)*(m/i)*((getans(last)-getans(i-1))%(mod+1)+mod+1))&mod;
	}
	ans_no[no] = ans;
}
int main()
{
	int q;
	scanf("%d",&q);
	quick_mu();
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].n,&ask[i].m,&ask[i].a);
		ask[i].no = i;
	}
	sort(ask+1,ask+q+1,cmpask);
	int r = 1;
	for(int i = 1;i<= q;i++)
	{
		while(g_no[r].val<=ask[i].a&&r<N)
		{
			for(int j = 1;j*g_no[r].no<N;j++)
				update(j*g_no[r].no,g_no[r].val*mu[j]);
			r++;
		}
		solve(ask[i].n,ask[i].m,ask[i].no);
	}
	for(int i=1;i<= q;i++)
		printf("%lld\n",ans_no[i]);
	return 0;
}
Problem3530

#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define mod 1000000007
#define LL long long
#include <queue>
using namespace std;
struct trie
{
    int ch[12],mark,fail,last;
}t[2005];
char N[1500],s[1500];
int m,tot=0,n[2000],l;
LL f[1205][2005][3];
void Insert(char s[])
{
    int x=0;
    for (int i=0;i<strlen(s);i++)
    {
        int c=s[i]-'0';
        if (!t[x].ch[c])
            t[x].ch[c]=++tot;
        x=t[x].ch[c];
    }
    t[x].mark=1;
}
void Make_fail()
{
    queue<int> q;
    for (int i=0;i<=9;i++)
        if (t[0].ch[i]) 
            q.push(t[0].ch[i]);
    while (!q.empty())
    {
        int x=q.front();
        q.pop();
        for (int i=0;i<=9;i++)
            if (t[x].ch[i])
            {
                int y=t[x].ch[i];
                q.push(y);
                int v=t[x].fail;
                while (v&&!t[v].ch[i])
                    v=t[v].fail;
                t[y].fail=v=t[v].ch[i];
                t[y].last=t[v].mark?v:t[v].last;
            }
    }
}
void Add(LL &a,LL b)
{
    a=(a+b)%mod;
}
int C(int a,int b)
{
    if (a==b) return 1;
    if (a<b) return 0;
    return 2;
}
void DP()
{
    LL ans=0;
    for (int k=1;k<=9;k++)
    {
        int v=t[0].ch[k];
        if (!t[v].mark&&!t[v].last)
            f[1][t[0].ch[k]][C(k,n[1])]+=1;
    }
    for (int j=0;j<=tot;j++)
        ans=(ans+f[1][j][0]+f[1][j][1]+f[1][j][2])%mod;
    for (int i=1;i<l;i++)
    {
        for (int j=0;j<=tot;j++)
            if (f[i][j][0]||f[i][j][1]||f[i][j][2])
                for (int k=0;k<=9;k++)
                {
                    int v=j;
                    while (v&&!t[v].ch[k])
                        v=t[v].fail;
                    v=t[v].ch[k];
                    if (!t[v].mark&&!t[v].last)
                    {
                        int x=C(k,n[i+1]);
                        if (x==0)
                            Add(f[i+1][v][0],f[i][j][0]+f[i][j][1]),
                            Add(f[i+1][v][2],f[i][j][2]);
                        if (x==1)
                            Add(f[i+1][v][0],f[i][j][0]),
                            Add(f[i+1][v][1],f[i][j][1]),
                            Add(f[i+1][v][2],f[i][j][2]);
                        if (x==2)
                            Add(f[i+1][v][0],f[i][j][0]),
                            Add(f[i+1][v][2],f[i][j][1]+f[i][j][2]);
                    }
                }
        for (int j=0;j<=tot;j++)
        {
            Add(ans,f[i+1][j][0]+f[i+1][j][1]);
            if (i+1!=l)
                Add(ans,f[i+1][j][2]);
        }
    }
    printf("%d\n",(int)ans%mod);
}
int main()
{
    scanf("%s",N);
    l=strlen(N);
    for (int i=1;i<=l;i++)
        n[i]=N[i-1]-'0';
    scanf("%d",&m);
    for (int i=1;i<=m;i++)
        scanf("%s",s),Insert(s);
    Make_fail();
    DP();
    return 0;
}
Problem3531

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define N 100005
#define M 10000005
struct seg{int ls,rs,sum,mw;}t[M];
int tpn,n;
struct E{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x]= tot;
}
int top[N],deep[N],fa[N],size[N],son[N],w[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x]= ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int score[N],color[N];
int root[N];
void update(int p,int l,int r,int x,int b)
{
	if(l==r){t[p].sum = b,t[p].mw= b;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)
	{
		if(t[p].ls==0)t[p].ls= ++tpn;
		update(t[p].ls,l,mid,x,b);
	}else
	{
		if(t[p].rs==0)t[p].rs= ++tpn;
		update(t[p].rs,mid+1,r,x,b);
	}
	t[p].sum = t[t[p].ls].sum+t[t[p].rs].sum;
	t[p].mw = max(t[t[p].ls].mw,t[t[p].rs].mw);	
}
int getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return t[p].mw;
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)
		ans = max(ans,getmax(t[p].ls,l,mid,a,b));
	if(b>mid)
		ans = max(ans,getmax(t[p].rs,mid+1,r,a,b));
	return ans;
}
int getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return t[p].sum;
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<= mid)
		ans+=getsum(t[p].ls,l,mid,a,b);
	if(b>mid)
		ans+=getsum(t[p].rs,mid+1,r,a,b);
	return ans;
}
int get_ans(int x,int y,int opt,int c)
{
	int ans = 0;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)ans += getsum(root[c],1,n,w[top[x]],w[x]);
		else ans = max(ans,getmax(root[c],1,n,w[top[x]],w[x]));
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)ans += getsum(root[c],1,n,w[y],w[x]);
	else ans = max(ans,getmax(root[c],1,n,w[y],w[x]));
	return ans;
}
int main()
{
	for(int i = 1;i<= N-5;i++)
		root[i] = ++tpn;
	int x,y,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&score[i],&color[i]);
	for(int i = 1;i<n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(root[color[i]],1,n,w[i],score[i]);
	char j[5];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",j,&x,&y);
		if(j[1]=='S')printf("%d\n",get_ans(x,y,1,color[x]));
		else if(j[1]=='M')printf("%d\n",get_ans(x,y,0,color[x]));
		else if(j[1]=='W')
		{
			score[x] = y;
			update(root[color[x]],1,n,w[x],y);
		}else
		{
			update(root[color[x]],1,n,w[x],0);
			color[x] = y;
			update(root[color[x]],1,n,w[x],score[x]);
		}
	}
	return 0;
}
Problem3538

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int M = 50005;
bool v[N];
struct E
{int next,to,val;};
queue<int>Q;
struct G
{
	E e[M<<1];
	int head[N],tot,minn;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val = f;
		head[x] = tot;
	}
	int dis[N];
	void spfa(int s,int t)
	{
		memset(dis,0x3f,sizeof(dis));
		dis[s] = 0;
		v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i = e[i].next)
			{
				if(dis[x]+e[i].val<dis[e[i].to])
				{
					dis[e[i].to] = dis[x]+e[i].val;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
			}
		}
		minn = dis[t];
	}
}g1,g2,g;
int main()
{
	int n,m,x,y,u,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		g1.add(y,x,u);
		g2.add(y,x,w);
	}
	g1.spfa(n,1);
	g2.spfa(n,1);
	for(int i = 1;i<= n;i++)
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			int t = g1.e[j].to;
			int cnt = 0;
			if(g1.dis[i]+g1.e[j].val!=g1.dis[t])cnt++;
			if(g2.dis[i]+g2.e[j].val!=g2.dis[t])cnt++;
			g.add(t,i,cnt);
		}
	g.spfa(1,n);
	printf("%d\n",g.minn);
	return 0;
}
Problem3540

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
const int LIM = (N<<1)+5;
struct C
{int k,s;}cow[N];
bool cmp(C a,C b)
{return a.s<b.s;}
int pos[(N<<1)+5];
int main()
{	
	int n,x;
	char tmp[3];
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%s",&x,tmp);
		if(tmp[0]=='W')cow[i].k = -1;
		else cow[i].k = 1;
		cow[i].s =x;
	}
	sort(cow+1,cow+n+1,cmp);
	memset(pos,0x3f,sizeof(pos));
	int sum = n,ans = 0;
	pos[sum] = cow[1].s;
	for(int i = 1;i< n;i++)
	{
		sum+=cow[i].k;
		pos[sum] = min(pos[sum],cow[i+1].s);
	}
	for(int i = 2*n;i>=0;i--)
		pos[i] = min(pos[i],pos[i+2]);
	sum = n;
	for(int i = 1;i<= n;i++)
	{
		sum+=cow[i].k;
		ans = max(cow[i].s-pos[sum],ans);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3545

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 5e6+5;
int sum[M],ls[M],rs[M],tot,root[N],maxn;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void Insert(int &p,int l,int r,int pos)
{
	if(!p)p=++tot;
	if(l==r)
	{
		sum[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)Insert(ls[p],l,mid,pos);
	else Insert(rs[p],mid+1,r,pos);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int merge(int x,int y,int l,int r)
{
	if(!x||!y)return x+y;
	if(l==r)
	{
		sum[x] = sum[x]+sum[y];
		return x;
	}
	int mid = (l+r)>>1;
	ls[x] = merge(ls[x],ls[y],l,mid);
	rs[x] = merge(rs[x],rs[y],mid+1,r);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
struct edge
{
	int x,y,w;
	bool operator <(const edge &s)const
	{
		return w<s.w;
	}
}e[5*N];
struct Ask
{
	int p,v,k,no;
	bool operator <(const Ask &s)const
	{
		return v<s.v;
	}
}ask[5*N];
int hill[N],ans[5*N];
int getans(int p,int k)
{
	if(k<=0)return -1;
	int l = 1,r = maxn,ans=-1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[ls[p]]>=k)
			p = ls[p],r=mid;
		else 
		{
			k-=sum[ls[p]];
			p = rs[p],l= mid+1;
		}
	}
	return l;
}
int main()
{
	int n,m,q;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<=n;i++)
		scanf("%d",&hill[i]),maxn = max(maxn,hill[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].p,&ask[i].v,&ask[i].k);
		ask[i].no = i;
	}
	sort(e+1,e+m+1);sort(ask+1,ask+q+1);
	for(int i = 1;i<= n;i++)
		Insert(root[i],1,maxn,hill[i]);
	int j = 1;
	for(int i = 1;i<= q;i++)
	{
		while(j<=m&&e[j].w<=ask[i].v)
		{
			int fx = getfa(e[j].x),fy = getfa(e[j].y);
			if(fx==fy){j++;continue;}
			fa[fy] = fx;
			root[fx] = merge(root[fx],root[fy],1,maxn);
			j++;
		}
		int tmp = getfa(ask[i].p);
		ans[ask[i].no] = getans(root[tmp],sum[root[tmp]]-ask[i].k+1);
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int sed = 299;
typedef unsigned long long ll;
const int N = 6e6+5;
ll pow[205];
ll hash[N];
char s[205];
int cnt;
int main()
{
	int n,l,q;
	pow[0]=1;
	for(int i = 1;i<205;i++)pow[i]=pow[i-1]*sed;
	scanf("%d%d%d",&n,&l,&q);
	for(int i = 1;i<= n;i++)
	{
		ll tmp = 0;
		scanf("%s",s+1);
		int lth = strlen(s+1);
		for(int i = 1;i<=lth;i++)
			tmp = tmp*sed+s[i];
		for(int i = 1;i<=lth;i++)
		{
			ll tt = tmp-s[i]*pow[lth-i];
			hash[++cnt] = tt;
		}
	}
	sort(hash+1,hash+cnt+1);
	ll ans = 0;
	int cc = 0;
	for(int i = 1;i<= cnt;i++)
	{
		if(i==1||hash[i]!=hash[i-1])
			cc=-1;
		cc++;
		ans+=cc;
	}
	printf("%llu\n",ans);
	return 0;
}
Problem3566

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const double eps = 1e-6;
struct E{int next,to;double p;}e[N<<2];
int head[N],tot;
void add(int x,int y,double val)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].p = val;
	head[x] = tot;
}
double g[N],f[N],q[N];
void dfs(int x,int fa)
{
	double tmp = 1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			tmp*=(1.0-e[i].p*f[e[i].to]);
		}	
	}
	f[x] = 1.0-tmp*(1.0-q[x]);	
}
void dfs2(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		double tmp = 1-f[e[i].to]*e[i].p;
		if(fabs(tmp)<eps)g[e[i].to] = 1;
		else
		{
			double y = (g[x]-f[e[i].to]*e[i].p)/(1-f[e[i].to]*e[i].p);
			g[e[i].to] = f[e[i].to]+y*e[i].p-f[e[i].to]*y*e[i].p;
		}
		dfs2(e[i].to,x);
	}
}
int main()
{
	int n,x,y;
	double p;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%lf",&x,&y,&p);
		add(x,y,p/100.0);
		add(y,x,p/100.0);
	}
	for(int i = 1;i<= n;i++)
		{scanf("%lf",&q[i]);q[i]/=100.0;}
	dfs(1,0);
	g[1] = f[1];
	dfs2(1,0);
	double ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=g[i];
	printf("%.6f",ans);
	return 0;
}
Problem3572

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+100;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;};
int size[N],fa[N][20],dep[N],dfn[N],Dfn;
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;
	}
	void dfs(int x,int f)
	{
		fa[x][0] = f;
		dep[x] = dep[f]+1;
		size[x] = 1;
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=f)
			{
				dfs(e[i].to,x);
				size[x]+=size[e[i].to];
			}
	}
	void init(int n)
	{
		for(int j = 1;j<= 19;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 19;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 19;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	int jump(int x,int h)
	{
		for(int i = 19;i>=0;i--)
			if(dep[fa[x][i]]>=h)
				x=fa[x][i];
		return x;
	}
}tree;
int h[N],stk[N],top;
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int father[N],rec[N],val[N],dis[N],ans[N],tr[N],len[N],near[N];
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i= 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		tree.add(x,y);
	}
	tree.dfs(1,0);
	tree.init(n);
	int q,m;
	scanf("%d",&q);
	while(q--)
	{
		scanf("%d",&m);
		int cnt = 0;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&h[i]);
			tr[++cnt] = h[i];
			rec[i] = near[h[i]]=h[i];
			dis[h[i]]=ans[h[i]]=0;
		}
		top = 0;
		sort(h+1,h+m+1,cmp);
		for(int i=1;i<=m;i++)
		{
			if(!top)father[stk[++top]=h[i]]=0;
			else
			{
				int lca = tree.getlca(stk[top],h[i]);
				while(dep[lca]<dep[stk[top]])
				{
					if(dep[lca]>=dep[stk[top-1]])
						father[stk[top]]=lca;
					top--;
				}
				if(stk[top]!=lca)
				{
					father[lca]=stk[top];
					stk[++top]=tr[++cnt]=lca;
					near[lca]=0,dis[lca]=INF;
				}
				father[stk[++top]=h[i]]=lca;
			}
		}
		sort(tr+1,tr+cnt+1,cmp);
		for(int i = 1;i<= cnt;i++)
		{
			val[tr[i]]=size[tr[i]];
			len[tr[i]]=dep[tr[i]]-dep[father[tr[i]]];
		}
		for(int i = cnt;i>=2;i--)
		{
			if(dis[father[tr[i]]]>dis[tr[i]]+len[tr[i]])
			{
				dis[father[tr[i]]]=dis[tr[i]]+len[tr[i]];
				near[father[tr[i]]]=near[tr[i]];
			}else if(dis[father[tr[i]]]==dis[tr[i]]+len[tr[i]])
				near[father[tr[i]]]=min(near[father[tr[i]]],near[tr[i]]);
		}
		for(int i = 2;i<= cnt;i++)
		{
			if(dis[tr[i]]>dis[father[tr[i]]]+len[tr[i]])
			{
				dis[tr[i]] = dis[father[tr[i]]]+len[tr[i]];
				near[tr[i]] = near[father[tr[i]]];
			}else if(dis[tr[i]]==dis[father[tr[i]]]+len[tr[i]])
				near[tr[i]]=min(near[father[tr[i]]],near[tr[i]]);
		}
		for(int i = 1;i<= cnt;i++)
		{
			if(i==1)ans[near[tr[i]]]=n-size[tr[i]];
			else
			{
				int x = tree.jump(tr[i],dep[father[tr[i]]]+1);
				int s = size[x]-size[tr[i]];
				val[father[tr[i]]]-=size[x];
				if(near[father[tr[i]]]==near[tr[i]])
					ans[near[tr[i]]]+=s;
				else
				{
					int num = dis[father[tr[i]]]+dis[tr[i]]+len[tr[i]]+1;
					int mid = dep[tr[i]]+dis[tr[i]]-(num+1)/2+1;
					if((num&1)&&near[tr[i]]>near[father[tr[i]]])mid++;
					x=size[x]-size[tree.jump(tr[i],mid)];
					ans[near[father[tr[i]]]]+=x;
					ans[near[tr[i]]]+=s-x;
				}
			}
		}
		for(int i = 1;i<= cnt;i++)
			ans[near[tr[i]]]+=val[tr[i]];
		for(int i = 1;i<= m;i++)
			printf("%d ",ans[rec[i]]);
		printf("\n");
	}
	return 0;
}
Problem3586

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
typedef long double ld;
int tt,n,l,t;
char s[10];
int trie[60][26],pos[60],tot,fail[60];
ld f[60][356],p[26],a[60][60];
queue<int> q;
void mkfail()
{
	q.push(0);
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=0;i<t;i++)
		{
			if(trie[x][i])
			{
				if(x) fail[trie[x][i]]=trie[fail[x]][i];
				q.push(trie[x][i]);
			}else trie[x][i]=trie[fail[x]][i];
		}
	}
}
void Gauss(int n)
{
	for(int i=0;i<=n;i++)
	{
		ld mx=0;int pos;
		for(int j=i;j<=n;j++)
		{
			if(fabs(a[j][i])>mx)
			{
				mx=fabs(a[j][i]);
				pos=j;
			}
		}
		for(int j=i;j<=n+1;j++) swap(a[i][j],a[pos][j]);
		for(int j=i+1;j<=n;j++)
		{
			ld f=a[j][i]/a[i][i];
			for(int k=i;k<=tot+1;k++)
				a[j][k]-=f*a[i][k];
		}
	}
	for(int i=n;i>=0;i--)
	{
		for(int j=i+1;j<=n;j++)
			a[i][tot+1]-=a[i][j]*a[j][tot+1];
		a[i][tot+1]/=a[i][i];
	}
}

void calc(int x)
{
	memset(a,0,sizeof a);
	for(int i=0;i<=tot;i++)
	{
		a[i][i]=1;
		if(pos[i]!=-1&&((1<<pos[i])&x)) a[i][tot+1]=f[i][x^(1<<pos[i])];
		else
		{
			a[i][tot+1]=1;
			for(int j=0;j<t;j++)
				a[i][trie[i][j]]-=p[j];
		}
	}
	Gauss(tot);
	for(int i=0;i<=tot;i++) f[i][x]=a[i][tot+1];
}
int main()
{
	scanf("%d",&tt);
	while(tt--)
	{
		memset(trie,0,sizeof trie);
		memset(pos,-1,sizeof pos);
		memset(fail,0,sizeof fail);
		memset(f,0,sizeof f);
		tot=0;
		scanf("%d%d%d",&n,&l,&t);
		for(int i=0;i<n;i++)
		{
			scanf("%s",s);
			int id=0;
			for(int j=0;s[j];j++)
				if(trie[id][s[j]-'a']) id=trie[id][s[j]-'a'];
				else id=trie[id][s[j]-'a']=++tot;
			pos[id]=i;
		}
		for(int i=0,x;i<t;i++)
		{
			scanf("%d",&x);
			p[i]=x/10000.0;
		}
		mkfail();
		for(int i=1;i<(1<<n);i++)
			calc(i);
		printf("%.10f\n",(double)f[0][(1<<n)-1]);
	}
	return 0;
}
Problem3590

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int S = 1<<12;
const int N = 13;
const int M = 85;
const int INF = 5e8;
struct E
{int next,to,val;}e[M];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
int g[S][N][N],h[S][N][2],n,m;
int f[S];
void graph_init()
{
	memset(head,0,sizeof(head));
	tot = 0;
	int x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
}
void edge_init()
{
	for(int i = 0;i<1<<n;i++)for(int j = 0;j<= n;j++)for(int k = 0;k<= n;k++)
		g[i][j][k] = INF;
	for(int i = 0;i<1<<n;i++)for(int j = 0;j<= n;j++)for(int k = 0;k<= 1;k++)
		h[i][j][k] = INF;
	for(int i = 0;i<n;i++)
		g[i<<1][i+1][i+1] = 0;
	for(int i = 1;i<=n;i++)
		for(int j = head[i];j;j = e[j].next)
		{
			int l = i,r = e[j].to;
			int s = (1<<(l-1))|(1<<(r-1));
			g[s][l][r] = min(g[s][l][r],e[j].val);
		}
	for(int s = 0;s<1<<n;s++)
	{
		for(int l = 1;l<= n;l++)
			for(int r = 1;r<= n;r++)
				if((s|(1<<(l-1))|(1<<(r-1)))==s)
					for(int p = head[r];p;p=e[p].next)
					{
						int nr = e[p].to;
						if((s|(1<<(nr-1)))!=s)
							g[s|(1<<(nr-1))][l][nr] = 
							min(g[s|(1<<(nr-1))][l][nr],g[s][l][r]+e[p].val);
					}
	}
	for(int s = 0;s<1<<n;s++)
		for(int i = 1;i<= n;i++)
			if((s|(1<<(i-1)))==s)
				for(int j = head[i];j;j = e[j].next)
				{
					int to = e[j].to;
					if((s|(1<<(to-1)))!=s)
					{
						if(e[j].val<=h[s][to][0])
						{
							h[s][to][1] = h[s][to][0];
							h[s][to][0] = e[j].val;
						}else if(e[j].val<h[s][to][1])
							h[s][to][1] = e[j].val;
					}
				}
}
int calc_sta(int x)
{
	int sta = 1;
	for(x = x&(x-1);x;x = x&(x-1))
		sta++;
	return sta;
}
void dp()
{
	for(int i = 1;i<1<<n;i++)
		f[i] = INF;
	for(int i = 0;i<n;i++)
		f[1<<i] = 0;
	for(int i = 1;i<1<<n;i++)
		if(calc_sta(i)>=2)
			for(int s = i&(i-1);s;s = (s-1)&i)
			{
				int t = i-s;
				for(int l = 1;l<= n;l++)
					for(int r = 1;r<= n;r++)
						if((s|(1<<(l-1)))==s&&(s|(1<<(r-1)))==s)
						{
							if(l==r)
								f[i] = min(f[i],f[t]+g[s][l][r]+h[t][l][0]+h[t][l][1]);
							else 
								f[i] = min(f[i],f[t]+g[s][l][r]+h[t][l][0]+h[t][r][0]);
						}

			}
	if(f[(1<<n)-1]<INF)printf("%d\n",f[(1<<n)-1]);
	else printf("impossible\n");
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		graph_init();
		edge_init();
		dp();
	}
	return 0;
}
Problem3597

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const int N = 5005;
const int M = 6005;
struct Road
{int x,y,a,b,c,d;}r[M];
struct E
{int next,to;double val;}e[M];
int head[N],tot,n,m;
void add(int x,int y,double f)
{e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].val=f;}
bool vis[N];double dis[N];
bool flag;
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(dis[e[i].to]>dis[x]+e[i].val)
		{
			if(vis[e[i].to])flag = true;
			else
			{
				dis[e[i].to] = dis[x]+e[i].val;
				dfs(e[i].to);
			}
		}
	}
	vis[x] = false;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(dis,0,sizeof(dis));
	memset(vis,0,sizeof(vis));
	flag = false;tot = 0;
}
bool check(double ans)
{
	init();
	for(int i = 1;i<= m;i++)
	{
		add(r[i].x,r[i].y,r[i].b+r[i].d+ans);
		if(r[i].c)add(r[i].y,r[i].x,r[i].a-r[i].d+ans);
	}
	for(int i = 1;i<= n && !flag;i++)
		dfs(i);
	return flag;
}
int main()
{
	scanf("%d%d",&n,&m);
	n+=2;
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d%d%d%d",&r[i].x,&r[i].y,&r[i].a,&r[i].b,&r[i].c,&r[i].d);
	double l = 0,r = 1e8;
	while(fabs(r-l)>eps)
	{
		double mid = (l+r)/2;
		if(check(mid))l=mid;
		else r = mid;
	}
	printf("%.2lf\n",l);
	return 0;
}
Problem3611

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+1000;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;};
int dep[N],fa[N][22],dfn[N],Dfn;
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dfs(int x,int ff)
	{
		dep[x] = dep[ff]+1;
		fa[x][0]=ff;
		dfn[x] =++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=ff)
				dfs(e[i].to,x);
	}
	void init(int n)
	{
		for(int j = 1;j<= 21;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int lca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 21;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 21;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
}tree;
vector<int>to[N];
vector<int>val[N];
void add(int x,int y,int f)
{
	if(x==y)return ;
	to[x].push_back(y);
	to[y].push_back(x);
	val[x].push_back(f);
	val[y].push_back(f);
}
int size[N];
bool v[N];
ll ans1,ans2,ans3;
void Tree_DP(int x,int from)
{
	static long long f[N],g[N],max_dis[N],min_dis[N];
	//f[x]表示以x为根的子树中有多少关键点
	//g[x]表示以x为根的子树中所有关键点到x的距离之和
	//max_dis[x]/min_dis[x]表示节点x为根的子树中的关键点到x的距离的最大/最小值
	int i;
	f[x]=v[x];g[x]=0;
	max_dis[x]=(v[x]?0:-INF);
	min_dis[x]=(v[x]?0:INF);
	int sz = to[x].size();
	for(i=0;i<sz;i++)
	{
		int t = to[x][i];
		if(t==from)
			continue;
		Tree_DP(t,x);
		int dis=val[x][i];
		ans1+=(g[x]+f[x]*dis)*f[t]+g[t]*f[x];
		ans2=min(ans2,min_dis[x]+min_dis[t]+dis);
		ans3=max(ans3,max_dis[x]+max_dis[t]+dis);
		f[x]+=f[t];
		g[x]+=g[t]+f[t]*dis;
		max_dis[x]=max(max_dis[x],max_dis[t]+dis);
		min_dis[x]=min(min_dis[x],min_dis[t]+dis);
	}
	v[x] = false,to[x].clear(),val[x].clear();
}
/*void dfs(int x,int ff,int dis)
{
	size[x] = v[x];
	if(v[x]&&dis)ans2 = min(ans2,dis),dis = 0;
	int sz = to[x].size();
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
		{
			dfs(t,x,dis+val[x][i]);
			size[x]+=size[t];
			ans1+=(ll)(tn-size[t])*size[t]*val[x][i];
		}
	}
	v[x] = false;
	to[x].clear(),val[x].clear();
}
int end,maxdis;
void get_rope(int x,int dis,int ff)
{
	if(dis&&dis>maxdis&&v[x])
	{
		maxdis = dis;
		end = x;
	}
	int sz = to[x].size();
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
			get_rope(t,dis+val[x][i],x);
	}
}*/
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int h[N],stk[N],top;
int main()
{
	int n,q,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		tree.add(x,y);
	}
	tree.dfs(1,0);
	tree.init(n);
	scanf("%d",&q);
	while(q--)
	{
		int k;
		scanf("%d",&k);
		for(int i = 1;i<= k;i++)
			scanf("%d",&h[i]),v[h[i]]=true;
		sort(h+1,h+k+1,cmp);
		top = 0;
		stk[++top]=h[1];
		for(int i = 2;i<= k;i++)
		{
			int u = h[i];
			int lca = tree.lca(u,stk[top]);
			while(true)
			{
				if(dep[lca]>=dep[stk[top-1]])
				{
					int len = dep[stk[top]]-dep[lca];
					add(lca,stk[top--],len);
					break;
				}
				add(stk[top-1],stk[top],dep[stk[top]]-dep[stk[top-1]]);
				top--;
			}
			if(stk[top]!=lca)stk[++top]=lca;
			if(stk[top]!=u)stk[++top]=u;
		}
		for(int i = 1;i<top;i++)
			add(stk[i],stk[i+1],dep[stk[i+1]]-dep[stk[i]]);
		ans1 = 0,ans2 = INF,ans3 = -INF;
		Tree_DP(h[1],-1);
		printf("%lld %lld %lld\n",ans1,ans2,ans3);
	}
	return 0;
}
Problem3613

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int mod;
typedef long long LL;
const int N = 5000005;
int a[N],sa,sb,sc,sd,n;
int F(int x)
{
	LL ans = 0;
	LL x2 = (LL)x*x%mod;LL x3 = x2*x%mod;
	ans = (((ans+(LL)sa*x3%mod)%mod+(LL)sb*x2%mod)%mod+(LL)sc*x%mod)%mod+sd;
	ans = ans%mod;
	return ans;
}
bool judge(int b)
{
	int mx = 1;
	for(int i = 1;i<= n;i++)
	{
		mx = max(mx,a[i]-b);
		if(mx>a[i]+b)return false;
	}
	return true;
}
int main()
{
	scanf("%d%d%d%d%d%d%d",&n,&sa,&sb,&sc,&sd,&a[1],&mod);
	for(int i = 2;i<= n;i++)
		a[i] = (F(a[i-1])+F(a[i-2]))%mod;
	int l = 0,r = mod+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(judge(mid))r = mid;
		else l = mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem3622

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int mod =1e9+9;
typedef long long ll;
int n,k;
ll f[N][N];
ll c[N][N],fac[N],g[N];
void init()
{
	fac[0] = 1;
	for(int i = 1;i<N;i++)
		fac[i] = fac[i-1]*i%mod;
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}	
}
int a[N],b[N],next[N];
int main()
{
	init();
	int n,k;
	scanf("%d%d",&n,&k);
	if((n+k)&1){printf("0\n");return 0;}
	k=(k+n)/2;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	int j = 1;
	for(int i = 1;i<= n;i++)
	{
		while(b[j]<a[i]&&j<=n)j++;
		next[i]=j-1;
	}
	f[0][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		f[i][0]=1;
		for(int j = 1;j<= i;j++)
			(f[i][j]+=f[i-1][j-1]*max(next[i]-j+1,0)+f[i-1][j])%=mod;
	}
	for(int i = n;i>=k;i--)
	{
		g[i] = (ll)f[n][i]*fac[n-i]%mod;
		for(int j = i+1;j<= n;j++)
			(g[i]+=mod-g[j]*c[j][i]%mod)%=mod;
	}
	printf("%lld\n",g[k]);
	return 0;
}
Problem3624

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int M = 100005;
int fa[N];
struct E{int x,y;}e1[M],e2[M];
int cnt1,cnt2;
int ansx[M],ansy[M],ansc[M];
int ans_cnt,n,m,k;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
bool Find_Must()
{
	int block = n;
	for(int i = 1;i<= cnt2;i++)
	{
		int fx = getfa(e2[i].x),fy = getfa(e2[i].y);
		if(fx==fy)continue;
		block--;
		uni(e2[i].x,e2[i].y);
		if(block==1)break;
	}
	for(int i = 1;i<= cnt1;i++)
	{
		int fx = getfa(e1[i].x),fy = getfa(e1[i].y);
		if(fx==fy)continue;
		block--;
		ans_cnt++;
		ansx[ans_cnt] = e1[i].x;ansy[ans_cnt] = e1[i].y;
		ansc[ans_cnt] = 0;
		uni(e1[i].x,e1[i].y);
		if(block==1)break;
	}
	if(ans_cnt>k)return false;
	else return true;
}
bool build()
{
	int block = n,tmp = 0;
	for(int i = 1;i<= ans_cnt;i++)
	{
		uni(ansx[i],ansy[i]);
		block--;
		tmp++;
	}
	for(int i = 1;i<= cnt1;i++)
	{
		int fx = getfa(e1[i].x),fy = getfa(e1[i].y);
		if(fx==fy)continue;
		block--;
		tmp++;
		ans_cnt++;
		ansx[ans_cnt] = e1[i].x;ansy[ans_cnt] = e1[i].y;
		ansc[ans_cnt] = 0;
		uni(e1[i].x,e1[i].y);
		if(block==1||tmp==k)break;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		int fx = getfa(e2[i].x),fy = getfa(e2[i].y);
		if(fx==fy)continue;
		block--;
		ans_cnt++;
		ansx[ans_cnt] = e2[i].x;ansy[ans_cnt] = e2[i].y;
		ansc[ans_cnt] = 1;
		uni(e2[i].x,e2[i].y);
		if(block==1)break;
	}
	if(tmp!=k)return false;
	else return true;
}
int main()
{
	int x,y,c;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		if(c==0){e1[++cnt1].x = x;e1[cnt1].y = y;}
		else {e2[++cnt2].x = x;e2[cnt2].y = y;}
	}
	if(!Find_Must())printf("no solution\n");
	memset(fa,0,sizeof(fa));
	if(!build())printf("no solution\n");
	else
	{
		for(int i = 1;i<= ans_cnt;i++)
			printf("%d %d %d\n",ansx[i],ansy[i],ansc[i]);
	}
	return 0;
}
Problem3625

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 261244<<1;
typedef long long ll;
const int mod = 998244353;
const int Inv2 = 499122177;
int a[N],b[N],c[N],cnt=0;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
void NTT(int *a,int len,int type)
{
	int t = 0,i,j,k,wn,tmp,w;
	for(i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(j = len>>1;(t^=j)<j;j=j>>1);
	}
	for(i = 2;i<= len;i<<=1)
	{
		wn = quick_pow(5,(mod-1)/i);
		for(j = 0;j<len;j+=i)
		{
			w = 1;
			for(k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
			{
				tmp = (ll)a[j+k+(i>>1)]*w%mod;
				a[j+k+(i>>1)] = (a[j+k]-tmp+mod)%mod;
				a[j+k] = (a[j+k]+tmp)%mod;
			}
		}
	}
	if(type==-1)
	{
		for(i = 1;i<(len>>1);i++)
			swap(a[i],a[len-i]);
		int Inv = quick_pow(len,mod-2);
		for(i = 0;i<len;i++)
			a[i] = (ll)a[i]*Inv%mod;
	}
	/*printf("#case %d:",++cnt);
	for(int i = 0;i<len;i++)
		printf("%d ",a[i]);
	printf("\n");*/
}
void Get_Inv(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = quick_pow(a[0],mod-2);
		return ;
	}
	Get_Inv(a,b,len>>1);
	static int tmp[N];
	memcpy(tmp,a,sizeof(int)*len);
	memset(tmp+len,0,sizeof(int)*len);
	NTT(tmp,len<<1,1);
	NTT(b,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i] = (ll)b[i]*(2-(ll)b[i]*tmp[i]%mod+mod)%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(ll)*len);
}
void Get_Root(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = 1;
		return ;
	}
	Get_Root(a,b,len>>1);
	static int tmpa[N],tmpb[N];
	memset(tmpb,0,sizeof(int)*len);  
    memset(tmpb+len,0,sizeof(int)*len);
	Get_Inv(b,tmpb,len);
	memcpy(tmpa,a,sizeof(int)*len);
	memset(tmpa+len,0,sizeof(int)*len);
	NTT(tmpa,len<<1,1),NTT(b,len<<1,1),NTT(tmpb,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i] = (ll)(b[i]+(ll)tmpa[i]*tmpb[i]%mod)%mod*Inv2%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(int)*len);
}
int main()
{
	int n,m,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		if(k<=m)a[k]++;
	}
	int len = 1;
	for(int i=1<<30;i;i>>=1)  
        if(m&i)  
            {len=i<<1;break;} 
	for(int i = 0;i<len;i++)
		if(a[i])a[i]=mod-4;
	a[0]++;
	Get_Root(a,b,len);
	memcpy(a,b,sizeof(int)*len);
	a[0]++;
	memset(b,0,sizeof(int)*len);
	Get_Inv(a,b,len);
	for(int i = 1;i<= m;i++)
		printf("%d\n",b[i]*2%mod);
	return 0;
}
Problem3627

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 2e4+5;
const int P = 60;
const int T = 80;
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
struct Trie
{
	int ch[N*20][T],cnt;
	int lazy[N*20],sign;
	char s[T];
	int insert()
	{
		scanf("%s",s+1);
		int x = 0,alp;
		for(int i = 1;s[i];i++)
		{
			alp = s[i]-'0';
			if(!ch[x][alp])ch[x][alp]=++cnt;
			x = ch[x][alp];
		}
		if(!lazy[x])lazy[x] = ++sign;
		return lazy[x];
	}
	int judge()
	{
		for(int i=1;s[i];i++)
            if(i>=5&&s[i]=='t'&&s[i-1]=='r'&&s[i-2]=='a'&&s[i-3]=='t'&&s[i-4]=='s')return 1;
        for(int i=1;s[i];i++)
        	if(i>=3&&s[i]=='s'&&s[i-1]=='a'&&s[i-2]=='g')return 2;
        for(int i=1;s[i];i++)
        	if(i>=3&&s[i]=='d'&&s[i-1]=='n'&&s[i-2]=='e')return 3;
        return 0;
	}
}trie;
struct E
{
	int u,v,next;
	double val;
}e[M<<1],E[15][P*P*2];
int head[N],tot;
int Head[15][P],cnt[15];
void add(int x,int y,double f)
{
	e[++tot].u = x;
	e[tot].v = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void ADD(int l,int x,int y,double f)
{
	E[l][++cnt[l]].u = x;
	E[l][cnt[l]].v = y;
	E[l][cnt[l]].val = f;
	E[l][cnt[l]].next = Head[l][x];
	Head[l][x] = cnt[l];
	//printf("%d %d %d %.5lf\n",l,x,y,f);
}
struct Point
{
	int x,y;
	Point(){}
	Point(int x,int y):x(x),y(y){}
};
queue<Point>Q;
double dis[15][N],aver[N];
bool in[15][N];
int n,m,light,gas,cost;
bool red[N];
int sta[N],gass[N],num;
char tmp[T];
void SPFA(int s)
{
	while(!Q.empty())Q.pop();
	memset(dis,0x7f,sizeof(dis));
	dis[0][s] = 0;
	in[0][s] = true;
	Q.push(Point(0,s));
	while(!Q.empty())
	{
		Point tt = Q.front();
		Q.pop();
		in[tt.x][tt.y] = false;
		for(int i = head[tt.y];i;i=e[i].next)
		{
			int to = e[i].v,temp = tt.x+red[to];
			if(temp<=light&&dis[tt.x][tt.y]+e[i].val+aver[to]<=gas&&dis[temp][to]>dis[tt.x][tt.y]+e[i].val+aver[to])
			{
				dis[temp][to] = dis[tt.x][tt.y]+e[i].val+aver[to];
				if(!in[temp][to])
				{
					in[temp][to] =true;
					Q.push(Point(temp,to));
				}
			}
		}
	}
}
double spfa(int s,int t)
{
	while(!Q.empty())Q.pop();
	memset(dis,0x7f,sizeof(dis));
	dis[0][s] = 0;
	in[0][s] = true;
	Q.push(Point(0,s));
	while(!Q.empty())
	{
		Point tt = Q.front();
		Q.pop();
		in[tt.x][tt.y] = false;
		for(int j = 0;j+tt.x<=light;j++)
		{
			for(int i = Head[j][tt.y];i;i=E[j][i].next)
			{
				int to = E[j][i].v;
				if(dis[j+tt.x][to]>dis[tt.x][tt.y]+cost+E[j][i].val)
				{
					dis[j+tt.x][to] = dis[tt.x][tt.y]+cost+E[j][i].val;
					if(!in[j+tt.x][to])
					{
						in[j+tt.x][to] = true;
						Q.push(Point(j+tt.x,to));
					}
				}
			}
		}
	}
	double ans = 99999999999.999;
	for(int i = 0;i<= light;i++)
		ans = min(ans,dis[i][t]);
	return ans;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&light,&gas,&cost);
	int k,s,t,v,ia,ib;
	double a,b,c;
	for(int i = 1;i<= n;i++)
	{
		trie.insert();
		if(k = trie.judge())
		{
			sta[i] = ++num;
			gass[num] = i;
			if(k==1)s=i;
			if(k==3)t=i;
		}
		scanf("%lf%lf",&a,&b);
		if(k==1||k==3)continue;
		if(a>eps)
            red[i]=1,aver[i]=a*a/2.0/(a+b);
	}
	for(int i = 1;i<= m;i++)
	{
		ia = trie.insert();
		ib = trie.insert();
		scanf("%s",tmp);
		scanf("%lf",&c);
		add(ia,ib,c),add(ib,ia,c);
	}
	for(int i = 1;i<= num;i++)
	{
		SPFA(gass[i]);
		for(int j = 1;j<= num;j++)
		{
			v = gass[j];
			if(j!=i)
			{
				for(int k = 0;k<=light;k++)
					if(dis[k][v]<INF)
						ADD(k,i,j,dis[k][v]);
			}
		}
	}
	printf("%.3lf\n",spfa(sta[s],sta[t])-cost);
	return 0;
}
Problem3629

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int prime[N],cnt;
ll Ans[10000005];
bool v[N];
void quick_prime()
{
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
			prime[++cnt]=i;
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
bool check_prime(int x)
{
	if(x==1)return false;
	for(int i = 1;prime[i]*prime[i]<= x;i++)
		if(x%prime[i]==0)return false;
	return true;
}
void getans(ll ans,int pos,ll left)
{
	if(left==1)
	{
		Ans[++Ans[0]]=ans;
		return ;
	}
	if(left-1>=prime[pos]&&check_prime(left-1))
		Ans[++Ans[0]] = ans*(left-1);
	for(int i = pos;prime[i]*prime[i]<=left;i++)
	{
		ll sum = 1+prime[i],powe = prime[i];
		for(;sum<=left;powe*=prime[i],sum+=powe)
			if(left%sum==0)
			{
				getans(ans*powe,i+1,left/sum);
			}
	}
}
int main()
{
	ll n;
	quick_prime();
	while(scanf("%lld",&n)!=EOF)
	{
		Ans[0] = 0;
		getans(1,1,n);
		sort(Ans+1,Ans+Ans[0]+1);
		printf("%lld\n",Ans[0]);
		for(int i = 1;i<= Ans[0];i++)
			printf("%lld%c",Ans[i],i==Ans[0]?'\n':' ');
	}
	return 0;
}
Problem3630

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
queue<int>Q;
const int N = 6010;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
typedef long long ll;
struct S
{
	int x1,y1,x2,y2,x,y,r;
	int k;
}s[N];
ll getdis(int x1,int y1,int x2,int y2)
{
	return (ll)(x1-x2)*(x1-x2)+(ll)(y1-y2)*(y1-y2);
}
bool check(int i,int j)
{
	int typ = s[i].k+s[j].k;
	if(typ==2)
	{
		return getdis(s[i].x,s[i].y,s[j].x,s[j].y)<=(ll)(s[i].r+s[j].r)*(s[i].r+s[j].r);
	}
	if(typ==3)
	{
		if(s[i].k==1)swap(i,j);
		if(getdis(s[i].x1,s[i].y1,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x1,s[i].y2,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x2,s[i].y1,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x2,s[i].y2,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(s[i].y1<=s[j].y&&s[i].y2>=s[j].y)
			if(abs(s[i].x2-s[j].x)<=s[j].r||abs(s[i].x1-s[j].x)<=s[j].r)
				return true;
		if(s[i].x1<s[j].x&&s[i].x2>s[j].x)
			if(abs(s[i].y2-s[j].y)<=s[j].r||abs(s[i].y1-s[j].y)<=s[j].r)
				return true;
		if(s[i].x1<=s[j].x&&s[i].x2>=s[j].x&&s[i].y1<=s[j].y&&s[i].y2>=s[j].y)
			return true;
	}
	if(typ==4)
	{
		if((s[i].x1>=s[j].x1&&s[i].x1<=s[j].x2)||(s[i].x2>=s[j].x1&&s[i].x2<=s[j].x2))
        if((s[i].y1>=s[j].y1&&s[i].y1<=s[j].y2)||(s[i].y2>=s[j].y1&&s[i].y2<=s[j].y2))return 1;
        if(s[i].x1<=s[j].x1&&s[j].x2<=s[i].x2&&s[j].y1<=s[i].y1&&s[i].y2<=s[j].y2)return 1;
        swap(i,j);
        if((s[i].x1>=s[j].x1&&s[i].x1<=s[j].x2)||(s[i].x2>=s[j].x1&&s[i].x2<=s[j].x2))
        if((s[i].y1>=s[j].y1&&s[i].y1<=s[j].y2)||(s[i].y2>=s[j].y1&&s[i].y2<=s[j].y2))return 1;
        if(s[i].x1<=s[j].x1&&s[j].x2<=s[i].x2&&s[j].y1<=s[i].y1&&s[i].y2<=s[j].y2)return 1;
	}
	return false;
}
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f1,int f2)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f1;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f2;
}
int d[N],st,ed;
bool bfs(int s,int t)
{
	for(int i = st;i<= ed;i++)
		d[i] = -1;
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
void display(int S,int T)
{
	for(int i = S;i<= T;i++)
		for(int j = head[i];j;j=e[j].next)
			printf("%d %d:%d\n",i,e[j].to,e[j].f);
}
int main()
{
	int cx,cy,n;
	scanf("%d%d%d",&cx,&cy,&n);
	int S = 1,T = (n+1)<<1;
	st = S,ed = T;
	s[0].k = 2,s[0].x1 = 0,s[0].y1 = cy,s[0].x2 = cx,s[0].y2 = cy;
	s[n+1].k = 2,s[n+1].x1 = 0,s[n+1].y1 = 0,s[n+1].x2=cx,s[n+1].y2 = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&s[i].k);
		if(s[i].k==1)scanf("%d%d%d",&s[i].x,&s[i].y,&s[i].r);
		else scanf("%d%d%d%d",&s[i].x1,&s[i].y1,&s[i].x2,&s[i].y2);
		for(int j = 0;j<i;j++)
			if(check(i,j))
				add(j<<1|1,i<<1,INF,0),add(i<<1|1,j<<1,INF,0);
	}
	for(int i = 1;i<= n;i++)
		if(check(i,n+1))
			add(i<<1|1,(n+1)<<1,INF,0),add((n+1)<<1|1,i<<1,INF,0);
	for(int i = 1;i<= n;i++)add(i<<1,i<<1|1,1,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem3631

#include <stdio.h>
#include <algorithm>
using namespace std;
#define N 300005
struct M
{
    int next,to;    
}edge[N*2];
int head[N],tot,num[N],cnt[N],fa[N][20],dep[N],line[N];
void add(int x,int y)
{
    edge[++tot].to = y;
    edge[tot].next = head[x];
    head[x] = tot;
}
bool v[N];
void dfs(int x)
{
    v[x] = true;
    for(int i = head[x];i;i = edge[i].next)
    {
        if(!v[edge[i].to])
        {
            fa[edge[i].to][0] = x;
            dep[edge[i].to] = dep[x]+1;
            dfs(edge[i].to);
        }
    }    
    return ;
}
void work(int n)
{
    for(int j = 1;j<= 18;j++)
        for(int i = 1;i<= n;i++)
            fa[i][j] = fa[fa[i][j-1]][j-1];
    return ;
}
int lca(int x,int y)
{
    int re;
    if(dep[x]<dep[y])swap(x,y);
    for(int j = 18;j>= 0;j--)
    {
        if(dep[fa[x][j]]>=dep[y])
            x = fa[x][j];
    }
    if(x==y)return x;
    for(int j = 18;j>= 0;j--)
    {
        if(fa[x][j]!=fa[y][j])
            x = fa[x][j],y = fa[y][j];
        else re = fa[x][j];
    }
    return re;
}
bool cha[N];
void dfs2(int x)  
{   
    for (int i=head[x];i;i=edge[i].next)       
        if (edge[i].to!=fa[x][0])          
        {           
            dfs2(edge[i].to);              
			cnt[x] = cnt[x]+cnt[edge[i].to];  
        }
    return ;  
}  
int main()
{
    int n,x,y,z;
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&num[i]);
    }
    for(int i = 1;i<n;i++)
    {
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    fa[1][0] = 1;
    dfs(1);
    work(n);
    for(int i = 1;i<n;i++)
    {
        x = num[i],y = num[i+1];
        int tmp = lca(x,y);
        cnt[x]++;cnt[y]++;
        cnt[tmp]--;
		if(tmp!=1)cnt[fa[tmp][0]]--;
    }
    dfs2(1);
   	for(int i = 2;i<= n;i++)cnt[num[i]]--;
    for(int i = 1;i<= n;i++)
    {
        printf("%d\n",cnt[i]);
    }
    return 0;
}
Problem3631

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int fa[300005],top[300005],son[300005],size[300005],w[300005],deep[300005],id[300005];
struct E
{int next,to;}e[600005];
int head[300005],tot,n;
bool v[300005];
int me = (300000<<1)+1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs1(int x,int dep)
{
	v[x] = true;
	size[x]++;
	deep[x] = dep;
	for(int i = head[x];i;i = e[i].next)
	{
		int t = e[i].to;
		if(!v[t])
		{
			dfs1(t,dep+1);
			size[x]+=size[t];
			if(size[t]>size[son[x]])son[x] = t;
			fa[t] = x;
		}
	}
}
int cnt;
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	id[cnt] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int num[300005],ans[300005];
int f[300005<<2];
void push_down(int p)
{
	f[p<<1]+=f[p];
	f[(p<<1)+1]+=f[p];
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b){f[p]++;return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)
		update(p<<1,l,mid,a,b);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b);
	return ;
}
void getans(int p,int l,int r)
{
	if(l==r){ans[id[l]] = f[p];return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	getans(p<<1,l,mid);
	getans((p<<1)+1,mid+1,r);
}
void get_cut(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		update(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	update(1,1,n,w[y],w[x]);
}
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<n;i++)
		get_cut(num[i],num[i+1]);
	getans(1,1,n);
	for(int i = 1;i<= n;i++)
	{
		if(num[1]!=i)printf("%d\n",ans[i]-1);
		else printf("%d\n",ans[i]);
	}
	return 0;
}
Problem3653

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int M = 1e7+5;
typedef long long ll;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int dfn[N],Dfn,dep[N],size[N],end[N],R,root[N];
struct P
{
	int dep,size,dfn;
	P(){}
	P(int dep,int size,int dfn):dep(dep),size(size),dfn(dfn){}
	bool operator <(const P &s)const
	{
		return dfn<s.dfn;
	}
}p[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa)
{
	dep[x]=dep[fa]+1;
	R = max(R,dep[x]);
	size[x]=1;
	dfn[x]=++Dfn;
	for(int i =head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			size[x]+=size[e[i].to];
		}
	end[x] = Dfn;
}
int ls[M],rs[M];
ll sum[M];
void update(int &p,int pre,int l,int r,int pos,int v)
{
	p = ++tot;
	sum[p] = sum[pre];
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(l==r)
	{
		sum[p]+=v;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,v);
	else update(rs[p],rs[pre],mid+1,r,pos,v);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
ll getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	ll ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs(1,0);
	for(int i = 1;i<= n;i++)
		p[i] = P(dep[i],size[i],dfn[i]);
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],1,R,p[i].dep,p[i].size-1);
	int p,k;
	while(q--)
	{
		scanf("%d%d",&p,&k);
		ll ans = getans(root[end[p]],1,R,dep[p]+1,min(dep[p]+k,R));
		ans = ans-getans(root[dfn[p]-1],1,R,dep[p]+1,min(dep[p]+k,R));
		ans+=(ll)(size[p]-1)*min(k,dep[p]-1);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem3669

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 1e5+5;
struct E
{
	int x,y,a,b;
	bool operator <(const E &s)const
	{
		return a<s.a;
	}
}e[M];
int Fa[N];
int getfa(int x)
{
	if(Fa[x]==x||!Fa[x])return Fa[x]=x;
	else   return Fa[x] = getfa(Fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	Fa[x] = y;
}
int ch[N+M][2],fa[N+M],size[N+M],val[N+M],mx[N+M];
bool rev[N+M];
inline bool is_root(int p)
{
	return ch[fa[p]][0]!=p&&ch[fa[p]][1]!=p;
}
inline void init(int p,int v)
{
	ch[p][0]=ch[p][1]=fa[p]=0;
	val[p]=v,mx[p] = p;
}
inline void reverse(int p)
{
	rev[p]^=1;
	swap(ch[p][0],ch[p][1]);
}
inline void Push_down(int p)
{
	if(!is_root(p))Push_down(fa[p]);
	if(rev[p])
	{
		if(ch[p][0])reverse(ch[p][0]);
		if(ch[p][1])reverse(ch[p][1]);
		rev[p] = false;
	}
}
inline void Push_up(int p)
{
	size[p] = size[ch[p][0]]+1+size[ch[p][1]];
	int ls = mx[ch[p][0]],rs = mx[ch[p][1]];
	if(val[ls]>=val[p]&&val[ls]>=val[rs])mx[p] = ls;
	else if(val[rs]>=val[p]&&val[rs]>=val[ls])mx[p] = rs;
	else mx[p] = p;
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		else if(ch[z][1]==y)ch[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y),Push_up(x);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[z][0]==y)^(ch[y][0]==x))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;
	ch[y][0] = 0;
	Push_up(y);
}
int getans(int x,int y)
{
	move_to_root(x);
	access(y);splay(y);
	return mx[y];
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].a,&e[i].b);
	sort(e+1,e+m+1);
	for(int i = 1;i<= m;i++)val[i+n] = e[i].b;
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= m;i++)
	{
		x = e[i].x,y = e[i].y;
		int fx = getfa(x),fy = getfa(y);
		if(fx!=fy)
		{
			link(x,i+n);link(i+n,y);
			merge(fx,fy);
		}else
		{
			int k = getans(x,y);
			if(val[k]>e[i].b)
			{
				cut(e[k-n].x,k);
				cut(k,e[k-n].y);
				link(x,i+n);link(i+n,y);
			}
		}
		if(getfa(1)==getfa(n))
			ans = min(ans,e[i].a+val[getans(1,n)]);
	}
	if(ans!=0x3f3f3f3f)printf("%d\n",ans);
	else puts("-1");
	return 0;
}
Problem3670

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
const int mod = 1e9+7;
char s[N];
int nxt[N],dep[N],len;
void getnxt()
{
	int i = 0,j = -1;
	nxt[i] = j;
	dep[i] = 0;
	while(i<len)
	{
		if(j==-1||s[i]==s[j])
		{
			i++,j++;
			dep[i] = dep[j]+1;
			nxt[i] = j;
		}else j = nxt[j];
	}
}
void getans()
{
	int i = 0,j = -1;
	ll ans = 1;
	while(i<len)
	{
		if(j==-1||s[i]==s[j])
		{
			i++,j++;
			while(j!=-1&&(j<<1)>i)
				j = nxt[j];
			if(j!=-1&&i!=-1)
				ans = ans*(dep[j]+1)%mod;
		}else
			j = nxt[j];
	}
	printf("%lld\n",ans);
}	
int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%s",s);
		len = strlen(s);
		getnxt();
		getans();
	}
	return 0;
}
Problem3671

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5001;
typedef long long ll;
int X[N*N],mp[N][N];
bool us[N][N];
int l[N],r[N],ans[N<<1],top;
int main()
{
	int a,b,c,d,n,m,q;
	scanf("%d%d%d%d%d",&X[0],&a,&b,&c,&d);
	scanf("%d%d%d",&n,&m,&q);
	int end = n*m;
	for(int i = 1;i<= end;i++)
		X[i] = ((ll)a*X[i-1]%d*X[i-1]%d+(ll)b*X[i-1]%d+c)%d;
	for(int i = 1;i<= end;i++)
		mp[(i-1)/m+1][(i-1)%m+1] = i;
	for(int i = 1;i<= end;i++)
	{
		int j = X[i]%i+1;
		swap(mp[(i-1)/m+1][(i-1)%m+1],mp[(j-1)/m+1][(j-1)%m+1]);
	}
	for(int t = 1;t<= q;t++)
	{
		int i,j;
		scanf("%d%d",&i,&j);
		swap(mp[(i-1)/m+1][(i-1)%m+1],mp[(j-1)/m+1][(j-1)%m+1]);
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			X[mp[i][j]] = (i-1)*m+j;
	for(int i = 1;i<= n;i++)l[i]=1,r[i]=m;
	for(int i = 1;i<= end;i++)
	{
		if(us[(X[i]-1)/m+1][(X[i]-1)%m+1])continue;
		ans[++top] = i;
		if(top>=n+m-1)break;
		int x = (X[i]-1)/m+1,y = (X[i]-1)%m+1;
		for(int j = x+1;j<= n;j++)
			for(int k = l[j];k<y;k++)us[j][k]=true,l[j]++;
		for(int j = x-1;j>=1;j--)
			for(int k = r[j];k>y;k--)us[j][k]=true,r[j]--;
	}
	for(int i = 1;i< top;i++)
		printf("%d ",ans[i]);
	printf("%d\n",ans[top]);
	return 0;
}
Problem3672

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
typedef long long ll;
struct E
{int next,to;ll val;}e[N<<1];
int head[N],tot,fa[N];
ll dis[N];
void add(int x,int y,ll f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
void dfs(int x)
{
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa[x])
	{
		fa[e[i].to] = x;
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to);
	}
}
ll p[N],q[N],l[N];
int f[N],size[N],sum,root;
bool used[N];
void get_root(int x,int pre)
{
	f[x] = 0,size[x] = 1;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre&&!used[e[i].to])
	{
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int seq[N];
inline bool cmp(int x,int y){return dis[x]-l[x]>dis[y]-l[y];}
void Dfs(int x,int pre)
{
	seq[++tot] = x;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre&&!used[e[i].to])
		Dfs(e[i].to,x);
}
ll dp[N];
inline double slope(int x,int y)
{
	return (double)(dp[x]-dp[y])/(double)(dis[x]-dis[y]);
}
int stack[N],top;
double k[N];
void Insert(int x)
{
	while(top>1&&slope(x,stack[top])>slope(stack[top],stack[top-1]))
		top--;
	stack[++top] = x;
	k[top] = -slope(x,stack[top-1]);
}
void solve(int x)
{
	if(sum<=1)return ;
	root = 0;
	get_root(x,0);
	int now = root;
	for(int i = head[fa[now]];i;i=e[i].next)
		if(e[i].to==now&&!used[e[i].to])
		{
			used[now] = true;
			sum = size[x]-size[now];
			solve(x);
			break;
		}
	for(int i = fa[now];i!=fa[x];i=fa[i])
		if(dis[now]-dis[i]<=l[now])
			dp[now]=min(dp[now],dp[i]+(dis[now]-dis[i])*p[now]+q[now]);
	tot = 0;
	for(int i = head[now];i;i=e[i].next)
		if(e[i].to!=fa[now]&&!used[e[i].to])
			Dfs(e[i].to,now);
	sort(seq+1,seq+tot+1,cmp);
	top = 0;
	for(int i = 1,j = now;i<= tot;i++)
	{
		for(;j!=fa[x]&&dis[j]>=dis[seq[i]]-l[seq[i]];j=fa[j])
			Insert(j);
		if(top==1)
		{	
			if(dis[seq[i]]-dis[stack[top]]<=l[seq[i]])
				dp[seq[i]] = min(dp[seq[i]],dp[stack[top]]+
								(dis[seq[i]]-dis[stack[top]])*p[seq[i]]+q[seq[i]]);
		}else
		{
			int ot=min(top,upper_bound(k+2,k+top+1,-p[seq[i]])-k-1);
			if(dis[seq[i]]-dis[stack[ot]]<=l[seq[i]])
			dp[seq[i]] = min(dp[seq[i]],dp[stack[ot]]+
							(dis[seq[i]]-dis[stack[ot]])*p[seq[i]]+q[seq[i]]);
		}
	}
	for(int i = head[now];i;i=e[i].next)
		if(e[i].to!=fa[now]&&!used[e[i].to])
		{
			used[e[i].to] = true;
			sum = size[e[i].to];
			solve(e[i].to);
		}
}
int main()
{
	int n,t,a;ll b;
	scanf("%d%d",&n,&t);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%lld",&a,&b);
		add(i,a,b);
		scanf("%lld%lld%lld",&p[i],&q[i],&l[i]);
	}
	dfs(1);
	for(int i = 2;i<= n;i++)dp[i]=1ll<<60;
	sum = f[root=0] = n;
	used[1] = true;
	solve(1);
	for(int i = 2;i<= n;i++)printf("%lld\n",dp[i]);
	return 0; 
}
Problem3685

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int sum[N<<2],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
void update(int p,int l,int r,int x,int c)
{
	if(l==r)
		{sum[p]+=c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,c);
	else update(p<<1|1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int getans(int p,int l,int r,int no,int s)
{
	if(l==r)return l;
	int mid = (l+r)>>1;
	if(s+sum[p<<1]<no)
		return getans(p<<1|1,mid+1,r,no,s+sum[p<<1]);
	else return getans(p<<1,l,mid,no,s);
}
int check(int p,int l,int r,int a,int b)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ret = 0;
	if(a<=mid)ret+=check(p<<1,l,mid,a,b);
	if(b>mid)ret+=check(p<<1|1,mid+1,r,a,b);
	return ret;
}
void work(int opt)
{
	int x;
	if(opt<=2||opt>=5)x = read();
	x++;
	if(opt==1){if(check(1,1,n,x,x)==0)update(1,1,n,x,1);}
	else if(opt==2){if(check(1,1,n,x,x)==1)update(1,1,n,x,-1);}
	else if(opt==3){if(sum[1]==0)printf("-1\n");else printf("%d\n",getans(1,1,n,1,0)-1);}
	else if(opt==4){if(sum[1]==0)printf("-1\n");else printf("%d\n",getans(1,1,n,sum[1],0)-1);}
	else if(opt==5)
		{	
			int tmp = check(1,1,n,1,x-1);
			if(tmp==0)printf("-1\n");
			else printf("%d\n",getans(1,1,n,tmp,0)-1);
		}
	else if(opt==6)
		{
			int tmp = check(1,1,n,x+1,n);
			if(tmp==0)printf("-1\n");
			else printf("%d\n",getans(1,1,n,sum[1]-tmp+1,0)-1);
		}
	else{if(check(1,1,n,x,x)==1)printf("1\n");else printf("-1\n");}
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		x = read();
		work(x);
	}
	return 0;
}
Problem3688

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int MOD = 100007;
const int TOP = 100000;
struct Tree_s
{
	int c[TOP+5];
	void update(int x,int y)
	{
		for(int i = x;i<TOP;i+=i&(-i))
			(c[i] +=y)%=MOD;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			(ans+=c[i])%=MOD;
		return ans;
	}

}g[2][15],f[2][15];
int G[N][15],F[N][15];
struct P
{int x,y;}pos[N];
bool cmp(P a,P b)
{
	return a.x<b.x;
}
int main()
{	
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&pos[i].x,&pos[i].y);
	sort(pos+1,pos+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		F[i][0] = 1;
		G[i][0] = 1;
		f[0][0].update(pos[i].y,F[i][0]),f[1][0].update(TOP-pos[i].y,F[i][0]);
		g[0][0].update(pos[i].y,G[i][0]),g[1][0].update(TOP-pos[i].y,G[i][0]);
		for(int j = 1;j<= k;j++)
		{
			F[i][j] = (F[i][j]+g[0][j-1].getans(pos[i].y-1)+f[0][j].getans(pos[i].y-1))%MOD;
			G[i][j] = (G[i][j]+g[1][j].getans(TOP-pos[i].y-1)+f[1][j-1].getans(TOP-pos[i].y-1))%MOD;
			f[0][j].update(pos[i].y,F[i][j]),f[1][j].update(TOP-pos[i].y,F[i][j]);
			g[0][j].update(pos[i].y,G[i][j]),g[1][j].update(TOP-pos[i].y,G[i][j]);
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		ans = (ans+F[i][k]+G[i][k])%MOD;
	printf("%d\n",ans);
	return 0;
}
Problem3694

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 100005;
const int N = 4005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,dis[N],dep[N],top[N],son[N],size[N],w[N],fa[N],cnt,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	e[tot].val = f;
	head[y] = tot;
}
struct S
{int u,v,val;}b[M<<1];
int snum;
void add_s(int x,int y,int f)
{
	b[++snum].u = x;
	b[snum].v = y;
	b[snum].val = f;
}
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x]++;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=f)
		{
			dis[e[i].to] = dis[x]+e[i].val;
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
void dfs2(int x,int tp)
{
	w[x] = ++cnt;
	top[x] = tp;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int minn[N<<2],lazy[N<<2];
void push_down(int l,int r,int p)
{
	if(l==r||lazy[p]==INF)return ;
	minn[p<<1] = min(minn[p<<1],lazy[p]);
	minn[p<<1|1] = min(minn[p<<1|1],lazy[p]);
	lazy[p<<1] = min(lazy[p<<1],lazy[p]);
	lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
	lazy[p] = INF;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(l,r,p);
	if(l>=a&&r<=b)
	{
		minn[p] = min(minn[p],c);
		lazy[p] = min(lazy[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid) update(p<<1|1,mid+1,r,a,b,c);
	minn[p] = min(minn[p<<1],minn[p<<1|1]);
}
int getans(int p,int l,int r,int x)
{
	push_down(l,r,p);
	if(l==r)
		return minn[p];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int get_cut(int x,int y,int c,int opt)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		if(opt)update(1,1,n,w[top[x]],w[x],c);
		x = fa[top[x]];
	}
	if(x==y)return x;
	if(dep[x]<dep[y])swap(x,y);
	if(opt)update(1,1,n,w[y]+1,w[x],c);
	return y;
}
int main()
{
	int a,d,l,t;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a,&d,&l,&t);
		if(t)add(a,d,l);
		else add_s(a,d,l);
	}
	dfs1(1,0);
	dfs2(1,1);
	memset(minn,0x3f,sizeof(minn));
	memset(lazy,0x3f,sizeof(lazy));
	for(int i = 1;i<= snum;i++)
	{
		int lca = get_cut(b[i].u,b[i].v,0,0);
		int tmp = dis[b[i].u]+b[i].val+dis[b[i].v];
		get_cut(b[i].v,lca,tmp,1);
		get_cut(b[i].u,lca,tmp,1);
	}
	for(int i = 2;i<=n;i++)
	{
		int tmp = getans(1,1,n,w[i]);
		if(tmp==INF)printf("-1 ");
		else printf("%d ",tmp-dis[i]);
	}
	return 0;
}
Problem3697

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int sum,root,f[N],size[N],n;
bool used[N];
void get_root(int x,int fa)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] =max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int G[N<<1][2],F[N<<1][2],t[N<<1];
int maxdep;
void get_sum(int x,int fa,int num,int dep)
{
	maxdep = max(maxdep,dep);
	if(t[num])G[num][1]++;
	else G[num][0]++;
	t[num]++;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			get_sum(e[i].to,x,num+e[i].val,dep+1);
	t[num]--;
}
LL ans;
void calc(int x)
{
	F[n][0] = 1;
	int mx = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			maxdep = 0;
			get_sum(e[i].to,x,n+e[i].val,1);
			mx = max(mx,maxdep);
			ans+=(F[n][0]-1)*G[n][0];
			for(int j = -maxdep;j<= maxdep;j++)
			{
				ans+=(LL)F[n-j][0]*G[n+j][1];
				ans+=(LL)F[n-j][1]*G[n+j][0];
				ans+=(LL)F[n-j][1]*G[n+j][1];
			}
			for(int j = n-maxdep;j<= n+maxdep;j++)
				{F[j][0]+=G[j][0],F[j][1]+=G[j][1];G[j][0] = G[j][1] = 0;}
		}
	for(int i = n-mx;i<= n+mx;i++)
		F[i][0] = F[i][1] = 0;
}
void work(int x)
{
	calc(x);
	used[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(used[e[i].to])continue;
		sum = size[e[i].to];
		root = 0;
		get_root(e[i].to,0);
		work(root);
	}
}
int main()
{
	int x,y,z;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(!z)z = -1;
		add(x,y,z),add(y,x,z);
	}
	f[0] = 0x3f3f3f3f;
	root = 0;sum = n;
	get_root(1,0);
	work(1);
	printf("%lld\n",ans);
	return 0;
}
Problem3702

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL cnt1,cnt2;
const int N = 200005;
int root[N<<1],L[N<<1],R[N<<1],ls[4000005],rs[4000005],sum[4000005],cv[N<<1],tot,seg,n;
void scantree(int x)
{
	scanf("%d",&cv[x]);
	if(!cv[x])
	{
		L[x]=++tot;
		scantree(L[x]);
		R[x]=++tot;
		scantree(R[x]);
	}
}
void build(int &p,int l,int r,int c)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		sum[p] = 1;
		return ;
	}
	int mid = (l+r)>>1;
	if(c<=mid)build(ls[p],l,mid,c);
	else build(rs[p],mid+1,r,c);
	sum[p] = sum[rs[p]]+sum[ls[p]];
}
int merge(int x,int y)
{
	if(!x)return y;
	if(!y)return x;
	cnt1+=(LL)sum[ls[x]]*sum[rs[y]];
	cnt2+=(LL)sum[rs[x]]*sum[ls[y]];
	ls[x] = merge(ls[x],ls[y]);
	rs[x] = merge(rs[x],rs[y]);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
LL ans;
void solve(int x)
{
	if(!x)return ;
	solve(L[x]);solve(R[x]);
	if(!cv[x])
	{
		cnt1 = cnt2 = 0;
		root[x] = merge(root[L[x]],root[R[x]]);
		ans+=min(cnt1,cnt2);
	}
}
int main()
{
	scanf("%d",&n);
	tot++;
	scantree(1);
	for(int i = 1;i<= tot;i++)
		if(cv[i])build(root[i],1,n,cv[i]);
	solve(1);
	printf("%lld\n",ans);
	return 0;
}
Problem3709

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct Data{int x,y,id;}a[N],b[N];
bool cmp1(const Data &m,const Data &n)
{
	return m.x<n.x;
}
bool cmp2(const Data &m,const Data &n)
{
	return m.y>n.y;
}
int main()
{
	int cnt1,cnt2;
	cnt1 = cnt2 = 0;
	int n,x,y;
	long long z;
	scanf("%d%lld",&n,&z);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		if(y>=x){a[++cnt1].x = x,a[cnt1].y = y,a[cnt1].id = i;}
		else{b[++cnt2].x = x,b[cnt2].y = y,b[cnt2].id = i;}
	}
	sort(a+1,a+cnt1+1,cmp1);
	sort(b+1,b+cnt2+1,cmp2);
	for(int i = 1;i<= cnt1;i++)
	{
		if(z-a[i].x<=0){printf("NIE\n");return 0;}
		z+=a[i].y-a[i].x;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		if(z-b[i].x<=0){printf("NIE\n");return 0;}
		z+=b[i].y-b[i].x;
	}
	printf("TAK\n");
	for(int i = 1;i<= cnt1;i++)
		printf("%d ",a[i].id);
	for(int i = 1;i<= cnt2;i++)
		printf("%d ",b[i].id);
	return 0;
}
Problem3711

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define P 1000000007
#define GET (ch>='0'&&ch<='9')
#define MAXN 1000005
#define lchild rt<<1,l,mid
#define rchild rt<<1|1,mid+1,r
#define ln rt<<1
#define rn rt<<1|1
#define MAXINT 1000000
using namespace std;
int n;
int c[MAXN],d[MAXN],g[MAXN];
struct node
{
	int x,y;
	node()  {   x=y=0;  }
	node(int tx,int ty) {   x=tx;y=ty;  }
	inline node operator + (const node& b)
	{
		if (x<b.x)  return  b;
		if (x>b.x)  return  (node){x,y};
		return (node){x,(y+b.y)%P};
	}
	inline node operator + (int tx) {   return (node){x+tx,y};  }
	inline void operator +=(const node& b)  {   *this=*this+b;  }
}f[MAXN];
struct seg
{
	int l,r;
	int pos,vald;
	node f,flag;
}tree[(MAXN<<1)+(int)(1e5)];
inline void build1(int rt=1,int l=0,int r=n)
{
	tree[rt].l=l;tree[rt].r=r;
	if (l==r)   {   tree[rt].pos=l;tree[rt].vald=d[l];return;   }
	int mid=(l+r)>>1;build1(lchild);build1(rchild);
	tree[rt].pos=c[tree[ln].pos]>c[tree[rn].pos]?tree[ln].pos:tree[rn].pos;
	tree[rt].vald=min(tree[ln].vald,tree[rn].vald);
}
inline void build2(int rt=1,int l=0,int r=n)
{
	tree[rt].flag=(node){-MAXINT,0};
	if (l==r)   {   tree[rt].vald=d[l];tree[rt].f=f[l];return;  }
	int mid=(l+r)>>1;build2(lchild);build2(rchild);
	tree[rt].f=tree[ln].f+tree[rn].f;
	tree[rt].vald=min(tree[ln].vald,tree[rn].vald);
}
inline void modify_add(int rt,int l,int r,node delta)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&R<=r) {   tree[rt].flag+=delta;return;    }
	if (r<=mid) modify_add(ln,l,r,delta);
	else    if (l>mid)  modify_add(rn,l,r,delta);
	else    modify_add(ln,l,mid,delta),modify_add(rn,mid+1,r,delta);
}
inline int query_c(int rt,int l,int r)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].pos;
	if (r<=mid) return query_c(ln,l,r);
	if (l>mid)  return query_c(rn,l,r);
	int t1=query_c(ln,l,mid),t2=query_c(rn,mid+1,r);    
	return c[t1]>c[t2]?t1:t2;
}
inline int query_d(int rt,int l,int r)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].vald;
	if (r<=mid) return query_d(ln,l,r);
	if (l>mid)  return query_d(rn,l,r);
	return min(query_d(ln,l,mid),query_d(rn,mid+1,r));
}
inline node query_f(int rt,int l,int r)
{
	if (l>r)    return node(-MAXINT,0);
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].f;
	if (r<=mid) return query_f(ln,l,r);
	if (l>mid)  return query_f(rn,l,r);
	return query_f(ln,l,mid)+query_f(rn,mid+1,r);
}
inline void modify_cov(int rt,int x,node delta)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (L==R)   {   tree[rt].f=delta;return;    }
	if (x<=mid) modify_cov(ln,x,delta); else    modify_cov(rn,x,delta);
	tree[rt].f=tree[ln].f+tree[rn].f;
}
node ask(int x)
{
	int rt=1,L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	node t=node(-MAXINT,0);
	while (L!=R)
	{
		t+=tree[rt].flag;
		mid=(L+R)>>1;rt<<=1;
		if (x>mid)  rt|=1;
		L=tree[rt].l,R=tree[rt].r;
	}
	t+=tree[rt].flag;
	return t;
}
inline void update(int l,int mid,int r)
{
	int i=max(c[mid]+l,mid);
	if (i>r||g[i]>=mid) return;
	int newl=max(l,g[i]),newr=i-c[mid];
	node tmp=query_f(1,newl,newr)+1;
	for (;i<=mid-1+c[mid]&&i<=r;i++)
	{
		if (g[i]>newl)
		{
			if (g[i]>=mid)  return;
			newl=g[i];tmp=query_f(1,newl,newr)+1;
		}
		f[i]+=tmp;newr++;
		if (newr>=newl) tmp+=f[newr]+1;
	}
	while (i<=r)
	{
		if (g[i]>newl)
		{
			if (g[i]>=mid)  return;
			newl=g[i];
		}
		tmp=query_f(1,newl,mid-1)+1;
		int t=query_d(1,newl+1,n);
		if (t>r)    {   modify_add(1,i,r,tmp);return;   }
		modify_add(1,i,t-1,tmp);i=t;
	}
}
void solve(int l,int r)
{
	if (l==r)
	{
		if (l)  modify_cov(1,l,f[l]=f[l]+ask(l));
		return;
	}
	int mid=query_c(1,l+1,r);
	solve(l,mid-1);update(l,mid,r);solve(mid,r);
}
int main()
{
	scanf("%d",&n);
	int i=0,j=0;
	for (i=1;i<=n;i++)scanf("%d%d",&c[i],&d[i]);	
	build1();
	for (i=0;i<=n;i++)  d[i]=n+1,f[i]=node(-MAXINT,0);
	f[0]=node(0,1);
	for (i=0;i<=n;i++)
	{
		while (j<i&&i-j>query_d(1,j+1,i))   j++;
		g[i]=j;
		if (d[g[i]]>n)  d[g[i]]=i;
	}
	build2();solve(0,n);
	printf(f[n].x>0?"%d %d\n":"NIE\n",f[n].x,f[n].y);
}
Problem3712

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e5+5;
const int K = 5e5+5;
int no[N],g[N],dep[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,fa[N][20],dfn[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	fa[y][0] = x;
}
struct Opt
{int x,y,dp,no;}opt[K];
bool cmp(const Opt &a,const Opt &b)
{
	if(a.dp==b.dp)return a.no<b.no;
	else return a.dp>b.dp;
}
void dfs(int x,int id)
{
	dfn[x] = id;
	for(int j = 1;j<= 19;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
	for(int i = head[x];i;i=e[i].next)
		dep[e[i].to] = dep[x]+1,
		dfs(e[i].to,id);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 19;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 19;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&g[i]),no[i]=i;
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(n+i,no[x]),add(n+i,no[y]);
		no[y] = n+i;
	}
	int tot = 0;
	for(int i = 1;i<= n+m;i++)if(!fa[i][0])dfs(i,++tot);
	int ask = 0;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		if(dfn[x]==dfn[y])opt[++ask] = (Opt){x,y,dep[getlca(x,y)],i};
	}
	sort(opt+1,opt+ask+1,cmp);
	long long ans = 0;
	for(int i = 1;i<= ask;i++)
	{
		int gd = min(g[opt[i].x],g[opt[i].y]);
		g[opt[i].x]-=gd,g[opt[i].y]-=gd;
		ans+=2*gd;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3714

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 4e6+5;
struct E
{int x,y,val;}e[M];
bool cmp(const E &a,const E &b)
{
	return a.val<b.val;
}
int fa[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,tot = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)
		{
			scanf("%d",&x);
			e[++tot].x = i-1,e[tot].y = j,e[tot].val = x;
		}
	for(int i = 0;i<=n;i++)fa[i] = i;
	sort(e+1,e+tot+1,cmp);
	long long ans = 0;
	for(int i = 1;i<= tot;i++)
	{
		int tx = e[i].x,ty = e[i].y;
		tx = getfa(tx),ty = getfa(ty);
		if(tx==ty)continue;
		ans+=e[i].val;
		uni(tx,ty);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3716

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 200005;
int n,m;
ll w,h,x,y,v,ans;
struct data
{
	ll x,y,v;
	bool operator<(const data &s)const
	{
		if(x==s.x)return y<s.y;
		return x<s.x;
	}
}p[N<<1];
struct Data
{
	ll y,v;
	bool operator<(const Data &s)const
	{
		return y<=s.y;
	}
};
set<Data>s;
set<Data>::iterator it;
int main()
{
	scanf("%d%d%lld%lld",&n,&m,&w,&h);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&v);
		x = x*h,y = y*w;
		p[i].x = x+y,p[i].y = y-x,p[i].v=v;
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&v);
		x = x*h,y = y*w;
		p[n+i].x = x+y,p[n+i].y = y-x,p[n+i].v=-v;
	}
	sort(p+1,p+m+n+1);
	for(int i = 1;i<= n+m;i++)
		for(y=p[i].y,v=p[i].v;v;ans-=it->v,v+=it->v,s.erase(it))
		{
			it = s.lower_bound((Data){y,0});
			if(it==s.end()||it->y!=y)
			{
				if(v>0){s.insert((Data){y,v});ans+=v;break;}
				else if(it==s.begin())break;
				else y = (--it)->y;
			}
		}
	printf("%lld\n",ans);
	return 0;
}
Problem3717

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = (1<<24)+5;
int f[N],g[N];
int a[N],c[105];
bool cmp(const int &a,const int &b)
{
	return a>b;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&c[i]);
	for(int i = n;i;i--)a[1<<(i-1)]=a[i];
	sort(c+1,c+m+1,cmp);
	int end = (1<<n),tmp,x;
	for(int i = 1;i<end;i++)
	{
		f[i] = m+1,g[i] = -1;
		for(int j = i;j;j-=tmp)
		{
			tmp = j&(-j),x = i-tmp;
			if(a[tmp]<=g[x]&&(f[x]<f[i]||(f[x]==f[i]&&g[x]-a[tmp]>g[i])))f[i]=f[x],g[i]=g[x]-a[tmp];
			else if((f[x]+1<f[i]||(f[x]+1==f[i]&&c[f[x]+1]-a[tmp]>g[i]))&&c[f[x]+1]>=a[tmp])f[i]=f[x]+1,g[i]=c[f[x]+1]-a[tmp];
		}
	}
	if(f[end-1]>m)printf("NIE\n");
	else printf("%d\n",f[end-1]);
	return 0;
}
Problem3718

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct C
{int a,b,c;}car[N];
int id[N];
bool cmp(const C &x,const C &y)
{
	return x.a>y.a;
}
int getid(int x,int tot)
{
	int l = 1,r = tot+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l=mid+1;
		else r = mid;
	}
	return l;
}
int c[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = max(c[i],y);
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans = max(ans,c[i]);
	return ans;
}
void work()
{
	memset(c,0,sizeof(c));
	int x1,x2,y1,y2;
	int n,w;
	scanf("%d%d",&n,&w);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		car[i].a = min(x1,x2);
		car[i].c = abs(y2-y1);
	}
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		car[i].b = min(x1,x2);id[i] = car[i].b;
	}
	sort(id+1,id+n+1);
	int tot = 0;
	id[0]=-1;
	for(int i = 1;i<= n;i++)
		if(id[tot]!=id[i])
			id[++tot] = id[i];
	sort(car+1,car+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		int pos = getid(car[i].b,tot);
		int maxn = getans(pos-1);
		if(w-maxn<car[i].c){printf("NIE\n");return ;}
		update(pos,car[i].c);
	}
	printf("TAK\n");
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)work();
	return 0;
}
Problem3719

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int S = 1e6+5;
const int size = 1e6;
struct data
{
	int x1,y1,x2,y2;
	bool operator <(const data &s)const
	{
		if(x1==s.x1)
		{
			if(x2==s.x2)
			{
				if(y1==s.y1)return y1<s.y1;
				else return y2<s.y2;
			}else return x2<s.x2;
		}else return x1<s.x1;
	}
}s[N],Ans[N];
int fa[N],st[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void merge(int a,int b)
{
	int x = getfa(a),y = getfa(b);
	if(x==y)return ;
	s[a].x1 = min(s[a].x1,s[b].x1),s[a].x2 = max(s[a].x2,s[b].x2);
	s[a].y1 = min(s[a].y1,s[b].y1),s[a].y2 = max(s[a].y2,s[b].y2);
	fa[y] = a;
}
struct node{ vector<int>q1,q2;}tr[S<<2];
bool cmp(int a,int b)
{
	return s[a].y2==s[b].y2?a<b:s[a].y2<s[b].y2;
}
int sta[S],top;
void Insert(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b){sta[++top]=p;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Insert(p<<1,l,mid,a,b);
	if(b >mid)Insert(p<<1|1,mid+1,r,a,b);
}
void update(int rt,int x)
{
	for(;rt;rt>>=1)tr[rt].q1.push_back(x);
}
int find_rt(int p,int l,int r,int x)
{
	if(l==r)return p;
	int mid = (l+r)>>1;
	if(x<=mid)return find_rt(p<<1,l,mid,x);
	else return find_rt(p<<1|1,mid+1,r,x);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&s[i].x1,&s[i].x2,&s[i].y1,&s[i].y2);
		s[i].x1++,s[i].y1++;fa[i]=st[i]=i;
	}
	sort(st+1,st+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		bool flag = true;
		while(flag)
		{
			top = 0;flag = false;
			Insert(1,1,size,s[st[i]].x1,s[st[i]].x2);
			for(int j = 1;j<= top;j++)
				for(int k = tr[sta[j]].q1.size()-1;k>=0;k--)
				{
					int y = tr[sta[j]].q1[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[sta[j]].q1.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[sta[j]].q1.pop_back();
				}
			for(int now = find_rt(1,1,size,s[st[i]].x1);now;now>>=1)
				for(int k = tr[now].q2.size()-1;k>=0;k--)
				{
					int y = tr[now].q2[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[now].q2.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[now].q2.pop_back();
				}
			for(int now = find_rt(1,1,size,s[st[i]].x2);now;now>>=1)
				for(int k = tr[now].q2.size()-1;k>=0;k--)
				{
					int y = tr[now].q2[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[now].q2.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[now].q2.pop_back();
				}
		}
		update(find_rt(1,1,size,s[st[i]].x1),st[i]);
		if(s[st[i]].x1!=s[st[i]].x2)
			update(find_rt(1,1,size,s[st[i]].x2),st[i]);
		top = 0;
		Insert(1,1,size,s[st[i]].x1,s[st[i]].x2);
		for(int j = 1;j<= top;j++)
			tr[sta[j]].q2.push_back(st[i]);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i)
		{
			Ans[++ans] = s[i];
			Ans[ans].x1--,Ans[ans].y1--;
		}
	printf("%d\n",ans);
	sort(Ans+1,Ans+ans+1);
	for(int i = 1;i<= ans;i++)
		printf("%d %d %d %d\n",Ans[i].x1,Ans[i].x2,Ans[i].y1,Ans[i].y2);
	return 0;
}
Problem3722

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int col[N],typ[N];
int dfs(int x,int fa)
{
	if(typ[x]<=0)return col[x];
	int sum = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			sum+=dfs(e[i].to,x);
	if(sum<0)return -1;
	else if(sum>0)return 1;
	return 0;
}
int ans[N],top;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&typ[i]);
		if(typ[i]==-2)col[i] = 1;
		else if(typ[i]==-1)col[i] = -1;
		else if(typ[i]>0)
		{
			int m = typ[i],x;
			while(m--)
				scanf("%d",&x),add(i,x);
		}
	}
	if(dfs(1,0)<0)printf("NIE\n");
	else
	{
		for(int i = 1;i<= n;i++)
			if(typ[i]==0)
			{
				col[i] = 1;
				if(dfs(1,0))ans[++top] = i;
				col[i] = 0;
			}
		printf("TAK %d\n",top);
		for(int i = 1;i<= top;i++)
		{
			printf("%d",ans[i]);
			if(i!=top)printf(" ");
		}
	}
	return 0;
}
Problem3725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
char s[N];
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	int last,now = 0,mn = n;
	for(int i = 1;i<= n;i++)
		if(s[i]!='*')
		{
			if(!last||last == s[i])last = s[i],now = i;
			else
			{
				mn = min(mn,i-now);
				last = s[i],now = i;
			}
		}
	printf("%d\n",n-mn+1);
	return 0;
}
Problem3726

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
char s[N];
int l0[N],r0[N],l1[N],r1[N],a[N],b[N],nxt[N],pre[N],G[N],NXT[N];
int L[N],R[N],ans;
void add(int x,int y){NXT[y]=G[x];G[x]=y;}
void del(int x){nxt[pre[x]]=nxt[x];pre[nxt[x]]=pre[x];}
int main()
{
	int n,m,i,j;
	scanf("%d%d",&n,&m);
	for(i = 1;i<= m;i++)l0[i]=l1[i]=1,r0[i]=r1[i]=m;
	for(int T = 1;T<= n;T++)
	{
		scanf("%s",s+1);
		for(i=j=1;i<=m;i++)
			if(s[i]=='.')
			{
				a[i]++,b[i]++;
				if(l0[i]<j)l0[i]=j;
				if(l1[i]<j)l1[i]=j;
			}else
			{
				b[i]=a[i]+1,a[i]=0;
				l1[i]=l0[i],l0[i]=1;
				if(l1[i]<j)l1[i]=j;
				j=i+1;
			}
		for(i=j=m;i>=1;i--)
			if(s[i]=='.')
			{
				if(r0[i]>j)r0[i]=j;
				if(r1[i]>j)r1[i]=j;
			}else
			{
				r1[i]=r0[i],r0[i]=m;
				if(r1[i]>j)r1[i]=j;
				j=i-1;
			}
		for(i = 0;i<= T;i++)G[i]=0;
		for(i = m;i;i--)add(a[i],i),pre[i]=i-1,nxt[i]=i+1;
		for(pre[1]=0,nxt[m]=m+1,i=T;~i;i--)
			for(j=G[i];j;j=NXT[j])
				L[j]=pre[pre[j]],del(j);
		for(i = 0;i<= T;i++)G[i]=0;
		for(i = 1;i<=m;i++)add(a[i],i),pre[i]=i-1,nxt[i]=i+1;
		for(pre[1]=0,nxt[m]=m+1,i=T;~i;i--)
			for(j=G[i];j;j=NXT[j])
				R[j]=nxt[nxt[j]],del(j);
		for(i = 1;i<=m;i++)
		{
			ans = max(ans,(r1[i]-l1[i]+1)*b[i]);
			if(!a[i])continue;
			j = l0[i];
			if(j>1&&b[j-1]>=a[i]){if(L[i])j=L[i]+1;else j--;}
			ans = max(ans,(r0[i]-j+1)*a[i]);
			j = r0[i];
			if(j<m&&b[j+1]>=a[i]){if(R[i])j=R[i]-1;else j++;}
			ans = max(ans,(j-l0[i]+1)*a[i]);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem3727

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 3e5+5;
int fa[N],dis[N];
struct EDGE
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct Fac
{
	LL c,a;
	void operator +=(const Fac &S)
		{c+=S.c;a+=S.a;}
	void operator -=(const Fac &S)
		{c-=S.c;a-=S.a;}
	void operator *=(int y)
		{c*=y,a*=y;}
}two_size[N],two_a[N];
void dfs(int x,int f)
{
	fa[x] = f;
	if(x!=1)dis[x] = dis[f]+1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
}
LL size[N],a[N],b[N];
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		scanf("%lld",&b[i]);
	dfs(1,0);
	for(int i = 2;i<= n;i++)
		two_size[i] = (Fac){b[fa[i]]-b[i],1};
	for(int i = 2;i<= n;i++)
	{
		two_a[i]+=two_size[i];
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to!=fa[i])
				two_a[i]-=two_size[e[j].to];
	}
	Fac b1;
	b1.c = 0,b1.a = 0;
	for(int i = 2;i<= n;i++)
	{
		Fac tmp = two_a[i];
		tmp*=dis[i];
		b1+=tmp;
	}
	size[1] = (b[1]*2-b1.c)/b1.a;
	for(int i = 2;i<= n;i++)
		size[i] = (two_size[i].c+size[1])/2;
	for(int i = 1;i<= n;i++)
	{
		a[i]+=size[i];
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to!=fa[i])
				a[i]-=size[e[j].to];
		printf("%lld",a[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem3728

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
bool cmp1(const int &a,const int &b){return a<b;}
bool cmp2(const int &a,const int &b){return b<a;}
int heap[N],ans[N],cnth,cnta;
int lamp[N],lst[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&lamp[i]);
	for(int i = 1;i<= n;i++)
		scanf("%d",&lst[i]);
	sort(lamp+1,lamp+n+1,cmp2);
	sort(lst+1,lst+n+1,cmp2);
	int j = 1;
	long long tans = 0;
	for(int i = 1;i<= n;i++)
	{
		while(j<=n&&lamp[j]>=lst[i])
		{
			heap[++cnth] = lamp[j];
			push_heap(heap+1,heap+cnth+1,cmp2);
			j++;
		}
		if(cnth<=0&&k>=1)k--,tans+=lst[i];
		else if(cnth<=0){printf("NIE\n");return 0;}
		else
		{
			tans+=heap[1];
			ans[++cnta] = heap[1]-lst[i];
			push_heap(ans+1,ans+cnta+1,cmp1);
			pop_heap(heap+1,heap+cnth+1,cmp2);
			cnth--;
		}
	}
	while(k&&cnta)
	{
		tans-=ans[1];
		pop_heap(ans+1,ans+cnta+1,cmp1);
		cnta--,k--;
	}
	printf("%lld\n",tans);
	return 0;
}
Problem3730

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e7;
int rot[N][2],cnt,n,m;
int ls[M],rs[M],sum[M],a[N];
void update(int &p,int l,int r,int pos,int val)
{
	if(!p)p = ++cnt;
	sum[p]+=val;
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],l,mid,pos,val);
	else update(rs[p],mid+1,r,pos,val);
	//sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	if(a>b)return 0;
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int pos[N],T,log_2[N<<1];
int min_dpt[N<<1][18],dpt[N];
void dfs(int x,int from)
{
	min_dpt[pos[x]=++T][0] = dpt[x];
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=from)
		{
			dpt[e[i].to] = dpt[x]+1;
			dfs(e[i].to,x);
			min_dpt[++T][0] = dpt[x];
		}
}
void build_lca()
{
	for(int i = 2;i<=T;i++)
		log_2[i] = log_2[i>>1]+1;
	for(int j = 1;j<= log_2[T];j++)
		for(int i = 1;i+(1<<j)-1<=T;i++)
			min_dpt[i][j] = min(min_dpt[i][j-1],min_dpt[i+(1<<(j-1))][j-1]);
}
int get_lcadpt(int x,int y)
{
	x = pos[x],y = pos[y];
	if(x>y)swap(x,y);
	int l = log_2[y-x+1];
	return min(min_dpt[x][l],min_dpt[y-(1<<l)+1][l]);
}
int getdis(int x,int y)
{
	return dpt[x]+dpt[y]-2*get_lcadpt(x,y);
}
bool used[N];
int size[N],f[N],Sum,father[N];
void get_size(int x,int pre)
{
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_size(e[i].to,x);
			size[x]+=size[e[i].to];
		}
}
int root;
void get_root(int x,int pre)
{
	size[x] = 1,f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],Sum-size[x]);
	if(f[x]<f[root])root = x;
}
int stack[N],top;
void DFS(int x,int pre)
{
	stack[++top] = x;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
			DFS(e[i].to,x);
}
void Build(int x,int pre)
{
	get_size(x,0);
	Sum = size[x];f[0] = Sum,root = 0;
	get_root(x,0);
	x = root;
	father[x] = pre;
	used[x] = true;
	top = 0;
	DFS(x,0);
	for(int i = 1;i<= top;i++)
	{
		int y = stack[i];
		update(rot[x][0],0,n,getdis(y,x),a[y]);
		update(rot[x][1],0,n,getdis(y,father[x]),a[y]);
	}
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
			Build(e[i].to,x);
}
void Update(int x,int del)
{
	for(int i = x;i;i=father[i])
	{
		update(rot[i][0],0,n,getdis(x,i),del);
		if(father[i])update(rot[i][1],0,n,getdis(x,father[i]),del);
	}
	a[x]+=del;
}
int Getans(int x,int k)
{
	int ans = 0;
	for(int i = x;i;i=father[i])
	{
		int Dis = getdis(i,x);
		if(Dis<=k)
			ans = ans+getans(rot[i][0],0,n,0,k-Dis);
		if(father[i])
		{
			int Dis2 = getdis(father[i],x);
			if(Dis2<=k)ans = ans-getans(rot[i][1],0,n,0,k-Dis2);
		}
	}
	return ans;
}
int main()
{
	//freopen("x.in","r",stdin);
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	int opt;
	dpt[1] = 1;
	dfs(1,0);
	build_lca();
	Build(1,0);
	int lastans = 0;
	while(m--)
	{
		scanf("%d%d%d",&opt,&x,&y);
		x = x^lastans,y = y^lastans;
		if(opt==0)
			printf("%d\n",lastans = Getans(x,y));
		else Update(x,y-a[x]);
	}
	return 0;
}
Problem3733

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e4+10;
typedef long long ll;
ll f[N][35];
int fac[N],n,m,k;
bool dfs(int now,int x,int pro)
{
	if(!x)return pro==n;
	x--;
	for(;now+x<=m;now++)
	{
		if(f[now][x]<0)return false;
		if((ll)pro*f[now][x]>n)return false;
		if(dfs(now+1,x,pro*fac[now]))return true;
	}
	return false;
}
int main()
{
	int test;
	scanf("%d",&test);
	while(test--)
	{
		m=0;
		scanf("%d%d",&n,&k);
		for(int i = 1;i*i<=n;i++)
			if(n%i==0)
			{
				fac[++m] = i;
				if(i*i!=n)fac[++m] = n/i;
			}
		sort(fac+1,fac+m+1);
		ll pro = 1;
		for(int i = 1;i<= m;i++)
		{
			pro = 1;
			for(int j = 0;j<k&&i+j<=m;f[i][j++]=pro)
			if(pro>0)
			{
				pro = pro*fac[i+j];
				if(pro>n)pro = -1;
			}
		}
		if(dfs(1,k,1))printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem3735

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	ll pos;int i;
	data(){}
	data(ll _pos,int _i):pos(_pos),i(_i){}
	bool operator <(const data &s)const
	{
		if(pos==s.pos)return i>s.i;
		return pos>s.pos;
	}
}heap[N];
int cnt,a[N];ll n,L,R,now;int k;
ll Ans[N];
bool check(ll mid)
{
	ll ans = n;
	for(int i = 1;i<= k;i++)
	{
		ans-=mid/a[i];
		if(ans<0)return false;
	}
	return true;
}
int main()
{
	scanf("%lld%d",&n,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&a[i]);
		R = max(R,1ll*a[i]);
	}
	L = R+1,R = R*n;
	ll ans = 0;
	while(L<=R)
	{
		ll mid = (L+R)>>1;
		if(check(mid))L=mid+1,ans=mid;
		else R = mid-1;
	}
	R = ans;
	for(int i = 1;i<= k;i++)R = min(R,max((ans/a[i]-1)*a[i],0ll));
	cnt = 0;
	for(int i = 1;i<= k;i++)
	{
		now+=R/a[i];
		heap[++cnt] = data(R/a[i]*a[i],i);
		push_heap(heap+1,heap+cnt+1);
	}
	while(now<n)
	{
		data tmp = heap[1];
		pop_heap(heap+1,heap+cnt+1);
		Ans[tmp.i] = ++now;
		tmp.pos+=a[tmp.i];
		heap[cnt] = tmp;
		push_heap(heap+1,heap+cnt+1);
	}
	for(int i = 1;i< k;i++)
		printf("%lld ",Ans[i]);
	printf("%lld\n",Ans[k]);
	return 0;
}
Problem3736

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2505;
int n,m,ml,mw,s,tmp[N][N],f[2][N],L[2][N],R[2][N],l[N],r[N];
int mxc[N],mxr[N];
char str[N];
bool a[N][N];
void solve(int mxc[])
{
	for(int j = 1;j<= m;j++)
		L[0][j] = 0,R[0][j] = m+1,f[0][j] = 0;
	for(int i = 1,cur = 1;i<= n;i++)
	{
		l[0] = 0,r[m+1] = m+1;
		for(int j = m;j;j--)
			if(a[i][j])r[j]=r[j+1];
			else r[j]=j;
		for(int j = 1;j<= m;j++)
			if(a[i][j])
			{
				l[j] = l[j-1];
				f[cur][j] = f[cur^1][j]+1;
				L[cur][j] = max(L[cur^1][j],l[j]);
				R[cur][j] = min(R[cur^1][j],r[j]);
				int r = f[cur][j],c = R[cur][j]-L[cur][j]-1;
				mxc[r] = min(mxc[r],c);
				if(!a[i+1][j])
				{
					for(int p = r+1;p<= n;p++)
						if(mxc[p])
							mxc[p]=0;
						else break;
				}
			}else
				l[j] = j,f[cur][j]=L[cur][j]=0,R[cur][j]=m+1;
		cur^=1;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",str+1);
		for(int j = 1;j<= m;j++)
			a[i][j]=str[j]=='X';
	}
	memset(mxc,0x3f,sizeof(mxc));
	memset(mxr,0x3f,sizeof(mxr));
	solve(mxc);
	for(int j = 1;j<= m;j++)
		for(int i = 1;i<= n>>1;i++)
			swap(a[i][j],a[n-i+1][j]);
	solve(mxc);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			tmp[j][i]=a[i][j],a[i][j]=false;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			a[i][j]=tmp[i][j];
	swap(n,m);
	solve(mxr);
	for(int j = 1;j<= m;j++)
		for(int i = 1;i<= n>>1;i++)
			swap(a[i][j],a[n-i+1][j]);
	solve(mxr);
	swap(n,m);
	mxr[0] = n+1;
	for(int i = n,j=1;j<= m;j++)
		for(;i>mxr[j];i--)
			mxc[i] = min(mxc[i],j-1);
	for(int i = 1;i<=n;i++)
		if(i*mxc[i]>s)
			s=i*mxc[i],ml=i,mw=mxc[i];
	printf("%d %d\n",ml,mw);
	return 0;
}
Problem3737

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <algorithm>
using namespace std;
typedef long long LL;
#define rep(i,j,n) for(int i=j;i<=n;i++)
char c;
bool t[4010010];
LL n,p[1000000],ans[1000000];
int T,tot,tott,len,S=10;
void pre()
{
    memset(t,true,sizeof(t));
    rep(i,2,4010000) 
    	if(t[i])
    	{
        	p[++len]=i;
       		rep(j,i,4010000/i) t[i*j]=false;
    	}
}
inline LL muti_mod(LL a,LL b,LL c)
{
    a%=c;
    b%=c;
    LL ret=0;
    while(b)
    {
        if(b&1){ret+=a;if(ret>=c)ret-=c;}
        a<<=1;
        if(a>=c)a-=c;
        b>>=1;
    }
    return ret;
}
inline LL pow_mod(LL x,LL n,LL mod)
{
    if(n==1)return x%mod;
    int bit[50],k=0;
    while(n)
    {
        bit[k++]=n&1;
        n>>=1;
    }
    LL ret=1;
    for(;k>0;k--)
    {
        ret=muti_mod(ret,ret,mod);
        if (bit[k-1]==1) ret=muti_mod(ret,x,mod);
    }
    return ret;
}
inline bool check(LL a,LL n,LL x,LL t)
{
    LL ret=pow_mod(a,x,n),last=ret;
    for(int i=1;i<=t;i++)
    {
        ret=muti_mod(ret,ret,n);
        if(ret==1&&last!=1&&last!=n-1) return true;
        last=ret;
    }
    if(ret!=1) return true;
    return false;
}
inline bool prime(LL n)
{
    if(n<2)return false;
    if(n==2)return true;
    if((n&1)==0) return false;
    LL x=n-1;LL t=0;
    while((x&1)==0){x>>=1;t++;}
    for(int i=0;i<S;i++)
    {
        LL a=rand()%(n-1)+1;
        if(check(a,n,x,t)) return false;
    }
    return true;
}
void find(LL n,int list,LL now)
{
    if(n==1){ans[tot++]=now;return;}
    if(1&n) return;
    LL N=now,m,maxi=int(sqrt(n))+1;
    rep(i,list,len) if(p[i]>maxi)break;else if(n%(p[i]-1)==0)
    {
        m=n/(p[i]-1);
        N*=p[i];
        find(m,i+1,N);
        while(m%p[i]==0)
        {
            m/=p[i];N*=p[i];
            find(m,i+1,N);
        }
        N=now;
    }
    if(n+1>=p[list])
    {
        if(n+1>p[len]){if(prime(n+1))ans[tot++]=N*(n+1);}
        else{if(t[n+1])ans[tot++]=N*(n+1);}
    }
}
int main()
{
    scanf("%d",&T);
    pre();
    while(T--)
    {
        scanf("%lld",&n);tot=0;
        if(1&n){
            if(n==1){puts("2");puts("1 2");}else puts("0"),puts("");
            continue;
        }
        find(n,1,1);
        sort(ans,ans+tot);
        printf("%d\n",tot);
        rep(i,0,tot-2) printf("%lld ",ans[i]);
        if(tot)printf("%lld\n",ans[tot-1]);else{puts("");};
    }
}
Problem3744

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
const int B = 305;
int c[N],sum[B][B],Sum[B][N];
int a[N],b[N],bel[N],bs[B],be[B],n,L,cnt,size;
int Find(int x)
{
	int l = 1,r = L+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(b[mid]<x)l=mid+1;
		else r = mid;
	}
	return l;
}
void update(int x,int y)
{
	for(int i = x;i<=n;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void Update(int id,int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		sum[id][i]+=y;
}
int Getans(int id,int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=sum[id][i];
	return ans;
}
void UPDATE(int id,int x,int y)
{
	for(int i = x;i<=n;i+=i&(-i))
		Sum[id][i]+=y;
}
int GETANS(int id,int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=Sum[id][i];
	return ans;
}
int ni[B];
int main()
{
	//freopen("noon.in","r",stdin);
	//freopen("noon.out","w",stdout);
	//freopen("x.in","r",stdin);
	scanf("%d",&n);
	size = floor(sqrt(n));
	for(int i = 1;i<= n;i+=size)
	{
		bs[++cnt]=i;be[cnt]=min(n,i+size-1);
		for(int j = bs[cnt];j<=be[cnt];j++)
			bel[j]=cnt;
	}
	for(int i =1;i<= n;i++)
		scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	for(int i = 1;i<= n;i++)
		if(b[i]!=b[L])
			b[++L]=b[i];
	for(int i = 1;i<= n;i++)a[i]=Find(a[i]);
	//for(int i = 1;i<= n;i++)printf("%d ",a[i]);
	//printf("\n");
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],1);
		for(int j = i+1;j<=cnt;j++)
		{
			int t = 0;
			for(int k = bs[j];k<=be[j];k++)
				t+=getans(n)-getans(a[k]);
			Update(i,j,t);
		}
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],-1);
	}
	for(int i=1;i<=cnt;i++)
		for(int j = 1;j<=be[i];j++)
			UPDATE(i,a[j],1);
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = bs[i];j<=be[i];j++)
		{
			ni[i]+=getans(n)-getans(a[j]);
			update(a[j],1);
			//if(i==1)printf("%d\n",ni[i]);
		}
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],-1);
	}
	//for(int i = 1;i<= cnt;i++)
	//	printf("%d\n",ni[i]);
	int q,ans=0;
	scanf("%d",&q);
	while(q--)
	{
		int l,r,j,k;
		scanf("%d%d",&j,&k);
		j^=ans,k^=ans;
		ans = 0;
		l = bel[j],r=bel[k];
		if(r-l<=1)
		{
			for(int i = j;i<= k;i++)
			{
				ans+=getans(n)-getans(a[i]);
				update(a[i],1);
			}
			for(int i = j;i<=k;i++)
				update(a[i],-1);
		}else
		{
			for(int i = l+1;i<= r-1;i++)
			{
				ans+=ni[i];
				ans+=Getans(i,r-1)-Getans(i,i);
				//printf("%d\n",ans);
			}
			for(int i = j;i<=be[l];i++)
			{
				ans+=getans(n)-getans(a[i]);
				ans+=GETANS(r-1,a[i]-1)-GETANS(l,a[i]-1);
				update(a[i],1);
				//printf("%d\n",ans);
			}
			for(int i = bs[r];i<=k;i++)
			{
				ans+=getans(n)-getans(a[i]);
				ans+=GETANS(r-1,n)-GETANS(r-1,a[i])-GETANS(l,n)+GETANS(l,a[i]);
				update(a[i],1);
				//printf("%d\n",ans);
			}
			for(int i=j;i<=be[l];i++)update(a[i],-1);
			for(int i=bs[r];i<=k;i++)update(a[i],-1);
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem3747

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
int w[N],f[N],next[N],last[N];
LL maxn[N<<2],lazy[N<<2];
void push_down(int p,int l,int r)
{
	if(lazy[p]==0||l==r)return ;
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=c;
		maxn[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
/*LL getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return maxn[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
	return ans;
}*/
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&f[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d",&w[i]);
	for(int i = n;i>=1;i--)
	{
		next[i] = last[f[i]];
		last[f[i]] = i;
	}
	for(int i = 1;i<= m;i++)
		if(last[i])
		{
			if(!next[last[i]])update(1,1,n,last[i],n,w[i]);
			else update(1,1,n,last[i],next[last[i]]-1,w[i]);
		}
	LL ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = max(ans,maxn[1]);
		int t = next[i];
		if(t)
		{
			update(1,1,n,i,t-1,-w[f[i]]);
			if(next[t])update(1,1,n,t,next[t]-1,w[f[i]]);
			else update(1,1,n,t,n,w[f[i]]);
		}else update(1,1,n,i,n,-w[f[i]]);
	}
	printf("%lld",ans);
	return 0;
}
Problem3748

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 507;
int f[N] = {0,1,0,0,2,2,0,0,0,3,3,0,0,3,3,0,4,4,0,0,4,4,0,0,0,4,4,0,0,4,4,0,0,0,5,5,6,6,5,5,6,5,5,0,0,5,5,0,0,6,5,5,6,6,5,5,6,6,7,7,0,6,6,7,8,6,6,0,8,7,6,6,0,8,6,6,0,6,6,7,8,6,6,7,7,7,6,6,7,7,6,6,0,8,7,7,0,9,7,7,7,7,7,7,7,7,7,9,0,8,7,7,0,8,7,7,8,8,8,7,7,8,8,7,7,8,7,7,0,8,7,7,9,8,8,7,7,9,8,7,7,8,8,8,9,8,8,8,8,8,8,8,8,8,8,8,9,10,8,8,9,9,8,8,8,8,8,8,8,8,8,9,9,10,8,8,9,10,8,8,9,9,9,8,8,9,9,8,8,10,8,8,9,10,8,8,9,9,9,8,8,9,9,8,8,9,9,9,9,10,9,9,9,10,9,9,9,9,10,9,9,9,9,9,9,10,9,9,9,9,9,9,9,9,9,9,9,10,10,9,9,10,10,9,9,9,9,9,9,9,9,9,10,10,10,9,9,11,10,9,9,10,10,10,9,9,10,10,9,9,10,9,9,11,10,9,9,11,10,10,9,9,10,10,9,9,10,10,10,11,10,10,10,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,10,10,10,11,10,10,10,10,11,10,10,10,10,10,10,11,10,10,10,10,10,10,10,10,10,10,10,11,11,10,10,11,11,10,10,10,10,10,10,10,10,10,11,11,11,10,10,11,11,10,10,11,11,11,10,10,11,11,10,10,11,10,10,11,11,10,10,11,12,11,10,10,11,11,10,10,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,12,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,12,12,11,11,11,11,11,11,11,11,11,12,12,12,11,11,12,12,11,11,12,12,12,11,11,12,12,11,11,12,11,11,12,12,11,11,12,12,12,11,11,12,12,11,11};
int v[N],sum[N];
LL F(LL x)
{
	return x*(x+1)*(x*2+1)/6;
}
int main()
{
	LL n;
	scanf("%lld",&n);
	for(int i = 2;i<N;i++)
		if(f[i])
			for(int j = 1;j<i;j++)
				if(!f[j]||f[i]<f[j])v[j] = 1;
	for(int i = 2;i<N;i++)sum[i] = sum[i-1]+v[i];
	if(n<N)
	{
		if(f[n]!=0)printf("%d %d\n",f[n],sum[n]);
		else printf("- %d\n",sum[n]);
		return 0;
	}
	int L = 1,R = 2e6;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(F(mid)<n)L = mid+1;
		else R = mid;
	}
	bool flag = false;
	if(F(L)-n<=(LL)506&&F(L)-n>0)
		if(f[F(L)-n]==0)
			printf("%d ",L+1),flag = true;
	if(!flag)printf("%d ",L);
	LL ans;
	int i;
	for(ans=(LL)(L-12)*31+sum[N-1],i=1;i<=128;i++)if(!f[i]&&F(L)-i<=n)ans++;
	printf("%lld",ans);
	return 0;
}
Problem3749

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int f[N][5],a[N],n,ans[N];
bool work(int u)
{
	memset(f,0,sizeof(f));
	f[1][u] = 1;
	for(int i = 2;i<= n;i++)
	{
		if(f[i-1][1]&&a[i-1]<=2*a[i])f[i][1] = 1;
		if(f[i-1][4]&&a[i-1]<=a[i])f[i][1] = 4;
		if(f[i-1][2]&&a[i-1]*2>=a[i])f[i][2] = 2;
		if(f[i-1][3]&&a[i-1]>=a[i])f[i][2] = 3;
		if(f[i-1][1]&&a[i-1]<=a[i])f[i][3] = 1;
		if(f[i-1][4]&&2*a[i-1]<=a[i])f[i][3] = 4;
		if(f[i-1][2]&&a[i-1]>=a[i])f[i][4] = 2;
		if(f[i-1][3]&&a[i-1]>=a[i]*2)f[i][4] = 3;
	}
	if(f[n][u]==0)return false;
	for(int i=n;i>=1;i--)
	{
        if(u==1)ans[i-1]=(i-1)%(n-1)+1;
        if(u==2)ans[i]=(i-1)%(n-1)+1;
        if(u==3)ans[i-1]=ans[i]=(i-1)%(n-1)+1;
        u=f[i][u];
    }
    for(int i = 1;i<n-1;i++)printf("%d ",ans[i]);
    printf("%d\n",ans[n-1]);
	return true;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	a[++n] = a[1];
	for(int i = 1;i<=4;i++)if(work(i))return 0;
	printf("NIE\n");
	return 0;
}
Problem3771

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double x = 0,double y = 0):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);
	}
}a[N],b[N],c[N],d[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i=2;i<=len;i=i<<1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w = cp(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int A[N];
int main()
{
	int maxa = -1,n;
	scanf("%d",&n);
	n--;
	for(int i = 0;i<= n;i++)
	{
		scanf("%d",&A[i]);
		a[A[i]].x=1,b[2*A[i]].x=1,c[3*A[i]].x=1;
		maxa = max(maxa,3*A[i]);
	}
	int m=maxa,L=0;
    for(n=1;n<=m;n<<=1)L++;
    FFT(a,n,1),FFT(b,n,1),FFT(c,n,1);
	for(int i = 0;i<=n;i++)
	{
		cp tmp = cp(1.0/6.0,0),tmp2 = cp(3.0,0),tmp3 = cp(2.0,0),tmp4 = cp(1.0/2.0,0);
		d[i]=d[i]+(a[i]*a[i]*a[i]-tmp2*a[i]*b[i]+tmp3*c[i])*tmp;
        d[i]=d[i]+(a[i]*a[i]-b[i])*tmp4;
        d[i]=d[i]+a[i];
	}
	FFT(d,n,-1);
	for(int i = 0;i<= maxa;i++)
	{
		int ans = (int)(d[i].x+0.1);
		if(ans!=0)printf("%d %d\n",i,ans);
	}
	return 0;
}
Problem3772

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int M = 4e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,m;
struct Ask
{int x,y;}ask[N];
bool cmp(Ask a,Ask b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
	e[++tot].to = x;e[tot].next = head[y];head[y]=tot;
}
int fa[N][18],root[N];
int ls[M],rs[M],sum[M];
int in[N],end[N],ind,dep[N],cnt;
int getans(int x,int y,int u,int v,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[x]+sum[y]-sum[u]-sum[v];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=getans(ls[x],ls[y],ls[u],ls[v],l,mid,a,b);
	if(b>mid) ans+=getans(rs[x],rs[y],rs[u],rs[v],mid+1,r,a,b);
	return ans;
}
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p] = sum[pre]+val;
		return ;
	}
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)
		update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
void dfs(int x)
{
	in[x] = ++ind;
	dep[x] = dep[fa[x][0]]+1;
	for(int j = 1;j<= 17;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
	for(int i = head[x];i;i=e[i].next)
	{
		if(e[i].to==fa[x][0])continue;
		fa[e[i].to][0] = x;
		dfs(e[i].to);
	}
	end[x] = ++ind;
}
vector<int>a[N];
void dfs2(int x)
{
	root[x] = root[fa[x][0]];
	for(int i = 0;i<a[x].size();i++)
	{
		update(root[x],root[x],1,ind,in[a[x][i]],1);
		update(root[x],root[x],1,ind,end[a[x][i]],-1);
	}
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
			dfs2(e[i].to);
}
ll ans = 0;
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void solve()
{
	for(int i = 1;i<= m;i++)
	{
		int x=ask[i].x,y = ask[i].y;int u = getlca(x,y),v = fa[u][0];
		ans+=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[x]);
		ans+=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[y]);
		ans-=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[u]);
		ans--;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		a[x].push_back(y);
		ask[i].x = x,ask[i].y = y;
	}
	sort(ask+1,ask+m+1,cmp);
	dfs(1);
	dfs2(1);
	solve();
	ll b = (ll)m*(m-1)/2;
	int j;
	for(int i = 1;i<= m;i=j)
		for(j=i;ask[i].x==ask[j].x&&ask[i].y==ask[j].y;j++)
			ans-=(ll)(j-i)*(j-i-1)/2;
	ll t = gcd(ans,b);
	ans = ans/t,b = b/t;
	printf("%lld/%lld\n",ans,b);
	return 0;
}
Problem3774

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e4+4;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].f = 0;
}
queue <int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] =-1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
	{
		ans+=get_mxf(s,t,INF);
	}
	return ans;
}
int n,m;
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
inline int id1(int i,int j)
{
	return i*m+j-m;
}
inline int id2(int i,int j)
{
	return i*m+j-m+n*m;
}
int main()
{
	int ans = 0;
	scanf("%d%d",&n,&m);
	int x;
	int S = 0, T = 2*n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			if((i+j)&1)
				add(S,id1(i,j),x);
			else 
				add(id1(i,j),T,x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			ans+=2*x;
			if((i+j)&1)
				add(S,id2(i,j),x),add(id1(i,j),T,x);
			else 
				add(id2(i,j),T,x),add(S,id1(i,j),x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if((i+j)&1)
			{
				add(id2(i,j),id1(i,j),INF);
				for(int d = 0;d<4;d++)
				{
					int xx = i+dx[d],yy = j+dy[d];
					if(xx<=0||yy<=0||xx>n||yy>m)continue;
					add(id2(i,j),id1(xx,yy),INF);
				}
			}else
			{
				add(id1(i,j),id2(i,j),INF);
				for(int d = 0;d<4;d++)
				{
					int xx = i+dx[d],yy = j+dy[d];
					if(xx<=0||yy<=0||xx>n||yy>m)continue;
					add(id1(xx,yy),id2(i,j),INF);
				}
			}
	ans-=dinic(S,T);
	printf("%d\n",ans);
	return 0;
}
Problem3786

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int Inv = 20000307;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct Splay
{
	Splay *ls,*rs,*fa;
	int pos,neg,sta,lazy;
	LL num,sum;
	Splay(LL x,int s);
	void push_up();
	void push_down();
	void Add(LL x);
}*null = new Splay(0,0),*root,*tree[N][2];
Splay :: Splay(LL x,int s)
{
	ls = rs = fa = null;
	num = x*(s==1?1:-1);
	sta = s;
	neg = pos = 0;
	if(sta==1)pos++;
	if(sta==2)neg++;
	lazy = 0;
}
void Splay :: push_up()
{
	sum = ls->sum+rs->sum+num;
	pos = ls->pos+rs->pos+(sta==1);
	neg = ls->neg+rs->neg+(sta==2);
}
void Splay :: push_down()
{
	if(lazy)
	{
		ls->Add(lazy);
		rs->Add(lazy);
		lazy = 0;
	}
}
void Splay :: Add(LL x)
{
	if(this==null)return ;
	num+=x*(sta==1?1:-1);
	sum+=x*(pos-neg);
	lazy+=x;
}
void Push_down(Splay *x)
{
	static Splay *stack[N<<1];
	static int top = 0;
	for(;x!=null;x = x->fa)
		stack[++top] = x;
	while(top)
		stack[top--]->push_down();
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)
		root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)
		root = x;
}
void splay(Splay *x,Splay *target)
{
	Push_down(x);
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==target)break;
		if(z==target)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
Splay* Insert(LL x,int s)
{
	Splay *y = root;
	while(y->rs!=null)
		y = y->rs;
	y->rs = new Splay(x,s);
	y->rs->fa = y;
	y->push_up();
	splay(y->rs,null);
	return root;
}
Splay* find_min(Splay *x)
{
	while(x->ls!=null)
		x = x->ls;
	return x;
}
Splay* find_max(Splay *x)
{
	while(x->rs!=null)
		x = x->rs;
	return x;
}
void move_to_root(Splay *x,Splay *y)
{
	splay(x,null);
	Splay *tmp1 = find_max(root->ls);
	splay(y,null);
	Splay *tmp2 = find_min(root->rs);
	splay(tmp1,null);
	splay(tmp2,root);
}
LL a[N];
void dfs(int x)
{
	tree[x][0] = Insert(a[x],1);
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to);
	tree[x][1] = Insert(a[x],2);
}
int main()
{
	int n,f;
	LL x,y;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d",&f);
		add(f,i);
	}
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	root = new Splay(Inv,3);
	dfs(1);
	Insert(Inv,4);
	int m;
	scanf("%d",&m);
	char opt[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')
		{
			scanf("%lld",&x);
			move_to_root(tree[1][0],tree[x][0]);
			printf("%lld\n",root->rs->ls->sum);
		}else if(opt[0]=='C')
		{
			scanf("%lld%lld",&x,&y);
			move_to_root(tree[x][0],tree[x][1]);
			Splay *tmp = root->rs->ls;
			root->rs->ls = null;
			root->rs->push_up();
			root->push_up();
			splay(tree[y][0],null);
			splay(find_min(root->rs),root);
			root->rs->ls = tmp;
			tmp->fa = root->rs;
			root->rs->push_up();
			root->push_up();
		}
		else
		{
			scanf("%lld%lld",&x,&y);
			move_to_root(tree[x][0],tree[x][1]);
			root->rs->ls->Add(y);
		}
	}
	return 0;
}
Problem3790

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
char s[N];
char a[N];
int no[N];
int p[N],maxp,id;
struct Q
{int l,r;}q[N];
vector<int>w[N];
int f[N],c[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = min(c[i],y);
}
int getans(int x)
{
	int ans = 0x3f3f3f3f;
	for(int i = x;i>0;i-=i&(-i))
		ans = min(ans,c[i]);
	return ans;
}
int main()
{
	while(scanf("%s",s+1)!=EOF)
	{
		memset(p,0,sizeof(p));
		int n = strlen(s+1);
		int len = 0;
		for(int i = 1;i<=n;i++)
		{
			a[++len]=s[i];
			no[len] = i;
			if(i!=n)a[++len]='^';
		}
		maxp = id = 1;
		for(int i = 1;i<= len;i++)
		{
			p[i] = max(0,min(p[2*id-i],maxp-i));
			while(i+p[i]<=len&&i-p[i]>=1&&a[i+p[i]]==a[i-p[i]])p[i]++;
			p[i]--;
			if(i+p[i]>maxp){maxp = i+p[i],id = i;}
			q[i]=(Q){no[i-p[i]]?no[i-p[i]]:no[i-p[i]+1],no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1]};
		}
		for(int i = 1;i<= len;i++)
			w[i].clear();
		for(int i = 1;i<=len;i++)
			if(q[i].l<=q[i].r)
				w[q[i].r].push_back(q[i].l);
		memset(f,0x3f,sizeof(f));
		memset(c,0x3f,sizeof(c));
		update(n+1,0);
		for(int i = 1;i<= n;i++)
		{
			for(int j = 0;j<w[i].size();j++)
				f[i] = min(f[i],getans(n-w[i][j]+2)+1);
			update(n-i+1,f[i]);
		}
		printf("%d\n",f[n]-1);
	}
	return 0;
}
Problem3812

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int S = 1<<15;
const LL mod = 1e9+7;
LL c[250][250];
LL f[S],g[S],h[S],power_2[S];
int in[S],out[S],dig[S];
int Count(int x)
{
	return dig[x>>8] + dig[x&255] ;
}
int main()
{
	int n,m,x,y,i;
	scanf("%d%d",&n,&m);
	for(i = 1;i<1<<8;i++)
		dig[i] = dig[i>>1]+(i&1);
	for(power_2[0]=1,i=1;i<=m;i++)
		power_2[i]=(power_2[i-1]<<1)%mod;
	for(i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		//add(x,y);
		//f[(1<<(x-1))|(1<<(y-1))]+=1;
		out[1<<(x-1)]|=1<<(y-1);
		in[1<<(y-1)]|=1<<(x-1);
	}
	for(i = 1;i<1<<n;i++)
	{
		int one = i&(-i),sta = i^one;
		h[i] = h[sta]+Count(in[one]&sta)+Count(out[one]&sta);
		for(int j = sta;j;j = (j-1)&sta)
			(g[i]+=mod-f[i^j]*g[j]%mod)%=mod;
		static int w[1<<15];
		f[i] = power_2[h[i]];
		for(int j = i;j;j = (j-1)&i)
		{
			if(j==i)w[j] = 0;
			else
			{
				int tmp = (i^j)&(-(i^j));
				w[j] = w[j^tmp]-Count(out[tmp]&(i^j))+Count(j&in[tmp]);
			}
			(f[i]+=mod-power_2[h[i^j]+w[j]]*g[j]%mod)%=mod;
		}
		(g[i]+=f[i])%=mod;
	}
	printf("%lld\n",f[(1<<n)-1]);
	return 0;
}
Problem3813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
const int mod = 19961993;
typedef pair<ll,ll> PLL;
pair <ll,ll> val[N<<2];
int prime[105],env[105],cnt;
bool v[405];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void init()
{
	for(int i = 2;cnt<=60;i++)
	{
		if(!v[i])prime[++cnt]=i;
		for(int j = 1;j<=cnt&&i*prime[j]<=400;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
	for(int i = 1;i<= 60;i++)
		env[i] = quick_pow(prime[i],mod-2);
}
void push_up(int p)
{
	val[p].first = val[p<<1].first|val[p<<1|1].first;
	val[p].second = val[p<<1].second*val[p<<1|1].second%mod;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		val[p].first|=1<<2;
		val[p].second = 3;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void update(int p,int l,int r,int x,ll v)
{
	if(l==r)
	{
		val[p].first = 0;
		for(int i = 1;i<= 60;i++)
			if(v%prime[i]==0)
				val[p].first|=(1ll<<i);
		val[p].second = v%mod;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,v);
	else update(p<<1|1,mid+1,r,x,v);
	push_up(p);
}
PLL uni(PLL a,PLL b)
{
	a.first |= b.first;
	(a.second *= b.second)%=mod;
	return a;
}
pair<ll,ll> getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return val[p];
	pair <ll,ll>ans;
	int mid = (l+r)>>1;
	ans.first = 0,ans.second = 1;
	if(a<=mid)ans=uni(ans,getans(p<<1,l,mid,a,b));
	if(b >mid)ans=uni(ans,getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
int main()
{
	int n = 1e5;
	int m;
	init();
	build(1,1,n);
	scanf("%d",&m);
	while(m--)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		if(a==1)
			update(1,1,n,b,c);
		else
		{
			PLL ans = getans(1,1,n,b,c);
			ll Ans = ans.second;
			for(int i =1;i<= 60;i++)
				if((ans.first>>i)&1)
					Ans = Ans*(prime[i]-1)%mod*env[i]%mod;
			printf("%lld\n",Ans);
		}
	}
	return 0;
}
Problem3827

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int INF = 0x3f3f3f3f;
int dis[N],nxt[N<<1],dep[N<<1];
int n,s;
int work(int x)
{
	int fa = x;
	for(;fa<x+n;fa = nxt[fa]);
	for(int i = nxt[x],j = x;i!=fa;j = i,i = nxt[i])nxt[j] = fa;
	return dep[x]-dep[fa];
}
int main()
{
	scanf("%d%d",&n,&s);
	int max_d = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&dis[i]);
		max_d = max(max_d,dis[i]);
	}
	while(s--)
	{
		int d;
		scanf("%d",&d);
		if(d<max_d){printf("NIE\n");continue;}
		int j = 1,sum = 0;
		int end = n<<1;
		for(int i = 1;i<= end;i++)
		{
			while(j<end&&sum+dis[j>n?j-n:j]<=d)
			{
				sum = sum+dis[j>n?j-n:j];
				j++;
			}
			sum-=dis[i>n?i-n:i];
			nxt[i] = j;
		}
		dep[end] = 0;
		for(int i = end;i>=1;i--)
			dep[i] = dep[nxt[i]]+1;
		int ans = INF;
		for(int i = 1;i<= n;i++)ans = min(ans,work(i));
		printf("%d\n",ans);
	}
	return 0;
}
Problem3828

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int last[N],a[N],tmp[N],stack[N],top,cnt,n,k;
struct Line
{
	int lth,col[N],nxt[N],last[N],Min[N],end[N];
	void init()
	{
		top = 0;
		for(int i = 1;i<= lth;i++)scanf("%d",&tmp[i]);
		for(int i = 1;i< lth;i++)nxt[tmp[i]] = tmp[i+1];
		for(int i = n;i>=1;i--)
		{
			end[i] = 0;
			if(col[i]==tmp[lth])end[i] = i;
			else if(nxt[col[i]]&&last[nxt[col[i]]])
				end[i] = end[last[nxt[col[i]]]];
			if(col[i]==tmp[1]&&end[i])stack[++top] = i;
			last[col[i]] = i;
		}
		stack[top+1] = 1;
		for(int i = 1;i<=top;i++)
			for(int j = stack[i]-1;j>= stack[i+1];j--)
				Min[j] = end[stack[i]];
	}
}a1,a2;
struct Seg
{int l,r;}seg[N];
bool cmp(Seg a,Seg b)
{
	return a.l<b.l;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		a1.col[i] = a[i],a2.col[i] = a[n-i+1];
	scanf("%d%d",&a1.lth,&a2.lth);
	a1.init();
	a2.init();
	for(int i = 1;i<= n;i++)
	{
		if(a1.last[a2.col[i]])
		{
			int tmp1 = a1.Min[a1.last[a2.col[i]]],tmp2 = a2.Min[i];
			if(tmp1&&tmp2&&tmp1<=n-tmp2+1)
				seg[++cnt] = (Seg){tmp1,n-tmp2+1};
		}
	}
	sort(seg+1,seg+cnt+1,cmp);
	int L = seg[1].l,R = seg[1].r,top = 0;
	for(int i = 2;i<= cnt;i++)
	{
		if(seg[i].l>R)
		{
			for(int j = L;j<=R;j++)
				if(a[j]==tmp[a2.lth])stack[++top] = j;
			L = seg[i].l,R = seg[i].r;
		}
		else R = max(seg[i].r,R);
	}
	for(int j = L;j<=R;j++)
		if(a[j]==tmp[a2.lth])stack[++top] = j;
	printf("%d\n",top);
	for(int i = 1;i<=top;i++)
		printf("%d ",stack[i]);
	//printf("%d\n",stack[top]);
	return 0;
}
Problem3829

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
struct P
{
	int f,size;
}p[N];
bool cmp(P a,P b)
{
	return a.f-a.size>b.f-b.size;
}
int size[N],f[N],c[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
P stack[N];
int top;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			p[e[i].to].size+=2;
			p[e[i].to].f = max(p[e[i].to].f+1,p[e[i].to].size);
			stack[++top] = p[e[i].to];
		}
	sort(stack+1,stack+top+1,cmp);
	p[x].f = c[x];
	for(int i = 1;i<=top;i++)
	{
		p[x].f = max(p[x].f,stack[i].f+p[x].size);
		p[x].size+=stack[i].size;
	}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	printf("%d\n",max(p[1].f,p[1].size+c[1]));
	return 0;
}
Problem3830

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
const LL INF = 1e18;
LL c[N];
LL f[N],a[N];
int n;
LL s;
void update(int x,LL t)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = min(c[i],t);
}
LL getans(int x)
{
	LL ans = INF;
	for(int i = x;i>0;i-=i&(-i))
		ans = min(ans,c[i]);
	return ans;
}
int main()
{
	memset(c,0x3f,sizeof(c));
	scanf("%d%lld",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	for(int i = 2;i<= n;i++)
		a[i] = max(a[i],a[i-1]+1);
	int L,R,mid;
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = i;
		while(L<R)
		{
			mid = (L+R)>>1;
			if(f[mid]-mid-1<=a[i]-i)
				L = mid+1;
			else R = mid;
		}
		f[i] = a[i]-L+i+s*2;
		if(L!=i)f[i] = min(f[i],getans(n-L+1)+s*2+i*2);
		update(n-i+1,f[i]-2*i-2);
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem3831

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int line[N],L,R,a[N],f[N];
bool smaller(int i,int j)
{
	if(f[i]!=f[j])
		return f[i]<f[j];
	return a[i]>a[j];
}
int main()
{
	int n,k,t;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&k);
		memset(f,0x3f,sizeof(f));
		L = 0,R = 0;line[R] = 1;
		f[1] = 0;
		for(int i = 2;i<= n;i++)
		{
			while(L<=R&&line[L]<i-k)L++;
			f[i] = min(f[i],f[line[L]]+(a[line[L]]<=a[i]));
			while(L<=R&&smaller(i,line[R]))R--;
			line[++R] = i;
		}
		printf("%d\n",f[n]);
	}
	return 0;
}
Problem3832

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e6+5;
const int N = 5e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[M],fe[M];
int head[N],fh[N],tot;
int line[N],top;
int g[N],f[N],ind[N];
void add(int x,int y)
{
	ind[y]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	fe[tot].to = x;
	fe[tot].next = fh[y];
	fh[y] = tot;
}
queue<int>Q;
int heap[M<<1],dele[M<<1],ch,cd;
int main()
{
	//freopen("raj.in","r",stdin);
	//freopen("raj.out","w",stdout);
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i);
	while(!Q.empty())
	{
		x = Q.front();
		Q.pop();
		line[++top] = x;
		for(int i = head[x];i;i = e[i].next)
			if(!--ind[e[i].to])
				Q.push(e[i].to);
	}
	for(int i = 1;i<= top;i++)
	{
		int tmp = line[i];
		f[tmp] = max(f[tmp],1);
		for(int j = head[tmp];j;j = e[j].next)
			f[e[j].to] = max(f[e[j].to],f[tmp]+1);
	}
	for(int i = top;i>= 1;i--)
	{
		int tmp = line[i];
		g[tmp] = max(g[tmp],1);
		for(int j = head[tmp];j;j = e[j].next)
			g[tmp] = max(g[tmp],g[e[j].to]+1);
	}
	for(int i = 1;i<= n;i++)
	{
		heap[++ch] = g[i];
		push_heap(heap+1,heap+ch+1);
	}
	int ans_len = INF,ans;
	for(int i = 1;i<= top;i++)
	{
		x = line[i];
		for(int j = fh[x];j;j = fe[j].next)
		{
			dele[++cd] = f[fe[j].to]+g[x];
			push_heap(dele+1,dele+cd+1);
		}
		dele[++cd] = g[x];
		push_heap(dele+1,dele+cd+1);
		while(dele[1]==heap[1]&&cd>=1&&ch>=1)
		{
			pop_heap(dele+1,dele+cd+1);
			cd--;
			pop_heap(heap+1,heap+ch+1);
			ch--;
		}
		if(ch&&heap[1]<ans_len)
		{
			ans_len = heap[1];
			ans = x;
		}
		for(int j=head[x];j;j = e[j].next)
		{
			heap[++ch] = f[x]+g[e[j].to];
			push_heap(heap+1,heap+ch+1);
		}
		heap[++ch] = f[x];
		push_heap(heap+1,heap+ch+1);
	}
	printf("%d %d\n",ans,ans_len-1);
	return 0;
}
Problem3834

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		x1--;
		x2--;
		int last = 0,ans = -1;
		for(int i = 1;i<= y1&&i<=y2;i = last+1)
		{
			last = min(y1/(y1/i),y2/(y2/i));
			if(y1/last>x1/last&&y2/last>x2/last)
				ans = max(ans,last);
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem3835

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int sum[N],max_dep;
void dfs(int x,int dep)
{
	max_dep = max(max_dep,dep);
	sum[dep]++;
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to,dep+1);
}
struct Ask
{int k,no,ans;}qur[N];
bool cmp(Ask a,Ask b){return a.k<b.k;}
bool ret(Ask a,Ask b){return a.no<b.no;}
int line[N],L,R;
double calc(int i,int j)
{
	return (double)(sum[i]-sum[j])/(double)(i-j);
}
int main()
{
	int n,q,x;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&qur[i].k);
		qur[i].no = i;
	}
	sort(qur+1,qur+1+q,cmp);
	for(int i = 2;i<=n;i++)
	{
		scanf("%d",&x);
		add(x,i);
	}
	dfs(1,1);
	for(int i = max_dep;i>=1;i--)
		sum[i]+=sum[i+1];
	R = -1;
	for(int i = 1;i<= max_dep;i++)
	{
		while(L<R&&calc(i,line[R-1])>=calc(line[R],line[R-1]))R--;
		line[++R] = i;
	}
	for(int t = 1;t<= q;t++)
	{
		int i = qur[t].k;
		while(L<R&&i*line[L]+sum[line[L]]<i*line[L+1]+sum[line[L+1]])L++;
		qur[t].ans = line[L];
	}
	sort(qur+1,qur+q+1,ret);
	for(int i = 1;i< q;i++)
		printf("%d ",max(max_dep,(sum[qur[i].ans]+qur[i].k-1)/qur[i].k+qur[i].ans-1));
	printf("%d\n",max(max_dep,(sum[qur[q].ans]+qur[q].k-1)/qur[q].k+qur[q].ans-1));
	return 0;
}
Problem3837

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;

const int N = 1e5+5;
const int M = 1e7+5;
int n,Ans1,Ans2,Maxx;
int A[N],B[N];
int p[M],v[M],vis[M],f[M];

inline void First()
{
	for(int i=2;i<=Maxx;i++)
	{
		if(!p[i]) p[++*p]=i,v[i]=*p;
		for(int j=1;j<=*p&&p[j]*i<=Maxx;j++)
		{
			p[p[j]*i]=1; v[p[j]*i]=j;
			if(i%p[j]==0) break;
		}
	}
}

int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}

int main()
{
	srand(2037);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&A[i]),Maxx=max(Maxx,A[i]);
	First();
	for(int K=1;K<=4;K++)
	{
		int x=A[rand()%n+1],cnt=0,w=0,Max=0,nAns=0;
		for(int i=1;i<=n;i++)
			if(A[i]!=x) B[++cnt]=A[i]<x?(x-A[i]):(A[i]-x);
			else w++;
		for(int i=1;i<=*p;i++) vis[i]=f[i]=0;
		for(int i=1;i<=cnt;i++)
		{
			int now=B[i];
			for(;now^1;now/=p[v[now]])
			{
				vis[v[now]]++;
				f[v[now]]=gcd(f[v[now]],B[i]);
				int y=p[v[now]];
				while((now/y)%y==0) now/=y;
			}
		}
		for(int i=1;i<=*p;i++)
			if(vis[i]>vis[Max]||(vis[i]==vis[Max]&&f[i]>nAns)) Max=i,nAns=f[i];
		if(vis[Max]+w>Ans1) Ans1=vis[Max]+w,Ans2=nAns;
		else if(vis[Max]+w==Ans1&&nAns>Ans2) Ans2=nAns;
	}
	printf("%d %d\n",Ans1,Ans2);
	return 0;
}
Problem3838

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
const int M = (N<<1)+5e4;
const int INF = 1e9+10;
ll ans;
int A[N],B[N],aa[M],ab[M],ba[M],bb[M],lazy[M],vm[M],n,k;
struct data
{
	int x,y;
	data(){}
	data(int _x,int _y):x(_x),y(_y){}
	data operator +(const data &b){return A[x]+B[y]<A[b.x]+B[b.y]?*this:b;}
}va[M],vb[M],vc[M],t;
inline void add(int x,int p)
{
	vm[x]+=p;
	lazy[x]+=p;
}
inline void Push_down(int p)
{
	if(!lazy[p])return ;
	add(p<<1,lazy[p]),add(p<<1|1,lazy[p]);
	lazy[p]=0;
}
inline void Push_up(int p)
{
	int ls = p<<1,rs = p<<1|1;
	va[p] = va[ls]+va[rs]+data(aa[ls],ab[rs]);
	vc[p] = vc[ls]+vc[rs]+data(aa[rs],ab[ls]);
	vb[p] = vb[ls]+vb[rs];
	aa[p] = A[aa[ls]]<A[aa[rs]]?aa[ls]:aa[rs];
	ab[p] = B[ab[ls]]<B[ab[rs]]?ab[ls]:ab[rs];
	if(vm[ls]<vm[rs])
	{
		vb[p] = vb[p]+vc[rs]+data(aa[rs],bb[ls]);
		ba[p] = ba[ls];
		bb[p] = B[ab[rs]]<B[bb[ls]]?ab[rs]:bb[ls];
		vm[p] = vm[ls];
	}
	else if(vm[ls]>vm[rs])
	{
		vb[p] = vb[p]+vc[ls]+data(ba[rs],ab[ls]);
		ba[p] = A[aa[ls]]<A[ba[rs]]?aa[ls]:ba[rs];
		bb[p] = bb[rs];
		vm[p] = vm[rs];
	}else
	{
		vb[p] = vb[p]+data(ba[rs],bb[ls]);
		ba[p] = ba[ls];
		bb[p] = bb[rs];
		vm[p] = vm[ls];
	}
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		va[p]=vc[p]=data(l,l),vb[p]=data(0,0);
		aa[p]=ba[p]=ab[p]=l;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	Push_up(p);
}
void Add(int p,int l,int r,int a,int b,int val)
{
	if(l>=a&&r<=b)
	{
		add(p,val);
		return ;
	}
	Push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)Add(p<<1,l,mid,a,b,val);
	if(b >mid)Add(p<<1|1,mid+1,r,a,b,val);
	Push_up(p);
}
void Change(int p,int l,int r,int pos)
{
	if(l==r)return ;
	Push_down(p);int mid = (l+r)>>1;
	if(pos<=mid)Change(p<<1,l,mid,pos);
	else Change(p<<1|1,mid+1,r,pos);
	Push_up(p);
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&A[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&B[i]);
	A[0]=B[0]=INF;
	build(1,0,n);
	while(k--)
	{
		t = va[1]+vb[1];
		int i = t.x,j = t.y;
		ans += A[i]+B[j];
		if(i<j)Add(1,0,n,i,j-1,1);
		if(j<i)Add(1,0,n,j,i-1,-1);
		A[i] = INF,Change(1,0,n,i);
		B[j] = INF,Change(1,0,n,j);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3864

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int S = 1<<15;
char let[]={'A','C','G','T'};
char s[20];
int f[2][S],trs[S][4],cnt[S],n,m,ans[20];
void init()
{
	for(int i = 0;i<1<<n;i++)
	{
		static int f[20],g[20];
		for(int j = 1;j<= n;j++)
			f[j] = f[j-1]+((i&(1<<(j-1)))?1:0);
		cnt[i] = f[n];
		for(int k = 0;k<4;k++)
		{
			for(int j = 1;j<= n;j++)
			{
				g[j] =max(g[j-1],f[j]);
				if(let[k]==s[j])
					g[j] = max(f[j-1]+1,g[j]);
			}
			trs[i][k] = 0;
			for(int j = 1;j<= n;j++)
				if(g[j]-g[j-1]==1)
					trs[i][k]|=1<<(j-1);
		}
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%s%d",s+1,&m);
		n = strlen(s+1);
		init();
		int pre = 0,now = 1;
		memset(f,0,sizeof(f));
		f[pre][0] = 1;
		for(int i = 1;i<= m;i++)
		{
			memset(f[now],0,sizeof(f[now]));
			for(int j = 0;j<1<<n;j++)
				for(int k = 0;k<4;k++)
					(f[now][trs[j][k]]+=f[pre][j])%=mod;
			swap(now,pre);
		}
		memset(ans,0,sizeof(ans));
		for(int i = 0;i<1<<n;i++)
			(ans[cnt[i]]+=f[pre][i])%=mod;
		for(int i = 0;i<= n;i++)
			printf("%d\n",ans[i]);
	}
	return 0;
}
Problem3872

#include <stdio.h>
#include <cctype>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int d[N];
void add(int x,int y)
{
	d[x]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
LL low[N],upn[N],a[N],maxa;
bool v[N];
queue<int>Q;
void bfs(int x)
{
	v[x] = true;
	Q.push(x);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!v[e[i].to])
			{
				Q.push(e[i].to);
				v[e[i].to] = true;
				if(low[x]*(d[x]-1)>maxa)low[e[i].to] = maxa+1;
				else low[e[i].to] = low[x]*(d[x]-1);
				if(upn[x]*(d[x]-1)+d[x]-2>maxa)upn[e[i].to] = maxa+1;
				else upn[e[i].to] = upn[x]*(d[x]-1)+d[x]-2;
			}
	}
}
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
LL read()
{
	static char ch;
	static LL D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
int main()
{
	int n,g,k;
	n = read(),g = read(),k =read();
	for(int i = 1;i<= g;i++)
	{
		a[i] = read();
		maxa = max(maxa,a[i]);
	}
	int s,t,x,y;
	for(int i = 1;i<n;i++)
	{
		x = read();y = read();
		add(x,y),add(y,x);
		if(i==1)s = x,t = y;
	}
	v[s] = v[t] = true;
	low[s] = low[t] = upn[s] = upn[t] = k;
	bfs(s);bfs(t);
	sort(a+1,a+g+1);
	LL ans = 0;
	for(int i = 1;i<= n;i++)
		if(d[i]==1)
		{
			int l = lower_bound(a+1,a+g+1,low[i])-a;
			int r = upper_bound(a+1,a+g+1,upn[i])-a;
			if(r>g||a[r]>upn[i])r--;
			ans+=(r-l+1);
		}
	printf("%lld\n",ans*k);
	return 0;
}
Problem3881

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 2e6+5;
char s[N];
int ch[N][26],fail[N],q[N],cnt,h,t;
int s_p[N];
int c[N],Dfn,fa[N][22],dfn[N],dep[N],end[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void dfs(int x)
{
	dfn[x] = ++Dfn;
	dep[x] = dep[fa[x][0]]+1;
	for(int i = head[x];i;i=e[i].next)
	{
		fa[e[i].to][0] = x;
		dfs(e[i].to);
	}
	end[x] = Dfn;
}
void Init()
{
	for(int j = 1;j<= 21;j++)
		for(int i = 1;i<= cnt;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 21;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 21;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void init()
{
	cnt = 1;
	for(int i = 0;i<26;i++)
		ch[0][i] = 1;
}
void insert(int id)
{
	int now = 1,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
		now = ch[now][s(i)];
		i++;
	}
	s_p[id] = now;
}
void build()
{
	h = 0,t = -1;
	q[++t] = 1,fail[0] = 1;
	while(h<=t)
	{
		int x = q[h++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[x][i];
			if(!j)
			{
				ch[x][i]=ch[fail[x]][i];
				continue;
			}
			int k = fail[x];
			while(!ch[k][i])k = fail[k];
			fail[j] = ch[k][i];
			q[++t]=j;
			add(fail[j],j);
		}
	}
}
int st[N],top;
int match()
{
	int now = 1,i = 0,top = 0;
	while(s[i])
	{
		now = ch[now][s(i)];
		st[++top] = now;
		i++;
	}
	return top;
}
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int main()
{
	int n;
	scanf("%d",&n);
	init();
	for(int i= 1;i<= n;i++)
	{
		scanf("%s",s);
		insert(i);
	}
	build();
	dfs(1);
	Init();
	int q;
	scanf("%d",&q);
	int opt,x;
	while(q--)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%s",s);
			int lth = match();
			sort(st+1,st+lth+1,cmp);
			top = 0;
			for(int i = 1;i<= lth;i++)
				if(st[top]!=st[i])
					st[++top] = st[i];
			lth = top;
			for(int i = 1;i<= lth;i++)
			{
				update(dfn[st[i]],1);
				if(i>1)update(dfn[getlca(st[i-1],st[i])],-1);
			}
		}else
		{
			scanf("%d",&x);
			x=s_p[x];
			printf("%d\n",getans(end[x])-getans(dfn[x]-1));
		}
	}
	return 0;
}
Problem3884

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll quick_pow(ll x,ll y,ll mod)
{
	ll re = 1;
	while(y)
	{
		if(y&1)(re*=x)%=mod;
		(x *= x)%=mod;
		y>>=1;
	}
	return re;
}
ll oula(ll x)
{
	ll phi = x;
	for(ll i = 2;i*i<=x;i++)
		if(x%i==0)
		{
			phi = phi/i*(i-1);
			while(x%i==0)x/=i;
		}
	if(x!=1)phi = phi/x*(x-1);
	return phi;
}
ll calc(ll mod)
{
	if(mod==1)return 0;
	ll ans = 1,cnt = 0,MOD = mod;
	while(mod%2==0)
		ans*=2,cnt++,mod/=2;
	int phi = oula(mod);
	ans = ans*quick_pow(2,((calc(phi)-cnt)%phi+phi)%phi,MOD)%MOD;
	return ans;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int x;
		scanf("%d",&x);
		printf("%lld\n",calc(x));
	}
	return 0;
}
Problem3886

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c[25][1005];
int lth[25];
int f[1<<20];
int find(int no,int x)
{
	int l = 1,r = c[no][0]+1;
	while(l<r)
	{
		int mid= (l+r)>>1;
		if(c[no][mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,l;
	scanf("%d%d",&n,&l);
	int end = 1<<n;
	memset(c,0x3f,sizeof(c));
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&lth[i],&c[i][0]);
		for(int j = 1;j<= c[i][0];j++)
			scanf("%d",&c[i][j]);
	}
	memset(f,-1,sizeof(f));
	f[0] = 0;
	int ans =50;
	for(int i = 0;i<end;i++)
	{
		if(f[i]==-1)continue;
		for(int j = 1;j<= n;j++)
		if(!(i&(1<<(j-1))))
		{
			int tmp = find(j,f[i]);
			if(c[j][tmp]>f[i])tmp--;
			if(tmp>0)f[i|(1<<(j-1))] = max(f[i|(1<<(j-1))],max(f[i],c[j][tmp]+lth[j]));
		}
		if(f[i]>=l)
		{
			int tmp = i,cnt = 0;
			while(tmp){tmp-=tmp&(-tmp);cnt++;}
			ans = min(ans,cnt);
		}
	}
	if(ans!=50)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem3887

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e5+5;
int n,m;
struct E
{
	int next,to;
};
struct G
{
	E e[M];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}
}g,g1,gf;
bool ret[N];
bool vis[N],ins[N];
int dep[N],low[N],stack[N],bel[N],top,dfn,scc,val[N];
void tarjan(int x)
{
	vis[x] = ins[x] = true;
	stack[++top] =x;
	dep[x] = low[x] = ++dfn;
	for(int i = g.head[x];i;i = g.e[i].next)
	{
		int u = g.e[i].to;
		if(!vis[u])
		{tarjan(u);low[x] = min(low[x],low[u]);}
		else if(ins[u])
		{low[x] = min(low[x],dep[u]);}
	}
	if(dep[x]==low[x])
	{
		scc++;
		int tmp;
		do{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = scc;
			val[scc]++;
		}while(tmp!=x);
	}
}
void rebuild()
{
	for(int i = 1;i<= n;i++)
		for(int j = g.head[i];j;j= g.e[j].next)
		{
			int u = g.e[j].to;
			if(bel[i]!=bel[u])
			{
				g1.add(bel[i],bel[u]);
				if(i==1)ret[bel[u]] = true;
				gf.add(bel[u],bel[i]);
			}
		}
}
int dis[2][N];
bool v[N];
queue<int>Q;
void spfa(int s)
{
	memset(dis,-1,sizeof(dis));
	dis[0][s] = val[s];
	Q.push(s);
	v[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]= false;
		for(int i = g1.head[x];i;i = g1.e[i].next)
		{
			int u = g1.e[i].to;
			if(dis[0][x]+val[u]>dis[0][u])
			{
				dis[0][u] = dis[0][x]+val[u];
				if(!v[u])
				{
					Q.push(u);
					v[u] = true;
				}
			}
		}
	}
	Q.push(s);
	v[s] = true;
	dis[1][s] = val[s];
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		v[x] = false;
		for(int i = gf.head[x];i;i=gf.e[i].next)
		{
			int u = gf.e[i].to;
			if(dis[1][x]+val[u]>dis[1][u])
			{
				dis[1][u] = dis[1][x]+val[u];
				if(!v[u])
				{
					Q.push(u);
					v[u] = true;
				}
			}
		}
	}
}
int main()
{
	//freopen("wander.in","r",stdin);
	//freopen("wander.out","w",stdout);
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		g.add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	rebuild();
	spfa(bel[1]);
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = g.head[i];j;j= g.e[j].next)
		{
			int u = g.e[j].to;
			if(bel[i]!=bel[u])
				if(dis[0][bel[u]]!=-1&&dis[1][bel[i]]!=-1)
					ans = max(ans,dis[0][bel[u]]+dis[1][bel[i]]-val[bel[1]]);
		}
	printf("%d\n",ans);
	return 0;
}
Problem3889

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
typedef long long LL;
using namespace std;
const int N = 1005;
LL INF;
int city[N];
bool v[N];
int d2[N],k2[N][N],n;
LL d1[N],k1[N][N];
queue<int>Q;
void spfa(int s)
{
	memset(d1,0x3f,sizeof(d1));
	memset(d2,0x3f,sizeof(d2));
	d1[s] = 0;d2[s] = 0;
	v[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = 1;i<= n;i++)
		{
			if(k1[x][i]==INF)continue;
			if(d1[x]+k1[x][i]<d1[i])
			{
				d1[i] = d1[x]+k1[x][i];
				d2[i] = d2[x]+k2[x][i];
				if(!v[i])Q.push(i),v[i] = true;
			}else if(d1[x]+k1[x][i]>d1[i])continue;
			else if(d2[x]+k2[x][i]<d2[i])
			{
				d2[i] = d2[x]+k2[x][i];
				if(!v[i])Q.push(i),v[i] = true;
			}
		}
	}
}
int main()
{
	memset(k1,0x3f,sizeof(k1));
	memset(k2,0x3f,sizeof(k2));
	INF = k1[0][0];
	int s,t,m;
	scanf("%d%d%d",&s,&t,&m);
	for(int i = 1;i<= m;i++)
	{
		int cost,len;
		scanf("%d%d",&cost,&len);
		for(int j = 1;j<= len;j++)
		{
			scanf("%d",&city[j]);
			n = max(n,city[j]);
		}
		for(int j = 1;j<= len;j++)
			for(int k = j+1;k<= len;k++)
			{
				if(k1[city[j]][city[k]]==cost)
					k2[city[j]][city[k]] = min(k2[city[j]][city[k]],k-j);
				if(k1[city[j]][city[k]]>cost)
				{
					k1[city[j]][city[k]] = cost;
					k2[city[j]][city[k]] = k-j;
				}
			}
	}
	spfa(s);
	if(d1[t]!=INF)printf("%lld %d\n",d1[t],d2[t]);
	else printf("-1 -1\n");
	return 0;
}
Problem3890

#include <stdio.h>
#include <queue>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
struct E
{int next,to,val1,val2;}e[N*N];
int head[N],tot;
int d[N];
void add(int x,int y,int f1,int f2)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val1 = f1;
	e[tot].val2 = f2;
	head[x] = tot;
}
bitset<10005>f[N],g[N];
queue<int>Q;
int main()
{
	int n,m,x,y,u,v;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&v);
		add(x,y,u,v);
		d[y]++;
	}
	for(int i = 1;i<= n;i++)
		if(!d[i])
			Q.push(i);
	f[1] = g[1] = 1;
	while(!Q.empty())
	{
		x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
		{
			f[e[i].to]|=f[x]<<e[i].val1;
			g[e[i].to]|=g[x]<<e[i].val2;
			if(!--d[e[i].to])
				Q.push(e[i].to);
		}
	}
	for(int i = 1;i<= 10000;i++)
		if(f[n][i]&&g[n][i])
		{
			printf("%d\n",i);
			return 0;
		}
	printf("IMPOSSIBLE\n");
	return 0;
}
Problem3894

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 30005;
const int M = 1000005;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	int x;
	while(!Q.empty())
	{
		x = Q.front();Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow!=0)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow!=0&&d[e[i].to]==d[s]+1)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int id,n,m;
inline int getid(int x,int y)
{
	return (x-1)*m+y;
}
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int main()
{
	int sum = 0,x;
	scanf("%d%d",&n,&m);
	id = n*m+1;
	int st = 0,end = id;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			add(0,getid(i,j),x);sum+=x;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),id,x);sum+=x;
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			++id;
			scanf("%d",&x);
			add(0,id,x);sum+=x;
			add(id,getid(i,j),INF);
			for(int k = 0;k<4;k++)
			{
				int tx = i+dx[k],ty = j+dy[k];
				if(tx&&ty&&tx<=n&&ty<=m)add(id,getid(tx,ty),INF);
			}
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			++id;
			scanf("%d",&x);
			add(id,end,x);sum+=x;
			add(getid(i,j),id,INF);
			for(int k = 0;k<4;k++)
			{
				int tx = i+dx[k],ty = j+dy[k];
				if(tx&&ty&&tx<=n&&ty<=m)add(getid(tx,ty),id,INF);
			}
		}
	sum = sum-dinic(st,end);
	printf("%d\n",sum);
	return 0;
}
Problem3924

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct E
{int next,to,val;};
int pos[N],n,q;
namespace Tree
{
	E e[N<<1];
	int head[N],tot,dis[N],dep[N],fa[N],lg2[N<<1];
	int a[N<<1][20],cnt;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].val = f;
	}
	void dfs(int x)
	{
		static int T=0;
		dep[x] = dep[fa[x]]+1;
		a[pos[x] = ++T][0] = dis[x];
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				dis[e[i].to] = dis[x]+e[i].val;
				dfs(e[i].to);
				a[++T][0] = dis[x];
			}
	}
	void init()
	{
		for(int i = 2;i<(N<<1);i++)
			lg2[i] = lg2[i>>1]+1;
		for(int j = 1;j<= 19;j++)
			for(int i = 1;i+(1<<(j-1))<=(n<<1);i++)
				a[i][j] = min(a[i][j-1],a[i+(1<<(j-1))][j-1]);
	}
	int getlca(int x,int y)
	{
		int l = pos[x],r = pos[y];
		if(l>r)swap(l,r);
		int lth = lg2[r-l+1];
		return min(a[l][lth],a[r-(1<<lth)+1][lth]);
	}
	int getdis(int x,int y)
	{
		return dis[x]+dis[y]-2*getlca(x,y);
	}
};
namespace New_Tree
{
	E e[N<<1];
	int head[N],tot,fa[N];
	ll dis_sum1[N],dis_sum2[N],sum1[N],sum2[N],ROOT;
	void add(int x,int y,int z)
	{
		e[++tot].to = y;
		e[tot].val = z;
		e[tot].next = head[x];
		head[x] =tot;
	}
	int root,sum,f[N],size[N];
	bool used[N];
	void get_root(int x,int pre)
	{
		size[x] = 1;
		f[x] =0;
		for(int i = Tree::head[x];i;i=Tree::e[i].next)
			if(Tree::e[i].to!=pre&&!used[Tree::e[i].to])
			{
				get_root(Tree::e[i].to,x);
				size[x]+=size[Tree::e[i].to];
				f[x] = max(f[x],size[Tree::e[i].to]);
			}
		f[x] = max(f[x],sum-size[x]);
		if(f[x]<f[root])root = x;
	}
	void work(int x)
	{
		used[x] = true;
		for(int i = Tree::head[x];i;i=Tree::e[i].next)
		{
			int to = Tree::e[i].to;
			if(used[to])continue;
			sum = size[to],root = 0;
			get_root(to,0);
			fa[root] = x;
			add(x,root,to);
			work(root);
		}
	}
	void update(int x,int y)
	{
		sum1[x]+=y;
		for(int i = x;fa[i];i=fa[i])
		{
			int dis = Tree::getdis(x,fa[i]);
			dis_sum1[fa[i]]+=(ll)dis*y;
			dis_sum2[i]+=(ll)dis*y;
			sum1[fa[i]]+=y;
			sum2[i]+=y;
		}
		return ;
	}
	ll calc(int x)
	{
		ll ans = dis_sum1[x];
		for(int i = x;fa[i];i=fa[i])
		{
			int dis = Tree::getdis(x,fa[i]);
			ans+=dis_sum1[fa[i]]-dis_sum2[i];
			ans+=(sum1[fa[i]]-sum2[i])*dis;
		}
		return ans;
	}
	ll getans(int x)
	{
		ll cst = calc(x);
		for(int i = head[x];i;i=e[i].next)
		{
			ll tmp = calc(e[i].val);
			if(tmp<cst)
				return getans(e[i].to);
		}
		return cst;
	}
};
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		Tree::add(x,y,c);
	}
	Tree::dfs(1);
	Tree::init();
	New_Tree::f[0] = New_Tree::sum = n;
	New_Tree::root = 0;
	New_Tree::get_root(1,0);
	New_Tree::ROOT = New_Tree::root;
	New_Tree::work(New_Tree::root);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&x,&y);
		New_Tree::update(x,y);
		ll ans = New_Tree::getans(New_Tree::ROOT);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem3925

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<10;
typedef long long ll;
double f[50][N],g[50][N];
int sz[N],cnt[N];
ll c[50][50];
int e[11];
int main()
{
	int n,m,u,v;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&u,&v);
		u--,v--;
		e[u]|=1<<v;
		e[v]|=1<<u;
	}
	c[0][0] = 1;
	for(int i = 1;i<50;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<50;j++)
			c[i][j] = c[i-1][j-1]+c[i-1][j];
	}
	for(int s = 1;s<1<<n;s++)
	{
		sz[s] = sz[s>>1]+(s&1);
		if(sz[s]==1)
		{
			g[0][s] = 1;
			continue;
		}
		for(int i = 0;i<n;i++)
			if(s&(1<<i))
				cnt[s]+=sz[s&e[i]];
		cnt[s]/=2;
		int lb = s&(-s);
		for(int k = (s-1)&s;k;k = s&(k-1))
			if(k&lb)
				for(int i = 0;i<=cnt[k];i++)
					for(int j = 0;j<=cnt[s^k];j++)
						f[i+j][s]+=g[i][k]*c[cnt[s^k]][j];
		for(int i = 0;i<=cnt[s];i++)
			g[i][s] = c[cnt[s]][i]-f[i][s];
	}
	double ans = 0;
	int end = (1<<n)-1;
	for(int i = 0;i<= m;i++)
		ans+=(double)f[i][end]/(double)c[cnt[end]][i];
	ans/=(double)(m+1);
	printf("%.6lf\n",ans);
	return 0;
}
Problem3926

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 4e6+5;
struct E
{int next,to;};
E e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int ch[M][10],fa[M],len[M],last,cnt;
int insert(int p,int x)
{
	int np = ++cnt,q,nq;
	last = np,len[np] = len[p]+1;
	for(;p&&!ch[p][x];p = fa[p])ch[p][x] = np;
	if(!p)fa[np] = 1;
	else
	{
		q = ch[p][x];
		if(len[q]==len[p]+1)fa[np] = q;
		else
		{
			fa[nq=++cnt] = fa[q];
			len[nq] = len[p]+1;
			memcpy(ch[nq],ch[q],sizeof(ch[q]));
			fa[np] = fa[q] = nq;
			for(;p&&ch[p][x]==q;p=fa[p])ch[p][x]=nq;
		}
	}
	return last;
}
long long ans;
void solve()
{
	for(int i=1;i<= cnt;i++)
		ans+=len[i]-len[fa[i]];
}
int id[N],val[N],ind[N];
void dfs(int x,int f,int p)
{
	int t = insert(p,val[x]);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x,t);
}
int main()
{
	int n,c,x,y;
	scanf("%d%d",&n,&c);
	for(int i = 1;i<= n;i++)scanf("%d",&val[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
		ind[x]++,ind[y]++;
	}
	id[0] = 1;
	cnt = 1;
	for(int i = 1;i<= n;i++)
		if(ind[i]==1)
			dfs(i,0,1);
	solve();
	printf("%lld\n",ans);
	return 0;
}
Problem3930

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
int d[2*N];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{
	ll n,k,a,b;
	scanf("%lld%lld%lld%lld",&n,&k,&a,&b);
	ll l = a/k,r=b/k;
	if(a%k)l++;
	for(int i = N-5;i>=1;i--)
	{
		ll L = l/i,R = r/i;
		if(l%i)L++;
		if(l<=r)
		{
			d[i]=quick_pow(R-L+1,n%(mod-1));
			d[i]=(d[i]-(R-L+1)+mod)%mod;
			for(int j = i*2;j<N;j+=i)
				d[i]=(d[i]-d[j]+mod)%mod;
		}
	}
	if(l==1)d[1] = (d[1]+1)%mod;
	printf("%d\n",d[1]);
	return 0;
}
Problem3931

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1005;
const int M = 500005;
const ll INF = 1e18;
const int inf = 0x3f3f3f3f;
struct E
{int next,to;ll f;};
ll dis[N];
int d[N];
bool v[N];
queue<int>Q;
struct G
{
	int head[N],tot;
	E e[M];
	void addE(int x,int y,int z)
	{e[++tot].to=y;e[tot].next = head[x];head[x]=tot;e[tot].f=z;}
	void addF(int x,int y,ll f)
	{
		e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;head[x]=tot;
		e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;head[y]=tot;
	}
	void spfa(int s,int n)
	{
		for(int i = 1;i<= n;i++)dis[i]=INF;
		dis[s]=0;v[s]=true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(dis[x]+e[i].f<dis[e[i].to])
				{
					dis[e[i].to]=dis[x]+e[i].f;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to]=true;
					}
				}
		}
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[t]=0;
		Q.push(t);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(d[e[i].to]==-1&&e[i^1].f)
				{
					d[e[i].to] = d[x]+1;
					Q.push(e[i].to);
				}
		}
		return d[s]!=-1;
	}
	ll get_maxflow(int s,int t,ll mf)
	{
		if(s==t)return mf;
		ll last = mf;
		for(int i = head[s];i;i=e[i].next)
			if(d[e[i].to]==d[s]-1&&e[i].f)
			{
				ll tof = get_maxflow(e[i].to,t,min(e[i].f,last));
				if(tof)
				{
					e[i].f-=tof;
					e[i^1].f+=tof;
					if(!(last-=tof))return mf;
				}
			}
		d[s]=-1;
		return mf-last;
	}
	ll dinic(int s,int t)
	{
		ll ans=0,nowflow;
		while(bfs(s,t))
			while((nowflow=get_maxflow(s,t,INF)))
				ans+=nowflow;
		return ans;
	}
}F,G;
int c[N],x[M],y[M],z[M];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&z[i]);
		G.addE(x[i],y[i],z[i]);
		G.addE(y[i],x[i],z[i]);
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	G.spfa(1,n);
	F.tot = 1;
	for(int i = 1;i<= m;i++)
	{
		if(dis[x[i]]+z[i]==dis[y[i]])
			F.addF(x[i]+n,y[i],INF);
		if(dis[y[i]]+z[i]==dis[x[i]])
			F.addF(y[i]+n,x[i],INF);
	}
	for(int i = 1;i<= n;i++)
		F.addF(i,i+n,c[i]);
	ll ans = F.dinic(n+1,n);
	printf("%lld\n",ans);
	return 0;
}
Problem3932

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 4000005;
typedef long long ll;
int ls[M],rs[M],sum[M],ans[M];
int root[N],n,m;
int a[N];
int st[N],ed[N],cnt;
struct P
{int val,id;}T[N];
bool cmpT(P a,P b){return a.val<b.val;}
struct Up
{int pos,val,aa;}ask[N<<1];
int cnt_ask;
bool cmp(Up a,Up b){return a.pos<b.pos;}
int a_T[N];
void init()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&st[i],&ed[i],&a[i]);
		ask[++cnt_ask] = (Up){st[i],1,i};
		ask[++cnt_ask] = (Up){ed[i]+1,-1,i};
		T[i] = (P){a[i],i};
	}
	sort(T+1,T+n+1,cmpT);
	for(int i = 1;i<= n;i++)
		a_T[T[i].id] = i;
	sort(ask+1,ask+cnt_ask+1,cmp);
}
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p]=sum[pre]+val;
		ans[p]=ans[pre]+val*T[l].val;
		return ;
	}
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
	sum[p] = sum[ls[p]]+sum[rs[p]];
	ans[p] = ans[ls[p]]+ans[rs[p]];
}
ll Ans;
void getans(int p,int k)
{
	int l = 1,r = n;
	Ans = 0;
	p = root[p];
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[ls[p]]>=k)
			p = ls[p],r = mid;
		else
			Ans+=ans[ls[p]],k-=sum[ls[p]],p = rs[p],l = mid+1;
	}
	Ans+=ans[p];
	printf("%lld\n",Ans);
}
int main()
{
	init();
	int j=1;
	for(int i = 1;i<= n;i++)
	{
		root[i] = root[i-1];
		while(j<=cnt_ask&&ask[j].pos==i)
		{
			update(root[i],root[i],1,n,a_T[ask[j].aa],ask[j].val);
			j++;
		}
	}
	int x,a,b,c,k;
	Ans=1;
	while(m--)
	{
		scanf("%d%d%d%d",&x,&a,&b,&c);
		k = ((ll)a*Ans+b)%c+1;
		//scanf("%d%d",&x,&k);
		getans(x,k);
	}
	return 0;
}
Problem3940

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 1e5+5;
int ch[N][26],fail[N];
int sum[N],cnt;
char s[N];
void insert()
{
	int now = 0,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)] = ++cnt;
		now = ch[now][s(i)];
		i++;
	}
	sum[now]=i;
}
int q[N],h,t;
void build()
{
	h = 0,t = -1;
	for(int i = 0;i<26;i++)
		if(ch[0][i])
			q[++t]=ch[0][i];
	while(h<=t)
	{
		int x= q[h++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[fail[x]][i];
			if(ch[x][i])
			{
				fail[ch[x][i]] = j;
				q[++t]=ch[x][i];
			}else
				ch[x][i] = j;
		}
	}
}
char str[N],st1[N];
int st2[N],top;
int main()
{
	scanf("%s",str);
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		insert();
	}
	build();
	int now = 0;
	for(int i = 0;str[i];i++)
	{
		st1[++top] = str[i];
		now = ch[now][str[i]-'a'];
		st2[top] = now;
		if(sum[now])
		{
			top-=sum[now];
			now = st2[top];
		}
	}
	for(int i = 1;i<= top;i++)printf("%c",st1[i]);
	return 0;
}
Problem3942

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
char A[N],B[N];
int fail[N],f[N],pos[N];
int main()
{
	scanf("%s",A+1);
	scanf("%s",B+1);
	int lenA = strlen(A+1),lenB = strlen(B+1);
	int j = 0;
	for(int i = 2;i<= lenB;i++)
	{
		while(B[i]!=B[j+1]&&j)
			j = fail[j];
		if(B[i]==B[j+1])j++;
		fail[i] = j;
	}
	for(int i = 1;i<= lenA;i++)
	{
		j = f[pos[pos[0]]];
		while(A[i]!=B[j+1]&&j)
			j = fail[j];
		if(A[i]==B[j+1])j++;
		if(j==lenB)pos[0]-=lenB-1;
		else {f[i] = j;pos[++pos[0]] = i;}
	}
	for(int i = 1;i<= pos[0];i++)
		printf("%c",A[pos[i]]);
	return 0;
}
Problem3944

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int M = 2e6+5;
const int N = 1e5+5;
const int m = 2e6;
bool v[M];
int prime[M],cnt,n;
ll mu[M],phi[M],p[N],q[N];
bool vis[N];
void quick_shai()
{
	phi[1] = mu[1] = 1;
	for(int i = 2;i<M;i++)
	{
		if(!v[i])
		{
			phi[i] = i-1;
			mu[i] = -1;
			prime[++cnt] = i;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<M;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])
			{
				mu[i*prime[j]] = -mu[i];
				phi[i*prime[j]] = phi[i]*(prime[j]-1);
			}else
			{
				mu[i*prime[j]] = 0;
				phi[i*prime[j]] = phi[i]*prime[j];
				break;
			}
		}
	}
	for(int i = 1;i<M;i++)
		phi[i]+=phi[i-1],mu[i]+=mu[i-1];
}
ll getp(int x)
{
	if(x<=m)return phi[x];
	else return p[n/x];
}
ll getq(int x)
{
	if(x<=m)return mu[x];
	else return q[n/x];
}
void solve(int x)
{
	if(x<=m)return ;
	int i,j = 1,t=n/x;
	if(vis[t])return ;
	vis[t] = true;
	p[t] = ((ll)x+1)*x/2;q[t] = 1;
	while(j<x)
	{
		i = j+1;
		j = x/(x/i);
		solve(x/i);
		q[t]-=getq(x/i)*(j-i+1);
		p[t]-=getp(x/i)*(j-i+1);
	}
}
int main()
{
	quick_shai();
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(vis,0,sizeof(vis));
		scanf("%d",&n);
		if(n<=m)printf("%lld %lld\n",phi[n],mu[n]);
		else
		{
			solve(1ll*n);
			printf("%lld %lld\n",p[1],q[1]);
		}
	}
	return 0;
}
Problem3963

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	int d,p,r,g,id;
	ll x,y;
	void read()
	{
		scanf("%d%d%d%d",&d,&p,&r,&g);
		x = g,y = r-p-(ll)d*g-g;
	}
}a[N],t[N];
struct Point
{
	ll x,y;
	Point(ll _x=0,ll _y=0):x(_x),y(_y){}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double operator *(const Point &a,const Point &b)
	{return (double)a.x*b.y-(double)a.y*b.x;}
}ch[N],p[N];
ll f[N];
inline bool cmp1(const data &a,const data &b)
{return a.d<b.d;}
inline bool cmp2(int i,int j)
{return a[i].x==a[j].x?a[i].y+f[a[i].id]<a[j].y+f[a[j].id]:a[i].x<a[j].x;}
inline ll Val(ll k,const Point &p){return k*p.x+p.y;}
void solve(int l,int r)
{
	if(l==r){f[l] = max(f[l-1],f[l]);return ;}
	int mid = (l+r)>>1;
	solve(l,mid);
	int n = 0,m = 0;
	for(int i = l;i<= mid;i++)if(f[a[i].id]>=a[i].p)
		p[++n] = Point(a[i].x,a[i].y+f[a[i].id]);
	for(int i = 1;i<= n;i++)
	{
		while(m>1&&(ch[m]-ch[m-1])*(p[i]-ch[m-1])>=0)m--;
		ch[++m] = p[i];
	}
	int j = 1;
	for(int i = mid+1;i<= r;i++)
	{
		while(j<m&&Val(a[i].d,ch[j+1])>=Val(a[i].d,ch[j]))j++;
		if(j<=m)f[i] = max(f[i],Val(a[i].d,ch[j]));
	}
	solve(mid+1,r);
	int p1 = l,p2 = mid+1;
	for(int i = l;i<=r;i++)
	{
		if(p2>r||(p1<=mid&&cmp2(p1,p2)))t[i]=a[p1++];
		else t[i] = a[p2++];
	}
	for(int i = l;i<= r;i++)a[i]=t[i];
}
int main()
{
	int n,d;
	int cas = 0;
	while(scanf("%d%lld%d",&n,&f[0],&d)!=EOF)
	{
		if(n==0&&f[0]==0&&d==0)break;
		for(int i = 1;i<= n;i++)a[i].read();
		a[++n].d = d+1;
		sort(a+1,a+n+1,cmp1);
		for(int i = 1;i<= n;i++)a[i].id = i,f[i] = 0;
		solve(1,n);
		printf("Case %d: %lld\n",++cas,f[n]);
	}
	return 0;
}
Problem3992

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MOD = 1004535809;
const int M = 16400;
const int G = 3;
int n,m,d,X,S;
int ind[M];
ll quick_pow(ll x,ll y,ll mod)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1,mod);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void NTT(int a[],int len,int type)
{
	static int tmp[M];
	if(len==1)return ;
	for(int i = 0;i<len;i+=2)
		tmp[i>>1] = a[i],tmp[(i+len)>>1]=a[i+1];
	memcpy(a,tmp,sizeof(a[0])*len);
	int *l = a,*r = a+(len>>1);
	NTT(l,len>>1,type);
	NTT(r,len>>1,type);
	ll w = quick_pow(G,(ll)type*(MOD-1)/len%(MOD-1),MOD),wn=1;
	for(int i = 0;i<(len>>1);i++,(wn*=w)%=MOD)
		tmp[i]=(l[i]+wn*r[i]%MOD)%MOD,tmp[i+(len>>1)]=((l[i]-wn*r[i]%MOD)%MOD+MOD)%MOD;
	memcpy(a,tmp,sizeof(a[0])*len);
	return ;
}
struct F
{
	int a[M];
	F(){}
	F(bool x)
	{
		memset(a,0,sizeof(a));
		a[0]=1;
	}
	int& operator[](int x)
	{
		return a[x];
	}
	F& operator*=(const F &s)
	{
		static int b[M];
		memcpy(b,s.a,sizeof(b));
		NTT(a,d,1);
		NTT(b,d,1);
		for(int i = 0;i<d;i++)
			a[i]=(ll)a[i]*b[i]%MOD;
		NTT(a,d,MOD-2);
		for(int i = m-1;i<= (m-2)<<1;i++)
			(a[i-(m-1)]+=a[i])%=MOD,a[i]=0;
		ll inv = quick_pow(d,MOD-2,MOD);
		for(int i=0;i<=m-2;i++)
			a[i]=a[i]*inv%MOD;
		return *this;
	}
}f;
int GPR()
{
	static int s[30];
	int x = m-1;
	for(int i = 2;i*i<=x;i++)
		if(x%i==0)
		{
			s[++s[0]]=i;
			while(x%i==0)x/=i;
		}
	if(x!=1)s[++s[0]]=x;
	for(int g = 2;;g++)
	{
		int j;
		for(j = 1;j<=s[0];j++)
			if(quick_pow(g,(m-1)/s[j],m)==1)
				break;
		if(j==s[0]+1)return g;
	}
}
F Quick_pow(F &a,int y)
{
	F re(true);
	while(y)
	{
		if(y&1)re*=a;
		a*=a,y>>=1;
	}
	return re;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&X,&S);
	for(d=1;d<=m+m;d<<=1);
	int g = GPR();
	for(int i = 0,x=1;i<m-1;i++,(x*=g)%=m)
		ind[x]=i;
	int x;
	for(int i = 1;i<= S;i++)
	{
		scanf("%d",&x);
		if(!x)continue;
		f[ind[x]] = 1;
	}
	F ans = Quick_pow(f,n);
	printf("%d\n",ans[ind[X]]);
	return 0;
}
Problem3995

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
int a[N][2],b[N],n,m;
struct data
{
	int l,r,sum;
	int mx,cnt;
	int lmx,rmx,lv,rv;
	data(){}
	data(int pos)
	{
		int x = b[pos];
		l = r = pos;
		sum = x;
		mx = 0,cnt=1;
		lmx=rmx=lv=rv=x;
	}
	friend data operator+(const data &x,const data &y)
	{
		data res;
		res.l = x.l,res.r = y.r;
		res.mx = max(max(a[x.r][0],a[x.r][1]),max(x.mx,y.mx));
		int max_val = max(max(a[x.r][0],a[x.r][1]),max(x.rmx,y.lmx));
		res.sum = x.sum+y.sum+a[x.r][0]+a[x.r][1]-max_val;
		res.cnt = x.cnt+y.cnt;
		res.lv = x.lv,res.rv = y.rv;
		res.lmx = x.lmx,res.rmx = y.rmx;
		if(x.rv==max_val)
		{
			res.cnt--;
			if(x.cnt==1)
			{
				res.lv = y.lv;
				res.lmx = max(max(x.mx,y.lmx),max(a[x.r][0],a[x.r][1]));
			}
		}else if(y.lv==max_val)
		{
			res.cnt--;
			if(y.cnt==1)
			{
				res.rv = x.rv;
				res.rmx = max(max(y.mx,x.rmx),max(a[x.r][0],a[x.r][1]));
			}
		}
		return res;
	}
}tr[N<<3];
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p] = data(l);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
void update1(int p,int l,int r,int pos)
{
	if(l==r)
	{
		tr[p] = data(l);
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update1(p<<1,l,mid,pos);
	else update1(p<<1|1,mid+1,r,pos);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
void update2(int p,int l,int r,int pos)
{
	int mid = (l+r)>>1;
	if(mid==pos)
	{
		tr[p] = tr[p<<1]+tr[p<<1|1];
		return ;
	}
	if(pos<=mid)
		update2(p<<1,l,mid,pos);
	else update2(p<<1|1,mid+1,r,pos);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
data getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans(p<<1|1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans(p<<1|1,mid+1,r,a,b);
}
void update(int x0,int y0,int x1,int y1,int z)  
{  
    if(y0==y1)//修改了一条竖边  
    {  
        b[y0]=z;  
        update1(1,1,n,y0);  
    }  
    else//修改了一条横边  
    {  
        if(y0>y1) swap(y0,y1);  
        a[y0][x0-1]=z; 
        update2(1,1,n,y0); 
    }  
}  
int main()
{
	scanf("%d%d",&n,&m);
	for(int j = 0;j<2;j++)
		for(int i = 1;i<= n-1;i++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);
	build(1,1,n);
	char opt[3];
	int x0,y0,x1,y1,w;
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='C')
		{
			scanf("%d%d%d%d%d",&x0,&y0,&x1,&y1,&w);
			update(x0,y0,x1,y1,w);
		}else
		{
			scanf("%d%d",&x0,&y0);
			data ans = getans(1,1,n,x0,y0);
			printf("%d\n",ans.sum);
		}
	}
	return 0;
}
Problem3996

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 4e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];e[tot].flow=f;head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];e[tot].flow=0;head[y]=tot;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t]=0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i=head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int main()
{
	int n,x,sum=0;
	scanf("%d",&n);
	int st = 0,end = n*n+n+1,id = n;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
		{
			id++;
			scanf("%d",&x);
			add(i,id,INF),add(j,id,INF);
			add(id,end,x);
			sum+=x;
		}
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		add(st,i,x);
	}
	printf("%d\n",sum-dinic(st,end));

	return 0;
}
Problem4001

#include <stdio.h>
int main()
{
	double x;
	scanf("%lf",&x);
	printf("%.9lf",x*(x+1)/2/(2*x-1));
}
Problem4002

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ll;
const ll mod = 7528443412579576937ll;
ll quick_plus(ll x,ll y)
{
	if(y==0)return 0;
	ll tmp = quick_plus(x,y>>1);
	if(y&1)return ((tmp+tmp)%mod+x)%mod;
	else return (tmp+tmp)%mod;
}
struct Matrix
{
	ll d[2][2];
	Matrix(){memset(d,0,sizeof(d));}
	void operator*=(const Matrix &s)
	{
		Matrix res;
		for(int i = 0;i<2;i++)for(int k = 0;k<2;k++)if(d[i][k])
			for(int j = 0;j<2;j++)
				(res.d[i][j]+=quick_plus(d[i][k],s.d[k][j]))%=mod;
		*this = res;
	}
	friend Matrix quick_pow(Matrix x,ll y)
	{
		Matrix ans;
		for(int i = 0;i<2;i++)ans.d[i][i]=1;
		while(y)
		{
			if(y&1)ans*=x;
			x*=x;
			y>>=1;
		}
		return ans;
	}
}a;
int main()
{
	ll b,d,n;
	scanf("%llu%llu%llu",&b,&d,&n);
	a.d[0][0] = 0;
	a.d[1][0] = 1;
	a.d[0][1] = (d-b*b)/4;
	a.d[1][1] = b;
	Matrix ans = quick_pow(a,n);
	ll Ans = (quick_plus(ans.d[0][0],2)+quick_plus(ans.d[1][0],b))%mod;
	Ans = Ans-(b!=d*d&&(~n&1));
	printf("%llu\n",(Ans+mod)%mod);
	return 0;
}
Problem4003

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
typedef long long ll;
const ll INF = 1e18;
int root[N],fa[N],d[N],a[N],death[N],ans[N];
ll h[N],v[N];
struct Merge_Heap
{
	#define ls son[p][0]
	#define rs son[p][1]
	int son[N][2],cnt;
	int id[N],level[N],exper[N];ll val[N],add[N],mul[N];
	void Push_down(int p)
	{
		if(mul[p]!=1)
		{
			val[p] = val[p]*mul[p];
			mul[ls]*=mul[p],mul[rs]*=mul[p];
			add[ls]*=mul[p],add[rs]*=mul[p];
			mul[p] = 1;
		}
		if(add[p])
		{
			val[p] = val[p]+add[p];
			add[ls]+=add[p],add[rs]+=add[p];
			add[p] = 0;
		}
		if(exper[p])
		{
			level[p]+=exper[p];
			exper[ls]+=exper[p],exper[rs]+=exper[p];
			exper[p] = 0;
		}
	}
	int merge(int x,int y)
	{
		if(!x||!y)return x+y;
		Push_down(x),Push_down(y);
		if(val[x]>val[y])swap(x,y);
		int tmp = rand()&1;
		son[x][tmp] = merge(son[x][tmp],y);
		return x;
	}
	void init(int p,ll _val,int _id)
	{
		++cnt;
		val[cnt] = _val,id[cnt] = _id;
		mul[cnt] = 1,add[cnt] = 0;
		root[p] = merge(root[p],cnt);
	}
	void Fight(int k)
	{
		for(int p = root[k];p;p=root[k])
		{
			Push_down(p);
			if(val[p]>=h[k])return ;
			ans[id[p]] = level[p];
			death[k]++;
			root[k] = merge(ls,rs);
		}
	}
	void Go(int k)
	{
		Push_down(root[k]);
		if(a[k])mul[root[k]]=v[k];
		else add[root[k]]=v[k];
		exper[root[k]]++;
		root[fa[k]] = merge(root[fa[k]],root[k]);
	}
}mh;
int stack[N],top;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lld",&h[i]);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d%lld",&fa[i],&a[i],&v[i]);
		d[fa[i]]++;
	}
	int s;ll c;
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%d",&c,&s);
		mh.init(s,c,i);
	}
	d[0] = 1,h[0] = INF;
	for(int i = 1;i<= n;i++)if(!d[i])stack[++top]=i;
	while(top)
	{
		int x = stack[top];
		top--;
		mh.Fight(x);
		if(x)
		{
			mh.Go(x);
			d[fa[x]]--;
			if(!d[fa[x]])stack[++top]=fa[x];
		}
	}
	for(int i = 1;i<= n;i++)
		printf("%d\n",death[i]);
	for(int i = 1;i<= m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4004

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
typedef long long ll;
const int mod = 1e9+7;
int b[N];
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
struct P
{
	int a[N];
	int val;
	bool operator <(const P &s)const
	{
		return val<s.val;
	}
}p[N];

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&p[i].a[j]);
	for(int i = 1;i<= n;i++)scanf("%d",&p[i].val);
	sort(p+1,p+n+1);
	int ans = 0,ansv = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(p[i].a[j])
			{
				if(!b[j])
				{
					b[j] = i;
					ans++;
					ansv+=p[i].val;
					break;
				}else
				{
					int tmp = (ll)p[i].a[j]*quick_pow(p[b[j]].a[j],mod-2)%mod;
					for(int k = j;k<= m;k++)
						p[i].a[k]=(p[i].a[k]-(ll)p[b[j]].a[k]*tmp%mod+mod)%mod;
				}
			}
	printf("%d %d\n",ans,ansv);
	return 0;
}
Problem4006

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<10;
const int N = 1005;
const int M = 6005;
const int P = 15;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
int head[N],tot,cnt,n,m,p;
void add(int x,int y,int f)
{
    e[++tot].to = y;
    e[tot].next = head[x];
    e[tot].val = f;
    head[x] = tot;
    e[++tot].to = x;
    e[tot].next = head[y];
    e[tot].val = f;
    head[y] = tot;
}
struct Point{int c,d;}po[P];
bool cmp(Point a,Point b){return a.c<b.c;}
int dis[S][N];
int g[S];
int Q[65540];
unsigned short l,r;
bool v[N];
void spfa(int dis[])
{
    while(l!=r)
    {
        int x = Q[l];
        l++;
        v[x] = false;
        for(int i = head[x];i;i = e[i].next)
        {
            if(dis[x]+e[i].val<dis[e[i].to])
            {
                dis[e[i].to] = dis[x]+e[i].val;
                if(!v[e[i].to])
                {
                    v[e[i].to] = true;
                    Q[r++] = e[i].to;
                }
            }
        }
    }
}
int DP()
{
    l = 1,r = 1;
    for(int i = 1;i<1<<cnt;i++)
    {
        //memset(v,0,sizeof(v));
        for(int j = 1;j<= n;j++)
        {
            for(int k = i&(i-1);k;k = (k-1)&i)
                dis[i][j] = min(dis[k][j]+dis[i^k][j],dis[i][j]);
            if(dis[i][j]!=INF){Q[r++] = j;v[j] = true;}
        }
        spfa(dis[i]);
    }
    int ans = INF;
    for(int i = 1;i<= n;i++)
        ans = min(ans,dis[(1<<cnt)-1][i]);
    return ans;
}
int main()
{
    int x,y,z;
    scanf("%d%d%d",&n,&m,&p);
    for(int i = 1;i<= m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
    }
    for(int i = 1;i<= p;i++)
        scanf("%d%d",&po[i].c,&po[i].d);
    int col = 0;
    int true_col[20]={};
    sort(po+1,po+p+1,cmp);
    for(int i=1;i<=p;i++)
    {
        if(i==1||po[i].c!=po[i-1].c)
            ++col;
        true_col[i]=col;
    }
    for(int i=1;i<=p;i++)
        po[i].c = true_col[i];
    memset(g,0x3f,sizeof(g));
    int end = 1<<col;
    for(int i = 0;i<end;i++)
    {
        cnt = 0;
        for(int j = 1;j<= p;j++)
            if(i&(1<<(po[j].c-1)))
                cnt++;
        memset(dis,0x3f,sizeof(dis[0][0])*N*(1<<cnt));
        cnt = 0;
        for(int j = 1;j<= p;j++)
            if(i&(1<<(po[j].c-1)))
                dis[1<<cnt++][po[j].d] = 0;
        g[i] = DP();
    }
    for(int i=1;i<end;i++)
        for(int j=i&(i-1);j;j = (j-1)&i)
            g[i]=min(g[i],g[j]+g[i^j]);
    printf("%d\n",g[(1<<col)-1]);
    return 0;
}
Problem4007

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = (1<<10)+5;
int dp[N][N],w[N][12],f[N][12],n,m;
void dfs(int x,int y,int sta,int cnt)
{
	for(int i = 0;i<= cnt;i++)dp[x][i] = 0;
	if(y==n-1)
	{
		for(int i = 0;i<y;i++)
			if(sta&(1<<i))dp[x][1]+=w[x-(1<<y)][i];
			else dp[x][0]+=f[x-(1<<y)][i];
		return ;
	}
	dfs(x<<1,y+1,sta,cnt>>1),dfs(x<<1|1,y+1,sta,cnt>>1);
	for(int i = 0;i<= cnt>>1;i++)
		for(int j = 0;j<= cnt>>1;j++)
			dp[x][i+j]=max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
	dfs(x<<1,y+1,sta|(1<<y),cnt>>1),dfs(x<<1|1,y+1,sta|(1<<y),cnt>>1);
	for(int i = 0;i<= cnt>>1;i++)
		for(int j = 0;j<= cnt>>1;j++)
			dp[x][i+j]=max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i< 1<<(n-1);i++)
		for(int j = n-2;j>=0;j--)
			scanf("%d",&w[i][j]);
	for(int i = 0;i< 1<<(n-1);i++)
		for(int j = n-2;j>=0;j--)
			scanf("%d",&f[i][j]);
	dfs(1,0,0,1<<(n-1));
	int ans = 0;
	for(int i = 0;i<= m;i++)ans = max(ans,dp[1][i]);
	printf("%d\n",ans);
}
Problem4008

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 220+5;
const int R = 132+5;
double f[N][R],Pow[N][R];
double p[N];
int w[N];
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(f,0,sizeof(f));
		memset(Pow,0,sizeof(Pow));
		int n,r;
		scanf("%d%d",&n,&r);
		for(int i = 1;i<= n;i++)
			scanf("%lf%d",&p[i],&w[i]);
		for(int i = 1;i<= n;i++)
		{
			Pow[i][0] = 1;
			for(int j = 1;j<=r;j++)
				Pow[i][j] = Pow[i][j-1]*(1.0-p[i]);
		}
		f[0][r] = 1;
		double ans = 0;
		for(int i = 0;i<n;i++)
		{
			for(int j = 0;j<=r;j++)
			{
				f[i+1][j] += f[i][j]*Pow[i+1][j];
				if(j-1>=0)
				{
					f[i+1][j-1] += f[i][j]*(1.0-Pow[i+1][j]);
					ans += f[i][j]*(1.0-Pow[i+1][j])*w[i+1];
				}
			}
		}
		printf("%.10f\n",ans);
	}
	return 0;
}
Problem4009

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,fa[N][20];
struct Plate
{int xd,xu,yd,yu,v;}plate[N];
struct Event
{int x,yd,yu,v,id;}event[N];
struct Poi
{int x,y,k,id;}poi[N],tmp1[N],tmp2[N];
bool operator <(Plate a,Plate b){return a.v<b.v;}
bool operator <(Event a,Event b){return a.x==b.x?a.id<b.id:a.x<b.x;}
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int last[N],dfn[N],dep[N],cnt,n,m,q,Cnt;
void dfs(int x,int f)
{
	dfn[x] = ++cnt;
	dep[x] = dep[f]+1;
	fa[x][0] = f;
	for(int i= head[x];i;i=e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
	last[x] = cnt;
}
void init()
{
	for(int j = 1;j<= 18;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 18;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 18;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int jump(int x,int h)
{
	for(int j = 18;j>= 0;j--)
		if(h>=(1<<j))
			x = fa[x][j],h-=(1<<j);
	return x;
}
struct Tree
{
	int val[N];
	void update(int l,int r,int x)
	{
		for(int i = l;i<N;i+=i&(-i))
			val[i]+=x;
		for(int i = r+1;i<N;i+=i&(-i))
			val[i]-=x;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans+=val[i];
		return ans;
	}
}T;
int ans[N],sum[N];
void solve(int l,int r,int st,int ed)
{
	if(ed<st)return ;
	if(l==r)
	{
		for(int i = st;i<= ed;i++)
			ans[poi[i].id] = plate[l].v;
		return ;
	}
	int mid = (l+r)>>1,siz=0;
	for(int i = l;i<= mid;i++)
	{
		event[++siz]=(Event){plate[i].xd,plate[i].yd,plate[i].yu,1,0};
		event[++siz]=(Event){plate[i].xu,plate[i].yd,plate[i].yu,-1,n+1};
	}
	for(int i = st;i<=ed;i++)
		event[++siz]=(Event){poi[i].x,poi[i].y,0,0,i};
	sort(event+1,event+siz+1);
	for(int i = 1;i<= siz;i++)
		if(event[i].id>=st&&event[i].id<=ed)
			sum[event[i].id]=T.getans(event[i].yd);
		else T.update(event[i].yd,event[i].yu,event[i].v);
	int a = 0,b = 0;
	for(int i = st;i<=ed;i++)
		if(sum[i]>=poi[i].k)tmp1[++a] = poi[i];
		else tmp2[++b] = (Poi){poi[i].x,poi[i].y,poi[i].k-sum[i],poi[i].id};
	for(int i = st;i<= st+a-1;i++)poi[i]=tmp1[i-st+1];
	for(int i = st+a;i<= ed;i++)poi[i] = tmp2[i-st-a+1];
	solve(l,mid,st,st+a-1),solve(mid+1,r,st+a,ed);
}
int main()
{
	int x,y,z,lca;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	init();
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		lca = getlca(x,y);
		if(dfn[x]>dfn[y])swap(x,y);
		if(lca!=x)plate[++Cnt] = (Plate){dfn[x],last[x],dfn[y],last[y],z};
		else
		{
			int t = jump(y,dep[y]-dep[x]-1);
			plate[++Cnt]=(Plate){1,dfn[t]-1,dfn[y],last[y],z};
			if(last[t]<n)
				plate[++Cnt]=(Plate){dfn[y],last[y],last[t]+1,n,z};
		}
	}
	sort(plate+1,plate+Cnt+1);
	for(int i =1;i<=q;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(dfn[x]>dfn[y])swap(x,y);
		poi[i]=(Poi){dfn[x],dfn[y],z,i};
	}
	solve(1,Cnt,1,q);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4010

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to;}e[N];
int head[N],tot,deg[N],n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	deg[y]++;
}
int ans[N],top,heap[N],cnt;
void topo()
{
	for(int i = n;i>=1;i--)
		if(!deg[i])
			heap[++cnt] = i;
	while(cnt)
	{
		int x = heap[1];
		ans[++top] = x;
		pop_heap(heap+1,heap+cnt+1);
		cnt--;
		for(int i = head[x];i;i=e[i].next)
			if(!(--deg[e[i].to]))
				heap[++cnt] = e[i].to,push_heap(heap+1,heap+cnt+1);
	}
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 0;
	memset(deg,0,sizeof(deg));
	cnt = top = 0;
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		scanf("%d%d",&n,&m);
		int x,y;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(y,x);
		}
		topo();
		if(top!=n)printf("Impossible!\n");
		else
		{
			for(int i = n;i>= 1;i--)
				printf("%d ",ans[i]);
			printf("\n");
		}
	}
	return 0;
}
Problem4011

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int deg[N],tdeg[N],invdeg[N],n,m,s,t;
ll ans;
void init()
{
	for(int i = 1;i<= n;i++)
		invdeg[i] = quick_pow(deg[i],mod-2);
}
queue<int>Q;
ll f[N];
void topo()
{
	f[t] = ans;
	for(int i = 1;i<= n;i++)
		if(!tdeg[i])
			Q.push(i);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		f[x] = (ll)f[x]*invdeg[x]%mod;
		for(int i = head[x];i;i=e[i].next)
		{
			(f[e[i].to]+=f[x])%=mod;
			if(!(--tdeg[e[i].to]))
				Q.push(e[i].to);
		}
	}
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&s,&t);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		deg[y]++;
		tdeg[y]++;
	}
	deg[t]++;
	ans = 1;
	for(int i = 2;i<= n;i++)
		ans = ans*deg[i]%mod;
	if(t==1)
		printf("%lld\n",ans);
	else
	{
		init();
		topo();
		printf("%lld\n",(ans-f[s]+mod)%mod);
	}
	return 0;
}
Problem4012

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 150005;
typedef long long ll;
typedef vector<pair<int,ll> >P;
const ll INF = 1e18;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
bool ban[N<<1];
void init()
{
	memset(head,0,sizeof(head));
	memset(ban,0,sizeof(ban));
	tot = 1;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
bool used[N];
int size[N],f[N],sum,root;
void get_root(int x,int from)
{
	size[x] = 1;f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to]&&e[i].to!=from)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int a[N],fa[N],dis[N];
P sum1[N];
P sum2[N];
void get_dis(int x,int from,P &s1,P &s2,ll dis)
{
	s1.push_back(pair<int,ll>(a[x],dis));
	s2.push_back(pair<int,ll>(a[x],dis));
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to]&&e[i].to!=from)
			get_dis(e[i].to,x,s1,s2,dis+e[i].val);
}
int work(int x)
{
	used[x] = true;
	sum1[x].push_back(pair<int,ll>(a[x],0));
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			sum=size[e[i].to];
			root = 0;
			P tmp;
			get_dis(e[i].to,x,sum1[x],tmp,e[i].val);
			get_root(e[i].to,0);
			fa[root] = x;sum2[root] = tmp;
			sum2[root].push_back(pair<int,ll>(-1,0));
			sort(sum2[root].begin(),sum2[root].end());
			for(int j = 1;j<sum2[root].size();j++)
				sum2[root][j].second+=sum2[root][j-1].second;
			work(root);
		}
	sum1[x].push_back(pair<int,ll>(-1,0));
    sort(sum1[x].begin(),sum1[x].end());
    for(int j=1;j<sum1[x].size();j++)
        sum1[x][j].second+=sum1[x][j-1].second;
}
int pos[N],T,log_2[N<<1];
ll min_dpt[N<<1][20],dpt[N];
void DFS(int x,int from)
{
	min_dpt[pos[x]=++T][0] = dpt[x];
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=from)
		{
			dpt[e[i].to] = dpt[x]+e[i].val;
			DFS(e[i].to,x);
			min_dpt[++T][0] = dpt[x];
		}
}
void build_lca()
{
	for(int i = 2;i<=T;i++)
		log_2[i] = log_2[i>>1]+1;
	for(int j = 1;j<= log_2[T];j++)
		for(int i = 1;i+(1<<j)-1<=T;i++)
			min_dpt[i][j] = min(min_dpt[i][j-1],min_dpt[i+(1<<(j-1))][j-1]);
}
ll get_lcadpt(int x,int y)
{
	x = pos[x],y = pos[y];
	if(x>y)swap(x,y);
	int l = log_2[y-x+1];
	return min(min_dpt[x][l],min_dpt[y-(1<<l)+1][l]);
}
ll get_distance(int x,int y)
{
	return dpt[x]+dpt[y]-2*get_lcadpt(x,y);
}
ll sumv1,sumv2;int cnt1,cnt2;
int qurey1(const P &s,int x)
{
	int l = 0,r = s.size();
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(s[mid].first<=x)l = mid+1;
		else r = mid;
	}
	l--;
	if(l<0)l = 0;
	return l;
}
int qurey2(const P &s,int x)
{
	int l = 0,r = s.size();
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(s[mid].first<x)l = mid+1;
		else r = mid;
	}
	l--;
	if(l<0)l = 0;
	return l;
}
ll ans;
void qurey(int x,int i,int l,int r)
{
	int r1 = qurey1(sum1[fa[i]],r),l1 = qurey2(sum1[fa[i]],l);
	int r2 = qurey1(sum2[i],r),l2 = qurey2(sum2[i],l);
	ans+=sum1[fa[i]][r1].second-sum1[fa[i]][l1].second-sum2[i][r2].second+sum2[i][l2].second;
	ans+=(ll)(r1-l1-r2+l2)*get_distance(x,fa[i]);
}
void qurey(int x,int l,int r)
{
	ans = 0;
	int L = qurey2(sum1[x],l),R = qurey1(sum1[x],r);
	ans+=sum1[x][R].second-sum1[x][L].second;
	for(int i = x;fa[i];i = fa[i])
		qurey(x,i,l,r);
}
void debug1(int x)
{
	printf("%d\n",sum1[x].size());
	for(int i = 0;i<sum1[x].size();i++)
		printf("%d:%I64d ",sum1[x][i].first,sum1[x][i].second);
	printf("\n");
}
void debug2(int x)
{
	printf("%d\n",sum2[x].size());
	for(int i = 0;i<sum2[x].size();i++)
		printf("%d:%I64d ",sum2[x][i].first,sum2[x][i].second);
	printf("\n");
}
int main()
{
	int n,q,A;
	scanf("%d%d%d",&n,&q,&A);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	DFS(1,0);
	build_lca();
	f[0] = sum = n;
	root = 0;
	get_root(1,0);
	work(root);
	ll last_ans = 0;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&z,&x,&y);
		x = (x+last_ans)%A;
		y = (y+last_ans)%A;
		if(x>y)swap(x,y);
		qurey(z,x,y);
		printf("%lld\n",last_ans = ans);
	}
	return 0;
}
Problem4013

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 405;
struct E
{int next,to;}e[N];
int head[N],tot,deg[N];
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	deg[y]++;
}
int fa[N],f[N][N],g[N],size[N],c[N][N];
bool vis[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
bool dfs(int x,int pre)
{
	vis[x] = true;
	bool flag = false;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre)
	{
		if(vis[e[i].to])return false;
		if(!dfs(e[i].to,x))return false;
		if(flag)
		{
			memset(g,0,sizeof(g));
			for(int j = 1;j<= size[x];j++)
				for(int k = 1;k<= size[e[i].to];k++)
					if(f[x][j]&&f[e[i].to][k])
					for(int I = max(j,k);I<=j+k;I++)
						(g[I]+=(ll)f[x][j]*f[e[i].to][k]%mod*c[j][j+k-I]%mod*c[I][j]%mod)%=mod;
			size[x]+=size[e[i].to];
			for(int I = 1;I<= size[x];I++)
				f[x][I] = g[I];
		}else
		{
			size[x]= size[e[i].to];
			flag = true;
			for(int I = 1;I<= size[x];I++)
				f[x][I] = f[e[i].to][I];
		}	
	}
	if(x)
	{
		size[x]++;
		if(flag)for(int i = size[x];i;i--)f[x][i] = f[x][i-1];
		else f[x][1] = 1;
	}
	return true;
}
void uni(int x,int y)
{
	x = getfa(x),y =getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
int X[N],Y[N];
int main()
{
	int n,m,x,y;
	char opt[3];
	scanf("%d%d",&n,&m);
	c[0][0]=1;
	for(int i = 1;i<= 400;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<= 400;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
	int cnt = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%s%d",&x,opt,&y);
		if(opt[0]=='=')
			uni(x,y);
		else
			X[++cnt] =x,Y[cnt] = y;
	}
	for(int i = 1;i<= cnt;i++)
	{
		x = getfa(X[i]),y = getfa(Y[i]);
		if(x==y){printf("0\n");return 0;}
		add(x,y);
	}
	for(int i=1;i<=n;i++)if(!deg[getfa(i)])add(0,getfa(i));
	if(!dfs(0,-1))return printf("0\n"),0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i&&!vis[i])return printf("0\n"),0;
	int ans = 0;
	for(int i = 1;i<= size[0];i++)ans=(ans+f[0][i])%mod;
	printf("%d\n",ans);
	return 0;
}
Problem4015

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define inf 0x1f1f1f1f
const int N = 210;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void clear()
{
	memset(head,0,sizeof(head));
	tot = 0;
}
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int q[N],fr,ta,fa[N],size[N];
vector <int> grav;
const int mod = 10007;
void Add(int &x,int y)
{
	if((x+=y)>=mod)
		x-=mod;
}
namespace solve1
{
	int f[N][N],g[N],fa[N],size[N];
	void dfs(int x)
	{
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				dfs(e[i].to);
				size[x]+=size[e[i].to];
			}
	}
	void dp(int x)
	{
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
				dp(e[i].to);
		f[x][1] = 1;
		memset(g,0,sizeof(g));
		g[0] = 1;
		for(int j = head[x];j;j=e[j].next)
			if(e[j].to!=fa[x])
				for(int k = size[x]-1;k>=0;k--)
					for(int i = 1;i<= size[e[j].to] && i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
		for(int i = 1;i<size[x];i++)
			f[x][i+1] = g[i];
	}
	void work(int root)
	{
		memset(fa,0,sizeof(fa));
		dfs(root);
		memset(f,0,sizeof(f));
		dp(root);
		int res = 0;
		for(int all = 1;all<= size[root];all++)
		{
			memset(g,0,sizeof(g));
			g[0] = 1;
			for(int j = head[root];j;j=e[j].next)
				for(int k = all-1;k>= 0;k--)
					for(int i = 1;i<=size[e[j].to]&&i*2<all&&i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
			Add(res,g[all-1]);
		}
		printf("%d\n",res);
	}
}

namespace solve2
{
	int f[N][N],g[N],size[N];
	void dp(int x,int fa)
	{
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa)
			{
				dp(e[i].to,x);
				size[x]+=size[e[i].to];
			}
		f[x][1] = 1;
		memset(g,0,sizeof(g));
		g[0] = 1;
		for(int j = head[x];j;j=e[j].next)
			if(e[j].to!=fa)
				for(int k = size[x]-1;k>=0;k--)
					for(int i = 1;i<= size[e[j].to]&&i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
		for(int i = 1;i<size[x];i++)
			f[x][i+1] = g[i];
	}
	void work(int r1,int r2)
	{
		memset(f,0,sizeof(f));
		dp(r1,r2),dp(r2,r1);
		int res = 0;
		for(int i = 1;i<= size[r1]&&i<= size[r2];i++)
			Add(res,f[r1][i]*f[r2][i]%mod);
		printf("%d\n",res);
	}
}
int main()
{
	//freopen("4015.in","r",stdin);
	//freopen("4015.out","w",stdout);
	int cas;
	scanf("%d",&cas);
	int n,a,b;
	for(int Cas = 1;Cas<= cas;Cas++)
	{
		printf("Case %d: ",Cas);
		clear();
		scanf("%d",&n);
		for(int i = 1;i<n;i++)
		{
			scanf("%d%d",&a,&b);
			add(a,b);
		}
		if(n<=2)puts("1");
		else
		{
			fr = 0;
			ta = -1;
			q[++ta] = 1;
			while(fr<=ta)
			{
				int x = q[fr++];
				for(int i = head[x];i;i=e[i].next)
					if(e[i].to!=fa[x])
					{
						fa[e[i].to] = x;
						q[++ta] = e[i].to;
					}
			}
			memset(size,0,sizeof(size));
			for(int i = ta;i>=0;i--)
				size[fa[q[i]]]+=++size[q[i]];
			size[0] = 0;
			grav.clear();
			int Min = inf,now;
			for(int i = 1;i<= n;i++)
			{
				now=n-size[i];
				for(int j = head[i];j;j=e[j].next)
					if(fa[e[j].to]==i)
						now = max(now,size[e[j].to]);
				if(now<Min)
				{
					Min = now;
					grav.clear();
					grav.push_back(i);
				}
				else if(now==Min)
					grav.push_back(i);
			}
			if(grav.size()==1)
				solve1::work(grav[0]);
			else
				solve2::work(grav[0],grav[1]);
		}
	}
	return 0;
}
Problem4016

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 6e4+5;
struct E
{int next,to,val;};
bool v[N],used[N];
int dis[N],f[N],size[N],dep[N],ft[N];
int F[N][2],G[N][2];
int sum,root,n,m,K,ans1,ans2;
struct Gragh
{
	E e[M<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val = f;
		head[x] = tot;
	}
	void spfa(int s)
	{
		queue<int>Q;
		memset(dis,0x3f,sizeof(dis));
		memset(v,0,sizeof(v));
		dis[s] = 0,v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i = e[i].next)
				if(dis[x]+e[i].val<dis[e[i].to])
				{
					dis[e[i].to] = dis[x]+e[i].val;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
		}
	}
	void get_root(int x,int fa)
	{	
		size[x] = 1;f[x] = 0;
		for(int i = head[x];i;i = e[i].next)
			if(!used[e[i].to]&&e[i].to!=fa)
			{
				get_root(e[i].to,x);
				f[x] = max(f[x],size[e[i].to]);
				size[x]+=size[e[i].to];
			}
		f[x] = max(f[x],sum-size[x]);
		if(f[x]<=f[root])root = x;
	}
	void calc(int x)
	{
		queue<int>Q;
		for(int i = 1;i<= K;i++)
			G[i][0] = G[i][1] = F[i][0] = F[i][1] = 0;
		F[0][1] = 1;
		dep[x] = 0,dis[x] = 0;
		for(int i = head[x];i;i = e[i].next)
		{
			if(used[e[i].to])continue;
			dep[e[i].to] = dep[x]+1;dis[e[i].to] = e[i].val;
			ft[e[i].to] = x;
			if(e[i].val>G[dep[e[i].to]][0])
			{
				G[dep[e[i].to]][0] = e[i].val;
				G[dep[e[i].to]][1] = 1;
			}
			else if(e[i].val==G[dep[e[i].to]][0])
				G[dep[e[i].to]][1]++;
			Q.push(e[i].to);
			while(!Q.empty())
			{
				int tp = Q.front();
				Q.pop();
				if(dep[tp]>=K)continue;
				for(int j = head[tp];j;j = e[j].next)
					if(e[j].to!=ft[tp]&&!used[e[j].to])
					{
						ft[e[j].to] = tp;
						dep[e[j].to] = dep[tp]+1;
						dis[e[j].to] = dis[tp]+e[j].val;
						if(dis[e[j].to]>G[dep[e[j].to]][0])
							G[dep[e[j].to]][0] = dis[e[j].to],G[dep[e[j].to]][1] = 1;
						else if(G[dep[e[j].to]][0]==dis[e[j].to])G[dep[e[j].to]][1]++;
						Q.push(e[j].to);
					}
			}
			for(int j = 1;j<= K;j++)
			{
				if(F[K-j][0]+G[j][0]>ans1)
					{ans1 = F[K-j][0]+G[j][0];ans2 = F[K-j][1]*G[j][1];}
				else if(F[K-j][0]+G[j][0]==ans1)
					{ans2+=F[K-j][1]*G[j][1];}
			}
			for(int j = 1;j<= K;j++)
			{
				if(G[j][0]>F[j][0]){F[j][0] = G[j][0],F[j][1] = G[j][1];}
				else if(G[j][0]==F[j][0]){F[j][1]+=G[j][1];}
				G[j][0] = G[j][1] = 0;
			}
		}
	}
	void work(int x)
	{
		calc(x);
		used[x] = true;
		for(int i = head[x];i;i= e[i].next)
			if(!used[e[i].to])
			{
				root = 0;
				sum= size[e[i].to];
				get_root(e[i].to,0);
				if(size[root]>=K)
					work(root);
			}
	}
	void dis_edge()
	{
		for(int i = 1;i<= n;i++)
			for(int j = head[i];j;j = e[j].next)
				if(i<=e[j].to)
					printf("%d %d %d\n",i,e[j].to,e[j].val);
	}
}g,t;
void rebuild(int x)
{
	v[x] = true;
	for(int i = g.head[x];i;i = g.e[i].next)
	{
		int to = g.e[i].to;
		if(!v[to]&&dis[x]+g.e[i].val==dis[to])
		{
			t.add(x,to,g.e[i].val),t.add(to,x,g.e[i].val);
			rebuild(to);
		}
	}
}
struct Edge
{int u,v,w;}edge[M<<1];
bool cmp(const Edge &a,const Edge &b)
{
	if(a.u==b.u)
		return a.v>b.v;
	return a.u<b.u;
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	K--;
	for(int i=1;i<= m;i++)
	{
		scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
		edge[i+m] = edge[i];
		swap(edge[i].u,edge[i].v);
	}
	sort(edge+1,edge+2*m+1,cmp);
	for(int i = 1;i<= 2*m;i++)
		g.add(edge[i].u,edge[i].v,edge[i].w);
	g.spfa(1);
	memset(v,0,sizeof(v));
	rebuild(1);
	//t.dis_edge();
	f[0] = sum= n;
	t.get_root(1,0);
	t.work(root);
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem4016

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 6e4+5;
struct E
{int next,to,val;};
bool v[N],used[N];
int dis[N],f[N],size[N],dep[N],ft[N];
int F[N][2],G[N][2];
int sum,root,n,m,K,ans1,ans2;
struct Gragh
{
    E e[M<<1];
    int head[N],tot;
    void add(int x,int y,int f)
    {
        e[++tot].to = y;
        e[tot].next = head[x];
        e[tot].val = f;
        head[x] = tot;
    }
    void spfa(int s)
    {
        queue<int>Q;
        memset(dis,0x3f,sizeof(dis));
        memset(v,0,sizeof(v));
        dis[s] = 0,v[s] = true;
        Q.push(s);
        while(!Q.empty())
        {
            int x = Q.front();
            Q.pop();
            v[x] = false;
            for(int i = head[x];i;i = e[i].next)
                if(dis[x]+e[i].val<dis[e[i].to])
                {
                    dis[e[i].to] = dis[x]+e[i].val;
                    if(!v[e[i].to])
                    {
                        Q.push(e[i].to);
                        v[e[i].to] = true;
                    }
                }
        }
    }
    void get_root(int x,int fa)
    {   
        size[x] = 1;f[x] = 0;
        for(int i = head[x];i;i = e[i].next)
            if(!used[e[i].to]&&e[i].to!=fa)
            {
                get_root(e[i].to,x);
                f[x] = max(f[x],size[e[i].to]);
                size[x]+=size[e[i].to];
            }
        f[x] = max(f[x],sum-size[x]);
        if(f[x]<=f[root])root = x;
    }
    void calc(int x)
    {
        queue<int>Q;
        for(int i = 0;i<= K;i++)
            G[i][0] = G[i][1] = F[i][0] = F[i][1] = 0;
        F[0][1] = 1;
        dep[x] = 0,dis[x] = 0;
        for(int i = head[x];i;i = e[i].next)
        {
            if(used[e[i].to])continue;
            dep[e[i].to] = dep[x]+1;dis[e[i].to] = e[i].val;
            ft[e[i].to] = x;
            Q.push(e[i].to);
            while(!Q.empty())
            {
                int tp = Q.front();
                Q.pop();
                if(dep[tp]>K)continue;
                if(dis[tp]>G[dep[tp]][0])
                    G[dep[tp]][0] = dis[tp],G[dep[tp]][1] = 0;
                if(G[dep[tp]][0]==dis[tp])G[dep[tp]][1]++;
                for(int j = head[tp];j;j = e[j].next)
                    if(e[j].to!=ft[tp]&&!used[e[j].to])
                    {
                        ft[e[j].to] = tp;
                        dep[e[j].to] = dep[tp]+1;
                        dis[e[j].to] = dis[tp]+e[j].val;
                        Q.push(e[j].to);
                    }
            }
            for(int j = 0;j<= K;j++)
            {
                if(F[K-j][0]+G[j][0]>ans1)
                    {ans1 = F[K-j][0]+G[j][0];ans2 = F[K-j][1]*G[j][1];}
                else if(F[K-j][0]+G[j][0]==ans1)
                    {ans2+=F[K-j][1]*G[j][1];}
            }
            for(int j = 0;j<= K;j++)
            {
                if(G[j][0]>F[j][0]){F[j][0] = G[j][0],F[j][1] = G[j][1];}
                else if(G[j][0]==F[j][0]){F[j][1]+=G[j][1];}
                G[j][0] = G[j][1] = 0;
            }
        }
    }
    void work(int x,int S)
    {
        calc(x);
        used[x] = true;
        for(int i = head[x];i;i= e[i].next)
            if(!used[e[i].to])
            {
                root = 0;
                sum= size[e[i].to];
                if(size[e[i].to]>size[x])size[e[i].to]=S-size[e[i].to];
                if(sum>=K)get_root(e[i].to,0);
                work(root,size[e[i].to]);
            }
    }
    void dis_edge()
    {
        for(int i = 1;i<= n;i++)
            for(int j = head[i];j;j = e[j].next)
                if(i<=e[j].to)
                    printf("%d %d %d\n",i,e[j].to,e[j].val);
    }
}g,t;
void rebuild(int x)
{
    v[x] = true;
    for(int i = g.head[x];i;i = g.e[i].next)
    {
        int to = g.e[i].to;
        if(!v[to]&&dis[x]+g.e[i].val==dis[to])
        {
            t.add(x,to,g.e[i].val),t.add(to,x,g.e[i].val);
            rebuild(to);
        }
    }
}
struct Edge
{int u,v,w;}edge[M<<1];
bool cmp(const Edge &a,const Edge &b)
{
    if(a.u==b.u)
        return a.v>b.v;
    return a.u<b.u;
}
int main()
{
    scanf("%d%d%d",&n,&m,&K);
    K--;
    for(int i=1;i<= m;i++)
    {
        scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
        edge[i+m] = edge[i];
        swap(edge[i].u,edge[i].v);
    }
    sort(edge+1,edge+2*m+1,cmp);
    for(int i = 1;i<= 2*m;i++)
        g.add(edge[i].u,edge[i].v,edge[i].w);
    g.spfa(1);
    memset(v,0,sizeof(v));
    rebuild(1);
    //t.dis_edge();
    f[0] = sum= n;
    t.get_root(1,0);
    t.work(root,sum);
    printf("%d %d\n",ans1,ans2);
    return 0;
}
Problem4025

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Edge
{
	int x,y,st,ed;
	Edge(int _x,int _y,int _s,int _e):x(_x),y(_y),st(_s),ed(_e){}
};
const int N = 100005;
int fa[N],rnk[N],stack[N<<2],a[N],top;
int getfa(int x)
{
	while(fa[x]!=x)x=fa[x];
	return fa[x]=x;
}
int getdis(int x)
{
	int res = 0;
	while(fa[x]!=x&&fa[x])res^=a[x],x=fa[x];
	return res;
}
void uni(int x,int y,int z)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(rnk[x]>rnk[y])swap(x,y);
	if(rnk[x]==rnk[y])
		rnk[y]++,stack[++top] = y;
	fa[x] = y,a[x] = z;stack[++top] = x;
}
void reset(int bot)
{
	while(top>bot)
	{
		if(stack[top]<0)
			rnk[-stack[top]]--;
		else 
			fa[stack[top]] = stack[top],a[stack[top]] = 0;
		top--;
	}
}
void solve(int l,int r,vector<Edge> &e)
{
	int mid = (l+r)>>1,bot = top;
	vector<Edge>L,R;
	for(int i = 0;i<e.size();i++)
	{
		if(e[i].st==l&&e[i].ed==r)
		{
			int _x = getfa(e[i].x),_y = getfa(e[i].y);
			int _z =getdis(e[i].x)^getdis(e[i].y)^1;
			if(_x!=_y)uni(_x,_y,_z);
			else if(_z&1)
			{
				for(int i = l;i<= r;i++)
					printf("No\n");
				reset(bot);
				return ;
			}
		}
		else if(e[i].ed<=mid)L.push_back(e[i]);
		else if(e[i].st>mid)R.push_back(e[i]);
		else
			L.push_back(Edge(e[i].x,e[i].y,e[i].st,mid)),
			R.push_back(Edge(e[i].x,e[i].y,mid+1,e[i].ed));
	}
	if(l==r)printf("Yes\n");
	else 
		solve(l,mid,L),solve(mid+1,r,R);
	reset(bot);
}
int main()
{
	int n,m,T,x,y,s,e;
	scanf("%d%d%d",&n,&m,&T);
	for(int i = 1;i<= n;i++)fa[i]=i;
	vector<Edge>E;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&s,&e);
		s++;
		if(s>e)continue;
		E.push_back(Edge(x,y,s,e));
	}
	solve(1,T,E);
	return 0;
}
Problem4027

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2000005;
int top,c[N],k[N],val[N],n,m,ans;
int stack[N];
bool cmp(int a,int b)
{
	return val[a]<val[b];
}
struct E
{int next,to;}e[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to);
	top = 0;
	for(int i= head[x];i;i = e[i].next)
		stack[++top] = e[i].to;
	sort(stack+1,stack+top+1,cmp);
	for(int i = 1;i<= top;i++)
	{
		if(val[x]+val[stack[i]]-1<=m)
		{
			ans++;
			val[x]+=val[stack[i]]-1;
		}else break;
	}
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&k[i]);
		val[i] = k[i]+c[i];
		for(int j = 1;j<= k[i];j++)
		{
			scanf("%d",&x);
			add(i,x+1);
		}
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}
Problem4028

#include <stdio.h>
#include <math.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 100005;
const int B = 5005;
int g[N],x[N],a[N];
int pos[N],lb[N],rb[N];
int gcd(int a,int b)
{
	if(a==-1)return b;
	if(b==0)return a;
	return gcd(b,a%b);
}
map<ll,int>s[B];
void debug(int b)
{
	printf("Bolck No #%d\n",b);
	map<ll,int>::iterator it;
	for(it = s[b].begin();it!=s[b].end();it++)
		printf("%lld %d\n",it->first,it->second);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int block = sqrt(n);
	for(int i = 1;i<= n;i++)
		pos[i] = (i-1)/block+1;
	int tot = pos[n];
	for(int i = 1;i<= tot;i++)
		lb[i] = (i-1)*block+1,rb[i] = i*block;
	rb[tot] = n;
	for(int i = 1;i<= tot;i++)
	{
		g[lb[i]] = a[lb[i]],x[lb[i]] = a[lb[i]];
		s[i][x[lb[i]]] = lb[i];
		for(int j = lb[i]+1;j<= rb[i];j++)
		{
			g[j] = gcd(g[j-1],a[j]),x[j] = x[j-1]^a[j];
			if(s[i].find(x[j])==s[i].end())s[i][x[j]] = j;
		}
		//debug(i);
	}
	int q,id,nv;
	ll p;
	scanf("%d",&q);
	while(q--)
	{
		char opt[10];
		scanf("%s",opt);
		if(opt[0]=='M')
		{
			scanf("%d%d",&id,&nv);
			id++;
			int Pos = pos[id];
			for(int i = id;i<= rb[Pos];i++)
				if(s[Pos][x[i]]==i)s[Pos].erase(x[i]);
			if(id==lb[Pos])g[id] = x[id] = nv;
			else g[id] = gcd(g[id-1],nv),x[id] = x[id-1]^nv;
			if(s[Pos].find(x[id])==s[Pos].end())s[Pos][x[id]] = id;
			for(int i = id+1;i<= rb[Pos];i++)
			{
				g[i] = gcd(g[i-1],a[i]),x[i] = x[i-1]^a[i];
				if(s[Pos].find(x[i])==s[Pos].end())s[Pos][x[i]] = i;
			}
			a[id] = nv;
			//debug(Pos);
		}
		else
		{
			scanf("%lld",&p);
			int lastgcd = -1;
			int lastxor = 0;
			bool flag = false;
			for(int i = 1;i<= tot&&!flag;i++)
			{
				int tmp_gcd = gcd(lastgcd,g[rb[i]]);
				if(tmp_gcd==lastgcd)
				{
					ll goal = (p/lastgcd)^lastxor;
					if(p%lastgcd)goal = -1;
					if(s[i].find(goal)!=s[i].end())
					{
						printf("%d\n",s[i][goal]-1);
						flag = true;
					}
				}else
				{
					for(int j = lb[i];j<= rb[i];j++)
					{
						ll tg = gcd(lastgcd,g[j]);
						ll tx = lastxor^x[j];
						if(tg*tx==p)
						{
							printf("%d\n",j-1);
							flag = true;break;
						}
					}
				}
				lastgcd = gcd(lastgcd,g[rb[i]]);
				lastxor = lastxor^x[rb[i]];
			}
			if(!flag)printf("no\n");
		}
	}
	return 0;
}
/*
10

1353600 5821200 10752000 1670400 3729600 6844320 12544000 117600 59400 640

10

MODIFY 7 20321280

QUERY 162343680

QUERY 1832232960000

MODIFY 0 92160

QUERY 1234567

QUERY 3989856000

QUERY 833018560

MODIFY 3 8600

MODIFY 5 5306112

QUERY 148900352

6

0

no

2

8

8
*/
Problem4029

#include <set>
#include <map>
#include <ctime>
#include <queue>
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int T,l,r,ans,mn;
int add(int x)
{
    int k=1;
    while(x%10==0)
    {
        k*=10;
        x/=10;
    }
    return k;
}
int cal(int x)
{
    while(x%10==0)
        x/=10;
    int t=x%10,a=0;
    while(x)
    {
        x/=10;
        a++;
    }
    if(t==5)
        return 2*a-1;
    return 2*a;
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&l,&r);
        mn=cal(l);ans=l;
        while(1)
        {
            l+=add(l);
            if(l>r)break;
            int t=cal(l);
            if(t<mn)mn=t,ans=l;
        }
        printf("%d\n",ans);
    }
    return 0;
}
Problem4033

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
typedef long long LL;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,n,K;
LL f[N][N];
int size[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dp(int x,int fa,int val)
{
	size[x]++;
	f[x][0] = f[x][1] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		dp(e[i].to,x,e[i].val);
		size[x]+=size[e[i].to];
		for(int j = min(size[x],K);j>= 0;j--)
			for(int k = 0;k<= j&&k<=size[e[i].to];k++)
				if(j-k>=0&&f[x][j-k]!=-1)f[x][j] = max(f[x][j],f[x][j-k]+f[e[i].to][k]);
	}
	for(int bn = 0;bn<= K&&bn<=size[x];bn++)
	{
		if(f[x][bn]==-1)f[x][bn] = 0;
		f[x][bn] = f[x][bn]+(LL)val*(LL)bn*(K-bn)+(LL)val*(LL)(size[x]-bn)*(n-K-size[x]+bn);
	}
}
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&K);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c),add(y,x,c);
	}
	memset(f,-1,sizeof(f));
	dp(1,0,0);
	printf("%lld\n",f[1][K]);
	return 0;
}
Problem4034

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int w[N],top[N],deep[N],son[N],size[N],fa[N],end[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	deep[x] = dep;
	size[x]++;
	v[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	end[x] = cnt;
}
long long sum[N<<3],f[N<<3];
void push_down(int p,int l,int r)
{
	f[p<<1]+=f[p];
	f[(p<<1)+1]+=f[p];
	int mid = (l+r)>>1;
	sum[p<<1]+=f[p]*(mid-l+1);
	sum[(p<<1)+1]+=f[p]*(r-mid);
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b,long long c)
{
	if(f[p])push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		f[p]+=c;
		sum[p]+=c*(r-l+1);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update((p<<1)+1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
long long getans(int p,int l,int r,int a,int b)
{
	if(f[p])push_down(p,l,r);
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1;
	long long ans = 0;
	if(a<=mid)ans+=getans(p<<1,l,mid,a,b);
	if(b>mid)ans+=getans((p<<1)+1,mid+1,r,a,b);
	return ans;
}
long long qurey(int x,int y)
{
	long long ans = 0;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		ans+=getans(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])
		swap(x,y);
	ans+=getans(1,1,n,w[y],w[x]);
	return ans;
}
int num[N];
int main()
{
	int x,y,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(1,1,n,w[i],w[i],num[i]);
	int opt;
	long long z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)
		{
			scanf("%lld",&z);
			update(1,1,n,w[x],w[x],z);
		}else if(opt==2)
		{
			scanf("%lld",&z);
			update(1,1,n,w[x],end[x],z);
		}else
			printf("%lld\n",qurey(1,x));
	}
	return 0;
}
Problem4036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<20;
const double eps = 1e-8;
double a[N+5];
int f[N+5];
int main()
{
	int n;
	scanf("%d",&n);
	f[0] = ((n+1)&1)?-1:1;
	for(int i = 0;i<(1<<n);i++)
	{
		scanf("%lf",&a[i]);
		if(i>0)f[i] = -f[i-(i&(-i))];
	}
	for(int k = 1;k<(1<<n);k<<=1)
		for(int i = 0;i<(1<<n);i++)
		{
			if(i&k)continue;
			a[i+k]+=a[i];
		}
	bool flag = true;
	for(int i = 0;flag&&i<(1<<n)-1;i++)
		if(a[i]+eps>1)
			flag = false;
	if(!flag)printf("INF\n");
	else
	{
		double ans = 0;
		for(int i = 0;i<(1<<n)-1;i++)
			ans+=f[i]/(1-a[i]);
		printf("%.7lf\n",ans);
	}
	return 0;
}
Problem4055

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 8e3+5;
typedef long double ld;
struct E
{int next,to,b;ld c;};
struct H
{int v,no;}heap[M];
bool cmp(H a,H b)
{
    return a.v>b.v;
}
bool on_tree[M];
int dis[N],ind[N],rei[N],a[N],n,m,cnt;bool v[N];
ld arc[N][N];
ld R[N],tr[N];
queue<int>Q;
struct Gragh
{
	E e[M];
	int head[N],tot;
	void init()
	{
		memset(head,0,sizeof(head));
		tot = 1;
	}
	void add(int x,int y,int b,ld c)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
		e[tot].b = b,e[tot].c = c;
	}
	void spfa(int s)
	{
		cnt = 0;
		memset(dis,0x3f,sizeof(dis));
		memset(v,false,sizeof(v));
		dis[s]=0;
		heap[1].v = 0;heap[1].no = s;
		cnt++;
		push_heap(heap+1,heap+cnt+1,cmp);
		while(cnt)
		{
			int now=heap[1].no;
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			if(v[now])continue;
			v[now]=1;
			for(int i=head[now];i;i=e[i].next)
				if(dis[now]+e[i].b<dis[e[i].to]&&!v[e[i].to])
				{
					dis[e[i].to]=dis[now]+e[i].b;
					heap[++cnt].v = dis[e[i].to];
					heap[cnt].no = e[i].to;
					push_heap(heap+1,heap+cnt+1,cmp);
				}
		}
		for(int i = 1;i<= n;i++)
			for(int j = head[i];j;j=e[j].next)
				if(dis[i]+e[j].b==dis[e[j].to])
					on_tree[j] = true,ind[e[j].to]++,rei[i]++;
	}
	void topo(int s)
	{
		arc[s][s] = 1;
		for(int i = 1;i<= n;i++)
			if(!ind[i])
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(on_tree[i])
				{
					arc[s][e[i].to]+=e[i].c*arc[s][x];
					if(!--ind[e[i].to])
						Q.push(e[i].to);
				}
		}
	}
	void retopo(int s)
	{
		for(int i = 1;i<= n;i++)
		{
			if(!rei[i])
				Q.push(i);
			tr[i] = 0;
		}
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
			if(on_tree[i^1])
			{
				tr[e[i].to]+=e[i].c*tr[x];
				tr[e[i].to]+=e[i].c*a[x]/arc[s][x];
				if(!--rei[e[i].to])
					Q.push(e[i].to);
			}
		}
	}
	void getR(int s)
	{
		for(int i=1;i<= n;i++)
			if(i!=s)
				R[i]+=arc[s][i]*a[s]*tr[i];
	}
}g;
int main()
{
	//freopen("misc.in","r",stdin);
	//freopen("misc.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int u,v,d;ld c;
	g.init();
	for(int i = 1;i<=m;i++)
	{
		scanf("%d%d%d%Lf",&u,&v,&d,&c);
		g.add(u,v,d,c);
		g.add(v,u,d,c);
	}
	for(int i= 1;i<= n;i++)
	{
		memset(ind,0,sizeof(ind));
		memset(rei,0,sizeof(rei));
		memset(on_tree,0,sizeof(on_tree));
		g.spfa(i);
		g.topo(i);
		g.retopo(i);
		g.getR(i);
	}
	for(int i = 1;i<= n;i++)
		printf("%.8Lf\n",R[i]);
	return 0;
}
Problem4071

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
LL sum[N<<3];
int size[N<<3];
struct P{int a,b;}per[N];
int pos[N<<1],cnt,tot,d[N<<1];
bool cmp(const P &x,const P &y)
{
	return (x.a+x.b)<(y.a+y.b);
}
void init()
{
	sort(pos+1,pos+cnt+1);
	int tmp = cnt;cnt = 0;
	pos[0] = -1e9;
	for(int i = 1;i<= tmp;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt] = pos[i];
}
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void push_up(int p)
{
	sum[p] = sum[p<<1]+sum[p<<1|1];
	size[p] = size[p<<1]+size[p<<1|1];
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = size[p] = 0;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void update(int p,int l,int r,int x)
{
	if(l==r)
	{
		sum[p]+=d[l];
		size[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x);
	else update(p<<1|1,mid+1,r,x);
	push_up(p);
}
LL get_sum(int p,int l,int r,int cnt)
{
	if(size[p]<=cnt)return sum[p];
	if(l==r)return (LL)cnt*d[l];
	int mid = (l+r)>>1;
	if(size[p<<1]>=cnt)return get_sum(p<<1,l,mid,cnt);
	else return sum[p<<1]+get_sum(p<<1|1,mid+1,r,cnt-size[p<<1]);
}
LL Ask(LL k)
{
	LL s = get_sum(1,1,cnt,k);
	return sum[1]-(LL)2*s;
}
LL ans[N];
int main()
{
	int k,n;
	scanf("%d%d",&k,&n);
	LL pre = 0;
	char x1[5],x2[5];int x,y;
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d%s%d",x1,&x,x2,&y);
		if(x1[0]==x2[0])pre+=abs(y-x);
		else
		{
			pre++;
			pos[++cnt] = x;pos[++cnt] = y;
			per[++tot].a = x;per[tot].b = y;
		}
	}
	init();
	sort(per+1,per+tot+1,cmp);
	if(cnt)
	{
		n = tot;
		for(int i = 1;i<= n;i++)
			d[find(per[i].a)] = per[i].a,d[find(per[i].b)] = per[i].b;
		build(1,1,cnt);
		for(int i = 1;i<= n;i++)
		{
			update(1,1,cnt,find(per[i].a));
			update(1,1,cnt,find(per[i].b));
			ans[i] = Ask(i);
		}
	}
	if(k==1){printf("%lld\n",ans[n]+pre);return 0;}
	else
	{
		LL Ans = ans[n];
		if(cnt)
		{
			build(1,1,cnt);
			for(int i = n;i>1;i--)
			{
				update(1,1,cnt,find(per[i].a));
				update(1,1,cnt,find(per[i].b));
				Ans = min(Ans,ans[i-1]+Ask(n-i+1));
			}
		}
		printf("%lld\n",Ans+pre);
	}
	return 0;
}
Problem4078

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 405;
const int M = 805;
const int INF = 0x3f3f3f3f;
struct Edge
{int u,v,w;}edge[N*N];
struct E
{int next,to;}e[M*M];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
}
bool cmp(const Edge &a,const Edge &b)
{
	if(a.w==b.w)
	{
		if(a.u==b.u)return a.v>b.v;
		else return a.u>b.u;
	}	
	else return a.w>b.w;
}
int fa[N],d[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	int res = getfa(fa[x]);
	d[x]^=d[fa[x]];
	return fa[x] = res;
}
int a[N][N];
bool ins[N];
int low[N],dfn[N],stack[N],top,dcc,bel[N],cnt;
void tarjan(int x)
{
	stack[++top] =x;
	dfn[x]=low[x]=++cnt;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(low[x]==dfn[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
bool check(int s1,int s2)
{
	for(int i = 1;i<= 2*n;i++)head[i]=low[i]=dfn[i]=bel[i]=ins[i]=0;
	top = dcc = tot = cnt = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
		{
			if(a[i][j]>s1)
			{
				add(i*2-1,j*2);
				add(j*2-1,i*2);
			}if(a[i][j]>s2)
			{
				add(i*2,j*2-1);
				add(j*2,i*2-1);
			}
		}
	for(int i = 1;i<= 2*n;i++)if(!dfn[i])tarjan(i);
	for(int i = 1;i<= n;i++)if(bel[i*2]==bel[i*2-1])return false;
	return true;
}
int getans(int c)
{
	int l = 0,r = c;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(check(c,mid))r = mid-1;
		else l = mid+1;
	}
	return l;
}
int main()
{
	int id = 0;
	scanf("%d",&n);
	if(n<=2){printf("0\n");return 0;}
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
		{
			id++;
			scanf("%d",&a[i][j]);a[j][i]=a[i][j];
			edge[id]=(Edge){i,j,a[i][j]};
		}
	for(int i = 1;i<= n;i++)fa[i]=i,d[i]=0;
	sort(edge+1,edge+id+1,cmp);
	int ans = INF;
	for(int i = 1;i<= id;i++)
	{
		int u = edge[i].u,v = edge[i].v,w = edge[i].w;
		int x = getfa(u),y = getfa(v);
		if(x!=y)
		{
			ans = min(ans,w+getans(w));
			d[x] = d[u]^d[v]^1;
			fa[x] = y;
		}else if(d[u]==d[v])
		{
			ans=min(ans,w+getans(w));
			break;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem4098

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int mod = 1e9+7;
char s[N][N];
int f[2][N][N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	f[0][1][n] = 1;
	for(int i = 1;i<=n;i++)
	{
		int now = i&1,pre = (i-1)&1;
		memset(f[now],0,sizeof(f[now]));
		for(int x1 = 1;x1<= i;x1++)
		{
			int y1 = i-x1+1;
			for(int x2 = n;x2>=n-i;x2--)
			{
				int y2 = n-(i-(n-x2))+1;
				if(s[x1][y1]==s[x2][y2])
					f[now][x1][x2] = ((f[pre][x1][x2]+f[pre][x1-1][x2])%mod+(f[pre][x1][x2+1]+f[pre][x1-1][x2+1])%mod)%mod;
			}
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		(ans+=f[n&1][i][i])%=mod;
	printf("%d\n",ans);
	return 0;
}
Problem4100

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL v[7][7];
int main()
{
	int n,x;
	char tmp[3];
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%s%d",tmp,&x);
		if(tmp[0]=='B')v[0][(x%7+7)%7]++;
		else if(tmp[0]=='E')v[1][(x%7+7)%7]++;
		else if(tmp[0]=='S')v[2][(x%7+7)%7]++;
		else if(tmp[0]=='I')v[3][(x%7+7)%7]++;
		else if(tmp[0]=='G')v[4][(x%7+7)%7]++;
		else if(tmp[0]=='O')v[5][(x%7+7)%7]++;
		else v[6][(x%7+7)%7]++;
	}
	LL ans = 0;
	for(int B = 0;B<7;B++)
	for(int E = 0;E<7;E++)
	for(int S = 0;S<7;S++)
	for(int I = 0;I<7;I++)
	for(int G = 0;G<7;G++)
	for(int O = 0;O<7;O++)
	for(int M = 0;M<7;M++)
	{
		if((B+E+S+S+I+E)*(G+O+E+S)*(M+O+O)%7==0)
			ans += v[0][B]*v[1][E]*v[2][S]*v[3][I]*v[4][G]*v[5][O]*v[6][M];
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4101

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct G
{int s,p;}g[N];
bool cmp(G a,G b)
{
	return a.p<b.p;
}
int n,b;
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(g[mid].p<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&b);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&g[i].s,&g[i].p);
	sort(g+1,g+n+1,cmp);
	int l = find(b)-1;
	int r = l+1;
	int ans = 0x3f3f3f3f;
	for(int i = l;i>=1;i--)
	{
		while(r<=n&&g[r].p-g[i].p<=g[i].s)
		{
			ans = min(ans,g[r].p-g[i].p-g[r].s);
			r++;
		}
	}
	r = l+1;
	for(int i = r;i<=n;i++)
	{
		while(l&&g[i].p-g[l].p<=g[i].s)
		{
			ans = min(ans,g[i].p-g[l].p-g[l].s);
			l--;
		}
	}
	if(ans!=0x3f3f3f3f)printf("%d\n",max(ans,0));
	else printf("-1\n");
	return 0;
}
Problem4102

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 20005;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
queue<int>Q;
int dis[N][N];
void bfs(int s)
{
	memset(dis[s],-1,sizeof(dis[s]));
	Q.push(s);
	dis[s][s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(dis[s][e[i].to]==-1)
			{
				dis[s][e[i].to] = dis[s][x]+1;
				Q.push(e[i].to);
			}
	}
	return ;
}
struct P
{int no,val;}p[N];
bool cmp(P a,P b)
{
	return a.val>b.val;
}
int f[N];
int main()
{
	int n,en;
	scanf("%d%d",&n,&en);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&p[i].val);
		p[i].no = i;
		int d,x;
		scanf("%d",&d);
		for(int j = 1;j<= d;j++)
		{
			scanf("%d",&x);
			add(i,x);
		}
	}
	for(int i = 1;i<= n;i++)
	{
		bfs(i);
		for(int j = 1;j<= n;j++)
			dis[i][j]*=en;
		dis[0][i] = 0;
	}
	sort(p+1,p+n+1,cmp);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<i;j++)
			if(dis[p[j].no][p[i].no]>=0)
				f[i] = max(f[i],f[j]-dis[p[j].no][p[i].no]+p[i].val);
	int ans =0;
	for(int i = 1;i<= n;i++)
		ans = max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4103

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 3e5+5;
const int W = M*35;
int n,m,cnt,U,D,L,R,k;
int a[N],b[M];
int ch[W][2],sum[W],root[M];
struct data{int x,y;}q[N];
void insert(int x,int &y,int num,int dep)
{
	y = ++cnt;
	sum[y] = sum[x]+1;
	ch[y][0]=ch[x][0],ch[y][1]=ch[x][1];
	if(dep<0)return ;
	int t = num&(1<<dep);t = t>>dep;
	insert(ch[x][t],ch[y][t],num,dep-1);
}
int solve(int k,int dep)
{
	if(dep==-1)return 0;
	int tmp = 0,t;
	for(int i = U;i<= D;i++)
	{
		t = a[i]&(1<<dep);t = t>>dep;
		tmp+=sum[ch[q[i].y][t^1]]-sum[ch[q[i].x][t^1]];
	}
	if(tmp>=k)
	{
		for(int i = U;i<=D;i++)
		{
			t = a[i]&(1<<dep);t = t>>dep;
			q[i].x = ch[q[i].x][t^1];
			q[i].y = ch[q[i].y][t^1];
		}
		return solve(k,dep-1)+(1<<dep);
	}else
	{
		for(int i = U;i<=D;i++)
		{
			t = a[i]&(1<<dep);t = t>>dep;
			q[i].x = ch[q[i].x][t];
			q[i].y = ch[q[i].y][t];
		}
		return solve(k-tmp,dep-1);
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&b[i]);
	for(int i = 1;i<= m;i++)insert(root[i-1],root[i],b[i],30);
	int Q;
	scanf("%d",&Q);
	for(int i = 1;i<= Q;i++)
	{
		scanf("%d%d%d%d%d",&U,&D,&L,&R,&k);
		for(int i = U;i<= D;i++)
			q[i].x = root[L-1],q[i].y = root[R];
		printf("%d\n",solve(k,30));
	}
	return 0;
}
Problem4140

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 500010;
int n,opt,top,num;
int l[40],r1[40],r2[40];
bool t;
double A,B,C,sum;
inline double sqr(double x){return x*x;}
struct Point
{
	double x,y;
}ins[N],newq[N],q1[N],q2[N];
inline bool cmp1(const Point &a,const Point &b)   
{return a.x==b.x?a.y>b.y:a.x<b.x;}
inline bool cmp2(const Point &a,const Point &b)   
{return a.x==b.x?a.y<b.y:a.x<b.x;}
void rebuild() 
{
	while (num&&top-l[num]==l[num]-l[num-1])    
		num--;
	l[++num]=top;
	int L=l[num-1]+1,R=L-1,cnt=0;
	for (int i=L;i<=top;i++)    
		newq[++cnt]=ins[i];
	sort(newq+1,newq+cnt+1,cmp1);
	for (int i=1;i<=cnt;i++)
	{
		while (R>L&&(q1[R].y-q1[R-1].y)*(newq[i].x-q1[R].x)<=(newq[i].y-q1[R].y)*(q1[R].x-q1[R-1].x))   
			R--;
		q1[++R]=newq[i];
	}
	r1[num]=R;
	R=L-1;
	sort(newq+1,newq+cnt+1,cmp2);
	for (int i=1;i<=cnt;i++)
	{
		while (R>L&&(q2[R].y-q2[R-1].y)*(newq[i].x-q2[R].x)>=(newq[i].y-q2[R].y)*(q2[R].x-q2[R-1].x))   
			R--;
		q2[++R]=newq[i];
	}
	r2[num]=R;
}
inline double calc(Point x) 
{return A*x.x+B*x.y;}
bool query1(int l,int r)
{
	int mid1,mid2,len;double s1,s2;
	while (l<=r)
	{
		len=(r-l)/3;
		mid1=l+len;
		mid2=r-len;
		s1=calc(q1[mid1]);
		s2=calc(q1[mid2]);
		if (s1<s2)  
			{if (s1<C)  return t=1;r=mid2-1;}
		else    
			{if (s2<C)  return t=1;l=mid1+1;}
	}
	return 0;
}
bool query2(int l,int r)
{
	int mid1,mid2,len;double s1,s2;
	while (l<=r)
	{
		len=(r-l)/3;
		mid1=l+len;
		mid2=r-len;
		s1=calc(q2[mid1]);
		s2=calc(q2[mid2]);
		if (s1<s2)  
			{if (s1<C)  return t=1;r=mid2-1;}
		else    
			{if (s2<C)  return t=1;l=mid1+1;}
	}
	return 0;
}
inline void Query()
{
	t=0;
	for (int i=1;i<=num;i++)
	{
		if (B<0)    
			query1(l[i-1]+1,r1[i]); 
		else    
			query2(l[i-1]+1,r2[i]);
		if (t)  return;
	}
}
int main()
{
	scanf("%d",&n);
	while (n--)
	{
		scanf("%d%lf%lf",&opt,&A,&B);A+=sum,B+=sum;
		if  (opt==0)    
			ins[++top].x=A,ins[top].y=B,rebuild();
		else    
		{
			if (!top)   
				{puts("No");continue;}
			C=sqr(A)+sqr(B);
			A*=2;B*=2;
			Query();
			puts(t?"No":"Yes");
			if (!t) sum++;
		}
	}
}
Problem4145

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<16;
const int INF = 0x3f3f3f3f;
int d[105],c[105][20];
int f[105][N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&d[i]);
		for(int j = 1;j<= m;j++)
			scanf("%d",&c[i][j]);
	}
	memset(f,0x3f,sizeof(f));
	f[0][0] = 0;
	for(int i = 1;i<= n;i++)
	{
		for(int sta = 0;sta<1<<m;sta++)
			f[i][sta] = f[i-1][sta]+d[i];
		for(int sta = 0;sta<1<<m;sta++)
		{
			if(f[i][sta]==INF)continue;
			for(int k = 0;k<m;k++)
			{
				if(sta&(1<<k))continue;
				f[i][sta|(1<<k)] = min(f[i][sta|(1<<k)],f[i][sta]+c[i][k+1]);
			}
		}
		for(int sta = 0;sta<1<<m;sta++)
			f[i][sta] = min(f[i-1][sta],f[i][sta]);
	}
	printf("%d\n",f[n][(1<<m)-1]);
	return 0;
}
Problem4147

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int gcd(int a,int b)
{
	if(!b)return a;
	else return gcd(b,a%b);
}
bool calc(int n,int p,int q)
{
	return n%p<q&&n%p%(p-q)==0;
}
int main()
{
	int cas;
	int p,q,n;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d%d",&p,&q,&n);
		int d = gcd(p,q);
		if(n%d){puts("R");continue;}
		p/=d,q/=d,n/=d;
		if(p==q)puts("E");
		else if(p>q)
		{
			if(n<p)puts("P");
			else puts(calc(n,p,q)?"E":"P");
		}else
		{
			if(n<p)
			{
				if(n+p<q)puts("E");
				else puts(calc(n+p,q,p)?"P":"E");
			}
			else puts("E");
		}
	}
}
Problem4173

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 998244353;
ll oula(ll x)
{
	ll ans = x;
	for(ll i = 2;i*i<= x;i++)
	{
		if(x%i==0)ans = ans/i*(i-1);
		while(x%i==0)x/=i;
	}
	if(x!=1)ans = ans/x*(x-1);
	return ans%mod;
}
int main()
{
	ll n,m;
	scanf("%lld%lld",&n,&m);
	printf("%lld\n",(n%mod)*(m%mod)%mod*oula(n)%mod*oula(m)%mod);
	return 0;
}
Problem4174

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int mod = 998244353;
typedef long long ll;
int mu[N],prime[N],cnt,sum[N];
bool v[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
		{
			prime[++cnt] =i;
			mu[i] = mod-1;
		}
		for(int j = 1;j<=cnt&&prime[j]*i<N;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]]=(mod-mu[i])%mod;
			else
			{
				mu[i*prime[j]]=0;
				break;
			}
		}
	}
}
ll getsum(ll n)
{
	return (n*(n+1)>>1)%mod;
}
int main()
{
	int n,m,x;
	scanf("%d%d%d",&n,&m,&x);
	quick_mu();
	ll ans = 0;
	ans=((getsum(n)*getsum(m)-n*getsum(m)-m*getsum(n))%mod+mod)%mod;
	if(n>m)swap(n,m);
	for(int i = 1;i<= n;i++)
	{
		ll tmp = i+x/i*i*2;
		for(int j = 1;j*i<=n;j++)
			(ans+=tmp*mu[j]%mod*(n/i/j)%mod*(m/i/j)%mod)%=mod;
	}
	ans = ans*((mod+1)>>1)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4176

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
const int mod = 1e9+7;
int n,S;
int mu[N],prime[N/10],cnt,sum2[N];
bool v[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<=S;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<=S;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])
				mu[prime[j]*i] = -mu[i];
			else {mu[prime[j]*i]=0;break;}
		}
	}
}
int Get_Sum(int n)
{
	int i,ans=0,last;
	for(i=1;i<=n;i=last+1)
	{
		last = n/(n/i);
		(ans+=(ll)(last-i+1)*(n/i)%mod)%=mod;
	}
	return ans;
}
int get_sum(int x)
{
	if(x<=S)return mu[x];
	else return sum2[n/x];
}
void init()
{
	quick_mu();
	for(int i = 2;i<=S;i++)
		mu[i]+=mu[i-1];
	int i,j,last;
	for(i=1;n/i>S;i++);
	for(j=i;j;j--)
	{
		int n = ::n/j;
		sum2[j] = 1;
		for(i=2;i<=n;i=last+1)
		{
			last = n/(n/i);
			(sum2[j]-=(ll)(last-i+1)*get_sum(n/i)%mod)%=mod;
		}
	}
}
int main()
{
	int i,last,ans =0;
	scanf("%d",&n);
	S = ceil(pow(n,0.75)-1e-7)+1e-7;
	init();
	for(i=1;i<=n;i=last+1)
	{
		last = n/(n/i);
		ll tmp = Get_Sum(n/i);
		(ans+=(get_sum(last)-get_sum(i-1))*tmp%mod*tmp%mod)%=mod;
	}
	printf("%d\n",(ans+mod)%mod);
	return 0;
}
Problem4180

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
const ll INF = 1ll<<62;
ll n;
char s[N];
struct Matrix
{
	ll d[4][4];
	Matrix()
	{
		memset(d,0,sizeof(d));
	}
	Matrix(bool flag)
	{
		memset(d,0,sizeof(d));
		for(int i = 0;i<4;i++)d[i][i]=1;
	}
	void operator *=(const Matrix &s)
	{
		Matrix res;
		for(int i = 0;i<4;i++)for(int j  =0;j<4;j++)
		{
			res.d[i][j] = INF;
			for(int k = 0;k<4;k++)
				res.d[i][j] = min(res.d[i][j],d[i][k]+s.d[k][j]);
		}
		*this = res;
	}
	friend Matrix quick_pow(Matrix s,ll d)
	{
		Matrix res(true);
		while(d)
		{
			if(d&1)res*=s;
			s*=s;
			d>>=1;
		}
		return res;
	}
};
struct SAM
{
	int trs[N][4],fa[N],len[N];
	int cnt,last;
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p,newp,q,newq;
		p = last,newp = ++cnt;
		last = newp,len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)fa[newp] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[newp] = q;
			else
			{
				newq = ++cnt;
				fa[newq] = fa[q];
				len[newq] = len[p]+1;
				memcpy(trs[newq],trs[q],sizeof(trs[q]));
				fa[newp] = fa[q] = newq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = newq;
			}
		}
	}
	ll mn[N][4];
	bool vis[N];
	void dfs(int x)
	{
		vis[x] = true;
		for(int i = 0;i<4;i++)
		{
			if(!vis[trs[x][i]])dfs(trs[x][i]);
			if(trs[x][i])mn[x][i] = INF;
			else mn[x][i]=1;
		}
		for(int i = 0;i<4;i++)if(trs[x][i])
			for(int j = 0;j<4;j++)
				mn[x][j] = min(mn[x][j],mn[trs[x][i]][j]+1);
	}	
}sam;
Matrix go;
bool check(ll x)
{
	Matrix ans = quick_pow(go,x);
	for(int i= 0;i<4;i++)
		for(int j = 0;j<4;j++)
			if(ans.d[i][j]+1<=n)return true;
	return false;
}
int main()
{
	scanf("%lld",&n);
	scanf("%s",s+1);
	sam.init();
	sam.vis[0] = true;
	for(int i = 1;s[i];i++)
		sam.insert(s[i]-'A');
	sam.dfs(1);
	for(int i = 0;i<4;i++)
		for(int j = 0;j<4;j++)
			go.d[i][j] = sam.mn[sam.trs[1][i]][j];
	ll l = 0,r = n+1,ans=0;
	while(l<=r)
	{
		ll mid = (l+r)>>1;
		if(check(mid))l=mid+1;
		else r = mid-1,ans = mid;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4195

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int fa[N<<1];
int idx[N<<1],cnt;
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
void init()
{
	for(int i = 1;i<= cnt;i++)fa[i]=i;
}
struct seg
{
	int x,y,o;
}a[N];
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(idx[mid]<=x)l=mid+1;
		else r = mid;
	}
	return l-1;
}
int main()
{
	int cas;
	int n;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d",&n);
		cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].o);
			idx[++cnt]=a[i].x,idx[++cnt]=a[i].y;
		}
		sort(idx+1,idx+cnt+1);
		int tmp = cnt;cnt = 0;
		for(int i = 1;i<= tmp;i++)
			if(i==1||idx[i]!=idx[i-1])
				idx[++cnt] = idx[i];
		init();
		for(int i = 1;i<= n;i++)
			if(a[i].o)uni(find(a[i].x),find(a[i].y));
		bool flag = true;
		for(int i = 1;i<= n&&flag;i++)
			if(a[i].o==0)
			{
				if(getfa(find(a[i].x))==getfa(find(a[i].y)))
					flag = false;
			}
		if(flag)puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem4196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,cnt;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int top[N],deep[N],fa[N],w[N],size[N],son[N],t[N];
int sum[N<<2],f[N<<2],n;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x]!=n)dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	t[x] = cnt;
}
void push_down(int p,int l,int r)
{
	int mid = (l+r)>>1;
	sum[p] = (r-l+1)*f[p];
	f[p<<1] = f[p];
	sum[p<<1] = f[p]*(mid-l+1);
	f[(p<<1)+1] = f[p];
	sum[(p<<1)+1] = f[p]*(r-mid);
	f[p] = -1;
}
void update(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){f[p] =c;sum[p] = (r-l+1)*f[p];return ;}
	if(f[p]!=-1)push_down(p,l,r);
	int mid = (l+r)>>1;
	if(a<= mid)
		update(p<<1,l,mid,a,b,c);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
int getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	if(f[p]!=-1)push_down(p,l,r);
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans((p<<1)+1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans((p<<1)+1,mid+1,r,a,b);
}
int t_ans;
void get_update(int x,int y,int c,int opt)
{
	while(top[x]!=top[y])
	{
		if(deep[x]<deep[y])swap(x,y);
		if(opt==1)update(1,1,n,w[top[x]],w[x],c);
		else t_ans+=getans(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)update(1,1,n,w[y],w[x],c);
	else t_ans+=getans(1,1,n,w[y],w[x]);
}
int main()
{
	memset(f,-1,sizeof(f));
	int x;
	scanf("%d",&n);
	for(int i = 0;i< n;i++)
		son[i] = n;
	for(int i = 1;i< n;i++)
		{scanf("%d",&x);add(x,i);}
	dfs1(0,1);
	dfs2(0,0);
	char j[20];
	int q,tmp1,tmp2;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d",j,&x);
		if(j[0]=='i')
		{
			t_ans = 0;
			get_update(0,x,0,0);
			tmp1 = t_ans;
			get_update(0,x,1,1);
			t_ans = 0;
			get_update(0,x,0,0);
			printf("%d\n",t_ans-tmp1);
		}else
		{
			tmp1= getans(1,1,n,w[x],t[x]);
			update(1,1,n,w[x],t[x],0);
			tmp2 = getans(1,1,n,w[x],t[x]);
			printf("%d\n",tmp1-tmp2);
		}
	}
	return 0;
}
Problem4197

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int S = 1<<8;
int prime[N],cnt;
bool vis[N];
void quick_prime()
{
	for(int i = 2;i<=500;i++)
	{
		if(!vis[i])
			prime[cnt++] = i;
		for(int j = 0;j<cnt&&i*prime[j]<=500;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
struct Num
{
	int l,p,i;
	bool operator <(const Num &s)const
	{
		return p<s.p;
	}
}num[N];
int f[S][S],dp[S][S][2];
void calc(int x)
{
	int tmp = x;
	for(int i = 0;i<8;i++)
		if(tmp%prime[i]==0)
		{
			num[x].l|=1<<i;
			while(tmp%prime[i]==0)tmp/=prime[i];
		}
	num[x].p = tmp;
}
int main()
{
	int n,mod;
	quick_prime();
	scanf("%d%d",&n,&mod);
	for(int i = 2;i<= n;i++)
		calc(i);
	sort(num+2,num+n+1);
	f[0][0] = 1;
	int end = (1<<8)-1,i,j,k;
	for(i = 2;i<= n;i++)
	{
		if(i==2||num[i].p==1||num[i-1].p!=num[i].p)
			for(j = end;j>=0;j--)
				for(k = end;k>=0;k--)
					dp[j][k][0]=dp[j][k][1]=f[j][k];
		for(j = end;j>=0;j--)
			for(k = end;k>=0;k--)
			{
				if((j&num[i].l)==0)
					(dp[j][k|num[i].l][1]+=dp[j][k][1])%=mod;
				if((k&num[i].l)==0)
					(dp[j|num[i].l][k][0]+=dp[j][k][0])%=mod;
			}
		if(i==n||num[i].p==1||num[i].p!=num[i+1].p)
			for(j = end;j>=0;j--)
				for(k = end;k>=0;k--)
				{
					f[j][k] = dp[j][k][0]+dp[j][k][1]-f[j][k];
					f[j][k] = (f[j][k]%mod+mod)%mod;
				}
	}
	int ans = 0;
	for(j = 0;j<=end;j++)
		for(k = 0;k<=end;k++)
			if((j&k)==0)(ans+=f[j][k])%=mod;
	printf("%d\n",ans);
	return 0;
}
Problem4198

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
struct Heap
{
	ll w;int l;
	Heap(){}
	Heap(ll _w,int _l):w(_w),l(_l)
	{}
	bool operator <(const Heap &s)const
	{
		if(w!=s.w)return s.w<w;
		else return s.l<l;
	}
};
priority_queue<Heap>heap;
int n,k,nn;
ll ans = 0;
int main()
{
	scanf("%d%d",&n,&k);
	nn = n;ll x;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&x);
		heap.push(Heap(x,1));
	}
	if((n-1)%(k-1))nn+=(k-1)-(n-1)%(k-1);
	for(int i = n+1;i<= nn;i++)
		heap.push(Heap(0,1));
	while(nn>1)
	{
		ll s1 = 0;int s2 = 0;
		for(int i = 1;i<= k;i++)
		{
			Heap x = heap.top();
			heap.pop();
			s1+=x.w;s2=max(s2,x.l);
		}
		ans+=s1,nn-=(k-1);
		heap.push(Heap(s1,s2+1));
	}
	printf("%lld\n%d\n",ans,heap.top().l-1);
	return 0;
}
Problem4199

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
typedef long long ll;
const int INF = 2e9;
char s[N];
int fa[N],mx[N],mn[N],cnt[N];
int sa[N],c[N],v[N],nv[N],q[N],h[N],rk[N];
ll ans,tot;
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i=0;i<lim;i++)c[i]=0;
	for(i=0;i<len;i++)c[v[i]=s[i]-'a']++;
	for(i=1;i<lim;i++)c[i]+=c[i-1];
	for(i=len-1;i>=0;i--)sa[--c[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)c[i]=0;
		for(i=0;i<len;i++)c[v[q[i]]]++;
		for(i=1;i<lim;i++)c[i]+=c[i-1];
		for(i=len-1;i>=0;i--)sa[--c[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rk[i])
		{
			int j = 0;
			if(i)j = max(0,h[rk[i-1]]-1);
			while(i+j<len&&sa[rk[i]-1]+j<len&&s[i+j]==s[sa[rk[i]-1]+j])j++;
			h[rk[i]]=j;
		}
}
int a[N];
void init(int len)
{
	for(int i = 0;i< len;i++)
		fa[i]=i,mx[i]=mn[i]=a[sa[i]],cnt[i]=1;
}
vector<int>Q[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(x>y)swap(x,y);
	ll tmp = max(1ll*mx[x]*mx[y],1ll*mn[x]*mn[y]);
	if(tmp>ans||!tot)ans = tmp;
	tot+=1ll*cnt[x]*cnt[y];
	fa[y] = x;
	mx[x] = max(mx[x],mx[y]),mn[x]=min(mn[x],mn[y]);
	cnt[x]+=cnt[y];
}
ll Ans[N][2];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s);
	for(int i = 0;i<n;i++)scanf("%d",&a[i]);
	build_sa(n,26);
	build_rank(n);
	build_height(n);
	init(n);
	for(int i = 1;i<=n;i++)
		Q[h[i]].push_back(i);
	for(int i = n-1;i>=0;i--)
	{
		for(int j = 0;j<Q[i].size();j++)
			uni(Q[i][j],Q[i][j]-1);
		Ans[i][0] = tot,Ans[i][1] = ans;
	}
	for(int i = 0;i<n;i++)
		printf("%lld %lld\n",Ans[i][0],Ans[i][1]);
	return 0;
}
Problem4199

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
typedef long long ll;
int sa[N],cnt[N],val[N],nv[N],q[N],h[N],rnk[N];
char s[N];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int lim,int len)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]-'a']++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;
		
		for(i =0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]]=q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		if(lim==len)return ;
		for(i = 0;i<len;i++)val[i] = nv[i];
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])
				j++;
			h[rnk[i]]=j;
		}
}
int fa[N],size[N],n;
ll mx[N],mn[N],a[N];
ll tot,ans;
ll Ans[N][2];
void init()
{
	for(int i = 0;i<n;i++)
		fa[i]=i,mx[i]=mn[i]=a[sa[i]],size[i]=1;
}
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(x>y)swap(x,y);
	ll tmp = max(mx[x]*mx[y],mn[x]*mn[y]);
	if(tmp>ans||!tot)ans = tmp;
	tot+=(ll)size[x]*size[y];
	fa[y] = x;
	mx[x] = max(mx[x],mx[y]),mn[x] =min(mn[x],mn[y]);
	size[x] = size[x]+size[y];
}
vector<int>Q[N];
int main()
{
	scanf("%d",&n);scanf("%s",s);
	for(int i = 0;i<n;i++)scanf("%lld",&a[i]);
	build_sa(26,n);
	build_rank(n);
	build_height(n);
	init();
	for(int i = 1;i<=n;i++)
		Q[h[i]].push_back(i);
	for(int i = n-1;i>= 0;i--)
	{
		for(int j = 0;j<Q[i].size();j++)
			uni(Q[i][j],Q[i][j]-1);
		Ans[i][0]=tot,Ans[i][1] = ans;
	}
	for(int i = 0;i<n;i++)
		printf("%lld %lld\n",Ans[i][0],Ans[i][1]);
	return 0;
}
Problem4200

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+10;
const int S = 5e4+3,T = 5e4+4,SS = 5e4+1,TT = 5e4+2;
const int M = 5e5+5;
const int INF = 0x3f3f3f3f;
struct P
{
	int x,y,id;
}p[N];
inline bool cmp1(const P &a,const P &b)
{return a.x+a.y==b.x+b.y?a.y<b.y:a.x+a.y<b.x+b.y;}
inline bool cmp2(const P &a,const P &b)
{return a.x-a.y==b.x-b.y?a.y<b.y:a.x-a.y<b.x-b.y;}
inline bool cmp3(const P &a,const P &b)
{return a.x==b.x?a.y<b.y:a.x<b.x;}
inline bool cmp4(const P &a,const P &b)
{return a.y==b.y?a.x<b.x:a.y<b.y;}
int s[N],t1[N],t2[N],t3[N],f[N],ff[N],l[N],r[N],lf[N],rf[N],a[N],an;
vector<int>v,t[N];
namespace Max_Flow
{
	queue<int>Q;
	struct E
	{int next,to,f;}e[M];
	int head[N],_head[N],tot,d[N];
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f=f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f=0;
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[s] = 0;Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f&&d[e[i].to]==-1)
				{
					d[e[i].to] = d[x]+1;
					Q.push(e[i].to);
				}
		}
		memcpy(_head,head,sizeof(head));
		return d[t]!=-1;
	}
	int get_mxf(int s,int t,int mx)
	{
		if(s==t)return mx;
		int last = mx;
		for(int &i = _head[s];i;i=e[i].next)
			if(e[i].f&&d[e[i].to]==d[s]+1)
			{
				int tof = get_mxf(e[i].to,t,min(last,e[i].f));
				if(tof)
				{
					e[i].f-=tof;e[i^1].f+=tof;
					if(!(last-=tof))return mx;
				}
			}
		d[s] = -1;
		return mx-last;
	}
	int dinic(int s,int t)
	{
		int ans = 0;
		while(bfs(s,t))
			ans+=get_mxf(s,t,INF);
		return ans;
	}
}
void update(int x,int y)
{
	if(ff[y]+1>f[x])f[x]=ff[y]+1,t[x].clear();
	if(ff[y]+1==f[x])t[x].push_back(y);
}
void getans(int x)
{
	a[++an] = x;
	int i,j,u=1;
	if(f[x]==ff[x])
	{
		u = 0;
		if(p[x].id)getans(t[x][0]);
	}
	for(i=l[x];u&&i<x;i++)if(f[i]+x-l[x]==ff[x])
	{
		u=0;
        for(j=x;--j>i;)a[++an]=j;
        for(j=l[x];j<=i;++j)a[++an]=j;
        if(p[i].id)getans(t[i][0]);
	}
	for(i=r[i];u&&i>x;--i)if(f[i]+r[x]-x==ff[x])
	{
        u=0;
        for(j=x;++j<i;)a[++an]=j;
        for(j=r[x];j>=i;--j)a[++an]=j;
        if(p[i].id)getans(t[i][0]);
	}
}
int d[N],u[N],c[N];
void Insert(int x,int y)
{
	Max_Flow::add(x,y,INF);
	c[x]++,c[y]--;
}
void dfs(int x)
{
    if(d[x])return;
    int i,j;d[x]=1;
    if(f[x]==ff[x]&&!u[x])
    	for(u[x]=1,i=0;i<t[x].size();++i)
    		Insert(t[x][i],x),dfs(t[x][i]);
    for(i=l[x];i<x;++i)
    	if(f[i]+x-l[x]==ff[x]&&!u[i])
    		for(u[i]=1,j=0;j<t[i].size();++j)
    			Insert(t[i][j],i),dfs(t[i][j]);
    for(i=r[x];i>x;--i)
    	if(f[i]+r[x]-x==ff[x]&&!u[i])
    		for(u[i]=1,j=0;j<t[i].size();++j)
    			Insert(t[i][j],i),dfs(t[i][j]);
}
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		p[i].id = i;
	}
	sort(p,p+n+1,cmp1);
	for(int i = 0;i<n;i++)if(p[i].x+p[i].y==p[i+1].x+p[i+1].y)t1[p[i].id]=p[i+1].id;
	sort(p,p+n+1,cmp2);
	for(int i = 0;i<n;i++)if(p[i].x-p[i].y==p[i+1].x-p[i+1].y)t2[p[i].id]=p[i+1].id;
	sort(p,p+n+1,cmp3);
	for(int i = 0;i<n;i++)if(p[i].x==p[i+1].x)t3[p[i].id] = p[i+1].id;
	sort(p,p+n+1,cmp4);for(int i = 0;i<= n;i++)s[p[i].id] = i;
	memset(f,0xef,sizeof(f));
	f[s[0]] = 0;
	for(int i = 0;i<= n;i=r[i]+1)
	{
		for(l[i]=r[i]=i;r[i]<n&&p[r[i]].y==p[r[i]+1].y;++r[i]);
		for(int j = l[i];++j<=r[i];)
			l[j]=l[i],r[j]=r[i];
		lf[l[i]] = -INF;
		for(int j = l[i];++j<=r[i];)lf[j] = max(lf[j-1],f[j-1]);
		rf[r[i]] = -INF;
		for(int j = r[i];--j>=l[i];)rf[j] = max(rf[j+1],f[j+1]);
		for(int j = l[i];j<=r[i];j++)
		{
			ff[j] = max(f[j],max(lf[j]+j-l[i],rf[j]+r[i]-j));
			if(t1[p[j].id])update(s[t1[p[j].id]],j);
			if(t2[p[j].id])update(s[t2[p[j].id]],j);
			if(t3[p[j].id])update(s[t3[p[j].id]],j);
			if(ff[j]>ans)ans=ff[j],v.clear();
			if(ff[j]==ans)v.push_back(j);
		}
	}
	Max_Flow::tot = 1;
	printf("%d\n",ans);
	getans(v[0]);
	for(int i = an;--i;)
		printf("%d ",p[a[i]].id);
	printf("\n");
	for(int i = 0;i<v.size();i++)dfs(v[i]);
	for(int i = 0;i<= n;i++)
	{
		if(c[i]<0)Max_Flow::add(S,i,-c[i]);
		if(c[i]>0)Max_Flow::add(i,T,c[i]);
		Max_Flow::add(SS,i,INF),Max_Flow::add(i,TT,INF);
	}
	Max_Flow::dinic(S,T);
	Max_Flow::add(TT,SS,INF);
	printf("%d\n",Max_Flow::dinic(S,T));
	return 0;
}
Problem4205

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 7e4+5;
const int M = 4e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],_head[N],tot = 1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	for(int i = s;i<= t;i++)d[i]=-1;
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	if(d[s]==-1)return false;
	memcpy(_head,head,sizeof(head));
	return true;
}
int get_mxf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last=mf;
	for(int i = _head[s];i;i=e[i].next)
	{
		_head[s] = i;
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	}
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
const int P = 205;
bool vis[P];
int prime[P],cnt;
vector<int>fac[P];
int id[50][50];
void quick_prime()
{
	for(int i = 2;i<=200;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<=200;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = prime[i];j<=200;j+=prime[i])
			fac[j].push_back(i);
	}
}
struct Card
{int a,b,c;}c0[30005],c1[30005];
int S,T;
int n1,n2;
void build(int no,int tp)
{
	int a,b,c;
	if(tp)a = c1[no].a,b = c1[no].b,c = c1[no].c;
	else a = c0[no].a,b = c0[no].b,c = c0[no].c;
	for(int i = 0;i<fac[a].size();i++)
		for(int j = 0;j<fac[b].size();j++)
			if(tp)add(id[fac[a][i]][fac[b][j]]+n1+n2,n1+no,1);
			else add(no,id[fac[a][i]][fac[b][j]]+n1+n2,1);
	for(int i = 0;i<fac[a].size();i++)
		for(int j = 0;j<fac[c].size();j++)
			if(tp)add(id[fac[a][i]][fac[c][j]]+cnt*cnt+n1+n2,n1+no,1);
			else add(no,id[fac[a][i]][fac[c][j]]+cnt*cnt+n1+n2,1);
	for(int i = 0;i<fac[b].size();i++)
		for(int j = 0;j<fac[c].size();j++)
			if(tp)add(id[fac[b][i]][fac[c][j]]+cnt*cnt*2+n1+n2,n1+no,1);
			else add(no,id[fac[b][i]][fac[c][j]]+cnt*cnt*2+n1+n2,1);
}
int main()
{
	scanf("%d%d",&n1,&n2);
	quick_prime();
	int Id = 0;
	for(int i = 1;i<= cnt;i++)
		for(int j = 1;j<= cnt;j++)
			id[i][j] = ++Id;
	S = 0,T = n1+n2+3*Id+1;
	for(int i = 1;i<= n1;i++)
		scanf("%d%d%d",&c0[i].a,&c0[i].b,&c0[i].c);
	for(int i = 1;i<= n2;i++)
		scanf("%d%d%d",&c1[i].a,&c1[i].b,&c1[i].c);
	for(int i = 1;i<= n1;i++)
		add(S,i,1),build(i,0);
	for(int i = 1;i<= n2;i++)
		add(i+n1,T,1),build(i,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem4206

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const double PI = acos(-1.0);
const double INF = 1e18;
double R,x,y,len,ang1,ang2;
double stack[N];
int top;
struct Point
{
	double x,y;
	bool flag;
	bool operator <(const Point &s)const
	{
		if(flag==s.flag)
		{
			if(x==s.x)return y<s.y;
			return x<s.x;
		}
		return flag<s.flag;
	}
}p[N];
double getdis(double x,double y)
{
	return sqrt(x*x+y*y);
}
int Find(double x)
{
	int l = 0,r = top,ans = 0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(stack[mid]>=x)ans = mid,r = mid-1;
		else l = mid+1;
	}
	return ans;
}
int main()
{
	int n;
	scanf("%d%lf",&n,&R);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf",&p[i].x,&p[i].y);
		if(getdis(p[i].x,p[i].y)<R)
		{
			p[i].flag = true;
			continue;
		}
		ang1 = atan2(p[i].y,p[i].x),ang2 = acos(R/getdis(p[i].x,p[i].y));
		p[i].x = ang1-ang2;p[i].y = ang1+ang2;
		if(p[i].y>PI)p[i].y-=PI*2,swap(p[i].x,p[i].y);
		if(p[i].x<-PI)p[i].x+=PI*2,swap(p[i].x,p[i].y);
	}
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i++)
		if(p[i].flag)
			{n = i-1;break;}
	stack[0] = -INF;
	int ans = 0;
	for(int i = 1;i<= n;i++)
	{
		stack[top=1]=p[i].y;
		for(int j = i+1;j<= n;j++)
		{
			if(p[j].x>p[i].y)break;
			if(p[j].y>stack[top])
				stack[++top] = p[j].y;
			else
			{
				int tmp = Find(p[j].y);
				if(tmp!=1)stack[tmp]=p[j].y;
			}
		}
		ans = max(ans,top);
	}
	printf("%d\n",ans);
	return 0;
}
Problem4212

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Lth = 2000005;
const int N = 2005;
char s[Lth],s1[Lth],s2[Lth];
struct STR{int bg,ed;}str[N];
int trie[Lth][26],Max[Lth],Min[Lth],root[Lth],tot;
struct Trie
{
	int ch[Lth][26],sum[Lth],cnt;
	int insert(int id,int pre)
	{
		int tmp,y;
		tmp = y = ++cnt;
		for(int i = str[id].ed;i>=str[id].bg;i--)
		{
			for(int j = 0;j<26;j++)ch[y][j]=ch[pre][j];
			sum[y] = sum[pre]+1;
			int p = s[i]-'a';
			pre = ch[pre][p];
			ch[y][p] = ++cnt;
			y = ch[y][p];
		}
		sum[y] = sum[pre]+1;
		return tmp;
	}
	int getans(int L,int R,int lth)
	{
		for(int i = lth;i>=1;i--)
		{
			//fprintf(stderr, "%d %d\n",L,R);
			L = ch[L][s2[i]-'a'],R = ch[R][s2[i]-'a'];
		}
		return sum[R]-sum[L];
	}
}tr;
bool cmp(const STR &a,const STR &b)
{
	int p1 = a.bg,p2 = b.bg;
	while(p1<=a.ed&&p2<=b.ed)
	{
		if(s[p1]<s[p2])return true;
		else if(s[p1]>s[p2])return false;
		p1++,p2++;
	}
	if (p1<=a.ed) return 0;
	else if (p2<=b.ed) return 1;
	else return 0;
}
char tmp[Lth];
int main()
{
	//freopen("x.in","r",stdin);
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",tmp+1);
		str[i].bg = str[i-1].ed+1;
		str[i].ed = str[i].bg+strlen(tmp+1)-1;
		for(int j = str[i].bg;j<=str[i].ed;j++)s[j]=tmp[j-str[i].bg+1];
	}
	sort(str+1,str+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		int now = 0;
		for(int j = str[i].bg;j<= str[i].ed;j++)
		{
			int p = s[j]-'a';
			if(!trie[now][p])trie[now][p] = ++tot;
			now = trie[now][p];
			if(Min[now]==0)Min[now] = i;
			Max[now] = max(Max[now],i);
		}
	}
	for(int i = 1;i<= n;i++)
		root[i] = tr.insert(i,root[i-1]);
	int ans = 0;
	int m;
	scanf("%d",&m);
	while(m--)
	{
		scanf("%s",s1+1);int lth1 = strlen(s1+1);
		scanf("%s",s2+1);int lth2 = strlen(s2+1);
		for(int i = 1;i<= lth1;i++)s1[i] = (s1[i]-'a'+ans)%26+'a';
		for(int i = 1;i<= lth2;i++)s2[i] = (s2[i]-'a'+ans)%26+'a';
		int now = 0,l = -1,r = -1;
		for(int i = 1;i<= lth1;i++)
		{
			int p = s1[i]-'a';
			if(!trie[now][p])break;
			now = trie[now][p];
			if(i==lth1){l=Min[now],r=Max[now];}
		}
		if(l==-1&&r==-1){ans = 0;printf("%d\n",ans);continue;}
		ans = tr.getans(root[l-1],root[r],lth2);
		printf("%d\n",ans);
	}
	return 0;
}
Problem4227

#include <stdio.h>
#include <queue>
#include <vector>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3e5+5;
const int M = 8e5+5;
struct E{int next,to,val;};
struct Edge{int x,y,f;}a[M];
ll dis[N];
bool vis[N];
queue<int>Q;
E e[M];
int head[N],tot,deg[N],n,m,id[N],cnt;
void add(int x,int y,int f=0)
{e[++tot].to=y;e[tot].next=head[x];e[tot].val=f;head[x]=tot;deg[y]++;}
void spfa(int s)
{
	memset(dis,0x3f,sizeof(dis));
	dis[s] = 0;vis[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].val)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(!vis[e[i].to])
				{
					vis[e[i].to]=true;
					Q.push(e[i].to);
				}
			}
	}
}
int dep[N],fa[N][18],size[N],sum[M];
void rebuild()
{
	memset(head,0,sizeof(head));
	memset(deg,0,sizeof(deg));
	tot = 0;cnt = n;
	for(int i = 1;i<= n;i++)size[i]=dis[i]<dis[0];
	for(int i = 1;i<= m;i++)
	{
		if(dis[a[i].x]+a[i].f==dis[a[i].y])
			id[++cnt]=i,add(a[i].x,cnt),add(cnt,a[i].y);
		if(dis[a[i].y]+a[i].f==dis[a[i].x])
			id[++cnt]=i,add(a[i].y,cnt),add(cnt,a[i].x);
	}
	for(int i = 1;i<= cnt;i++)
		if(!deg[i])
			add(cnt+1,i);
	cnt++;
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
vector<int>E[N];
void dfs(int x)
{
	for(int i = 0;i<E[x].size();i++)
	{
		dfs(E[x][i]);
		size[x]+=size[E[x][i]];
	}
	sum[id[x]]=size[x];
}
ll ans[N];
int main()
{
	int s;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].f);
		add(a[i].x,a[i].y,a[i].f),add(a[i].y,a[i].x,a[i].f);
	}
	scanf("%d",&s);
	spfa(s);
	rebuild();
	Q.push(cnt);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		if(fa[x][0])E[fa[x][0]].push_back(x);
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<18;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
		for(int i = head[x];i;i=e[i].next)
		{
			if(!fa[e[i].to][0])fa[e[i].to][0]=x;
			else fa[e[i].to][0]=getlca(fa[e[i].to][0],x);
			if(!--deg[e[i].to])Q.push(e[i].to);
		}	
	}
	dfs(cnt);
	for(int i = 1;i<= m;i++)
		ans[a[i].x]+=sum[i],ans[a[i].y]+=sum[i];
	for(int i = 1;i<= n;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem4237

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 2e9;
struct P
{
	int x,y;
}a[N],q1[N],q2[N];
bool cmpy(const P &a,const P &b)
{
	return a.y>b.y;
}
bool cmpx(const P &a,const P &b)
{
	return a.x<b.x;
}
long long ans;
int find(int x,int lim)
{
	int l = 1,r = lim;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(q1[mid].y<=x)r = mid-1;
		else l = mid+1;
	}
	return r;
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)return ;
	CDQ(l,mid);
	sort(a+l,a+mid+1,cmpy);
	sort(a+mid+1,a+r+1,cmpy);
	int top1 = 0,top2 = 0,p = mid+1;
	q1[0].y = q2[0].y = INF;
	int ll,rr;
	for(int i = l;i<=mid;i++)
	{
		while(p<=r&&a[p].y>a[i].y)
		{
			while(top1&&a[p].x<q1[top1].x)
				top1--;
			q1[++top1] = a[p];
			p++;
		}
		while(top2&&a[i].x>q2[top2].x)
			top2--;
		q2[++top2] = a[i];
		ll = find(q2[top2-1].y,top1)+1;
		rr = find(q2[top2].y,top1);
		if(ll<=rr)
			ans+=rr-ll+1;
	}
	sort(a+l,a+mid+1,cmpx);
	sort(a+mid+1,a+r+1,cmpx);
	CDQ(mid+1,r);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<= n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmpx);
	CDQ(1,n);
	printf("%lld\n",ans);
	return 0;
}
Problem4238

#include<stdio.h>
#include<string.h>
#include<algorithm>
#define N 110000
#define M 210000
using namespace std;
int next[M<<1],to[M<<1],head[N],tot=1;
int deep[N],fa[N],good[N],bad[N],gc,bc;
bool vis[N];
void add(int x,int y)
{
  to[++tot]=y;
  next[tot]=head[x];
  head[x]=tot;
}
void dfs(int x,int pre)
{
  deep[x]=deep[fa[x]]+1,vis[x]=1;
  int i;
  for(i=head[x];i;i=next[i])
  {
    if((i^1)==pre)  continue;
    if(!vis[to[i]])
    {
      fa[to[i]]=x;
      dfs(to[i],i);
      good[x]+=good[to[i]];
      bad[x]+=bad[to[i]];
    }
    else
    {
      if(deep[to[i]]>deep[x]) continue;
      if(deep[x]-deep[to[i]]&1)
        good[x]++,good[to[i]]--,gc++;
      else
        bad[x]++,bad[to[i]]--,bc++;
    }
  }
}
int main()
{
  int n,m,i,j,k,x,y,ans;
  scanf("%d%d",&n,&m);
  for(i=1;i<=m;i++)
  {
    scanf("%d%d",&x,&y);
    add(x,y),add(y,x);
  }
  for(i=1;i<=n;i++)
  {
    if(!vis[i])
      dfs(i,0);
  }
  for(i=1,ans=0;i<=n;i++)
  {
    if(fa[i]&&bad[i]==bc&&!good[i])
      ans++;
  }
  if(bc==1)
    ans++;
  printf("%d\n",ans);
  return 0;
}
Problem4243

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 2e5+5;
struct E
{int next,to;}e[M<<1];
int head1[N],head2[N],tot;
void add1(int x,int y){e[++tot].to=y;e[tot].next=head1[x];head1[x]=tot;}
void add2(int x,int y){e[++tot].to=y;e[tot].next=head2[x];head2[x]=tot;}
int fa[N],size[N],outd[N];
bool bo[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(size[x]<size[y])swap(x,y);
	fa[y] = x;size[x]+=size[y];
}
queue<int>Q;
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add1(x,y),add2(y,x),outd[x]++;
	}
	for(int i = 1;i<= n;i++)fa[i]=i,size[i]=1;
	for(int i = 1;i<= n;i++)
	{
		for(int id = head1[i];id;id=e[id].next)bo[e[id].to]=true;
		for(int id = head2[i];id;id=e[id].next)
			if(bo[e[id].to])merge(i,e[id].to);
		for(int id = head1[i];id;id=e[id].next)bo[e[id].to]=false;
	}
	for(int i = 1;i<= n;i++)
	{
		int y = 0;
		for(int id = head1[i];id;id=e[id].next)
			if(y)merge(y,e[id].to);
			else y = e[id].to;
	}
	memset(bo,true,sizeof(bo));
	for(int i = 1;i<= n;i++)
		if(size[getfa(i)]>1)Q.push(i),bo[i]=false;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head1[x];i;i=e[i].next)
		{
			merge(x,e[i].to);
			if(bo[e[i].to]){bo[e[i].to]=false;Q.push(e[i].to);}
		}
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
		if(getfa(i)==i)
		{
			if(size[i]>1)ans+=(long long)size[i]*(size[i]-1);
			else ans+=outd[i];
		}
	printf("%lld\n",ans);
	return 0;
}
Problem4246

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define fir first
#define sec second
typedef long long ll;
const double eps = 1e-10;
const int N = 3005;
const double PI = 3.1415926535897323;
int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	if(x>0)return 1;else return -1;
}
struct Point
{
	int x,y;
	Point(int _x=0,int _y=0):x(_x),y(_y){}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double arctan2(const Point &p)
	{
		double ang = atan2(p.y,p.x);
		if(ang<=0)return ang+PI;
		else return ang;
	}
}O;
pair<Point,int>point[N],stack[N];
int top;
ll ans;
void calc(int c)
{
	static pair<double,int>b[N];
	bool v[N];
	static pair<Point,int>_stack[N];
	int cnt[2][3]={};
	for(int i = 1;i<= top;i++)
		b[i] = make_pair(arctan2(stack[i].fir-O),i);
	sort(b+1,b+top+1);
	for(int i = 1;i<= top;i++)
		_stack[i]=stack[b[i].sec];
	memcpy(stack+1,_stack+1,sizeof(stack[0])*top);
	for(int i = 1;i<= top;i++)
	{
		if(stack[i].fir.y<O.y||stack[i].fir.y==O.y&&stack[i].fir.x>O.x)
			cnt[v[i]=false][stack[i].sec]++;
		else 
			cnt[v[i]=true][stack[i].sec]++;
	}
	int cnt0,cnt1;
	for(int i = 1;i<= top;i++)
	{
		cnt[v[i]][stack[i].sec]--;
		cnt0 = (c==0?1:cnt[0][0])*(c==1?1:cnt[0][1])*(c==2?1:cnt[0][2]);
		int C = stack[i].sec;
		cnt1 = (C==0?1:cnt[1][0])*(C==1?1:cnt[1][1])*(C==2?1:cnt[1][2]);
		//cnt0/=cnt[0][c],cnt1/=cnt[1][stack[i].sec];
		ans+=(ll)cnt0*cnt1;
		cnt0 = (c==0?1:cnt[1][0])*(c==1?1:cnt[1][1])*(c==2?1:cnt[1][2]);
		cnt1 = (C==0?1:cnt[0][0])*(C==1?1:cnt[0][1])*(C==2?1:cnt[0][2]);
		//cnt0/=cnt[1][c],cnt1/=cnt[0][stack[i].sec];
		ans+=(ll)cnt0*cnt1;
		cnt[v[i]^1][stack[i].sec]++;
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&point[i].fir.x,&point[i].fir.y,&point[i].sec);
	for(int i = 1;i<= n;i++)
	{
		top = 0;
		for(int j = 1;j<= n;j++)
			if(i!=j)
				stack[++top]=point[j];
		O = point[i].fir;
		calc(point[i].sec);
	}
	printf("%lld\n",ans>>2);
	return 0;
}
Problem4260

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e5+5;
const int M = 35*N;
struct Trie
{
	int ch[M][2],sum[M];
	int cnt;
	int insert(int x,int num)
	{
		int tmp,y;
		tmp=y=++cnt;
		for(int i = 30;i>=0;i--)
		{
			int t = num&(1<<i);t = t>>i;
			ch[y][0]=ch[x][0],ch[y][1]=ch[x][1];
			x = ch[x][t];
			y = ch[y][t]=++cnt;
			sum[y] = sum[x]+1;
		}
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 30;i>= 0;i--)
		{
			int t = val&(1<<i);t=t>>i;
			if(sum[ch[r][t^1]]-sum[ch[l][t^1]]>0)
				l=ch[l][t^1],r=ch[r][t^1],ans+=(1<<i);
			else l = ch[l][t],r=ch[r][t];
		}
		return ans;
	} 
}trie;
int z[N],y[N],a[N],root[N];
int main()
{
	int n;
	scanf("%d",&n);
	n++;
	a[1] = 0;
	for(int i = 2;i<= n;i++)
	{
		scanf("%d",&a[i]);
		a[i] = a[i-1]^a[i];
	}
	for(int i = 1;i<= n;i++)
		root[i] = trie.insert(root[i-1],a[i]);
	for(int i = 2;i<=n;i++)
	{
		z[i] = trie.getans(root[0],root[i],a[i]);
		y[i] = trie.getans(root[i-1],root[n],a[i]);
	}
	for(int i = 1;i<= n;i++)z[i] = max(z[i],z[i-1]);
	for(int i = n;i>= 1;i--)y[i] = max(y[i],y[i+1]);
	int ans = 0;
	for(int i = 2;i<=n;i++)
		ans = max(ans,z[i]+y[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4276

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<iostream>
#define maxn 30010
#define maxm 200010
#define inf 1000000000

using namespace std;

struct yts
{
	int l,r,num;
}a[20010];

int head[maxn],to[maxm],c[maxm],len[maxm],next[maxm],p[maxm],fr[maxn],dis[maxn],q[maxn];
bool vis[maxn];
int n,m,s,t,num,ans,cnt;

void addedge(int x,int y,int z,int w)
{
	num++;to[num]=y;c[num]=z;len[num]=w;p[num]=x;next[num]=head[x];head[x]=num;
	num++;to[num]=x;c[num]=0;len[num]=-w;p[num]=y;next[num]=head[y];head[y]=num;
}

void build(int i,int l,int r)
{
	a[i].l=l;a[i].r=r;a[i].num=++cnt;
	if (l==r)
	{
		addedge(a[i].num,t,1,0);
		return;
	}
	int mid=(l+r)/2;
	build(i*2,l,mid);build(i*2+1,mid+1,r);
	addedge(a[i].num,a[i*2].num,inf,0);
	addedge(a[i].num,a[i*2+1].num,inf,0);
}

void query(int i,int l,int r,int x)
{
	if (l<=a[i].l && a[i].r<=r)
	{
		addedge(x,a[i].num,1,0);
		return;
	}
	int mid=(a[i].l+a[i].r)/2;
	if (l<=mid) query(i*2,l,r,x);
	if (mid<r) query(i*2+1,l,r,x);
} 

bool spfa()
{
	for (int i=s;i<=t;i++) dis[i]=-inf;
	int l=0,r=1;
	q[1]=s;dis[s]=0;vis[s]=1;
	while (l!=r)
	{
		l++;if (l==maxn) l=0;
		int x=q[l];
		for (int p=head[x];p;p=next[p])
		  if (c[p] && dis[x]+len[p]>dis[to[p]])
		  {
		  	dis[to[p]]=dis[x]+len[p];
		  	fr[to[p]]=p;
		  	if (!vis[to[p]])
		  	{
		  		r++;if (r==maxn) r=0;
		  		q[r]=to[p];vis[to[p]]=1;
		  	}
		  }
		vis[x]=0;
	}
	if (dis[t]==-inf) return 0; else return 1;
}

void mcf()
{
	int x=inf;
	for (int i=fr[t];i;i=fr[p[i]]) x=min(x,c[i]);
	for (int i=fr[t];i;i=fr[p[i]]) ans+=x*len[i],c[i]-=x,c[i^1]+=x;
}

void costflow()
{
	while (spfa()) mcf();
}

int main()
{
	scanf("%d",&n);
	num=1;s=0,t=30000;
	build(1,1,5000);
	for (int i=1;i<=n;i++)
	{
		int l,r,x;
		scanf("%d%d%d",&l,&r,&x);
		r--;
		addedge(s,++cnt,1,x);
		query(1,l,r,cnt);
	}
	costflow();
	printf("%d\n",ans);
	return 0;
}
Problem4291

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int a[N];
int main()
{
	int n;
	ll ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),ans+=a[i];
	sort(a+1,a+n+1);
	if(n==1)
	{
		if(a[1]%2==1)printf("NIESTETY\n");
		else printf("%d\n",a[1]);
	}
	else
	{
		if(ans%2==0)printf("%lld\n",ans);
		else
		{
			for(int i = 1;i<= n;i++)
				if(a[i]%2==1)
					{ans-=a[i];break;}
			printf("%lld\n",ans);
		}
	}
	return 0;
}
Problem4292

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
bool check(ll ans,int num)
{
	int tmp = 0;
	while(ans)
	{
		int k = ans%10;
		ans/=10;
		tmp +=k*k;
	}
	return tmp==num;
}
int main()
{
	ll k,a,b,ans=0;
	scanf("%lld%lld%lld",&k,&a,&b);
	for(int i = max(a/k-2,0ll);i<= min(b/k+2,1458ll);i++)
		if(check(k*i,i)&&k*i<=b&&k*i>=a)
			ans++;
	printf("%lld\n",ans);
	return 0;
}
Problem4293

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
struct Seg
{
	ll sum,v,lazy,del;
	Seg(){lazy = -1;}
}t[N<<2];
ll a[N],sum[N];
inline int id(int l,int r){return (l+r)|(l!=r);}
void add_day(int l,int r,ll d)
{
	t[id(l,r)].v += d*a[r];
	t[id(l,r)].sum += (sum[r]-sum[l-1])*d;
	t[id(l,r)].del+=d;
}
void push_down(int l,int r)
{
	int mid = (l+r)>>1;
	int p = id(l,r);
	if(t[p].lazy!=-1)
	{
		int lf = id(l,mid),rt = id(mid+1,r);
		t[lf].lazy=t[rt].lazy=t[p].lazy;
		t[lf].v=t[rt].v=t[p].lazy;
		t[lf].sum=(ll)(mid-l+1)*t[p].lazy,t[rt].sum=(ll)(r-mid)*t[p].lazy;
		t[lf].del=t[rt].del=0;
		t[p].lazy=-1;
	}
	if(t[p].del)
	{
		add_day(l,mid,t[p].del);
		add_day(mid+1,r,t[p].del);
		t[p].del=0;
	}
}
void push_up(int l,int r)
{
	int mid = (l+r)>>1;
	t[id(l,r)].sum= t[id(l,mid)].sum+t[id(mid+1,r)].sum;
	t[id(l,r)].v = t[id(mid+1,r)].v;
}
int L;
int Find(int l,int r,ll x)
{
	if(l==r)return l;
	int mid = (l+r)>>1;
	push_down(l,r);
	if(t[id(l,mid)].v>=x)return Find(l,mid,x);
	else return Find(mid+1,r,x);
}
ll Update(int l, int r,ll b) 
{
    if(r<L) return 0;
    int mid = (l+r)>>1,p = id(l,r); 
	ll ans = 0;
    if(L<=l) 
	{ 
		ans = t[p].sum; 
		t[p].del = 0; 
		t[p].sum = (ll)(r-l+1)*b; 
		t[p].v = b; 
		t[p].lazy = b; 
		return ans; 
	}
	push_down(l,r);
	ans = Update(l,mid,b)+Update(mid+1,r,b);
    push_up(l,r);
    return ans;
}
int main()
{
	int n,m;
	ll last = 0,d,b;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	for(int i = 1;i<= n;i++)sum[i] = sum[i-1]+a[i];
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld",&d,&b);
		ll dt = d-last;last = d;
		add_day(1,n,dt);
		if(t[id(1,n)].v<b){printf("0\n");continue;}
		L = Find(1,n,b);
		printf("%lld\n",Update(1,n,b)-b*(n-L+1));
	}
	return 0;
}
Problem4294

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll base = 6000000000000000000ull;
const int N = 20;
ll quick_plus(ll x,ll y,ll mod)
{
	ll ans = 0;
	while(y)
	{
		if(y&1)(ans+=x)%=mod;
		x = (x+x)%mod;
		y>>=1;
	}
	return ans;
}
void getfib(ll n,ll &x,ll &y,ll mod)
{
	if(!n){x=0,y=1;return ;}
	else if(n==1){x=y=1;return ;}
	if(n&1){getfib(n-1,y,x,mod);y=(x+y)%mod;return;}
	ll a,b;
	getfib(n>>1,a,b,mod);
	x = (quick_plus(a,b,mod)+quick_plus(a,b>a?b-a:b-a+mod,mod))%mod;
	y = (quick_plus(a,a,mod)+quick_plus(b,b,mod))%mod;
}
ll Pow[N],b[N];
char s[N];
bool flag;
ll ans;
void dfs(int n,ll now,ll mod)
{
	if(flag)return ;
	ll x,y;
	getfib(now,x,y,Pow[n]);
	if(x!=b[n])return ;
	if(n==1){flag = true;ans = base+now;return ;}
	for(int i = 0;i<10;i++)
		dfs(n-1,(now+mod*i)%(mod*10),mod*10);
}
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	for(int i = n;i;i--)
	{
		if(i==n)Pow[i]=1;
		else Pow[i]=Pow[i+1]*10;
		b[i]=b[i+1]+Pow[i]*(s[i]-'0');
	}
	for(int i = 1;i<= n;i++)Pow[i]*=10;
	for(int i = 0;i<60;i++)
		dfs(n,i,60);
	if(flag)printf("%llu\n",ans);
	else printf("NIE\n");
	return 0;
}
Problem4295

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define ll long long
#define inf 2000000000000000000ll
#define eps 1e-10
#define md
#define N 5000010
using namespace std;
const int D=2000000;
struct QQ { int dt,id;} q[N];
int a[N],b[N],r[N],sum[N],mn[N],T[N];
char st[N];
bool vis[N];
ll lun[N],ed[N],win[N],last[N];
int main()
{
	int n,m;
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&a[i]);
	scanf("%d",&m); scanf("%s",st);
	for (int i=0;i<m;i++) b[i]=st[i]=='W'?1:-1;
	for (int i=0;i<m;i++)
		if (!vis[i])
		{
		int x=i,tot=0;
		while (!vis[x])
		{
			vis[x]=1; r[++tot]=x; sum[tot]=sum[tot-1]+b[x];
			x=(x+n)%m;
		}
		for (int j=1;j<=tot;j++)
		{
			r[j+tot]=r[tot];
			sum[j+tot]=sum[j+tot-1]+b[r[j]];
		}
		int h=1,w=0;
		for (int j=1;j<=tot;j++)
		{
			while (h<=w&&q[w].dt>=sum[j]) w--;
			q[++w].id=j; q[w].dt=sum[j];
		}
		for (int j=1;j<=tot;j++)
		{
			while (h<=w&&q[h].id<j) h++;
			mn[j]=-(q[h].dt-sum[j-1]);
			win[j]=sum[j+tot-1]-sum[j-1];
			while (h<=w&&q[w].dt>=sum[j+tot]) w--;
			q[++w].id=j+tot; q[w].dt=sum[j+tot];
		}
		for (int j=D-(tot<<1);j<=D+(tot<<1);j++) last[j]=inf;
		for (int j=(tot<<1);j>tot;j--)
			last[sum[j]+D]=j;
		for (int j=tot;j;j--)
		{
			x=r[j]; T[x]=tot;
			last[sum[j]+D]=j;
			while (x<n)
			{
				if (win[j]>=0&&a[x]>mn[j]) lun[x]=inf;
				else
				{
					if (a[x]<=mn[j]) lun[x]=0;
					else lun[x]=(a[x]-mn[j]-1)/(-win[j])+1;
					ed[x]=a[x]+lun[x]*win[j];
					ed[x]=last[-ed[x]+sum[j-1]+D]-(j-1);
				}
				x+=m;
			}
		}
	}
	ll ans=inf;
	for (int i=0;i<n;i++)
	{
		if (lun[i]==inf) continue;
		ans=min(ans,(lun[i]*T[i]+ed[i]-1)*n+i+1);
	}
	if (ans==inf) printf("-1\n");
		else printf("%lld\n",ans);
	return 0;
}
Problem4296

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int fa[N],size[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,d[N];
int n,m,D;
bool v[N];
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;d[x]++;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;d[y]++;
}
queue<int>Q;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
	size[y]=size[x]+size[y];
	size[x] = 0;
}
int main()
{
	int x,y;
	scanf("%d%d%d",&n,&m,&D);
	for(int i = 1;i<= n;i++)size[fa[i]=i]=1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]<D)
			Q.push(i),v[i]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(!v[e[i].to])
			{
				d[e[i].to]--;
				if(d[e[i].to]<D)Q.push(e[i].to),v[e[i].to]=true;
			}
	}
	for(int i = 1;i<= n;i++)
		if(!v[i])
			for(int j = head[i];j;j=e[j].next)
				if(!v[e[j].to])
					uni(i,e[j].to);
	int maxi = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i]&&getfa(i)==i)
			if(size[i]>size[maxi])
				maxi = i;
	if(maxi==0)printf("NIE\n");
	else
	{
		printf("%d\n",size[maxi]);
		for(int i = 1;i<= n;i++)
			if(!v[i]&&getfa(i)==maxi)
				printf("%d ",i);
	}
	return 0;
}
Problem4297

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
int l[N],r[N],del[N],a[N<<1],c,n,m;
ll s,now,ans,tmp;
struct E
{int next,to;};
struct Gragh
{
	E e[N<<1];
	int head[N],tot,d[N],f[N];
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
		d[y]++;
		f[y] = x;
	}
}g,G;
void dfs(int x)
{
	if(!G.head[x])return ;
	for(int i = G.head[x];i;i=G.e[i].next)
		dfs(G.e[i].to);
	tmp = 1ll<<60;
	c = m = s = 0;
	for(int j = 0,i = G.head[x];i;i=G.e[i].next)
	{
		int to = G.e[i].to;
		a[m++]=l[to];
		a[m++]=r[to];
		c--;
		s+=l[to];
	}
	std::sort(a,a+m);
	for(int i = 0;i<m;i++)
	{
		c++;
		s-=a[i];
		now=s+1ll*a[i]*c;
		if(now<tmp)
			l[x]=a[i],tmp = now;
		if(now==tmp)
			r[x]=a[i];
	}
	ans+=tmp;
}
int q[N],h,t,ed;
int main()
{
	int o,u;
	scanf("%d%d",&n,&m);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&o,&u);
		g.add(o,u),g.add(u,o);
	}
	for(int i = 1;i<= m;i++)
		scanf("%d",&l[i]),r[i]=l[i];
	if(n==m)
	{
		for(int i = 1;i<= n;i++)
			for(int j = g.head[i];j;j=g.e[j].next)
			{
				int to = g.e[j].to;
				ans+=abs(l[i]-l[to]);
			}
		printf("%lld\n",ans>>1);
		return 0;
	}
	h = 1,t = 0;
	for(int i = 1;i<= m;i++)
		del[q[++t]=i]=1;
	int x=0;
	while(h<=t)
	{
		for(int i = h;i<= t;i++)
			for(int j = g.head[q[i]];j;j=g.e[j].next)
				if(!del[g.e[j].to])
				{
					int to = g.e[j].to;
					G.add(to,q[i]);
				}
		x = t;
		for(int i = h;i<= x;i++)
			for(int j = g.head[q[i]];j;j=g.e[j].next)
				if(!del[g.e[j].to])
				{
					int to = g.e[j].to;
					if((--g.d[to])<=1)
						del[q[++t]=to]=1;
				}
		h = x+1;
	}
	for(int i = 1;i<= n;i++)
		if(!G.f[i])
			G.add(0,i);
	dfs(0);
	printf("%lld\n",ans);
	return 0;
}
Problem4298

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int base = 60383;
const int mod = 793999;
const int T = 205;
const int N = 5005;
const int M = 1000005;
struct HASH
{int next,cnt;ull to;}Hash[M];
int hd[mod+5],Cnt;
ull pow[T],hash[N];
int id[T][N],size[T][N],ans;
void Insert(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans+=(Hash[i].cnt<<1)+1;
			Hash[i].cnt++;
			return ;
		}
	ans++;
	Hash[++Cnt].to = x;Hash[Cnt].next = hd[p];hd[p] = Cnt;
	Hash[Cnt].cnt = 1;
}
void Delete(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans-=(Hash[i].cnt<<1)-1;
			--Hash[i].cnt;
			return ;
		}
}
struct E
{int next,to;}e[M<<1];
int head[T][N],tot;
void add(int d,int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[d][x];
	head[d][x] = tot;
}
void dfs(int d,int x,int pre,int fa)
{
	Delete(hash[x]);
	hash[x]-=pow[d]*id[d][x];
	id[d][x] = fa;
	hash[x]+=pow[d]*id[d][x];
	Insert(hash[x]);
	for(int i = head[d][x];i;i=e[i].next)if(e[i].to!=pre)
		dfs(d,e[i].to,x,fa);
}
void uni(int d,int x,int y)
{
	if(id[d][x]==id[d][y])return ;
	if(size[d][id[d][x]]<size[d][id[d][y]])swap(x,y);
	size[d][id[d][x]]+=size[d][id[d][y]];
	add(d,x,y),add(d,y,x);
	dfs(d,y,x,id[d][x]);
}
int main()
{
	int d,n,m;
	scanf("%d%d%d",&d,&n,&m);
	pow[0]=1;
	for(int i = 1;i<= d;i++)pow[i]=pow[i-1]*base;
	for(int i = 1;i<= d;i++)
		for(int j = 1;j<= n;j++)
			id[i][j]=j,size[i][j]=1,hash[j]+=pow[i]*j;
	for(int j = 1;j<=n;j++)Insert(hash[j]);
	int a,b,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&k);
		uni(k,a,b);
		printf("%d\n",ans);
	}
}
Problem4298

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int base = 60383;
const int mod = 1747969;
const int T = 205;
const int N = 5005;
const int M = 1000005;
struct HASH
{int next,cnt;ull to;}Hash[M];
int hd[mod+5],Cnt;
ull pow[T],hash[N];
int id[T][N],size[T][N],ans;
void Insert(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans+=(Hash[i].cnt<<1)+1;
			Hash[i].cnt++;
			return ;
		}
	ans++;
	Hash[++Cnt].to = x;Hash[Cnt].next = hd[p];hd[p] = Cnt;
	Hash[Cnt].cnt = 1;
}
void Delete(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans-=(Hash[i].cnt<<1)-1;
			--Hash[i].cnt;
			return ;
		}
}
struct E
{int next,to;}e[M<<1];
int head[T][N],tot;
void add(int d,int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[d][x];
	head[d][x] = tot;
}
void dfs(int d,int x,int pre,int fa)
{
	Delete(hash[x]);
	hash[x]-=pow[d]*id[d][x];
	id[d][x] = fa;
	hash[x]+=pow[d]*id[d][x];
	Insert(hash[x]);
	for(int i = head[d][x];i;i=e[i].next)if(e[i].to!=pre)
		dfs(d,e[i].to,x,fa);
}
void uni(int d,int x,int y)
{
	if(id[d][x]==id[d][y])return ;
	if(size[d][id[d][x]]<size[d][id[d][y]])swap(x,y);
	size[d][id[d][x]]+=size[d][id[d][y]];
	add(d,x,y),add(d,y,x);
	dfs(d,y,x,id[d][x]);
}
int main()
{
	int d,n,m;
	scanf("%d%d%d",&d,&n,&m);
	pow[0]=1;
	for(int i = 1;i<= d;i++)pow[i]=pow[i-1]*base;
	for(int i = 1;i<= d;i++)
		for(int j = 1;j<= n;j++)
			id[i][j]=j,size[i][j]=1,hash[j]+=pow[i]*j;
	for(int j = 1;j<=n;j++)Insert(hash[j]);
	int a,b,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&k);
		uni(k,a,b);
		printf("%d\n",ans);
	}
}
Problem4305

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 3e5+5;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int fac[N],inv[N];
void init()
{
	fac[0] = inv[0] = 1;
	for(int i = 1;i<N;i++)fac[i]=(ll)fac[i-1]*i%mod;
	inv[N-1] = quick_pow(fac[N-1],mod-2);
	for(int i = N-2;i>= 1;i--)inv[i] = (ll)inv[i+1]*(i+1)%mod;
}
int a[N],cnt[N],ans[N];
int C(int n,int m)
{
	if(m>n)return 0;
	return (ll)fac[n]*inv[n-m]%mod*inv[m]%mod;
}
int main()
{
	int n,m,k;
	init();
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),cnt[a[i]]++;
	for(int i = 1;i<= m;i++)
		for(int j = i+i;j<= m;j+=i)
			cnt[i]+=cnt[j];
	for(int i = 1;i<= m;i++)
		if(cnt[i]>=n-k)
			ans[i] = (ll)C(cnt[i],n-k)*quick_pow(m/i-1,cnt[i]-n+k)%mod*quick_pow(m/i,n-cnt[i])%mod;
	for(int i = m;i>= 1;i--)
		for(int j = i+i;j<= m;j+=i)
			(ans[i]+=mod-ans[j])%=mod;
	for(int i = 1;i< m;i++)printf("%d ",ans[i]);
	printf("%d\n",ans[m]);
	return 0;
}
Problem4316

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 6e4+5;
const int INF = 0x3f3f3f3f;
int f[M<<1][2];
namespace Cactus
{
	struct E
	{int next,to;}e[M<<1];
	int head[N],tot=1,n;
	int dfn[N],low[N],Dfn,stk[N],top;
}
namespace R_S_Tree
{
	struct E
	{int next,to;}e[M<<2];
	int head[N<<1],tot=1,n;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dp(int x,int fa)
	{
		f[x][1]=1;
		if(x<=Cactus::n)
		{
			for(int i = head[x];i;i=e[i].next)
				if(e[i].to!=fa)
				{
					dp(e[i].to,x);
					if(e[i].to>Cactus::n)continue;
					f[x][0]+=max(f[e[i].to][0],f[e[i].to][1]);
					f[x][1]+=f[e[i].to][0];
				}
		}else
		{
			static int g[M<<1][2];
			int top = 0;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].to!=fa)
					dp(e[i].to,x);
			for(int i = head[x];i;i=e[i].next)
			{
				g[++top][0] = f[e[i].to][0];
				g[top][1] = f[e[i].to][1];
			}
			for(int i = top-1;i>=1;i--)
			{
				g[i][0]+=max(g[i+1][0],g[i+1][1]);
				g[i][1]+=g[i+1][0];
			}
			f[fa][0] = g[1][0];
			for(int i = 1;i<top;i++)
			{
				g[i][0]-=max(g[i+1][0],g[i+1][1]);
				g[i][1]-=g[i+1][0];
			}
			g[top][1] = -INF;
			for(int i = top-1;i>=1;i--)
			{
				g[i][0]+=max(g[i+1][0],g[i+1][1]);
				g[i][1]+=g[i+1][0];
			}
			f[fa][1] = g[1][1];
		}
	}
}
namespace Cactus
{
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dfs(int x,int pre)
	{
		stk[++top] = x;
		dfn[x] = low[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)if(i!=(pre^1))
		{
			if(!dfn[e[i].to])
			{
				dfs(e[i].to,i);
				low[x] =min(low[x],low[e[i].to]);
				if(low[e[i].to]>=dfn[x])
				{
					int tmp;
					R_S_Tree::n++;
					do
					{
						tmp = stk[top--];
						R_S_Tree::add(tmp,R_S_Tree::n);
					}while(tmp!=e[i].to);
					R_S_Tree::add(x,R_S_Tree::n);
				}
			}else low[x] = min(low[x],dfn[e[i].to]);
		}
	}
};
int main()
{
	int m;
	scanf("%d%d",&Cactus::n,&m);
	R_S_Tree::n = Cactus::n;
	int x,y;
	while(m--)
	{
		scanf("%d%d",&x,&y);
		Cactus::add(x,y);
	}
	Cactus::top = 0,Cactus::Dfn = 0;
	Cactus::dfs(1,0);
	R_S_Tree::dp(1,0);
	printf("%d\n",max(f[1][0],f[1][1]));
	return 0;
}
Problem4318

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100000+5;
double f[N],l1[N],l2[N];
double p[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf",&p[i]);
	for(int i = 1;i<= n;i++)
	{
		l1[i] = p[i]*(l1[i-1]+1);
		l2[i] = p[i]*(l2[i-1]+2*l1[i-1]+1);
		f[i] = p[i]*(f[i-1]+3.0*l2[i-1]+3.0*l1[i-1]+1)+(1-p[i])*f[i-1];
	}
	printf("%.1f",f[n]);
	return 0;
}
Problem4320

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int X = 300005;
const int N = 100005;
struct A{int opt,num;}ask[N];
int ans[N],modn[605],fa[X];
bool v[X];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
int main()
{
	int n;
	char x[2];
	scanf("%d",&n);
	memset(ans,-1,sizeof(ans));
	memset(modn,0x3f,sizeof(modn));
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",x,&ask[i].num);
		if(x[0]=='A')
		{
			for(int j = 1;j<= 600;j++)
				modn[j] = min(modn[j],ask[i].num%j);
			ask[i].opt = 1;
			v[ask[i].num] = true;
		}
		else 
		{
			if(ask[i].num<=600)ans[i] = modn[ask[i].num];
			ask[i].opt = 2;
		}
	}
	for(int i = 1;i<=X-5;i++)
		if(!v[i])
			fa[i] =i+1;
	for(int i = n;i>= 1;i--)
	{
		if(ask[i].opt==1)fa[ask[i].num] = ask[i].num+1;
		else if(ask[i].num>600)
		{
			int tmp = 0x3f3f3f3f;
			for(int j = 0;j<= X-5;j+=ask[i].num)
			{
				int tt = getfa(max(1,j));
				if(tt<=X-5)tmp = min(tmp,tt%ask[i].num);
			}
			ans[i] = tmp;
		}
	}
	for(int i = 1;i<= n;i++)
		if(ans[i]!=-1)
			printf("%d\n",ans[i]);
	return 0;
}
Problem4346

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 1e9;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][3][3],g[N][3],p[N][3],q[N][3],c[3][3];
void dp(int x,int fa)
{
	p[x][1] = 1,p[x][2] = 2;
	memset(g[x],0x3f,sizeof(g[x]));
	memset(f[x],0x3f,sizeof(f[x]));
	f[x][0][0] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			int y = e[i].to;
			dp(y,x);
			int tmp = min(min(p[y][1],p[y][2]),q[y][1]);
			for(int j = 0;j<3;j++)
				tmp = min(tmp,g[y][j]);
			p[x][1]+=tmp,p[x][2]+=min(tmp,q[y][2]);
			memset(c,0x3f,sizeof(c));
			for(int j = 0;j<3;j++)
				for(int k = 0;k<3;k++)
					if(f[x][j][k]<INF)
					{
						tmp = f[x][j][k];
						for (int l=1; l<3; l++) c[min(2,j+l)][k]=min(c[min(2,j+l)][k],tmp+p[y][l]);  
                   		for (int l=0; l<3; l++) c[j][max(k,2-l)]=min(c[j][max(k,2-l)],tmp+g[y][l]);  
					}
			memcpy(f[x],c,sizeof(c));
		}
	for (int i=0; i<3; i++)  
        for (int j=0; j<=i; j++) g[x][i]=min(g[x][i],f[x][i][j]);  
    q[x][1]=min(f[x][0][1],f[x][1][2]);  
    q[x][2]=f[x][0][2];  
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
    for (int i=1; i<n; i++){  
    	scanf("%d%d",&x,&y); 
        add(x,y);
    }  
    dp(1,0); 
    int ans=min(p[1][1],p[1][2]);  
    for (int i=0; i<3; i++) ans=min(ans,g[1][i]);  
    printf("%d\n",ans);  
	return 0;
}
Problem4348

#include <stdio.h>
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define N 1005
int n,m,i,j,x,y,l,r,f[N][N],ans,t,q[10005][3],cnt;bool a[N][N];char ch[N];
struct P {int x,y,l,r,s;}s[N*N];
inline void up(int b) {if(ans<b)ans=b;}
inline void add(int x,int y,int z) 
{
	if(x&&x==y)return;
	q[++cnt][0]=x,q[cnt][1]=y,q[cnt][2]=z;
}
int main() 
{
	scanf("%d",&n);
	gets(ch);
	if(n==1){printf("1",ans);return 0;}
	for(int i = 1;i<= n;i++)
		for(gets(ch+1),j=1;j<=n;j++)
			if(ch[j]=='B')a[i][j]=1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(a[i][j]&&!f[i][j]) 
			{
				for(x=i;a[x][j];x++);
				for(y=j;a[i][y];y++);
				s[++m].x=i,s[m].y=--x,s[m].l=j,s[m].r=--y;
				up(s[m].s=(x-i+1)*(y-j+1));
				for(int I = i;I<= x;I++)
					for(int J = j;J<=y;J++)
						f[I][J]=m;
			}
	if(ans==n*n){printf("%d",ans);return 0;}
	for(i=n;~i;i--)
		for(j=n;~j;j--)
			f[i+1][j+1]=f[i][j];
	for(i=1;i<=m;i++)
		s[i].x++,s[i].y++,s[i].l++,s[i].r++;
	n+=2;
	ans=2;
	rep(i,1,m) 
	{
		x=s[i].x,y=s[i].y,l=s[i].l,r=s[i].r,cnt=0;
		if(x>2)rep(j,l,r) 
		{
			if(f[x-2][j])add(f[x-2][j],0,0);
			else 
			{
				t=s[i].s+2+s[f[x-2][j-1]].s+s[f[x-2][j+1]].s;
				if(f[x-2][j-1]!=f[x-1][j-1])t+=s[f[x-1][j-1]].s;
				if(f[x-2][j+1]!=f[x-1][j+1])t+=s[f[x-1][j+1]].s;
				if(x>3)t+=s[f[x-3][j]].s;
				up(t);
			}
		}
		if(y+2<=n)rep(j,l,r) 
		{
			if(f[y+2][j])add(f[y+2][j],0,0);
			else 
			{
				t=s[i].s+2+s[f[y+2][j-1]].s+s[f[y+2][j+1]].s;
				if(f[y+2][j-1]!=f[y+1][j-1])t+=s[f[y+1][j-1]].s;
				if(f[y+2][j+1]!=f[y+1][j+1])t+=s[f[y+1][j+1]].s;
				if(y+3<=n)t+=s[f[y+3][j]].s;
				up(t);
			}
		}
		if(l>2)rep(j,x,y) 
		{
			if(f[j][l-2])add(f[j][l-2],0,0);
			else 
			{
				t=s[i].s+2+s[f[j-1][l-2]].s+s[f[j+1][l-2]].s;
				if(f[j-1][l-2]!=f[j-1][l-1])t+=s[f[j-1][l-1]].s;
				if(f[j+1][l-2]!=f[j+1][l-1])t+=s[f[j+1][l-1]].s;
				if(l>3)t+=s[f[j][l-3]].s;
				up(t);
			}
		}
		if(r+2<=n)rep(j,x,y) 
		{
			if(f[j][r+2])add(f[j][r+2],0,0);
			else 
			{
				t=s[i].s+2+s[f[j-1][r+2]].s+s[f[j+1][r+2]].s;
				if(f[j-1][r+2]!=f[j-1][r+1])t+=s[f[j-1][r+1]].s;
				if(f[j+1][r+2]!=f[j+1][r+1])t+=s[f[j+1][r+1]].s;
				if(r+3<=n)t+=s[f[j][r+3]].s;
				up(t);
			}
		}
		if(f[x-1][l-1]) 
		{
			if(x>2)add(f[x-1][l-1],f[x-2][l],0);
			if(l>2)add(f[x-1][l-1],f[x][l-2],0);
		}
		if(f[y+1][l-1]) 
		{
			if(y+2<=n)add(f[y+1][l-1],f[y+2][l],0);
			if(l>2)add(f[y+1][l-1],f[y][l-2],0);
		}
		if(f[x-1][r+1]) 
		{
			if(x>2)add(f[x-1][r+1],f[x-2][r],0);
			if(r+2<=n)add(f[x-1][r+1],f[x][r+2],0);
		}
		if(f[y+1][r+1]) 
		{
			if(y+2<=n)add(f[y+1][r+1],f[y+2][r],0);
			if(r+2<=n)add(f[y+1][r+1],f[y][r+2],0);
		}
		if(x==y) 
		{
			if(l>2)add(f[x][l-2],f[x-1][l-1],f[x+1][l-1]);
			if(r+2<=n)add(f[x][r+2],f[x-1][r+1],f[x+1][r+1]);
		}
		if(l==r) 
		{
			if(x>2)add(f[x-2][l],f[x-1][l-1],f[x-1][l+1]);
			if(y+2<=n)add(f[y+2][l],f[y+1][l-1],f[y+1][l+1]);
		}
		up(s[i].s+2);
		rep(j,1,cnt) 
		{
			up(s[i].s+2+s[q[j][0]].s+s[q[j][1]].s+s[q[j][2]].s);
			rep(k,j+1,cnt) 
			{
				t=s[i].s+2+s[q[j][0]].s+s[q[j][1]].s+s[q[j][2]].s+s[q[k][0]].s+s[q[k][1]].s+s[q[k][2]].s;
				if(q[k][0]==q[j][0]||q[k][0]==q[j][1]||q[k][0]==q[j][2])t-=s[q[k][0]].s;
				if(q[k][1]==q[j][0]||q[k][1]==q[j][1]||q[k][1]==q[j][2])t-=s[q[k][1]].s;
				if(q[k][2]==q[j][0]||q[k][2]==q[j][1]||q[k][2]==q[j][2])t-=s[q[k][2]].s;
				up(t);
			}
		}
		if(x>1&&l>1&&!f[x-1][l-1]) 
		{
			t=s[i].s+2+s[f[x-2][l-1]].s+s[f[x-1][l-2]].s;
			if(x==y&&l==r) 
			{
				if(f[x-1][l-2]!=f[x][l-2])up(t+s[f[x][l-2]].s+s[f[x+1][l-1]].s);else up(t+s[f[x+1][l-1]].s);
				if(f[x-2][l-1]!=f[x-2][l])up(t+s[f[x-2][l]].s+s[f[x-1][l+1]].s);else up(t+s[f[x-1][l+1]].s);
			}else 
			{
				if(f[x-1][l-2]!=f[x][l-2])up(t+s[f[x][l-2]].s);
				if(f[x-2][l-1]!=f[x-2][l])up(t+s[f[x-2][l]].s);
			}
		}
		if(x>1&&r<n&&!f[x-1][r+1]) 
		{
			t=s[i].s+2+s[f[x-2][r+1]].s+s[f[x-1][r+2]].s;
			if(x==y&&l==r) 
			{
				if(f[x-1][r+2]!=f[x][r+2])up(t+s[f[x][r+2]].s+s[f[x+1][l+1]].s);else up(t+s[f[x+1][l+1]].s);
				if(f[x-2][r+1]!=f[x-2][r])up(t+s[f[x-2][r]].s+s[f[x-1][l-1]].s);else up(t+s[f[x-1][l-1]].s);
			}else 
			{
				if(f[x-1][r+2]!=f[x][r+2])up(t+s[f[x][r+2]].s);
				if(f[x-2][r+1]!=f[x-2][r])up(t+s[f[x-2][r]].s);
			}
		}
		if(y<n&&l>1&&!f[y+1][l-1]) 
		{
			t=s[i].s+2+s[f[y+2][l-1]].s+s[f[y+1][l-2]].s;
			if(x==y&&l==r) 
			{
				if(f[y+1][l-2]!=f[y][l-2])up(t+s[f[y][l-2]].s+s[f[x-1][l-1]].s);else up(t+s[f[x-1][l-1]].s);
				if(f[y+2][l-1]!=f[y+2][l])up(t+s[f[y+2][l]].s+s[f[x+1][l+1]].s);else up(t+s[f[x+1][l+1]].s);
			}else 
			{
				if(f[y+1][l-2]!=f[y][l-2])up(t+s[f[y][l-2]].s);
				if(f[y+2][l-1]!=f[y+2][l])up(t+s[f[y+2][l]].s);
			}
		}
		if(y<n&&r<n&&!f[y+1][r+1]) 
		{
			t=s[i].s+2+s[f[y+2][r+1]].s+s[f[y+1][r+2]].s;
			if(x==y&&l==r) 
			{
				if(f[y+1][r+2]!=f[y][r+2])up(t+s[f[y][r+2]].s+s[f[x-1][l+1]].s);else up(t+s[f[x-1][l+1]].s);
				if(f[y+2][r+1]!=f[y+2][r])up(t+s[f[y+2][r]].s+s[f[x+1][l-1]].s);else up(t+s[f[x+1][l-1]].s);
			}else 
			{
				if(f[y+1][r+2]!=f[y][r+2])up(t+s[f[y][r+2]].s);
				if(f[y+2][r+1]!=f[y+2][r])up(t+s[f[y+2][r]].s);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
Problem4349

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2505;
const int INF = 0x3f3f3f3f;
const double eps = 1e-7;
struct E
{int u,v;double val;}e[M];
int p[N],num[N],pre[N],vis[N],mark[N];
double c[N],in[N];
double work(int root,int n,int m)
{
	double ans = 0;
	while(true)
	{
		for(int i = 1;i<= n;i++)in[i] = INF;
		for(int i = 1;i<= m;i++)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].val<in[v])
			{
				in[v] = e[i].val;
				pre[v] = u;
			}
		}
		for(int i = 1;i<= n;i++)
		{
			if(i==root)continue;
			if(fabs(in[i]-INF)<eps)return -1;
		}
		memset(mark,-1,sizeof(mark));
		memset(vis,-1,sizeof(vis));
		in[root] = 0;int cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			ans+=in[i];
			int v=i;
			while(v!=root&&mark[v]==-1&&vis[v]!=i)
			{
				vis[v] = i;
				v = pre[v];
			}
			if(v!=root&&mark[v]==-1)
			{
				++cnt;
				for(int u = pre[v];u!=v;u = pre[u])
					mark[u] = cnt;
				mark[v] = cnt;
			}
		}
		if(cnt==0)break;
		for(int i = 1;i<= n;i++)
			if(mark[i]==-1)mark[i]=++cnt;
		for(int i = 1;i<=m;i++)
		{
			int u = e[i].u,v = e[i].v;
			e[i].u = mark[u],e[i].v = mark[v];
			if(e[i].u!=e[i].v)
				e[i].val-=in[v];
		}
		n=cnt,root = mark[root];
	}
	return ans;
}
int main()
{
	int n,m=0;
	scanf("%d",&n);
	int tmp = n;n = 1;
	double x;int t;
	for(int i = 1;i<= tmp;i++)
	{
		scanf("%lf%d",&x,&t);
		if(t)
		{
			p[i]=++n;
			e[++m] = (E){1,n,x};
			c[n] = x;num[n] = t;
		}
	}
	int a,b,k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%lf",&a,&b,&x);
		if(p[a]&&p[b])
		{
			e[++m] = (E){p[a],p[b],x};
			c[p[b]] = min(c[p[b]],x);
		}
	}
	double ans = work(1,n,m);
	for(int i = 2;i<= n;i++)
		if(num[i]>1)ans+=c[i]*(num[i]-1);
	printf("%.2f\n",ans);
	return 0;
}
Problem4377

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 1e6+5;
int n,a,b,p,m,cnt;
struct S
{int l,r;}seg[M<<2];
char s[M];
void add(int l,int r)
{
	if(l<=r){seg[++cnt].l = l;seg[cnt].r = r;}
	else 
	{
		seg[++cnt].l = l;seg[cnt].r = n-1;
		seg[++cnt].l = 0;seg[cnt].r = r;
	}
}
bool cmp(S a,S b)
{
	return a.l<b.l;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&a,&b,&p,&m);
	scanf("%s",s);
	int now = 0;
	for(int i = 0;i<m;i++,now = (now+a)%n)
	{
		if(s[i]=='0')add((p-now+n)%n,(n-1-now+n)%n);
		else add((n-now)%n,(p-1-now+n)%n);
	}
	for(int i=1,c=(b-a+n)%n;i<m;i++,c=(c-a+n)%n)
        add(c,c);
    sort(seg+1,seg+cnt+1,cmp);
    int end = -1,ans = 0;
    for(int i = 1;i<= cnt;i++)
    {
    	if(seg[i].l>end)
    	{
    		ans+=seg[i].l-end-1;
    		end = seg[i].r;
    	}
    	end = max(seg[i].r,end);
    }
    printf("%d\n",ans+n-1-end);
	return 0;
}
Problem4378

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
int a[N],num[N],cnt;
LL cn[N],cs[N];
struct opt
{int kind;LL x,y;}Opt[N];
int Find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(num[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void update(int pos,int xn,int xs)
{
	for(int i = pos;i<N;i+=i&(-i))
		cn[i]+=xn,cs[i]+=xs;
	return ;
}
LL getn(int pos)
{
	LL ans = 0;
	for(int i = pos;i>0;i-=i&(-i))
		ans+=cn[i];
	return ans;
}
LL gets(int pos)
{
	LL ans = 0;
	for(int i = pos;i>0;i-=i&(-i))
		ans+=cs[i];
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	char o[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",o);
		if(o[0]=='U')
			Opt[i].kind = 1;
		else
			Opt[i].kind = 2;
		scanf("%lld%lld",&Opt[i].x,&Opt[i].y);
		num[++cnt] = Opt[i].y;
	}
	memset(a,-1,sizeof(a));
	sort(num+1,num+cnt+1);
	for(int i = 1;i<= m;i++)
	{
		if(Opt[i].kind==1)
		{
			int tmp = a[Opt[i].x];
			if(tmp!=-1)update(Find(tmp),-1,-tmp);
			update(Find(Opt[i].y),1,Opt[i].y);
			a[Opt[i].x] = Opt[i].y;
		}else
		{
			LL tmp = getn(cnt)-getn(Find(Opt[i].y)-1);
			if(tmp>=Opt[i].x)printf("TAK\n");
			else if(gets(Find(Opt[i].y)-1)>=(Opt[i].x-tmp)*Opt[i].y)printf("TAK\n");
			else printf("NIE\n");
		}
	}
	return 0;
}
Problem4379

#include<iostream>
#include<cstdio>
#include<cstring>
#include <cctype>
#define N 1000010
using namespace std;
int to[N],nxt[N],pre[N],cnt;
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
void ae(int ff,int tt)
{
	cnt++;
	to[cnt]=tt;
	nxt[cnt]=pre[ff];
	pre[ff]=cnt;
}
int fa[N],d1[N],fir[N],sec[N],thr[N];
int fd[N],sd[N];
void dfs(int x)
{
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==fa[x]) continue;
		fa[j]=x;
		dfs(j);
		thr[x]=max(fir[j]+1,thr[x]);
		if(thr[x]>sec[x]) swap(thr[x],sec[x]);
		if(sec[x]>fir[x]) swap(sec[x],fir[x]);
		d1[x]=max(d1[x],d1[j]);
		sd[x]=max(d1[j],sd[x]);
		if(sd[x]>fd[x]) swap(sd[x],fd[x]);
	}
	d1[x]=max(d1[x],fir[x]+sec[x]);
}
int minn=707185547,x4,y4;
int maxn,x5,y5;
int cal(int x,int y)
{
	if(x>y) swap(x,y);
	int yy=y;
	x=x/2+x%2;y=y/2+y%2;
	return max(x+y+1,yy);
}
void solve(int x,int d2,int lg)
{
//	cout<<d1[x]<<' '<<x<<' '<<d2<<' '<<lg<<endl;
	int t,tmp;
	if(x!=1)
	{
		t=cal(d1[x],d2);
	//	cout<<fa[x]<<' '<<x<<' '<<d1[x]<<' '<<d2<<endl;
		if(t<minn) minn=t,x4=fa[x],y4=x;
		if(d1[x]+d2+1>maxn) maxn=d1[x]+d2+1,x5=fa[x],y5=x;
	}
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==fa[x]) continue;
		t=fir[x];tmp=fd[x];
		if(tmp==d1[j]) tmp=sd[x];
		if(t==fir[j]+1)
		{
			t=sec[x];
			tmp=max(tmp,sec[x]+max(thr[x],lg));
		}
		else if(sec[x]==fir[j]+1) tmp=max(tmp,fir[x]+max(thr[x],lg));
		else tmp=max(tmp,fir[x]+max(sec[x],lg));
		t=max(lg,t);tmp=max(tmp,d2);
		solve(j,tmp,t+1);
	}
}
int t[5],T,ma;
bool del[N];
void dfs1(int x,int ff,int dd)
{
	int i,j;
	if(dd>ma) ma=dd,t[T]=x;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==ff||del[i]) continue;
		dfs1(j,x,dd+1);
	}
}
int ans[3],TT;
bool getans(int x,int ff,int dd)
{
	if(x==t[T])
	{
		if(ma==0) ans[TT]=x;
		return true;
	}
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==ff||del[i]) continue;
		if(getans(j,x,dd+1))
		{
			if(dd==ma/2) ans[TT]=x;
			return true;
		}
	}
	return false;
}
void findmin(int x,int y)
{
	int i;
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=true;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=true;
	ma=-1;T=1;
	dfs1(x,y,0);
	ma=-1;T=2;
	dfs1(t[1],0,0);
	TT=1;
	getans(t[1],0,0);
	ma=-1;T=3;
	dfs1(y,x,0);
	ma=-1;T=4;
	dfs1(t[3],0,0);
	TT=2;
	getans(t[3],0,0);
	printf("%d %d %d %d %d\n",minn,x,y,ans[1],ans[2]);
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=false;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=false;
}
void findmax(int x,int y)
{
	int i;
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=true;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=true;
	ma=-1;T=1;
	dfs1(x,y,0);
	ma=-1;T=2;
	dfs1(t[1],0,0);
	ma=-1;T=3;
	dfs1(y,x,0);
	ma=-1;T=4;
	dfs1(t[3],0,0);
	printf("%d %d %d %d %d",maxn,x,y,t[1],t[3]);
}
int main()
{
	int n,m;
	n = read();
	int i,j,x,y;
	for(i=1;i<n;i++)
	{
		x = read();y = read();
		ae(x,y);ae(y,x);
	}
	dfs(1);
	solve(1,0,0);
	findmin(x4,y4);
	findmax(x5,y5);
}
Problem4380

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 52;
const int M = 4002;
const int INF = 500000;
int L[M],R[M],c[M],stack[M],pos[N][N][M],val[N][N][M];
LL f[N][N][M],sum[N][N][M];
int pid[N];
void printans(int l,int r,int t)
{
	if(l>r)return ;
	int tmp = val[l][r][t];
	printans(l,pos[l][r][t]-1,tmp);
	printf("%d ",pid[tmp]);
	printans(pos[l][r][t]+1,r,tmp);
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&L[i],&R[i],&c[i]);
		pid[i] = c[i];
	}
	sort(pid+1,pid+m+1);
	for(int lth = 1;lth<=n;lth++)
	{
		for(int l = 1;l+lth-1<= n;l++)
		{
			int r = l+lth-1;
			for(int k = l;k<= r;k++)
			{
				int top = 0;
				for(int t = 1;t<= m;t++)
					if(L[t]>=l&&R[t]<=r&&k>=L[t]&&k<=R[t])
						stack[++top] = c[t];
				sort(stack+1,stack+top+1);
				int head = 1;
				for(int t = 1;t<= m;t++)
				{
					while(head<=top&&stack[head]<pid[t])head++;
					LL tmp = sum[l][k-1][t]+sum[k+1][r][t]+(LL)(top-head+1)*pid[t];
					if(tmp>=f[l][r][t])
					{
						f[l][r][t] = tmp;
						pos[l][r][t] = k;
					}
				}
			}
			for(int k = m;k>=1;k--)
			{
				val[l][r][k] = k;
				if(f[l][r][k]<sum[l][r][k+1])
				{
					val[l][r][k] = val[l][r][k+1];
					pos[l][r][k] = pos[l][r][k+1];
				}
				sum[l][r][k] = max(sum[l][r][k+1],f[l][r][k]);
			}
		}
	}
	printf("%lld\n",sum[1][n][1]);
	printans(1,n,1);
	return 0;
}
Problem4381

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N],size[N],son[N],top[N],id[N],pos[N],dep[N],sum[N][155],a[N];
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x]++;
	dep[x] = dep[f]+1;
	int p = fa[x];
	for(int i =1;i<= 150&&p;p = fa[p],i++)sum[x][i] = sum[p][i]+a[x];
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=f)
		{
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
int cnt;
void dfs2(int x,int tp)
{
	top[x] = tp;
	id[++cnt] = x;
	pos[x] = cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=son[x]&&e[i].to!=fa[x])
			dfs2(e[i].to,e[i].to);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
int find(int x,int y)
{
	while(dep[x]-dep[top[x]]<y)
	{
		y-=dep[x]-dep[top[x]]+1;
		x = fa[top[x]];
	}
	return id[pos[x]-y];
}
int ask(int x,int y,int z)
{
	int ans = 0;
	if(z<=150)return sum[x][z]-sum[y][z]+a[y];
	while(top[x]!=top[y])
	{
		int i;
		for(i = pos[x];i>=pos[top[x]];i-=z)ans+=a[id[i]];
		x = find(x,pos[x]-i);
	}
	for(int i = pos[x];i>=pos[y];i-=z)ans+=a[id[i]];
	return ans;
}
int solve(int x,int y,int z)
{
	int ans = 0,lca = getlca(x,y);
	int lth = dep[x]+dep[y]-2*dep[lca];
	if(lth%z)ans+=a[y];
	y = find(y,lth%z);
	int t1 = find(x,(dep[x]-dep[lca])/z*z);
	if(dep[y]<=dep[lca])return ans+ask(x,t1,z);
	int t2 = find(y,(dep[y]-dep[lca])/z*z);
	if(t1==t2)ans-=a[t1];
	return ans+ask(x,t1,z)+ask(y,t2,z);
}
int b[N],c[N];
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs1(1,0);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	for(int i = 1;i< n;i++)
	{
		scanf("%d",&x);
		printf("%d\n",solve(b[i],b[i+1],x));
	}
	return 0;
}
Problem4382

#include <stdio.h>
#include <map>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
typedef unsigned long long ull;
const int N = 1000005;
const LL seed = 131133;
map<ull,int>id;
LL cnt;
ull pw[N],val[N],sum[N];
int pre[N],next[N],a[N];
bool vis[N];
int stack[N],top,n,k,ans,tot;
int calc(int x,int y)
{
	int t = y-x;
	return abs(t-n+t);
}
int main()
{
	scanf("%d%d",&n,&k);
	pw[0] = 1;
	for(int i = 1;i<= n;i++)pw[i] = pw[i-1]*seed;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		if(pre[a[i]])
		{
			val[pre[a[i]]]+=pw[++tot];
			val[i]-=pw[tot];
		}
		pre[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
		sum[i] = sum[i-1]+val[i];
	for(int i = 1;i<= n;i++)
	{
		if(id.count(sum[i]))
			next[id[sum[i]]] = i;
		id[sum[i]] = i;
	}
	ans = n;
	for(int i = 1;i<= n;i++)
		if(!vis[i])
		{
			top = 0;
			for(int j = i;j;j = next[j])
				stack[++top] = j,vis[j] = true;
			cnt+=(LL)top*(top-1)>>1;
			int k = 1;
			for(int j = 1;j<= top;j++)
			{
				while(k<j&&calc(stack[k],stack[j])>calc(stack[k+1],stack[j]))k++;
				ans = min(ans,calc(stack[k],stack[j]));
			}
		}
	printf("%lld %d",cnt,ans);
	return 0;
}
Problem4383

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Ed = 2e6+5;
const int N = 6e5+5;
const int INF = 1e9;
struct E
{int next,to,val;}e[Ed];
int ls[N],rs[N],L[N],R[N];
int sit[N];
int head[N],tot,cnt,ind[N],c[N],d[N],ans[N];
bool done[N];
void add(int x,int y,int f)
{
	ind[y]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int build(int l,int r)
{
	cnt++;
	L[cnt] = l,R[cnt] = r;
	int p = cnt;
	if(l==r)
	{
		sit[l] = cnt;
		return p;
	}
	int mid = (l+r)>>1;
	ls[p] = build(l,mid);
	add(p,ls[p],0);
	rs[p] = build(mid+1,r);
	add(p,rs[p],0);
	return p;
}
void update(int p,int a,int b,int c)
{
	if(L[p]>=a&&R[p]<=b)
	{
		add(c,p,0);return ;
	}
	int mid = (L[p]+R[p])>>1;
	if(a<=mid)update(ls[p],a,b,c);
	if(b>mid)update(rs[p],a,b,c);
	return ;
}
void dfs(int x)
{
	done[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		ans[e[i].to] = min(ans[e[i].to],ans[x]-e[i].val);
		ind[e[i].to]--;
		if(!ind[e[i].to])dfs(e[i].to);
	}
}
int main()
{
	int n,s,m;
	scanf("%d%d%d",&n,&s,&m);
	build(1,n);
	for(int i = 1;i<= cnt;i++)ans[i] = INF;
	int tmp = cnt;
	for(int i = 1;i<= s;i++)
	{
		scanf("%d%d",&c[i],&d[i]);
		ans[sit[c[i]]] = d[i];
	}
	int left,right,k;
	int y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&left,&right,&k);
		y = left;
		cnt++;
		for(int i = 1;i<= k;i++)
		{
			int x;
			scanf("%d",&x);
			add(sit[x],cnt,1);
			if(x>y)update(1,y,x-1,cnt);
			y = x+1;
		}
		if(right>=y)update(1,y,right,cnt);
	}
	for(int i = tmp+1;i<= cnt;i++)ans[i] = INF;
	dfs(1);
	for(int i = 1;i<= n;i++)
		if(!done[sit[i]]||ans[sit[i]]<1)
			{printf("NIE\n");return 0;}
	for(int i = 1;i<= s;i++)
		if(ans[sit[c[i]]]!=d[i])
			{printf("NIE\n");return 0;}
	printf("TAK\n");
	for(int i = 1;i< n;i++)
		printf("%d ",ans[sit[i]]);
	printf("%d\n",ans[sit[n]]);
	return 0;
}
Problem4385

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 2e6+5;
LL sum[N];
int a[N];
int line[N],L,R;
int main()
{
	int n,d;
	LL p;
	scanf("%d%lld%d",&n,&p,&d);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum[i] = sum[i-1]+a[i];
	}
	int i = 0,ans = 0;
	L = 0,R = -1;
	for(int j = d;j<= n;j++)
	{
		while(L<=R&&sum[j]-sum[j-d]>sum[line[R]]-sum[line[R]-d])R--;
		line[++R] = j;
		while(sum[j]-sum[i]-sum[line[L]]+sum[line[L]-d]>p)
		{
			i++;
			if(line[L]-d<i)L++;
		}
		ans = max(ans,j-i);
	}
	printf("%d\n",ans);
	return 0;
}
Problem4386

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 41;
int n,m,cnt;
LL K,mx;
struct Martix
{
	LL a[N*3][N*3];
	Martix()
	{
		memset(a,0,sizeof(a));
	}
	Martix operator*(const Martix &S)const
	{
		Martix ans;
		int i,j,k;
		for (i=0; i<=cnt; i++)
			for (j=0; j<=cnt; j++)
				if (S.a[i][j]<0 || a[i][j]<0)
				{
					ans.a[0][0]=-1; return ans;
				}
		for (i=0; i<=cnt; i++)
			for (j=0; j<=cnt; j++) 
				if (S.a[i][j])
				for (k=0; k<=cnt; k++) 
					if(a[j][k]){
					if (S.a[i][j]>K/a[j][k]){
						ans.a[0][0]=-1; return ans;
					}
					ans.a[i][k]+=S.a[i][j]*a[j][k];
					if (ans.a[i][k]>K){
						ans.a[0][0]=-1; return ans;
					}
				}
		return ans;
	}
};
Martix quick[65],b,c;
int id[N][3],st[N*3];
bool check()
{
	if (b.a[0][0]<0) return 0; 
	LL tmp=0;
	for (int i=1; i<=cnt; i++) 
		if (b.a[0][i] && st[i])
		{
			if(b.a[0][i]>K/st[i]) return 0;
			tmp+=b.a[0][i]*st[i];
			if (tmp>=K) return 0;
		}
	return 1;
}
int main()
{
	int x,y,C;
	scanf("%d%d%lld",&n,&m,&K);
	mx = K*3;
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<3;j++)
			id[i][j] = ++cnt;
	Martix A;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 0;j<2;j++)
			A.a[id[i][j]][id[i][j+1]]++;
		A.a[0][id[i][0]] = 1;
	}
	A.a[0][0] = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&C);
		A.a[id[x][C-1]][id[y][0]]++;
		st[id[x][C-1]]++;
	}
	int len = 0;
	while((LL)1<<len<=mx)len++;
	len--;
	quick[0] = A;
	for(int i = 1;i<= len;i++)
		quick[i] = quick[i-1]*quick[i-1];
	c.a[0][0] = 1;
	LL ans = 0;
	for(int i = len;i>=0;i--)
	{
		b = quick[i]*c;
		if(check())
		{
			ans|=((LL)1<<i);
			memcpy(c.a[0],b.a[0],sizeof(b.a[0]));
		}
	}
	ans++; 
	printf("%lld\n",(ans<=mx)?ans:-1);
	return 0;
}
Problem4398

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e5+5;
const int N = 4e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;};
struct p
{
	int v,no;
}heap[N<<2];
bool cmp(p a,p b)
{
	return a.v>b.v;
}
int dist[N],pre[N],cnt;
bool v[N];
struct G
{
	E e[M<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val  = f;
		head[x] = tot;
	}
	void spfa()
	{
		dist[1]=0;
		heap[1].v = 0;heap[1].no = 1;
		cnt++;
		push_heap(heap+1,heap+cnt+1,cmp);
		while(cnt)
		{
			int now=heap[1].no;
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			if(v[now])continue;
			v[now]=1;
			for(int i=head[now];i;i=e[i].next)
				if(dist[now]+e[i].val<dist[e[i].to]&&!v[e[i].to])
				{
					dist[e[i].to]=dist[now]+e[i].val;
					if(now==1)pre[e[i].to]=e[i].to;
					else pre[e[i].to]=pre[now];
					heap[++cnt].v = dist[e[i].to];
					heap[cnt].no = e[i].to;
					push_heap(heap+1,heap+cnt+1,cmp);
				}
		}
	}
}g1,g2;
int main()
{
	int n,m,x,y,u,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		g1.add(x,y,u);
		g1.add(y,x,w);
	}
	memset(dist,0x3f,sizeof(dist));
	g1.spfa();
	int end = n+1;
	for(int i = g1.head[1];i;i = g1.e[i].next)
	{
		if(pre[g1.e[i].to]!=g1.e[i].to)
			g2.add(1,g1.e[i].to,g1.e[i].val);
		//else g2.add(1,g1.e[i].to,dist[g1.e[i].to]);
	}
	for(int i = 2;i<= n;i++)
	{
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			if(g1.e[j].to==1)
			{
				if(pre[i]!=i)
					g2.add(1,end,dist[i]+g1.e[j].val);
				else g2.add(i,end,g1.e[j].val);
			}else
			{
				if(pre[g1.e[j].to]!=pre[i])
					g2.add(1,g1.e[j].to,dist[i]+g1.e[j].val);
				else g2.add(i,g1.e[j].to,g1.e[j].val);
			}
		}
	}
	memset(dist,0x3f,sizeof(dist));
	memset(v,0,sizeof(v));
	g2.spfa();
	if(dist[end]==INF)printf("-1\n");
	else printf("%d\n",dist[end]);
	return 0;
}
Problem4412

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
int c[N<<1];
int q[N],l,r;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&c[i]);
		c[i+n] = c[i];
	}
	int last = 0,sum = 0,st = 0,beg = 0;
	for(int i = 1;i<= 2*n;i++)
	{
		if(last<0)
			last = 0,beg = i;
		last+=c[i]-1;
		if(last>sum)
			sum = last,st = beg;
	}
	LL ans = 0;
	r = -1;
	for(int i = st;i<st+n;i++)
	{
		while(c[i]--)
			q[++r] = i;
		ans+=(LL)(i-q[l])*(i-q[l]);
		l++;
	}
	printf("%lld",ans);
	return 0;
}
Problem4422

#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
const int X=1000001,Y=1000000,N=2000005;
struct FEN{
    int xl,xr,y,i;
    bool flag;
    bool operator < (const FEN &o)const{
        return y!=o.y?y>o.y:xl<o.xl;
    }
} fen[N<<1];

struct FLO{
    int x,y;
    bool operator < (const FLO &o)const{
        return y>o.y;
    }
} flo[N];
struct CS{
    int x,y,i;
    bool operator < (const CS &o)const{
        return y>o.y;
    }
} cow[N];
struct SS{
    int nm;
    bool cov,cut;
} tr[X<<2];
int ans[N],fs[N];;
char * cp=(char *)malloc(20000000);
inline void in(int &x){
    for (;*cp<'0'||*cp>'9';cp++);
    for (x=0;*cp>='0'&&*cp<='9';cp++)
        x=x*10+*cp-'0';
}
inline void pushup(int x){
    tr[x].nm=tr[x<<1].nm+tr[x<<1|1].nm;
    tr[x].cut=tr[x<<1].cut|tr[x<<1|1].cut;
}
inline void paint(int x){
    tr[x].cov=1;
    tr[x].nm=0;
}
inline void pushdown(int x){
    if(tr[x].cov){
        paint(x<<1),paint(x<<1|1);
        tr[x].cov=0;
    }
}
void add(int x,int l,int r,int pur,int val){
    tr[x].nm+=val;
    if (l==r) return; 
    int mid=(l+r)>>1;
    pushdown(x);
    if(pur<=mid)
        add(x<<1,l,mid,pur,val);
    else 
        add(x<<1|1,mid+1,r,pur,val);
    pushup(x);
}
void cov(int x,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        paint(x);
        return;
    }
    pushdown(x);
    int mid=(l+r)>>1;
    if(L<=mid)cov(x<<1,l,mid,L,R);
    if(R>mid)cov(x<<1|1,mid+1,r,L,R);
    pushup(x);
}
int query(int x,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)
    {
        return tr[x].nm;
    }
    int mid=(l+r)>>1,ans=0;
    pushdown(x);
    if(L<=mid)ans+=query(x<<1,l,mid,L,R);
    if(R>mid)ans+=query(x<<1|1,mid+1,r,L,R);
    return ans;
}
void update(int x,int l,int r,int pur)
{
    if(l==r)
    {
        tr[x].cut^=1;
        return; 
    }
    int mid=l+r>>1;
    pushdown(x);
    if(pur<=mid)
        update(x<<1,l,mid,pur);
    else 
        update(x<<1|1,mid+1,r,pur);
    pushup(x);
}
int next(int x,int l,int r,int L)
{
    if(l>=L)
    {
        if(tr[x].cut)
        {
            while(l!=r)
                if(tr[x<<1].cut)
                    x<<=1,r=l+r>>1;
                else 
                    x=x<<1|1,l=(l+r>>1)+1;
            return l;
        }
        else return 0;
    }
    int tmp,mid=(l+r)>>1;
    pushdown(x);
    if(L<=mid&&(tmp=next(x<<1,l,mid,L)))
        return tmp;
    else 
        return next(x<<1|1,mid+1,r,L);
}
int main()
{
	//freopen("tt.in","r",stdin);
    fread(cp,1,20000000,stdin);
    int f,m,n,x1,y1,x2,y2;
    in(f);
    for(int i=f;i--;)
    {
        in(x1),in(y1),in(x2),in(y2);
        fen[i<<1]=(FEN){x1,x2,y1-1,i,0};
        fen[i<<1|1]=(FEN){x1,x2,y2,i,1};
    }
    sort(fen,fen+(f<<1));
    in(m);
    for(int i=m;i--;)
        in(flo[i].x),in(flo[i].y);
    sort(flo,flo+m);
    in(n);
    for(int i=0;i<n;++i)
    {
        in(cow[i].x),in(cow[i].y);
        cow[i].i=i;
    }
    sort(cow,cow+n);
    f=m=n=0;
    update(1,1,Y,Y);
    int sum,cut;
    for(int i=Y;i;--i)
    {
        for(;fen[f].y==i;++f)
            if(fen[f].flag==0)
            {
                cov(1,1,Y,fen[f].xl,fen[f].xr);
                if(fen[f].xl!=1)
                    add(1,1,Y,fen[f].xl-1,-fs[fen[f].i]);
                if(fen[f].xl!=1)
                    update(1,1,Y,fen[f].xl-1);
                if(fen[f].xr!=Y)
                    update(1,1,Y,fen[f].xr);
            }else
            {
                cut=next(1,1,Y,fen[f].xr);
                sum=query(1,1,Y,fen[f].xl,fen[f].xr);
                fs[fen[f].i]=query(1,1,Y,fen[f].xr+1,cut);
                cov(1,1,Y,fen[f].xl,fen[f].xr);
                if(fen[f].xl>1)
                    add(1,1,Y,fen[f].xl-1,sum+fs[fen[f].i]);
                if(fen[f].xl!=1)
                    update(1,1,Y,fen[f].xl-1);
                if(fen[f].xr!=Y)
                    update(1,1,Y,fen[f].xr);
            }
        for(;flo[m].y==i;++m)
            add(1,1,Y,flo[m].x,1);
        for(;cow[n].y==i;++n)
        {
            cut=next(1,1,Y,cow[n].x);
            ans[cow[n].i]=query(1,1,Y,cow[n].x,cut);
        }
    }
    for(int i=0;i<n;++i)
        printf("%d\n",ans[i]);
    return 0;
}
Problem4425

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int n,m,ans;
struct stuff
{int l,r;}s[N];
inline bool cmp(const stuff &a,const stuff &b){return a.l<b.l;}
struct pro
{
	int x;
	bool operator <(const pro &a)const{return x>a.x;}
};
priority_queue<pro>heap;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&s[i].l,&s[i].r),s[i].r+=s[i].l;
	sort(s+1,s+n+1,cmp);
	heap.push((pro){s[1].r+m});
	for(int i = 2;i<= n;i++)
	{
		while(!heap.empty()&&heap.top().x<s[i].l)heap.pop();
		int t = heap.top().x;
		if(t-m<=s[i].l&&s[i].l<=t)ans++,heap.pop();
		heap.push((pro){s[i].r+m});
	}
	printf("%d\n",ans);
	return 0;
}
Problem4426

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 210;
const int INF = 0x3f3f3f3f;
struct data
{
	int l,r;
	data(){}
	data(int _l,int _r):l(_l),r(_r){}
}s[N],q[2][N];
int cnt[2],ans = -INF;
bool cmp1(const data &a,const data &b)
{return a.l<b.l;}
bool cmp2(const data &a,const data &b)
{return a.r-a.l+1>b.r-b.l+1;}
int f[N][N],sum[N];
void solve(int now,int l,int r,int dl,int dr)
{
	int mid = (l+r)>>1,dmid = dl,maxn = ans;
	for(int i = min(dr,mid-1);i>=dl;i--)
	{
		if(q[0][i+1].r<=q[0][mid].l)break;
		int tmp = f[now-1][i]+q[0][i+1].r-q[0][mid].l;
		if(tmp>=maxn)maxn = tmp,dmid = i;
	}
	f[now][mid] = maxn;
	if(l<mid)solve(now,l,mid-1,dl,dmid);
	if(r>mid)solve(now,mid+1,r,dmid,dr);
}
int main()
{
	int n,p;
	scanf("%d%d",&n,&p);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&s[i].l,&s[i].r);
	for(int i = 1;i<= n;i++)
	{
		int flag = 0;
		for(int j = 1;j<= n;j++)
			if(s[i].l<=s[j].l&&s[i].r>=s[j].r&&(s[i].l!=s[j].l||s[i].r!=s[j].r||i<j))
				flag = 1;
		q[flag][++cnt[flag]] = s[i];
	}
	sort(q[0]+1,q[0]+cnt[0]+1,cmp1);
	for(int i = 1;i<= cnt[0];i++)f[0][i]=-INF;
	for(int i = 1;i<= p;i++)f[i][0] = -INF;
	for(int i = 1;i<= p;i++)solve(i,1,cnt[0],0,cnt[0]);
	sort(q[1]+1,q[1]+cnt[1]+1,cmp2);
	for(int i = 1;i<= cnt[1];i++)sum[i] = sum[i-1]+q[1][i].r-q[1][i].l;
	for(int i = 1;i<= p;i++)
		if((p-i)<=cnt[1]&&f[i][cnt[0]]>=0)
			ans = max(ans,f[i][cnt[0]]+sum[p-i]);
	printf("%d\n",ans);
	return 0;
}
Problem4427

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-9;
const int N = 1005;
inline int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	return x>0?1:-1;
}
inline int sqr(int x)
{
	return x*x;
}
struct Point
{
	double x,y;
	Point(){}
	Point(double _x,double _y):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double operator *(const Point &a,const Point &b)
	{return a.x*b.y-a.y*b.x;}
	friend bool operator !=(const Point &a,const Point &b)
	{return a.x!=b.x||a.y!=b.y;}
	friend bool operator ==(const Point &a,const Point &b)
	{return a.x==b.x&&a.y==b.y;} 
}poi[N];
struct Line
{
	Point a,b;
	Line(){}
	Line(const Point &_a,const Point &_b):a(_a),b(_b){}
}line[N];
struct E
{int next,to;}e[N*N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool Inter(const Line &l1,const Line &l2)
{
	return dcmp((l1.b-l1.a)*(l2.a-l1.a))*dcmp((l1.b-l1.a)*(l2.b-l1.a))<0
			&& dcmp((l2.b-l2.a)*(l1.a-l2.a))*dcmp((l2.b-l2.a)*(l1.b-l2.a))<0;
}
int col[N];
queue<int>Q;
int main()
{
	int n,m,x,y,id;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		poi[i] = Point(x,y);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&id,&x,&y);
		line[i].a = poi[id];
		line[i].b = Point(x,y);
	}
	for(int i = 1;i<= m;i++)
		for(int j = i+1;j<= m;j++)
			if((Inter(line[i],line[j])||line[i].b==line[j].b)&&
				line[i].a!=line[j].a&&line[i].a!=line[j].b&&line[i].b!=line[j].a)
					add(i,j),add(j,i);
	for(int i = 1;i<= m;i++)
	{
		if(col[i])continue;
		col[i] = 1;
		Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int j = head[x];j;j=e[j].next)
			{
				if(col[e[j].to])
				{
					if(col[e[j].to]==col[x])
					{
						printf("impossible\n");
						return 0;
					}
				}else
				{
					col[e[j].to] = col[x]==1?2:1;
					Q.push(e[j].to);
				}
			}
		}
	}
	printf("possible\n");
	return 0;
}
Problem4432

#include <stdio.h>
#include <math.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int mx = 3e5;
int Tim,n,m,top,tp;
int cnt[N][4];
char s[N];
struct seg;
struct edge;
vector<edge*>now[N][4];
struct edge
{
	seg *pre,*nxt;
	inline void solve();
	inline void merge();
}List[N<<1];
struct seg
{
	int l,r,flag,h0,t0;
	edge *pre,*nxt;
	inline int calc()
	{return h0+cnt[Tim][flag]-cnt[t0][flag];}
	inline bool checka()
	{return pre&&pre->pre->calc()>calc();}
	inline bool checkb()
	{return nxt&&nxt->nxt->calc()>calc();}
	inline void update()
	{flag = checka()|(checkb()<<1);}
}list[N<<1],*last,*first;
inline void edge::solve()
{
	int delta = abs(pre->calc()-nxt->calc()),flag = pre->flag^nxt->flag;
	if(delta && flag && delta+cnt[Tim][flag]<=mx)
		now[delta+cnt[Tim][flag]][flag].push_back(this);
}
inline void edge::merge()
{
	if(!(pre&&nxt))return ;
	int h = pre->calc();
	if(nxt->calc()!=h)return ;
	seg* ret = pre;
	ret->l = pre->l,ret->r = nxt->r,ret->h0 = h,ret->t0 = Tim;
	ret->pre = pre->pre,ret->nxt = nxt->nxt,ret->update();
	if(ret->pre)ret->pre->nxt = ret;
	if(ret->nxt)ret->nxt->pre = ret;
	if(ret->pre)ret->pre->solve();
	if(ret->nxt)ret->nxt->solve();
	pre = NULL,nxt = NULL;
}

int main()
{
	int h;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&h);
		if(last && last->h0==h)
			{last->r=i;continue;}
		++top;
		list[top].l = list[top].r = i;list[top].h0 = h,list[top].t0 = 0;
		if(last)
		{
			++tp;
			List[tp].pre = last,List[tp].nxt = &list[top];
			last->nxt = &List[tp];list[top].pre = &List[tp],last->update();
		}else first = &list[top];
		last = &list[top];
	}
	last->update();
	for(seg *i = first;i->nxt;i=i->nxt->nxt)
		i->nxt->solve();
	scanf("%s",s+1);
	for(Tim = 1;Tim<=m;Tim++)
	{
		cnt[Tim][1]=cnt[Tim-1][1]+(s[Tim]=='A'),cnt[Tim][2]=cnt[Tim-1][2]+(s[Tim]=='B');
		cnt[Tim][3]=cnt[Tim-1][3]+1;
		for(int f = 1;f<= 3;f++)
		{
			int sz = now[cnt[Tim][f]][f].size();
			for(int i = 0;i<sz;i++)now[cnt[Tim][f]][f][i]->merge();
		}
	}
	Tim = m;
	for (seg* i=first;i;i=i->nxt?i->nxt->nxt:NULL)
   	    for (int j=i->l;j<=i->r;++j)
        {
            if (j>1) putchar(' ');
            printf("%d",i->calc());
        }
    putchar('\n');
	return 0;
}
Problem4435

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
const int M = 9005;
const int INF = 0x3f3f3f3f;
typedef unsigned long long ull;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f;
}
int d[N],n,m;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(s);
	d[s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]+1)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
bool vis[N];
int a[N],b[N];
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!vis[e[i].to])
			dfs(e[i].to);
}
void reset()
{
	for(int i = 2;i<=tot;i+=2)
		e[i].f=e[i^1].f=(e[i].f+e[i^1].f)>>1;
}
ull BASE = 1,hash[4][N];
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(vis,0,sizeof(vis));
	dfs(s);
	BASE *= 131;
	for(int i = 1;i<= n;i++)
		if(~d[i])
			hash[tmp][i]+=BASE;
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(vis[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i]=i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,1);
	}
	solve(1,n);
	int Ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			for(int k = 0;k<= 3;k++)if(hash[k][i]!=hash[k][j])
			{
				Ans+=k;
				break;
			}
	printf("%d\n",Ans);
	return 0;
}
Problem4436

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
int nxt[N];
bool ins[N],vis[N];
int head[N],tot,ind[N];
queue<int>Q;
void getans(int x,int c)
{
	vis[x] = true;
	ins[x] = c;
	if(!vis[nxt[x]])getans(nxt[x],c^1);
}
int main()
{
	int n,x;
	scanf("%d",&n);
	n<<=1;
	for(int i = 1;i<= n;i++)
		scanf("%d",&nxt[i]),ind[nxt[i]]++;
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i),vis[i]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		ins[x] = true;
		int y = nxt[x];
		if(vis[y])continue;
		vis[y] = true;
		int z = nxt[y];
		if(!--ind[z])
		{
			Q.push(z);
			vis[z] = true;
		}
	}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			getans(i,1);
	for(int i = 1;i<= n;i++)
		if(ins[i])printf("%d ",i);
	return 0;
}
Problem4437

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
const int M=2000000;
const int P=(1<<24)-1;
char map[105][105];
struct E
{int x,y,next;}e[M+5];
int head[P+1],tot,n,m;
void add(int x,int y)
{
	int p = ++tot;
	e[p].x = x;
	e[p].y = y;
	e[p].next = head[((x<<9)^y)&P];
	head[((x<<9)^y)&P] = p;
}
bool ask(int x,int y)
{
	for(int i = head[((x<<9)^y)&P];i;i=e[i].next)
		if(x==e[i].x&&y==e[i].y)
			return true;
	return false;
}
int _dx[]={0,0,1,-1};
int _dy[]={1,-1,0,0};
int l,r,Qx[M],Qy[M];
const int lim = 10000;
int cnt;
void bfs()
{
	l=r=-1;Qx[++r]=0,Qy[r]=0;
	add(0,0);
	int x,y,sx,sy;
	while(l<r&&cnt<lim)
	{
		x = Qx[++l],y = Qy[l];
		for(int d = 0;d<4;d++)
		{
			sx = x+_dx[d],sy = y+_dy[d];
			if(!ask(sx,sy)&&map[(sx%n+n)%n][(sy%m+m)%m]=='.')
			{
				Qx[++r] = sx,Qy[r] = sy;
				add(sx,sy);
				if(sx%n==0&&sy%m==0)cnt++;
				if(r==M-1)return ;
			}
		}
	}
}
inline ll Abs(ll x){return x>0?x:-x;}
int flag;
ll dx,dy;
void getans(int x,int y)
{
	if(cnt<lim&&r<M-1){printf("%s\n",ask(x,y)?"yes":"no");return ;}
	if(flag){printf("%s\n",ask((x%n+n)%n,(y%m+m)%m)?"yes":"no");return ;}
	int L = -1e9,R = 1e9;
	while(L+5<R)
	{
		int m1 = (L+L+R)/3,m2 = (L+R+R)/3;
		ll f1 = Abs(dx*m1+x)+Abs(dy*m1+y);
		ll f2 = Abs(dx*m2+x)+Abs(dy*m2+y);
		if(f1<f2)R = m2;
		else L = m1;
	}
	int k = L;
	for(int i = L;i<= R;i++)
		if(Abs(dx*k+x)+Abs(dy*k+y)>=Abs(dx*i+x)+Abs(dy*i+y))
		{
			if (ask(x+dx*i,y+dy*i)) return void(printf("yes\n"));
			k=i;
		}
	printf("no\n");
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i< n;i++)
		scanf("%s",map[i]);
	bfs();
	if(cnt>=lim||r==M-1)
	{
		if(ask(n,0)&&ask(0,m))
			flag = 1;
		else
		{
			dx = 1ll<<40,dy = 1ll<<40;
			for (int i=1;i<=r;i++)
				if (Qx[i]%n==0 && Qy[i]%m==0)
					if (Qx[i]+Qy[i]<dx+dy)
						dx=Qx[i],dy=Qy[i];
		}
	}
	int Q,x,y;
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%d%d",&x,&y);
		getans(x,y);
	}
	return 0;
}
Problem4444

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int INF = 1e9;
const int N = 400020;
struct yts { int x,t,ne;} e[N];
struct PP { int l,r,id;} p[N];
int head[N],dep[N],st[N],ans[N],w;
int m,num;
 
bool cmp(PP a,PP b) { return a.l<b.l;}
void put(int x,int y)
{
	num++; e[num].x=x; e[num].t=y;
	e[num].ne=head[x]; head[x]=num;
}
 
void dfs(int x,int h)
{
	st[++w]=x;
	if (p[x].id!=-1)
	{
		while (h<w&&p[st[h+1]].r>=p[x].l+m) h++;
		ans[p[x].id]=dep[x]-dep[st[h]]+1;
	}
	for (int i=head[x];i;i=e[i].ne)
	{
		int y=e[i].t;
		dep[y]=dep[x]+1;
		dfs(y,h);
	}
	w--;
}
 
int main()
{
	int n;
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		if (r<l) r+=m;
		p[i]=(PP){l,r,i}; p[i+n]=(PP){l+m,r+m,-1};
	}
	n<<=1;
	sort(p+1,p+n+1,cmp);
	int now=1;
	for (int i=1;i<n;i++)
	{
		while (now<n&&p[now+1].l<=p[i].r) now++;
		put(now,i);
	}
	n>>=1;
	dep[2*n]=1; dfs(2*n,1);
	for (int i=1;i<=n;i++) printf("%d ",ans[i]);
	printf("\n");
	return 0;
}
Problem4445

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
const double eps = 1e-10;
int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	if(x>0)return 1;else return -1;
}
struct Point
{
	double x,y;
	Point(double _x=0,double _y=0):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend Point operator *(const Point &a,const double &k)
	{return Point(a.x*k,a.y*k);}
	friend double operator *(const Point &a,const Point &b)
	{return a.x*b.x+a.y*b.y;}
	friend double operator ^(const Point &a,const Point &b)
	{return a.x*b.y-a.y*b.x;}

};
struct Line
{
	Point p,v;
	double ang;
	Line(){}
	Line(Point _p,Point _v):p(_p),v(_v)
	{ang = atan2(v.y,v.x);}
	bool operator <(const Line &s)const
	{return ang<s.ang;}
};
bool on_left(const Line &l,const Point &p)
{return dcmp(l.v^(p-l.p))>0;}
Point Get_intersection(const Line &l1,const Line &l2)
{
	double x = ((l2.p-l1.p)^l2.v)/(l1.v^l2.v);
	return l1.p+l1.v*x;
}
double pans;
Line l[N],q[N];
Point t[N],p[N];
void Get_Half_Plane_Intersection(int n)
{
	sort(l+1,l+n+1);
	int hd = 1,tl = 0;
	q[++tl]=l[1];
	for(int i = 2;i<= n;i++)
	{
		while(hd<tl&& !on_left(l[i],p[tl-1]))tl--;
		while(hd<tl&& !on_left(l[i],p[hd]))hd++;
		q[++tl]=l[i];
		if(dcmp(q[tl].v^q[tl-1].v)==0)
		{
			tl--;
			if(hd<tl && !on_left(l[i],p[tl-1]))q[tl]=l[i];
		}
		if(hd<tl)p[tl-1] = Get_intersection(q[tl],q[tl-1]);
	}
	while(hd<tl && !on_left(q[hd],p[tl-1]))tl--;
	if(tl-hd<=1)
	{
		printf("0.0000");
		return ;
	}
	p[tl] = Get_intersection(q[tl],q[hd]);
	double ans = 0;
	for(int i = hd+1;i< tl;i++)
		ans+=((p[i]-p[hd])^(p[i+1]-p[hd]));
	ans = ans*0.5;
	printf("%.4f\n",ans/pans);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf",&t[i].x,&t[i].y);
	t[n+1]=t[1];
	for(int i = 2;i<n;i++)
		pans+=((t[i]-t[1])^(t[i+1]-t[1]));
	pans*=0.5;
	int cnt = 0;
	double x1 = t[1].x,y1 = t[1].y;
	double x2 = t[2].x,y2 = t[2].y;
	for(int i = 2;i<= n;i++)
	{
		double x3 = t[i].x,y3 = t[i].y;
		double x4 = t[i+1].x,y4 = t[i+1].y;
		double a = y1+y4-y2-y3;
		double b = x2+x3-x1-x4;
		double c = (t[1]^t[2])+(t[i+1]^t[i]);
		Point p,v;
		if(dcmp(b)!=0)p=Point(0,-c/b);  
        else p=Point(-c/a,0);  
       	v=Point(-b,a);
       	l[++cnt]=Line(p,v);
	}
	for(int i = 1;i<= n;i++)l[++cnt]=Line(t[i],t[i+1]-t[i]);
	Get_Half_Plane_Intersection(cnt);
	return 0;
}
Problem4446

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
ll f[N][20],g[N][20],A[N],B[N],dep[N],dis[N];
int ls[N],rs[N],fa[N];
void dp(int x)
{
	if(!ls[x]&&!rs[x])
	{
		for(int y = 2;y<=dep[x];y++)
		{
			int lca = x>>(dep[x]-y+1),z = x>>(dep[x]-y)^1;
			f[x][y]=(dis[x]+dis[z]-2*dis[lca])*A[z];
		}
	}else if(ls[x]&&!rs[x])
	{
		dp(ls[x]);
		for(int y = 2;y<= dep[x];y++)
			f[x][y]=A[ls[x]]*B[ls[x]]+f[ls[x]][y];
	}else
	{
		dp(ls[x]),dp(rs[x]);
		for(int y = 2;y<= dep[x];y++)
			f[x][y]=min(A[ls[x]]*B[ls[x]]+f[ls[x]][dep[x]+1]+f[rs[x]][y],
						A[rs[x]]*B[rs[x]]+f[rs[x]][dep[x]+1]+f[ls[x]][y]);
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
		scanf("%lld",&A[i]);
	dep[1]=1;
	for(int i = 2;i<= n;i++)
	{
		scanf("%lld",&B[i]);
		fa[i]=i>>1;
		dep[i]=dep[fa[i]]+1;
		dis[i]=dis[fa[i]]+B[i];
		if(ls[fa[i]])rs[fa[i]]=i;
		else ls[fa[i]]=i;
	}
	dp(1);
	for(int x = n;x>=1;x--)
		for(int y = 0;y<=dep[x];y++)
		{
			if(!rs[x])
			{
				if(!ls[x])
				{
					if(!y)g[x][y]=0;
					else
					{
						int z=x>>(dep[x]-y);
						g[x][y]=(dis[x]-dis[z])*A[z];
					}
				}else
					g[x][y]=A[ls[x]]*B[ls[x]]+g[ls[x]][y];
			}else
			{
				g[x][y]=min(A[ls[x]]*B[ls[x]]+f[ls[x]][dep[x]+1]+g[rs[x]][y],
							A[rs[x]]*B[rs[x]]+f[rs[x]][dep[x]+1]+g[ls[x]][y]);
			}
		}
	ll ans = g[1][0];
	for(int i = 2;i<= n;i++)
	{
		int x = i;ll sum = g[x][dep[x]-1];
		while(x!=1)
		{
			if((x^1)>n)
				sum+=A[x>>2]*B[x>>1];
			else 
				sum+=A[x^1]*B[x^1]+g[x^1][dep[x>>1]-1];
			x=x>>1;
		}
		ans = min(ans,sum);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4447

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
int n,m,s,t,a[N];
char opt[N];
struct Seg
{
	int x,y,z,s1,s2,t1,t2;
	void init(int i)
	{
		x = y = i;z = 1;
		s1 = t1 = i?-1:0;
		s2 = t2 = -1;
	}
	friend Seg operator +(const Seg &a,const Seg &b)
	{
		Seg res={a.x,b.y,a.z+b.z};
		int j = (a.y||b.x)?-1:0;
		if(b.s1==j)res.s1=a.s1,res.s2=a.s2;
		else 
			res.s1 = b.s1+a.z,res.s2=(b.s2!=j)?b.s2+a.z:a.s1;
		if(a.t1==j)res.t1=b.t1,res.t2=b.t2;
		else
			res.t1 = a.t1+b.z,res.t2=(a.t2!=j)?a.t2+b.z:b.t1;
		return res;
	}
}tr[N<<3];
int cal(int i)
{
	int s = i%n,t=(s+n-1)%n;
	if(opt[s]=='+')return (a[s]+a[t])%10;
	else return a[s]*a[t]%10;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].init(cal(l));
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p]=tr[p<<1]+tr[p<<1|1];
}
void update(int p,int l,int r,int pos,int val)
{
	if(l==r)
	{
		tr[p].init(val);
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,val);
	else update(p<<1|1,mid+1,r,pos,val);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
Seg getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans(p<<1|1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans(p<<1|1,mid+1,r,a,b);
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i<n;i++)
		scanf("%d %c",&a[i],&opt[i]);
	build(1,0,2*n-1);
	int s,t;
	while(m--)
	{
		scanf("%d%d",&s,&t);
		if(s==1)
		{
			scanf("%d %c",&a[t],&opt[t]);
			update(1,0,2*n-1,t,cal(t));
			update(1,0,2*n-1,t+n,cal(t));
			update(1,0,2*n-1,t+1,cal(t+1));
			if(t!=n-1)
				update(1,0,2*n-1,t+n+1,cal(t+1));
		}else
		{
			update(1,0,2*n-1,t,a[t]);
			Seg a=getans(1,0,2*n-1,t,t+(n-1)/2);
			Seg b=getans(1,0,2*n-1,t+(n+1)/2,t+n-1);
			if(~b.t1&&(a.x||b.t1))++b.t1;
            if(~b.t2&&(a.x||b.t2))++b.t2;
            printf("%d\n",a.y||b.x?max(a.s1,b.t1):max(max(a.s2,b.t2),min(a.s1,b.t1)));
            update(1,0,2*n-1,t,cal(t));
		}
	}
	return 0;
}
Problem4448

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],size[N],son[N],top[N],fa[N],dfn[N],seq[N],Dfn,cnt;
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x]=e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x]=tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=son[x]&&e[i].to!=fa[x])
			dfs2(e[i].to,e[i].to);
}
struct Ask
{
	int x,y,c;
	int dat;
}ask[N];
int root[N],sum[N*100],TOT,ls[N*100],rs[N*100],val[N];
int mx = 2e5;
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++TOT;
	sum[p]=sum[pre]+1;
	if(l==r)return ;
	ls[p]=ls[pre],rs[p]=rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
int getans(int p1,int p2,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p2]-sum[p1];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p1],ls[p2],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p1],rs[p2],mid+1,r,a,b);
	return ans;
}
int lth;
int getans(int x,int y,int c)
{
	int ans = 0;
	lth = dep[x]+dep[y];
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=getans(root[dfn[top[x]]-1],root[dfn[x]],0,mx,c,mx);
		x = fa[top[x]];
	}
	if(dep[y]<dep[x])swap(x,y);
	ans+=getans(root[dfn[x]-1],root[dfn[y]],0,mx,c,mx);
	lth-=dep[x]+dep[fa[x]];
	return ans;
}
int main()
{
	int n,m,rot;
	int k,x,y,c;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(!x)rot=i;
		else add(x,i);
	}
	dfs1(rot);
	dfs2(rot,rot);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&k,&x);
		if(k==1)
		{
			scanf("%d%d",&y,&c);
			cnt++;
			ask[cnt].x=x,ask[cnt].y=y,ask[cnt].c=c;ask[cnt].dat=i;
		}else
			val[x] = m-i;
	}
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],0,mx,val[seq[i]]);
	for(int i = 1;i<= cnt;i++)
	{
		int ans2 = getans(ask[i].x,ask[i].y,ask[i].c+m-ask[i].dat+1);
		int ans1 = lth;
		printf("%d %d\n",ans1,ans2);
	}
	return 0;
}
Problem4451

#include <bits/stdc++.h>

const int N = 400005;
const int mod = 1000003;
typedef long long ll;
int toA[N],toB[N];
int ny[N],jc[N];
int n,a,b,c,w;
int pow(int x,int y)
{
	int ans = 1;
	while (y)
	{
		if (y & 1)
			ans = (ll) ans * x % mod;
		x = (ll) x * x % mod;
		y >>= 1;
	}
	return ans;
}

void getJc()
{
	jc[0] = ny[0] = 1;
	for (int i = 1; i <= N - 5; i++)
	{
		jc[i] = (ll) jc[i - 1] * i % mod;
		ny[i] = pow(jc[i],mod - 2);
	}
}

int getW(int x1,int y1)
{
	return (ll)jc[x1 + y1] % mod * ny[x1] % mod * ny[y1] % mod * toB[x1] % mod * toA[y1] % mod;
}

int main()
{
	getJc();
	scanf("%d%d%d%d",&n,&a,&b,&c);
	int ans=0;
	toA[0]=toB[0]=1;
	for (int i = 1; i <= n; i++)
		toA[i] = (ll)toA[i - 1] * a % mod, toB[i] = (ll)toB[i - 1] * b % mod;
	for (int i = 1; i <= n; i++)
	{
		scanf("%d",&w);
		int x = n - i,y = n - 1;
		if (i > 1)
			ans = (ans + (ll)toB[x] * toA[y] % mod * jc[x + y - 1] % mod * ny[x] % mod * ny[y - 1] % mod * w % mod) % mod;
	}
	for (int i = 1; i <= n; i++)
	{
		scanf("%d",&w);
		int x = n - 1, y = n - i;
		if (i > 1)
			ans = (ans + (ll)toB[x] * toA[y] % mod * jc[x + y - 1] % mod * ny[x - 1] % mod * ny[y] % mod * w % mod) % mod;
	}
	n--;
	int now = 1, w = (a + b) % mod;
	ans = (ans + c) % mod;
	for (int i = 1; i < n; i++)
	{
		now = (ll)now * w % mod;
		ans = (ans + (ll)now * c % mod) % mod;
	}
	int x1 = 0, y1 = n-1, x2 = n-1, y2 = 0;
	for (int i = 1; i < n; i++)
	{
		int w1 = getW(x1,y1);
		int w2 = getW(x2,y2);
		now = (now - (ll)w1 + mod) % mod;
		now = (now - (ll)w2 + mod) % mod;
		now = (ll)now * w % mod;
		now = (now + (ll)w1 * b % mod) % mod;
		now = (now + (ll)w2 * a % mod) % mod;
		ans = (ans + (ll)now * c % mod) % mod;
		x1++;
		y2++;
	}
	printf("%d\n",ans);
}
Problem4452

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int fa[N],size[N],deg[N],size2[N],num0,num2,numc;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x] = getfa(fa[x]);
}
void del(int x)
{
	if(deg[x]==0)num0--;
	if(deg[x]==2)num2--,size2[getfa(x)]--;
}
void add(int x)
{
	if(deg[x]==0)num0++;
	if(deg[x]==2)num2++,size2[getfa(x)]++;
}
void delc(int x){if(size[x]==size2[x])numc--;}
void addc(int x){if(size[x]==size2[x])numc++;}
void merge(int u,int v)
{
	int x = getfa(u),y = getfa(v);
	if(x^y)
	{
		delc(x),delc(y),del(u),del(v);
		deg[u]++,deg[v]++;
		add(u),add(v);
		fa[x] = y,size[y]+=size[x],size2[y]+=size2[x];
		addc(y);
	}else
	{
		delc(x),del(u),del(v);
		deg[u]++,deg[v]++;
		add(u),add(v),addc(x);
	}
}
int a[N],idx[N],ans1[N],ans2[N];
bool cmp(int x,int y)
{
	return a[x]>a[y];
}
struct E
{
	int x,y,w;
	bool operator <(const E &s)const
	{
		return w>s.w;
	}
}e[N];
int main()
{
	int n,m,q;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w);
	sort(e+1,e+m+1);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)scanf("%d",&a[i]),idx[i]=i;
	sort(idx+1,idx+q+1,cmp);
	for(int i = 1;i<= n;i++)
		deg[i]=0,fa[i]=i,size[i]=1,size2[i]=0;
	num0 = n;
	int pnt = 1;
	int curm = 0;
	for(int i = 1;i<= q;i++)
	{
		while(pnt<=m&&e[pnt].w>=a[idx[i]])
			merge(e[pnt].x,e[pnt].y),pnt++,curm++;
		ans1[idx[i]] = n-num0-num2+numc;
		ans2[idx[i]] = curm-num2+numc;
	}
	for(int i = 1;i<= q;i++)
		printf("%d %d\n",ans1[i],ans2[i]);
	return 0;
}
Problem4453

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
char s[N];
int len;
namespace SA
{
	int sa[N],val[N],nv[N],h[N],rnk[N],cnt[N],q[N];
	bool is_same(int a,int b,int hl,int len)
	{
		return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
	}
	void build_sa(int lim,int len)
	{
		int i,j,k;
		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]] = i;
		for(int d = 1;;d++)
		{
			int hl = 1<<(d-1);
			int id = 0;
			for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
			for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

			for(i = 0;i<lim;i++)cnt[i] = 0;
			for(i = 0;i<len;i++)cnt[val[q[i]]]++;
			for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
			for(i = len-1;i>= 0;i--)sa[--cnt[val[q[i]]]] = q[i];

			lim = 0;
			for(i = 0;i<len;lim++)
			{
				for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
				for(k = i,i = j+1;k<=j;k++)nv[sa[k]] = lim;
			}
			for(i = 0;i<len;i++)val[i] = nv[i];
			if(lim==len)break;
		}
	}
	void build_rank(int len)
	{
		for(int i = 0;i<len;i++)
			rnk[sa[i]] = i;
	}
	void build_height(int len)
	{
		for(int i = 0;i<len;i++)
			if(rnk[i])
			{
				int j = 0;
				if(i)j = max(h[rnk[i-1]]-1,0);
				while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])
					j++;
				h[rnk[i]] = j;
			}
	}
	int st[N][20];
	int lg2[N];
	void build_st(int len)
	{
		for(int i = 2;i<N;i++)
			lg2[i] = lg2[i>>1]+1;
		for(int i = 0;i<len;i++)
			st[i][0] = h[i];
		for(int j = 1;j<= 18;j++)
			for(int i = 0;i+(1<<(j-1))<=len;i++)
				st[i][j] = min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
	}
	int lcp(int i,int j)
	{
		i = rnk[i],j = rnk[j];
		if(i>j)swap(i,j);
		i++;
		int lth = lg2[j-i+1];
		return min(st[i][lth],st[j-(1<<lth)+1][lth]);
	}
}
struct E{int next,to,id;};
struct List
{
	E e[N];
	int h[N],tot;
	void insert(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = h[x];
		h[x] = tot;
	}
}g,list;
struct Q
{int next,to,id;}q[N];
int head[N],tot;
void addq(int x,int y,int id)
{
	q[++tot].to = y;
	q[tot].next = head[x];
	q[tot].id = id;
	head[x] = tot;
}
int vis[N];
set<int>S;
void dfs(int x)
{
	vis[x] = 1;
	S.erase(x);
	for(int i = g.h[x];i;i=g.e[i].next)
	{
		int to = g.e[i].to;
		if(vis[to])continue;
		dfs(to);
	}
}
int stack[N],top,ans[N];
void solve()
{
	for(int r = 0;r< len;r++)
	{
		S.insert(r);
		while(top)
		{
			int lth = SA::lcp(r,stack[top]);
			if(s[r+lth]<s[stack[top]+lth])break;
			list.insert(r+lth,stack[top]);
			g.insert(r,stack[top]);
			top--;
		}
		stack[++top] = r;
		for(int i = list.h[r];i;i=list.e[i].next)
		{
			int to = list.e[i].to;
			if(!vis[to])dfs(to);
		}
		for(int i = head[r];i;i=q[i].next)
			ans[q[i].id] = *S.lower_bound(q[i].to);
	}
}
int main()
{
	scanf("%s",s);
	len = strlen(s);
	SA::build_sa(255,len);
	SA::build_rank(len);
	SA::build_height(len);
	SA::build_st(len);
	int q,l,r;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&l,&r);
		l--,r--;
		addq(r,l,i);
	}
	solve();
	for(int i = 1;i<= q;i++)printf("%d\n",ans[i]+1);
	return 0;
}
Problem4455

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 20;
int mp[N][N],fa[N],n,m;
bool islf[N];
ll f[N][N];
struct E
{int next,to;}e[N*N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int p[N],q[N];
void dfs(int s)
{
	q[1] = s;
	int l = 1,r = 1;
	while(l<=r)
	{
		int x = q[l++];
		islf[x] = true;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				islf[x] = false;
				q[++r] = e[i].to;
			}
	}
}
int get_point(int x)
{
	int j = 0,cnt = 0;
	while(x)
	{
		j++;
		if(x&1)p[++cnt] = j;
		x>>=1;
	}
	return cnt;
}
void dp(int cnt)
{
	for(int i = n;i>= 1;i--)
	{
		int x = q[i];
		if(islf[x])continue;
		for(int j = 1;j<= cnt;j++)
		{
			for(int o = head[x];o;o=e[o].next)
			{
				ll num = 0;int to = e[o].to;
				if(fa[to]!=x)continue;
				for(int k = 1;k<= cnt;k++)
					if(mp[p[j]][p[k]])
						num+=f[to][k];
				f[x][j]*=num;
			}
		}
	}
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)mp[i][i]=1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		mp[x][y] = mp[y][x] = 1;
	}
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1);
	ll ans = 0;int tmp = n%2;
	for(int i = 0;i<(1<<n);i++)
	{
		int cnt = get_point(i);
		int flag = (cnt%2==tmp)?1:-1;
		ll tans = 0;
		for(int j = 1;j<= n;j++)
			for(int k =1;k<= cnt;k++)
				f[j][k] = 1;
		dp(cnt);
		for(int j = 1;j<= cnt;j++)tans+=f[1][j];
		ans+=(ll)flag*tans;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4456

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
struct Ask
{
	int id;
	int x1,y1,x2,y2;
	Ask(){}
}a[M],b[M];
int head[M],tot;
int n,m;
inline int getid(int i,int j)
{
	return i*m-m+j;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool cmp(const int &a,const int &b)
{
	return a>b;
}
int d[M],id[M],cnt,ans[M],q[M];
void goup(int x)
{
	int y=q[x],t=d[y];
	for (; x>1 && t<d[q[x>>1]]; x>>=1)
	{
		q[x]=q[x>>1]; id[q[x]]=x;
	}
	q[x]=y; id[y]=x;
}
void godown(int x)
{
	int y=x<<1,z=q[x],t=d[z];
	if (y<cnt && d[q[y|1]]<d[q[y]]) y|=1;
	while (y<=cnt && d[q[y]]<t)
	{
		q[x]=q[y]; id[q[x]]=x;
		x=y; y<<=1; if (y<cnt && d[q[y|1]]<d[q[y]]) y|=1;
	}
	q[x]=z; id[z]=x;
}
void dijk(int s,int x1,int y1,int x2,int y2)
{
	register int i,j;
	d[s] = 0,id[s] =1,cnt=0;
	q[++cnt] =s;
	for(i = x1;i<= x2;i++)
		for(j = y1;j<= y2;j++)
			if(getid(i,j)!=s)
			{
				int no = getid(i,j);
				q[++cnt] = no;
				d[no] = INF;id[no] = cnt;
			}
	while(cnt)
	{
		int x=q[1];
		q[1]=q[cnt--];
		id[q[1]]=1;
		godown(1);
		for(i = head[x];i;i=e[i].next)
		{
			int to = e[i].to,u = (to-1)/m+1,v = (to-1)%m+1;
			if(u<=x2&&u>=x1&&v<=y2&&v>=y1&&d[x]+e[i].val<d[to])
				{d[to]=d[x]+e[i].val;goup(id[to]);}
		}
	}
}
/*queue<int>Q;
bool vis[M];
void dijk(int s,int x1,int y1,int x2,int y2)
{
	for(int i = x1;i<=x2;i++)
		for(int j = y1;j<= y2;j++)
			d[getid(i,j)] = INF;
	Q.push(s);d[s] = 0;vis[s] =true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] =false;
		for(int i = head[x];i;i=e[i].next)
		{
			int no = e[i].to;
			int u = (no-1)/m+1,v = (no-1)%m+1;
			if(u<=x2&&u>=x1&&v<=y2&&v>=y1&&d[no]>d[x]+e[i].val)
			{
				d[no] =d[x]+e[i].val;
				if(!vis[no])
					Q.push(no);
			}
		}
	}
}*/
void solve(int x1,int y1,int x2,int y2,int l,int r)
{
	int i,j,k;
	int mid;
	if(l>r)return ;
	if(x2-x1>y2-y1)
	{
		mid = (x1+x2)>>1;
		for(i = y1;i<= y2;i++)
		{
			dijk(getid(mid,i),x1,y1,x2,y2);
			for(j = l;j<= r;j++)
				ans[a[j].id] = min(ans[a[j].id],d[getid(a[j].x1,a[j].y1)]+d[getid(a[j].x2,a[j].y2)]);
		}
		j = l-1,k = r+1;
		for(i = l;i<= r;i++)
			if(a[i].x1<mid&&a[i].x2<mid)b[++j]=a[i];
			else if(a[i].x1>mid&&a[i].x2>mid)b[--k]=a[i];
		for(i = l;i<= j;i++)a[i]=b[i];solve(x1,y1,mid-1,y2,l,j);
		for(i = r;i>= k;i--)a[i]=b[i];solve(mid+1,y1,x2,y2,k,r);
	}else
	{
		mid = (y1+y2)>>1;
		for(i = x1;i<= x2;i++)
		{
			dijk(getid(i,mid),x1,y1,x2,y2);
			for(j = l;j<= r;j++)
				ans[a[j].id] = min(ans[a[j].id],d[getid(a[j].x1,a[j].y1)]+d[getid(a[j].x2,a[j].y2)]);
		}
		j = l-1,k = r+1;
		for(i = l;i<= r;i++)
			if(a[i].y1<mid&&a[i].y2<mid)b[++j]=a[i];
			else if(a[i].y1>mid&&a[i].y2>mid)b[--k]=a[i];
		for(i = l;i<= j;i++)a[i]=b[i];solve(x1,y1,x2,mid-1,l,j);
		for(i = r;i>= k;i--)a[i]=b[i];solve(x1,mid+1,x2,y2,k,r);
	}
}
int main()
{
	//freopen("ex_tourist3.in","r",stdin);
	memset(ans,0x3f,sizeof(ans));
	int q,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),getid(i,j+1),x);
			add(getid(i,j+1),getid(i,j),x);
		}
	for(int i = 1;i< n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),getid(i+1,j),x);
			add(getid(i+1,j),getid(i,j),x);
		}
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d%d",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
		a[i].id = i;
	}
	solve(1,1,n,m,1,q);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4472

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct data
{
	int val,x;
	data(){}
	data(int val,int x):val(val),x(x){}
	bool operator <(const data &a)const
	{
		return val>a.val;
	}
}stack[N];
int f[N],n;
bool can[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,top,lim[N],val[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	top = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			stack[++top] = data(f[e[i].to],e[i].to);
	sort(stack+1,stack+top+1);
	int i;
	for(i = 1;i<= top;i++)
	{
		if(stack[i].val<0||i==lim[x])break;
		f[x]+=stack[i].val;
		if(can[stack[i].x])can[x] = true;
		if(stack[i].val==0)can[x] = true;
	}
	if(i<lim[x]&&i<=top&&i!=0&&stack[i].val==stack[i-1].val)
		can[x] = true;
	f[x]+=val[x];
}
int main()
{
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
		scanf("%d",&val[i]);
	for(int i = 2;i<= n;i++)
		scanf("%d",&lim[i]);
	lim[1] = 10*n;
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	printf("%d\n",f[1]);
	if(!can[1])printf("solution is unique\n");
	else printf("solution is not unique\n");
	return 0;
}
Problem4484

#include <stdio.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 1e5+5;
bitset<N>bit[N];
struct E
{int next,to;}e[M];
struct data
{
	int en,v;
	bool operator <(const data &a)const
	{
		return v>a.v;
	}
}a[N];
int head[N],tot,d[N],n,m,len[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	d[y]++;
}
int q[N],s,t,ans=0;
void getans()
{
	s = 1,t = 0;
	for(int i = 1;i<= n;i++)
		if(!d[i])
			q[++t] = i;
	while(s<=t)
	{
		int x = q[s++];
		for(int i = head[x];i;i=e[i].next)
			if(!(--d[e[i].to]))
				q[++t] = e[i].to;
	}
	int num;
	for(int i = t;i>= 1;i--)
	{
		int x = q[i];
		bit[x][x] = 1,num = 0,len[x] = 1;
		for(int j = head[x];j;j=e[j].next)
		{
			a[++num] = (data){e[j].to,len[e[j].to]};
			len[x] = max(len[x],len[e[j].to]+1);
		}
		sort(a+1,a+num+1);
		for(int j = 1;j<= num;j++)
		{
			int y = a[j].en;
			if(bit[x][y])ans++;
			bit[x]|=bit[y];
		}
	}	
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	getans();
	printf("%d\n",ans);
	return 0;
}
Problem4485

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot = 1,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].f = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].f = f;head[y] = tot;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
inline int getid(int x,int y)
{
	return (x-1)*m+y;
}
int main()
{
	int d,sum = 0;
	scanf("%d%d",&n,&m);
	int S = 0,T = n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&d);
			if(d>0)add(S,getid(i,j),d),sum+=d;
			else add(getid(i,j),T,-d),sum+=-d;
		}
	for(int i = 1;i<n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&d);
			add(getid(i,j),getid(i+1,j),d);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<m;j++)
		{
			scanf("%d",&d);
			add(getid(i,j),getid(i,j+1),d);
		}
	printf("%d\n",sum-dinic(S,T));
	return 0;
}
Problem4487

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 405;
int c[N][N];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void init()
{
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
}
int main()
{
	int n,m,p;
	ll ans = 0;
	init();
	scanf("%d%d%d",&n,&m,&p);
	for(int i = 0;i<= n;i++)
		for(int k = 0;k<= p;k++)
		{
			ans+=(ll)c[n][i]*c[p][k]%mod*((n+m+p-i-k)%2?-1:1)*quick_pow(1-quick_pow(k+1,i),m)%mod;
			ans=(ans%mod+mod)%mod;
		}
	printf("%lld\n",ans);
	return 0;
}
Problem4488

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	ll num;int pos;
	bool operator <(const data &a)const
	{
		if(num==a.num)return pos<a.pos;
		return num<a.num;
	}
};
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	else return gcd(y,x%y);
}
data tmp,f[2][N];
ll a[N];
int main()
{
	int n;
	ll ans = 0;
	scanf("%d",&n);
	int now = 1,pre = 0;
	int cntn = 0,cntp = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&a[i]);
		for(int j = 1;j <= cntp;j++)
			f[pre][j].num = gcd(f[pre][j].num,a[i]);
		tmp.num = a[i];
		tmp.pos = i;
		cntp++;
		f[pre][cntp] = tmp;
		sort(f[pre]+1,f[pre]+cntp+1);
		cntn = 0;
		for(int j = 1;j<= cntp;j++)
			if(f[pre][j].num!=f[pre][j-1].num)
				f[now][++cntn] = f[pre][j];
		for(int j = 1;j<= cntn;j++)
			ans = max(ans,f[now][j].num*(i-f[now][j].pos+1));
		swap(now,pre);
		cntp = cntn;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4503

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
const double pi = 3.14159265358979323;
#define N 300005
using namespace std;

struct cpx{ double r,i; }a[N],b[N],c[N]; int n1,n2,m,f[N],g[N],pos[N];
char s1[N],s2[N];
cpx operator +(cpx x,cpx y){ x.r+=y.r; x.i+=y.i; return x; }
cpx operator -(cpx x,cpx y){ x.r-=y.r; x.i-=y.i; return x; }
cpx operator *(cpx x,cpx y){
	cpx t; t.r=x.r*y.r-x.i*y.i; t.i=x.r*y.i+x.i*y.r; return t;
}
void dft(cpx *a,int flag){
	int i,j,k; cpx w,wn,u,v;
	if (flag>0) for (i=0; i<m; i++) a[i].i=0;
	for (k=1; k<m; k<<=1){
		wn.r=cos(pi*flag/k); wn.i=sin(pi*flag/k);
		for (i=0; i<m; i+=(k<<1)){
			w.r=1; w.i=0;
			for (j=i; j<i+k; j++){
				u=a[j]; v=a[j+k]*w;
				a[j]=u+v; a[j+k]=u-v; w=w*wn;
			}
		}
	}
	if (flag<0) for (i=0; i<m; i++) a[i].r/=m;
}
int main(){
	scanf("%s%s",s1+1,s2+1); int i,j,k,cnt=0;
	n1=strlen(s1+1); n2=strlen(s2+1);
	for (i=1; i<=n1; i++) f[i]=s1[i]-'a'+1;
	for (i=1; i<=n2; i++) g[n2-i+1]=(s2[i]=='?')?0:s2[i]-'a'+1;
	m=n1+n2+1;
	for (i=1; i<m; i<<=1) cnt++; m=i;
	for (i=0; i<m; i++)
		for (k=i,j=1; j<=cnt; j++,k>>=1) pos[i]=pos[i]<<1|(k&1);
	for (i=0; i<m; i++){ a[pos[i]].r=f[i]*f[i]; b[pos[i]].r=g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=a[i]*b[i];
	for (i=0; i<m; i++){ a[pos[i]].r=1;  b[pos[i]].r=g[i]*g[i]*g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=c[pos[i]]+a[i]*b[i];
	for (i=0; i<m; i++){ a[pos[i]].r=f[i]*2; b[pos[i]].r=g[i]*g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=c[pos[i]]-a[i]*b[i];
	dft(c,-1); cnt=0;/*
	for(int i = 0;i<m;i++)
		printf("%.2f ",c[i].r);*/
	for (i=1; i<=n1-n2+1; i++) if (c[i+n2].r<0.5) f[++cnt]=i;
	printf("%d\n",cnt);
	for (i=1; i<=cnt; i++) printf("%d\n",f[i]-1);
	return 0;
}
Problem4511

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int pre[7];
int main()
{
	int sum = 0;
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		(sum+=x)%=7;
		if(pre[sum])ans = max(ans,i-pre[sum]);
		else pre[sum] = i;
	}
	printf("%d\n",ans);
	return 0;
}
Problem4512

#include <stdio.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2050;
bitset<N>r[N],u[N],v[N];
char s[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	int x =1024,y = 1024,ans = 0;
	for(int i = 1;i<= n;i++)
	{
		v[x][y] = true;
		if(s[i]=='E')
		{
			x++;
			if(!r[x-1][y]&&v[x][y])
				ans++;
			r[x-1][y] = true;
		}else if(s[i]=='W')
		{
			x--;
			if(!r[x][y]&&v[x][y])
				ans++;
			r[x][y] = true;
		}else if(s[i]=='N')
		{
			y--;
			if(!u[x][y]&&v[x][y])
				ans++;
			u[x][y] = true;
		}else
		{
			y++;
			if(!u[x][y-1]&&v[x][y])
				ans++;
			u[x][y-1] = true;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem4513

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll pow2[64];
ll f[100][2][2][2],g[100][2][2][2];
ll mod;
void work()
{
	ll N,M,K;
	scanf("%lld%lld%lld%lld",&N,&M,&K,&mod);
	N--,M--;
	ll ans = 0;
	memset(f,0,sizeof(f));
	memset(g,0,sizeof(g));
	f[0][1][1][1] = 1;
	for(int i=0;i<=63;i++)
		for(int a=0;a<2;a++)
		for(int b=0;b<2;b++)
		for(int c=0;c<2;c++)
			if(f[i][a][b][c])
			{
				int p = ((N&pow2[63-i])==0)?0:1;
				int q = ((M&pow2[63-i])==0)?0:1;
				int t = ((K&pow2[63-i])==0)?0:1;
				for(int x = 0;x<2;x++)
				{
					if(a&&x>p)continue;
					for(int y = 0;y<2;y++)
					{
						if(b&&y>q)continue;
						int z = x^y;
						if(c&&z<t)continue;
						int A = (a&&x==p);
						int B = (b&&y==q);
						int C = (c&&z==t);
						(f[i+1][A][B][C]+=f[i][a][b][c])%=mod;
						g[i+1][A][B][C]=(g[i+1][A][B][C]+g[i][a][b][c]+((z==0)?0:pow2[63-i]%mod)*f[i][a][b][c]%mod)%mod;
					}
				}
			}
	K%=mod;
	for(int a=0;a<2;a++)
		for(int b=0;b<2;b++)
			for(int c=0;c<2;c++)
		    	ans=(ans+g[64][a][b][c]-K*f[64][a][b][c]%mod+mod)%mod;
	printf("%lld\n",ans);
}
int main()
{
	pow2[0] = 1;
	for(int i = 1;i<64;i++)
		pow2[i] = pow2[i-1]*2;
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem4514

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll INF = 1e18;
const int N = 305;
const int M = N*N+10*N;
const int maxX = 1e5+5;
int prime[maxX],cnt;
bool vis[maxX];
struct E
{
	int next,to,from;
	ll c,f;
}e[M];
int head[N],tot = 1,from[N];
void add(int x,int y,ll f,ll c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;e[tot].c = c;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;e[tot].c = -c;
	e[tot].from = y,e[tot-1].from = x;
}
queue<int>Q;
bool v[N];
ll dis[N],rl[N];
void spfa(int S,int T)
{
	for(int i = S;i<= T;i++)dis[i] = -INF;
	Q.push(S);
	dis[S] = 0,vis[S] = true;
	rl[S] = INF;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[x]+e[i].c>dis[e[i].to])
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				rl[e[i].to] = min(rl[x],e[i].f);
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
}
void init()
{
	for(int i = 2;i<maxX;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<maxX;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int a[N],b[N],c[N],f[N];
int main()
{
	init();
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		ll tmp = a[i];
		for(int j = 1;(ll)prime[j]*prime[j]<=(ll)tmp;j++)
			while(tmp%prime[j]==0)f[i]++,tmp/=prime[j];
		if(tmp!=1&&tmp!=-1)f[i]++;
	}
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
	for(int i = 1;i<= n;i++)
		if(f[i]&1)
			for(int j = 1;j<= n;j++)
				if(f[j]==f[i]-1&&a[i]%a[j]==0||f[j]==f[i]+1&&a[j]%a[i]==0)
					add(i,j,INF,(ll)c[i]*c[j]);
	int S = 0,T = n+1;
	for(int i = 1;i<= n;i++)
		if(f[i]&1)
			add(S,i,b[i],0);
		else add(i,T,b[i],0);
	ll now = 0,ans = 0;
	ll tmp = 0;
	while(true)
	{
		spfa(S,T);
		if(dis[T]==-INF||now+dis[T]<0)break;
		if(dis[T]>=0)tmp = rl[T];
		else tmp = min(rl[T],now/(-dis[T]));
		ans+=tmp;
		now+=dis[T]*tmp;
		for(int i = from[T];i;i=from[e[i].from])
			e[i].f-=tmp,e[i^1].f+=tmp;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4515

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long ll;
const ll INF = 123456789123456789ll;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
int dep[N],top[N],size[N],son[N],fa[N],n,m;
ll dis[N];
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dis[e[i].to] = dis[x]+e[i].val;
			dfs1(e[i].to);
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
			size[x]+=size[e[i].to];
		}
}
int dfn[N],seq[N],Dfn;
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct Seg
{ll a,b,mn;}tr[N<<2];
void build(int p,int l,int r)
{
	tr[p].a=0,tr[p].b=INF,tr[p].mn = INF;
	if(l==r)return;
	int mid = (l+r)>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
}
ll calc(ll a,ll b,ll x)
{
	return a*dis[seq[x]]+b;
}
void Update(int p,int l,int r,ll a,ll b)
{
	ll xl = calc(tr[p].a,tr[p].b,l);
	ll xr = calc(tr[p].a,tr[p].b,r);
	ll yl = calc(a,b,l),yr = calc(a,b,r);
	if(xl<=yl&&xr<=yr)return ;
	if(xl>=yl&&xr>=yr){tr[p].a=a,tr[p].b=b;return ;}
	int mid = (l+r)>>1;
	ll xm = calc(tr[p].a,tr[p].b,mid);
	ll ym = calc(a,b,mid);
	if(xm>=ym)
	{
		swap(a,tr[p].a),swap(b,tr[p].b);
		swap(xl,yl),swap(xr,yr),swap(xm,ym);
	}
	if(xl>=yl)Update(p<<1,l,mid,a,b);
	else Update(p<<1|1,mid+1,r,a,b);
}
void update(int p,int l,int r,int a,int b,ll A,ll B)
{
	tr[p].mn = min(tr[p].mn,min(calc(A,B,a),calc(A,B,b)));
	if(l>=a&&r<=b){Update(p,l,r,A,B);return ;}
	int mid = (l+r)>>1;
	if(b<=mid)update(p<<1,l,mid,a,b,A,B);
	else if(a >mid)update(p<<1|1,mid+1,r,a,b,A,B);
	else update(p<<1,l,mid,a,mid,A,B),update(p<<1|1,mid+1,r,mid+1,b,A,B);
}
ll ans;
void getans(int p,int l,int r,int a,int b)
{
	ans = min(ans,min(calc(tr[p].a,tr[p].b,a),calc(tr[p].a,tr[p].b,b)));
	if(l>=a&&r<=b){ans = min(ans,tr[p].mn);return ;}
	int mid = (l+r)>>1;
	if(b<=mid)getans(p<<1,l,mid,a,b);
	else if(a >mid)getans(p<<1|1,mid+1,r,a,b);
	else getans(p<<1,l,mid,a,mid),getans(p<<1|1,mid+1,r,mid+1,b);
	return ;
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
void update(int f,int x,ll a,ll b)
{
	while(top[x]!=top[f])
	{
		update(1,1,n,dfn[top[x]],dfn[x],a,b);
		x = fa[top[x]];
	}
	update(1,1,n,dfn[f],dfn[x],a,b);
}
void getans(int f,int x)
{
	while(top[x]!=top[f])
	{
		getans(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	getans(1,1,n,dfn[f],dfn[x]);
}
int main()
{
	int x,y;
	ll z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%lld",&x,&y,&z);
		add(x,y,z);
	}
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	int opt;
	while(m--)
	{
		scanf("%d%d%d",&opt,&x,&y);
		if(opt==1)
		{
			ll a,b;
			scanf("%lld%lld",&a,&b);
			int lca = getlca(x,y);
			update(lca,x,-a,a*dis[x]+b);
			update(lca,y,a,a*(dis[x]-dis[lca]*2)+b);
		}else
		{
			int lca = getlca(x,y);
			ans = INF;
			getans(lca,x);
			getans(lca,y);
			printf("%lld\n",ans);
		}
	}
	return 0;
}
Problem4516

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct SAM
{
	map<int,int>trs[N];
	int fa[N],len[N];
	int cnt,last;
	long long ans;
	void init(){cnt = last = 1,ans = 0;}
	void insert(int x)
	{
		int p = last,newp = ++cnt,q,newq;
		last = newp,len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)fa[newp] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[newp] = q;
			else
			{
				fa[newq=++cnt]=fa[q];
				len[newq] = len[p]+1;
				trs[newq] = trs[q];
				fa[newp] = fa[q] = newq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=newq;
			}
		}
		ans+=len[newp]-len[fa[newp]];
	}
}sam;
int d[N];
int main()
{
	int n;
	scanf("%d",&n);
	sam.init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&d[i]);
		sam.insert(d[i]);
		printf("%lld\n",sam.ans);
	}
	return 0;
}
Problem4519

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 900;
const int M = 9000;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M<<1];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f=f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f=f;
}
int d[N],n;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t]=0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(mx,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
bool vis[N];
int ans[N][N],a[N],b[N];
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!vis[e[i].to])
			dfs(e[i].to);
}
void reset()
{
	for(int i = 2;i<= tot;i+=2)
		e[i].f=e[i^1].f=(e[i].f+e[i^1].f)>>1;
}
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(vis,0,sizeof(vis));
	dfs(s);
	for(int i = 1;i<= n;i++)
		if(vis[i])
			for(int j = 1;j<= n;j++)
				if(!vis[j])
					ans[i][j]=ans[j][i]=min(ans[i][j],tmp);
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(vis[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)
		a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
int q[N*N],cnt;
int main()
{
	memset(ans,0x3f,sizeof(ans));
	int m,u,v,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	for(int i = 1;i<= n;i++)a[i]=i;
	solve(1,n);
	cnt = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			q[++cnt]=ans[i][j];
	sort(q+1,q+cnt+1);
	cnt = unique(q+1,q+cnt+1)-q-1;
	printf("%d\n",cnt);
	return 0;
}
Problem4521

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;

ll f[20][2][10][10][4][2];
ll pow10[20];
int sta(int a,int b)
{
	return ((a==8||b==8)<<1)|((a==4||b==4));
}
ll dp(ll x)
{
	if(x<pow10[10])return 0;
	int s[20]={};
	int cnt = 0;
	while(x){s[11-cnt]=x%10;x/=10;cnt++;}
	memset(f,0,sizeof(f));
	int ap = sta(s[1],s[2]),fg = 0;
	f[2][0][s[1]][s[2]][ap][0]=1;
	for(int i = 1;i<= s[1];i++)
		for(int j = 0;j<= 9;j++)
		{
			if(i==s[1]&&j>=s[2])continue;
			f[2][1][i][j][sta(i,j)][0]=1;
		}
	for(int i = 3;i<= 11;i++)
	{
		ap|=sta(s[i],s[i]),fg|=(s[i]==s[i-1]&&s[i-1]==s[i-2]);
		if(ap!=3)f[i][0][s[i-1]][s[i]][ap][fg] = 1;
		for(int j = 0;j<= 9;j++)
		for(int k = 0;k<= 9;k++)
		for(int a = 0;a<= 2;a++)
			for(int b = 0;b<= 9;b++)
			{	
				int t1 = a|sta(b,b),t2 = j==k&&k==b;
				if(t1==3)continue;
				f[i][1][k][b][t1][1]+=(b<s[i])*f[i-1][0][j][k][a][1]+f[i-1][1][j][k][a][1];
				f[i][1][k][b][t1][t2]+=(b<s[i])*f[i-1][0][j][k][a][0]+f[i-1][1][j][k][a][0];
			}
	}
	ll ans = 0;
	for(int i = 0;i<= 9;i++)for(int j = 0;j<= 9;j++)
	for(int a = 0;a<= 2;a++)for(int b = 0;b<= 1;b++)
		ans+=f[11][b][i][j][a][1];
	return ans;
}

int main()
{
	ll l,r;
	scanf("%lld%lld",&l,&r);
	pow10[0]=1;
	for(int i = 1;i<= 11;i++)pow10[i]=pow10[i-1]*10;
	printf("%lld\n",dp(r)-dp(l-1));
	return 0;
}
Problem4522

#include<cstdio>
#include<algorithm>
#include<cmath>
#define fo(i,a,b) for(i=a;i<=b;i++)
using namespace std;
typedef long long ll;
ll e,d,n,nn,r,c,a,xx,yy,t,p,q,mod;
void gcd(ll a,ll b)
{
    if (!b)
    {
        xx=1;
        yy=0;
        t=a;
    }
    else
    {
        gcd(b,a%b);
        swap(xx,yy);
        yy-=xx*(a/b);
    }
}
ll getny(ll x,ll y)
{
    gcd(x,y);
    xx=(xx%y+y)%y;
    return xx;
}
int rand() 
{
    static int rand_seed=1542071823;
    rand_seed+=rand_seed<<1|1;
    return rand_seed;
}
ll quick_plus(ll x,ll y)
{
    if (!y) return 0;
    ll t=quick_plus(x,y/2);
    t=(t+t)%mod;
    if (y%2) t=(t+x)%mod;
    return t;
}
ll quick_pow(ll x,ll y)
{
    if (!y) return 1;
    ll t=quick_pow(x,y/2);
    t=quick_plus(t,t);
    if (y%2) t=quick_plus(t,x);
    return t;
}
ll f(ll x)
{
    return (quick_plus(x,x)+a)%mod;
}
ll pollard_rho(ll n)
{
    ll r1,r2,p;
    while (1)
    {
        a=rand()%100;
        r1=r2=2;
        do{
            r1=f(r1);
            r2=f(f(r2));
            gcd(abs(r2-r1),n);
            p=t;
            if (p>1) return p;
        }while (r1!=r2);
    }
}
int main()
{
    scanf("%lld%lld%lld",&e,&n,&c);
    mod=n;
    p=pollard_rho(n);
    q=n/p;
    r=(p-1)*(q-1);
    d=getny(e,r);
    nn=quick_pow(c,d);
    printf("%lld %lld\n",d,nn);
}
Problem4522

#include<cstdio>
#include<algorithm>
#include<cmath>
#define fo(i,a,b) for(i=a;i<=b;i++)
using namespace std;
typedef long long ll;
ll e,d,n,nn,r,c,a,xx,yy,t,p,q,mod;
void gcd(ll a,ll b)
{
    if (!b)
    {
        xx=1;
        yy=0;
        t=a;
    }
    else
    {
        gcd(b,a%b);
        swap(xx,yy);
        yy-=xx*(a/b);
    }
}
ll getny(ll x,ll y)
{
    gcd(x,y);
    xx=(xx%y+y)%y;
    return xx;
}
int rand() 
{
    static int rand_seed=1e9+7;
    rand_seed+=rand_seed<<1|1;
    return rand_seed;
}
ll quick_plus(ll x,ll y)
{
    if (!y) return 0;
    ll t=quick_plus(x,y/2);
    t=(t+t)%mod;
    if (y%2) t=(t+x)%mod;
    return t;
}
ll quick_pow(ll x,ll y)
{
    if (!y) return 1;
    ll t=quick_pow(x,y/2);
    t=quick_plus(t,t);
    if (y%2) t=quick_plus(t,x);
    return t;
}
ll f(ll x)
{
    return (quick_plus(x,x)+a)%mod;
}
ll pollard_rho(ll n)
{
    ll r1,r2,p;
    while (1)
    {
        a=rand()%100;
        r1=r2=2;
        do{
            r1=f(r1);
            r2=f(f(r2));
            gcd(abs(r2-r1),n);
            p=t;
            if (p>1) return p;
        }while (r1!=r2);
    }
}
int main()
{
    scanf("%lld%lld%lld",&e,&n,&c);
    mod=n;
    p=pollard_rho(n);
    q=n/p;
    r=(p-1)*(q-1);
    d=getny(e,r);
    nn=quick_pow(c,d);
    printf("%lld %lld\n",d,nn);
}
Problem4524

#include <stdio.h>
#include <set>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 18000000+5;
struct Heap
{
	int ls,rs;
	int dis;ll key,mul;
}tr[N];
int tot;
ll n;int E;
ll quick_pow(ll x,ll y)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res=res*x;
		x = x*x;
		y>>=1;
	}
	return res;
}
int newnode(int x)
{
	if(!x)return 0;
	int t = ++tot;
	tr[t] = tr[x];
	return t;
}
int multi(int x,ll y)
{
	int t = newnode(x);
	tr[t].mul*=y,tr[t].key*=y;
	return t;
}
void Push_down(int x)
{
	if(tr[x].mul>1)
	{
		tr[x].ls = multi(tr[x].ls,tr[x].mul);
		tr[x].rs = multi(tr[x].rs,tr[x].mul);
		tr[x].mul = 1;
	}
}
int merge(int x,int y)
{
	if(!x)return newnode(y);
	if(!y)return newnode(x);
	Push_down(x),Push_down(y);
	if(tr[x].key<tr[y].key)swap(x,y);
	int t = newnode(x);
	tr[t].rs = merge(tr[x].rs,y);
	if(tr[tr[t].rs].dis>tr[tr[t].ls].dis)
		swap(tr[t].ls,tr[t].rs);
	tr[t].dis = tr[tr[t].rs].dis+1;
	return t;
}
int pop(int x)
{
	Push_down(x);
	return merge(tr[x].ls,tr[x].rs);
}
struct Int
{
	int id;
	Int(int _id):id(_id){}
	bool operator <(const Int &s)const
	{
		return tr[id].key>tr[s.id].key||tr[id].key==tr[s.id].key&&id<s.id;
	}
};
multiset<Int>ans;
int prime[200],cnt;
bool vis[200];
int f[200][100],g[200][200];
void get_prime()
{
	for(int i = 2;i<= 127&&i<= n;i++)
	{
		if(!vis[i])prime[++cnt]=i;
		for(int j = 1;j<=cnt&&i*prime[j]<=127;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	scanf("%lld%d",&n,&E);
	get_prime();
	f[0][0]=g[0][0]=1;
	tr[1].dis = tr[1].key = tr[1].mul = tot = 1;
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = 1;j<= (int)floor(log(n)/log(prime[i]));j++)
		{
			for(int k = 1;k<= j;k++)
			{
				int t = multi(g[i-1][j-k],quick_pow(prime[i],k));
				f[i][j] =merge(f[i][j],t);
			}
			ans.insert(Int(f[i][j]));
			g[i][j] = merge(g[i-1][j],f[i][j]);
		}
		g[i][0]=g[i-1][0];
	}
	E--;
	while(E--)
	{
		int t = (*ans.begin()).id;
		ans.erase(ans.begin());
		ans.insert(Int(merge(tr[t].ls,tr[t].rs)));
	}
	printf("%lld\n",tr[(*ans.begin()).id].key);
	return 0;
}
Problem4525

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int pos[N],n,k;
bool check(int x)
{
	int last = 1,ans = 0;
	for(int i= 1;i<= n;i++)
		if(pos[i]-pos[last]>x)
			ans++,last = i;
	ans++;
	return ans<=k;
}
int main()
{		
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&pos[i]);
	sort(pos+1,pos+n+1);
	int l = 0,r = pos[n]+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(2*mid))r = mid;
		else l = mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem4530

#include <bits/stdc++.h>
#define N 100005
typedef long long ll;
using namespace std;
int n,q,ans,tot,num;
struct Link_Cut_Tree
{
    int c[N][2],fa[N],size1[N],size2[N],q[N],top;
    bool rev[N];
    inline void pushup(int x)
    {
        int l=c[x][0],r=c[x][1];
        size1[x]=size1[l]+size1[r]+size2[x];
    }
    inline bool isroot(int x)
    {return c[fa[x]][1]!=x&&c[fa[x]][0]!=x;}
    inline void pushdown(int x)
    {
        int l=c[x][0],r=c[x][1];
        if(rev[x])
        {
            rev[l]^=1;rev[r]^=1;rev[x]^=1;
            swap(c[x][0],c[x][1]);
        }
    }
    inline void rotate(int x)
    {
        int y=fa[x],z=fa[y],l,r;
        if(c[y][0]==x)l=0;else l=1;r=l^1;
        if(!isroot(y)){if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
        fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
        c[y][l]=c[x][r];c[x][r]=y;
        pushup(y);pushup(x);
    }
    inline void splay(int x)
    {
        top=1;q[top]=x;
        for(int i=x;!isroot(i);i=fa[i])q[++top]=fa[i];
        for(int i=top;i;i--)pushdown(q[i]);
        while(!isroot(x))
        {
            int y=fa[x],z=fa[y];
            if(!isroot(y))
            {
                if((c[z][0]==y)^(c[y][0]==x))rotate(x);
                else rotate(y);
            }
            rotate(x);
        }
        pushup(x);
    }
    void access(int x)
    {
        for(int t=0;x;t=x,x=fa[x])
        {
            splay(x);size2[x]+=size1[c[x][1]];
            c[x][1]=t;size2[x]-=size1[t];pushup(x);
        }
    }
    void makeroot(int x){access(x);splay(x);rev[x]^=1;}
    int find(int x){access(x);splay(x);while(c[x][0])x=c[x][0];return x;}
    void split(int x,int y){makeroot(x);access(y);splay(y);}
    void link(int x,int y)
    {
        makeroot(x);makeroot(y);fa[x]=y;size2[y]+=size1[x];
        pushup(y);
    }
    void cut(int x,int y){split(x,y);if(c[y][0]==x)c[y][0]=0,fa[x]=0;}
    void init(int n)
    {
        for(int i=1;i<=n;i++)size1[i]=size2[i]=1;
    }
}T;
int main()
{
    scanf("%d%d",&n,&q);
    T.init(n);char s[10];
    while(q--)
    {
        scanf("%s",s);
        int x,y;
        scanf("%d%d",&x,&y);
        if(s[0]=='A')T.link(x,y);
        else
        {
            T.makeroot(x);T.access(y);T.splay(x);
            printf("%lld\n",(ll)((T.size2[y])*(T.size1[x]-T.size2[y])));
        }
    }
    return 0;
}
Problem4537

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 1e5+5;
const int Q = 5e4+5;
struct E
{
	int x,y,a,b,id;
	void read(int no)
	{
		scanf("%d%d%d%d",&x,&y,&a,&b);
		id = no;
	}
	bool operator <(const E &s)const
	{
		if(a==s.a)return b<s.b;
		return a<s.a;
	}
}e[M],ask[Q],tmp[Q];
struct Opt
{
	int x,y,fa,mxa,mxb,sz;
}opt[Q];
bool cmp(const E &x,const E &y)
{
	if(x.b==y.b)return x.a<y.a;
	return x.b<y.b;
}
int tot,top;
int fa[N],size[N],mxa[Q],mxb[Q],ans[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return getfa(fa[x]);
}
void merge(int x,int y,int a,int b)
{
	x = getfa(x),y = getfa(y);
	if(size[x]>size[y])swap(x,y);
	opt[++tot].x = x,opt[tot].mxa = mxa[y],opt[tot].mxb = mxb[y];
	opt[tot].y = y,opt[tot].fa = fa[x],opt[tot].sz = size[y];
	if(x==y)
	{
		mxa[x] = max(mxa[x],a);
		mxb[x] = max(mxb[x],b);
		return ;
	}
	fa[x] = y,size[y]+=size[x];
	mxa[y] = max(mxa[y],max(mxa[x],a));
	mxb[y] = max(mxb[y],max(mxb[x],b));
}
void go_back()
{
	while(tot)
	{
		fa[opt[tot].x] = opt[tot].fa;
		mxa[opt[tot].y] = opt[tot].mxa;
		mxb[opt[tot].y] = opt[tot].mxb;
		size[opt[tot].y] = opt[tot].sz;
		tot--;
	}
}
int main()
{
	int n,m,q;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		e[i].read(i);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
		ask[i].read(i);
	sort(e+1,e+m+1);
	sort(ask+1,ask+q+1,cmp);
	int block = sqrt(m);
	for(int i = 1;i<= m;i+=block)
	{
		top = 0;
		for(int j = 1;j<= q;j++)
			if(ask[j].a>=e[i].a&&(i+block>m||ask[j].a<e[i+block].a))
				tmp[++top] = ask[j];
		sort(e+1,e+i,cmp);
		for(int j = 1;j<= n;j++)fa[j]=j,size[j]=1,mxa[j]=mxb[j]=-1;
		for(int j = 1,k = 1;j<= top;j++)
		{
			for(;k<i&&e[k].b<=tmp[j].b;k++)
				merge(e[k].x,e[k].y,e[k].a,e[k].b);
			tot = 0;
			for(int l = i;l<i+block&&l<=m;l++)
				if(e[l].a<=tmp[j].a&&e[l].b<=tmp[j].b)
					merge(e[l].x,e[l].y,e[l].a,e[l].b);
			int x = getfa(tmp[j].x),y = getfa(tmp[j].y);
			ans[tmp[j].id] = x==y&&mxa[x]==tmp[j].a&&mxb[x]==tmp[j].b;
			go_back();
		}
	}
	for(int i = 1;i<= q;i++)
		if(ans[i])printf("Yes\n");
		else printf("No\n");
	return 0;
}
Problem4538

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,m;

struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;
}
int son[N],size[N],dfn[N],top[N],Dfn,fa[N],dep[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] =dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>=size[son[x]])son[x]=e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}

struct Heap
{
	priority_queue<int>a,b;
	void del(int val){b.push(val);}
	void push(int val){a.push(val);}
	int top()
	{
		while(!b.empty()&&a.top()==b.top()) a.pop(),b.pop();
        if(a.empty()) return -1;
        return a.top();
	}
}t[270005];
void update(int p,int l,int r,int a,int b,int val,bool flag)
{
	if(a>b)return ;
	if(l>=a&&r<=b)
	{
		if(!flag)t[p].push(val);
		else t[p].del(val);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,val,flag);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,val,flag);
}
int getans(int p,int l,int r,int pos)
{
	if(l==r)
		return t[p].top();
	int mid = (l+r)>>1;
	if(pos<=mid)return max(t[p].top(),getans(p<<1,l,mid,pos));
	else return max(t[p].top(),getans(p<<1|1,mid+1,r,pos));
}

vector<pair<int,int> >stack;
void Update(int x,int y,int val,bool flag)
{
	stack.clear();
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		stack.push_back(make_pair(dfn[top[x]],dfn[x]));
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	stack.push_back(make_pair(dfn[y],dfn[x]));
	sort(stack.begin(),stack.end());
	x = 1;
	int sz = stack.size();
	for(int i = 0;i<sz;i++)
	{
		update(1,1,n,x,stack[i].first-1,val,flag);
		x = stack[i].second+1;
	}
	update(1,1,n,x,n,val,flag);
	return ;
}

int X[N<<1],Y[N<<1],Z[N<<1];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&X[0],&Y[0]);
		add(X[0],Y[0]);
	}
	int root = rand()%n+1;
	dfs1(root);
	dfs2(root,root);
	int tp;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&tp);
		if(tp==0)
		{
			scanf("%d%d%d",&X[i],&Y[i],&Z[i]);
			Update(X[i],Y[i],Z[i],(bool)tp);
		}else if(tp==1)
		{
			scanf("%d",&X[i]);
			Update(X[X[i]],Y[X[i]],Z[X[i]],(bool)tp);
		}else
		{
			scanf("%d",&X[i]);
			printf("%d\n",getans(1,1,n,dfn[X[i]]));
		}
	}
	return 0;
}
Problem4539

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int maxn = 2e5+5;
const int M = 2e6+5;
ll N;
int idx,n,m,q,root[maxn],from[maxn];
namespace seg
{
	int sz[M],ls[M],rs[M],root[maxn],tot;
	void Insert(int &p,int pre,int l,int r,int v)
	{
		p = ++tot;
		sz[p] = sz[pre]+1;
		if(l==r)return ;
		int mid = (l+r)>>1;
		ls[p] = ls[pre],rs[p] = rs[pre];
		if(v<=mid)Insert(ls[p],ls[pre],l,mid,v);
		else Insert(rs[p],rs[pre],mid+1,r,v);
	}
	void insert(int idx,int x)
	{
		Insert(root[idx],root[idx-1],1,n,x);
	}
	int calc(int x,int y,int k)
	{
		x = root[x-1],y = root[y];
		int l= 1,r = n;
		while(l<r)
		{
			int mid = (l+r)>>1;
			if(sz[ls[y]]-sz[ls[x]]>=k)r=mid,y = ls[y],x = ls[x];
			else k-=sz[ls[y]]-sz[ls[x]],l=mid+1,y = rs[y],x = rs[x];
		}
		return l;
	}
}
int size[maxn],dfn[maxn],last[maxn];
struct Gragh
{
	struct E
	{int next,to;ll val;}e[maxn<<1];
	int head[maxn],tot;
	void add(int x,int y,ll f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
	}
	int dep[maxn],fa[maxn][18],Dfn;
	ll dis[maxn];
	void dfs1(int x)
	{
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<= 17;i++)
			fa[x][i] = fa[fa[x][i-1]][i-1];
		for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa[x][0])
		{
			dis[e[i].to] = dis[x]+e[i].val;
			fa[e[i].to][0] = x;
			dfs1(e[i].to);
		}
	}
	void dfs2(int x)
	{
		dfn[x] = ++Dfn;
		seg::insert(Dfn,x);
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x][0])
			{
				dfs2(e[i].to);
				size[x] += size[e[i].to];
			}
		last[x] = Dfn;
	}
	int go_up(int x,int d)
	{
		for(int i = 17;i>= 0;i--)
			if((d>>i)&1)x=fa[x][i];
		return x;
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i =17;i>= 0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 17;i>= 0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	ll getdis(int x,int y)
	{
		return dis[x]+dis[y]-dis[getlca(x,y)]*2;
	}
	int find(int x,int v)
	{
		return go_up(x,dep[x]-dep[v]-1);
	}
}G[2];
ll list[maxn];
int getpos(ll x)
{
	return lower_bound(list+1,list+idx+1,x)-list;
}
int main()
{
	ll x,y;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		G[0].add(x,y,1);
	}
	G[0].dfs1(1);
	G[0].dfs2(1);
	N = n,idx = 1;
	root[1] = 1;
	list[1] = N;
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld",&x,&y);
		int t = getpos(y),r=root[t],yy=seg::calc(dfn[r],last[r],y-list[t-1]);
		G[1].add(t,idx+1,G[0].dis[yy]-G[0].dis[r]+1);
		N+=size[x],root[++idx] = x,list[idx] = N,from[idx] = yy;
	}
	G[1].dfs1(1);
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld%lld",&x,&y);
		int tx = getpos(x),rx = root[tx],xx = seg::calc(dfn[rx],last[rx],x-list[tx-1]);
		int ty = getpos(y),ry = root[ty],yy = seg::calc(dfn[ry],last[ry],y-list[ty-1]);
		int lca = G[1].getlca(tx,ty);
		ll ans = G[0].dis[xx]+G[0].dis[yy]-G[0].dis[rx]-G[0].dis[ry]+G[1].getdis(tx,ty);
		if(tx==ty)
		{
			printf("%lld\n",G[0].getdis(xx,yy));
		}else if(tx==lca)
		{
			int fry = from[G[1].find(ty,lca)];
			printf("%lld\n",ans-(G[0].dis[xx]+G[0].dis[fry]-G[0].getdis(xx,fry)-2*G[0].dis[rx]));
		}else if(ty==lca)
		{
			int frx = from[G[1].find(tx,lca)];
			printf("%lld\n",ans-(G[0].dis[yy]+G[0].dis[frx]-G[0].getdis(yy,frx)-2*G[0].dis[ry]));
		}else
		{
			int frx = from[G[1].find(tx,lca)];
			int fry = from[G[1].find(ty,lca)];
			printf("%lld\n",ans-(G[0].dis[frx]+G[0].dis[fry]-G[0].getdis(frx,fry)-2*G[0].dis[root[lca]]));
		}
	}
	return 0;
}
Problem4540

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
int a[N],lg2[N];
int st[N][18],n,q;
int Min(int x,int y)
{
	return a[x]<a[y]?x:y;
}
void build_st()
{
	for(int i = 2;i<= n;i++)
		lg2[i] = lg2[i>>1]+1;
	for(int i = 1;i<= n;i++)
		st[i][0] = i;
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<=n;i++)
		{
			st[i][j] = st[i][j-1];
			if(i+(1<<(j-1))<=n)
				st[i][j] = Min(st[i][j],st[i+(1<<(j-1))][j-1]);
		}
}
int Ask(int l,int r)
{
	if(l>r)swap(l,r);
	int lth = lg2[r-l+1];
	return Min(st[l][lth],st[r-(1<<lth)+1][lth]);
}

ll left[N],right[N];
int stack[N],top;
void init()
{
	stack[top=0]=0;
	for(int i = 1;i<= n;i++)
	{
		while(top&&a[stack[top]]>=a[i])top--;
		right[i] = right[stack[top]]+(ll)a[i]*(i-stack[top]);
		stack[++top] = i;
	}
	stack[top=0]=n+1;
	for(int i = n;i;i--)
	{
		while(top&&a[stack[top]]>=a[i])top--;
		left[i] = left[stack[top]]+(ll)a[i]*(stack[top]-i);
		stack[++top] = i;
	}
}
ll getleft(int l,int r)
{
	int t = Ask(l,r);
	return (ll)a[t]*(r-t+1)+left[l]-left[t];
}
ll getright(int l,int r)
{
	int t = Ask(l,r);
	return (ll)a[t]*(t-l+1)+right[r]-right[t];
}

struct Ask
{
	int l,r,lpos,id;
	bool operator <(const Ask &s)const
	{
		if(lpos==s.lpos)return r<s.r;
		return lpos<s.lpos;
	}
}ask[N];
ll ans;
ll Ans[N];
void solve()
{
	int l = 1,r = 0;
	for(int i = 1;i<= q;i++)
	{
		while(r<ask[i].r)ans+=getright(l,++r);
		while(r>ask[i].r)ans-=getright(l,r--);
		while(l<ask[i].l)ans-=getleft(l++,r);
		while(l>ask[i].l)ans+=getleft(--l,r);
		Ans[ask[i].id] = ans;
	}
}

int main()
{
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	build_st();
	init();
	int block = sqrt(q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].lpos = (ask[i].l-1)/block+1;
		ask[i].id = i;
	}
	sort(ask+1,ask+q+1);
	solve();
	for(int i = 1;i<= q;i++)
		printf("%lld\n",Ans[i]);
	return 0;
}
Problem4541

#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <math.h>
#include <vector>
using namespace std;
const int N=200010;
typedef long long ll;
struct point
{
    int x,y;
    friend ll operator *(const point &a,const point &b)
    {
        return (ll)a.x*b.y-(ll)b.x*a.y;
    }
    friend point operator -(const point &a,const point &b)
    {
        point tmp;
        tmp.x=a.x-b.x; tmp.y=a.y-b.y;
        return tmp;
    }
}p[N];
struct edge
{
    int u,v,id;
    double ang;
    edge(){}
    edge(int a,int b,int k)
    {
        u=a; v=b; id=k;
        ang=atan2((double)p[b].y-p[a].y,(double)p[b].x-p[a].x);
    }
    friend bool operator <(const edge &a,const edge &b)
    {
        return a.ang<b.ang;
    }
}e[6*N];
vector<edge> E[N],TE[N*2];
int Nex[N*6],v[N*6],cnt=1,num,rt;
int vi[N*2],fa[N*2],flag[N*6];
int n,m,k,x,y,rec,q[N];
ll ans1,ans2,P,S[N*2],S1[N*2];

int Find(int x,const edge &a)
{
    int mid,l=0,r=E[x].size();
    while(r-l>1)
    {
        mid=(l+r)>>1;
        if(a<E[x][mid]) r=mid;
        else l=mid;
    }
    return l;
}
ll gcd(ll a,ll b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}
void solve()
{
    int now,tmp,st; ll s;
    for(int i=2;i<=cnt;i++)
    if(!v[i])
    {
        s=0; now=i; v[i]=++num; st=e[i].u;
        while(1)
        {
            tmp=Nex[now]; v[tmp]=num;
            if(e[tmp].v==st) break;
            s+=(p[e[tmp].u]-p[st])*(p[e[tmp].v]-p[st]);
            now=tmp;
        }
        S[num]=s;
        if(s<=0) rt=num;
    }
    for(int i=2;i<=cnt;i++) 
    TE[v[i]].push_back(edge(v[i],v[i^1],i));
}
void dfs(int x)
{
    vi[x]=1; S1[x]=S[x]*S[x]; S[x]*=2;
    for(int i=0;i<(int)TE[x].size();i++)
    if(!vi[TE[x][i].v])
    {
        fa[TE[x][i].v]=x;
        flag[TE[x][i].id]=1;
        flag[TE[x][i].id^1]=1;
        dfs(TE[x][i].v);
        S[x]+=S[TE[x][i].v];
        S1[x]+=S1[TE[x][i].v];
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++) scanf("%d%d",&p[i].x,&p[i].y);
    for(int i=1;i<=m;i++) 
    {
        scanf("%d%d",&x,&y);
        ++cnt; e[cnt]=edge(x,y,cnt);
        E[x].push_back(e[cnt]);
        ++cnt; e[cnt]=edge(y,x,cnt);
        E[y].push_back(e[cnt]);
    }
    for(int i=1;i<=n;i++) sort(E[i].begin(),E[i].end());
    for(int i=2;i<=cnt;i++)
    {
        Nex[i]=Find(e[i].v,e[i^1])-1;
        if(Nex[i]<0) Nex[i]=E[e[i].v].size()-1;
        Nex[i]=E[e[i].v][Nex[i]].id;
    }
    solve(); dfs(rt);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&q[0]);q[0]=(q[0]+P)%n+1;
        for(int j=1;j<=q[0];j++) scanf("%d",&q[j]),q[j]=(q[j]+P)%n+1;
        ans1=ans2=0; q[++q[0]]=q[1];
        for(int j=1;j<q[0];j++)
        {
            x=q[j]; y=q[j+1];
            int tmp=Find(x,edge(x,y,0));
            tmp=E[x][tmp].id;
            if(!flag[tmp]) continue;
            if(v[tmp]==fa[v[tmp^1]]) ans1+=S[v[tmp^1]],ans2+=S1[v[tmp^1]];
            else ans1-=S[v[tmp]],ans2-=S1[v[tmp]];
        }
        if(ans1<0) ans1=-ans1,ans2=-ans2;
        ll d=gcd(ans1,ans2); ans1/=d; ans2/=d;
        printf("%lld %lld\n",P=ans2,ans1);
    }
    return 0;
}
Problem4542

#include <stdio.h>
#include <math.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
struct Ask
{
	int l,r,lpos,id;
	bool operator <(const Ask &s)const
	{
		if(lpos==s.lpos)return r<s.r;
		return lpos<s.lpos;
	}
}ask[N];
ll s[N],cd[N],ba[N],Ans[N];
char str[N];
map<ll,ll>tt;
int main()
{
	ll p;
	int n,m;
	scanf("%lld",&p);
	scanf("%s",str+1);
	scanf("%d",&m);
	n = strlen(str+1);
	if(p!=2&&p!=5)
	{
		ll pow10 = 1;
		for(int i = n;i;i--)
		{
			pow10 = pow10*10%p;
			s[i] = (s[i+1]+(ll)(str[i]-'0')*pow10%p)%p;
			cd[i] = s[i];
		}
		sort(cd+1,cd+n+1);
		for(int i= 1;i<= n+1;i++)
			tt[cd[i]]=i;
		for(int i = 1;i<= n+1;i++)
			s[i] = tt[s[i]];
		int block = sqrt(n);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&ask[i].l,&ask[i].r);
			ask[i].r++;
			ask[i].lpos = ask[i].l/block;
			ask[i].id = i;
		}
		sort(ask+1,ask+m+1);
		ll ans = 0;
		int l = 1,r = 0;
		for(int i = 1;i<= m;i++)
		{
			while(r<ask[i].r)ans+=ba[s[++r]]++;
			while(r>ask[i].r)ans-=--ba[s[r--]];
			while(l<ask[i].l)ans-=--ba[s[l++]];
			while(l>ask[i].l)ans+=ba[s[--l]]++;
			Ans[ask[i].id] = ans;
		}
		for(int i = 1;i<= m;i++)
			printf("%lld\n",Ans[i]);
	}else
	{
		for(int i = 1;i<= n;i++)
		{
			if(!((str[i]-'0')%p))
				ba[i] = ba[i-1]+1,cd[i] = cd[i-1]+i;
			else ba[i] = ba[i-1],cd[i] = cd[i-1];
		}
		for(int i = 1;i<= m;i++)
		{
			int l,r;
			scanf("%d%d",&l,&r);
			printf("%lld\n",cd[r]-cd[l-1]-(ba[r]-ba[l-1])*(l-1));
		}
	}
	return 0;
}
Problem4551

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int mx[N<<2],lazy[N<<2],dep[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,in[N],out[N],Dfn;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	in[x] = ++Dfn;
	dep[x] = dep[fa]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	out[x] = Dfn;
}
inline int merge(int x,int y)
{
	return dep[x]>dep[y]?x:y;
}
inline void Push_down(int p)
{
	if(!lazy[p])return ;
	mx[p<<1] = merge(mx[p<<1],lazy[p]),mx[p<<1|1] = merge(mx[p<<1|1],lazy[p]);
	lazy[p<<1] = merge(lazy[p<<1],lazy[p]),lazy[p<<1|1] = merge(lazy[p<<1|1],lazy[p]);
	lazy[p] = 0;
}
void build(int p,int l,int r)
{
	lazy[p] = 0;
	if(l==r){mx[p]=1;return ;}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);build(p<<1|1,mid+1,r);
	mx[p] = merge(mx[p<<1],mx[p<<1|1]);
}
void update(int p,int l,int r,int a,int b,int id)
{
	if(l>=a&&r<=b)
	{
		mx[p] = merge(mx[p],id);lazy[p] = merge(lazy[p],id);
		return ;
	}
	Push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,id);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,id);
	mx[p] = merge(mx[p<<1],mx[p<<1|1]);
}
int getans(int p,int l,int r,int pos)
{
	if(l==r)return mx[p];
	Push_down(p);
	int mid = (l+r)>>1;
	if(pos<=mid)return getans(p<<1,l,mid,pos);
	else return getans(p<<1|1,mid+1,r,pos);
}
int main()
{
	//freopen("x.in","r",stdin);
	int n,q,x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	build(1,1,n);
	char opt[3];
	while(q--)
	{
		scanf("%s%d",opt,&x);
		if(opt[0]=='Q')printf("%d\n",getans(1,1,n,in[x]));
		else update(1,1,n,in[x],out[x],x);
	}
	return 0;
}
Problem4552

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int sum[N<<2],cov[N<<2];
int a[N];
int MID;
void build(int p,int l,int r)
{
	cov[p] = -1;
	if(l==r)
	{
		sum[p] = a[l]>=MID;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
inline void Push_down(int p,int l,int r)
{
	if(cov[p]==-1)return ;
	int mid = (l+r)>>1;
	if(cov[p]==1)
	{
		sum[p<<1] = mid-l+1;sum[p<<1|1] = r-mid;
		cov[p<<1] = cov[p],cov[p<<1|1] = cov[p];
	}else
	{
		sum[p<<1] = sum[p<<1|1] = cov[p<<1] = cov[p<<1|1] = 0;
	}
	cov[p] = -1;
}
void Update(int p,int l,int r,int a,int b,int v)
{
	if(a>b)return ;
	if(l>=a&&r<=b)
	{
		sum[p] = (r-l+1)*v;
		cov[p] = v;
		return ;
	}
	Push_down(p,l,r);
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,v);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,v);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int Getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	Push_down(p,l,r);
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getsum(p<<1,l,mid,a,b);
	if(b >mid)ans+=Getsum(p<<1|1,mid+1,r,a,b);
	return ans;
}
int opt[N],l[N],r[N];
int n,m,q;
bool check(int mid)
{
	MID = mid;
	build(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		int tmp = Getsum(1,1,n,l[i],r[i]);
		int lth = r[i]-l[i]+1;
		if(!opt[i])
		{
			Update(1,1,n,l[i],l[i]+lth-tmp-1,0);
			Update(1,1,n,l[i]+lth-tmp,r[i],1);
		}else
		{
			Update(1,1,n,l[i],l[i]+tmp-1,1);
			Update(1,1,n,l[i]+tmp,r[i],0);
		}
	}
	return Getsum(1,1,n,q,q)==1;
}
int main()
{
	//freopen("x.in","r",stdin);
	//freopen("x.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&opt[i],&l[i],&r[i]);
	scanf("%d",&q);
	int L = 1,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(check(mid))L = mid+1;
		else R = mid;
	}
	printf("%d\n",L-1);
	return 0;
}
Problem4553

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int MX = 1e5;
const int N = 1e5+5;
const int M = 1e7+5;
int rot[N],ls[M],rs[M],mx[M],tot,f[N],a[N];
void update(int &p,int l,int r,int pos,int val)
{
	if(!p)p = ++tot;
	mx[p] = max(mx[p],val);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],l,mid,pos,val);
	else update(rs[p],mid+1,r,pos,val);
}
int getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(ls[p],l,mid,a,b);
	else if(a>mid)return getans(rs[p],mid+1,r,a,b);
	else return max(getans(ls[p],l,mid,a,b),getans(rs[p],mid+1,r,a,b));
}
void Update(int x,int y)
{
	for(int i = x;i<=MX;i+=i&(-i))
		update(rot[i],1,MX,a[y],f[y]);
}
int Getans(int x,int y)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))
		ans = max(ans,getans(rot[i],1,MX,1,y));
	return ans;
}
int Mx[N],Mn[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),Mx[i]=Mn[i]=a[i];
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		Mx[x] = max(Mx[x],y);Mn[x] = min(Mn[x],y); 
	}
	//for(int i = 1;i<= n;i++)f[i] = 1;
	for(int i = 1;i<= n;i++)
	{
		f[i] = Getans(a[i],Mn[i])+1;
		Update(Mx[i],i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)ans = max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4554

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6005;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[N*10];
int head[N],tot=1;
int d[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
bool bfs(int s,int t)
{
	for(int i = s;i<=t;i++)d[i]=-1;
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int n,m;
char s[55][55];
inline int id(int x,int y)
{
	return (x-1)*m+y;
}
int bl1[N],bl2[N];
int main()
{
	int cnt1=1,cnt2=1;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= m;j++)
			if(s[i][j]=='#')cnt1++;
			else bl1[id(i,j)] = cnt1;
		cnt1++;
	}
	for(int j = 1;j<= m;j++)
	{
		for(int i = 1;i<= n;i++)
			if(s[i][j]=='#')cnt2++;
			else bl2[id(i,j)]=cnt2;
		cnt2++;
	}
	int S =0,T = cnt1+cnt2+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(s[i][j]=='*')add(bl1[id(i,j)],bl2[id(i,j)]+cnt1,1);
	for(int i = 1;i<= cnt1;i++)add(S,i,1);
	for(int i = 1;i<= cnt2;i++)add(i+cnt1,T,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem4555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 261244*2;
const int mod = 998244353;
int quick_pow(int x,int y)
{
    int res = 1;
    while(y)
    {
        if(y&1)res = (ll)res*x%mod;
        x = (ll)x*x%mod;
        y>>=1;
    }
    return res;
}
void NTT(int *a,int len,int type)
{
	//for(int i = 0;i<len;i++)printf("%d ",a[i]);
	//printf("\n");
    int t = 0;
    for(int i = 0;i<len;i++)
    {
        if(t<i)swap(a[t],a[i]);
        for(int j = len>>1;(t^=j)<j;j>>=1);
    }
    for(int i = 2;i<= len;i<<=1)
    {
        int wn = quick_pow(3,(mod-1)/i);
        for(int j = 0;j<len;j+=i)
        {
            int w = 1,tmp;
            for(int k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
            {
                tmp = (ll)a[j+k+(i>>1)]*w%mod;
                a[j+k+(i>>1)] = (a[j+k]-tmp)%mod;
                a[j+k] = (a[j+k]+tmp)%mod;
            }
        }
    }
    if(type==-1)
    {
        for(int i = 1;i<len>>1;i++)swap(a[i],a[len-i]);
        int Inv = quick_pow(len,mod-2);
        for(int i = 0;i<len;i++)
            a[i] = (ll)a[i]*Inv%mod;
    }
	//for(int i = 0;i<len;i++)printf("%d ",a[i]);
	//printf("\n");
}
void conv(int *a,int *b,int *c,int len)
{
    NTT(a,len,1),NTT(b,len,1);
    for(int i = 0;i<len;i++)c[i]=(ll)a[i]*b[i]%mod;
    NTT(c,len,-1);
}
int fac[N],env[N],a[N],b[N],c[N];
int main()
{
    int n,len=1;
    scanf("%d",&n);
    for(;len<=2*n;len<<=1);
    fac[0] = 1;
    for(int i = 1;i<= n;i++)fac[i]=(ll)fac[i-1]*i%mod;
    env[n] = quick_pow(fac[n],mod-2);
    for(int i = n-1;i>=0;i--)env[i] = (ll)env[i+1]*(i+1)%mod;
    for(int i = 0;i<= n;i++)a[i]=i%2?-env[i]:env[i];
    b[0]=1,b[1]=n+1;
    for(int i = 2;i<= n;i++)b[i]=(ll)(quick_pow(i,n+1)-1)*quick_pow(i-1,mod-2)%mod*env[i]%mod;
    conv(a,b,c,len);
    int j = 1,ans=0;
    for(int i = 0;i<=n;i++)
    {
        if(i)j=(ll)j*i%mod;
        ans=(ans+(ll)quick_pow(2,i)*fac[i]%mod*c[i]%mod)%mod;
        ans = (ans+mod)%mod;
    }
    printf("%d\n",(ans%mod+mod)%mod);
    return 0;
}
Problem4556

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 5e6+5;
int ls[M],rs[M],sum[M];
int rot[N],Cnt,n,m;
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++Cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
int getans(int L,int R,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[R]-sum[L];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[L],ls[R],l,mid,a,b);
	if(b >mid)ans+=getans(rs[L],rs[R],mid+1,r,a,b);
	return ans;
}
int sa[N],cnt[N],val[N],rnk[N],h[N],q[N],nv[N];
char s[N];
inline bool is_same(int a,int b,int hl,int len)
{return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[val[i]]] = i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[i]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]] = q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i=j+1;k<=j;k++)nv[sa[k]] = lim;
		}
		if(lim==len)break;
		for(i = 0;i<len;i++)val[i]=nv[i];
	}
}
void build_rank(int len)
{for(int i = 0;i<=len;i++)rnk[sa[i]]=i;}
int mn[N][18];
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]] = j;
		}
}
int lg2[N];
void build_st(int len)
{
	for(int i = 2;i<= len;i++)lg2[i] = lg2[i>>1]+1;
	for(int i = 0;i<=len;i++)mn[i][0] = h[i];
	for(int j = 1;j<= 18;j++)
		for(int i = 0;i+(1<<j)-1<= len;i++)
			mn[i][j] = min(mn[i][j-1],mn[i+(1<<(j-1))][j-1]);
}
int main()
{
	//freopen("x.in","r",stdin);
	scanf("%d%d",&n,&m);
	scanf("%s",s);
	int a,b,c,d;
	build_sa(n+1,256);
	build_rank(n);build_height(n);
	build_st(n);
	for(int i = 1;i<= n;i++)
		update(rot[i],rot[i-1],1,n,sa[i]+1);
	while(m--)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		int l = 1,r = min(d-c+1,b-a+1),ans=0,mid;
		while(l<=r)
		{
			mid = (l+r)>>1;
			int lp = rnk[c-1],rp = lp;
			for(int k = lg2[n];k>=0;k--)
			{
				if(lp>=(1<<k) && mn[lp-(1<<k)+1][k]>=mid)lp-=(1<<k);
				if(rp<=n-(1<<k) && mn[rp+1][k]>=mid)rp+=(1<<k);
			}
			if(getans(rot[lp-1],rot[rp],1,n,a,b-mid+1)>0)ans = mid,l=mid+1;
			else r = mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem4557

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,d,m;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][25],g[N][25];
int w[N];bool need[N];
void dfs(int x,int fa)
{
	f[x][0] = g[x][0] = need[x]?w[x]:0;
	for(int i = 1;i<= d;i++)g[x][i]=w[x];
	g[x][d+1] = INF; 
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			for(int j = 0;j<= d;j++)
				g[x][j] = min(g[x][j]+f[e[i].to][j],g[e[i].to][j+1]+f[x][j+1]);
			for(int j = d;j>=0;j--)g[x][j] = min(g[x][j+1],g[x][j]);
			f[x][0]=g[x][0];
			for(int j = 1;j<=d;j++)f[x][j]+=f[e[i].to][j-1];
			for(int j = 1;j<=d;j++)f[x][j] = min(f[x][j-1],f[x][j]);
		}
}
int main()
{
	scanf("%d%d",&n,&d);
	for(int i = 1;i<= n;i++)
		scanf("%d",&w[i]);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		int x;
		scanf("%d",&x);
		need[x] = true;
	}
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	printf("%d\n",f[1][0]);
	return 0;
}
Problem4558

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int mod = 1e8+7;
typedef long long ll;
const int N = 2005;
const int MOD = 1880213;
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
}p[N];
int n,m,k;
bool inmap(const Point &s)
{
	return s.x<=n&&s.x>=0&&s.y<=m&&s.y>=0;
}
struct Hash
{
	int head[MOD],tot;
	int nxt[N],x[N],y[N];
	void add(int a,int b)
	{
		int tmp = ((ll)a*37+b)%MOD;
		++tot;
		nxt[tot] = head[tmp];
		x[tot] = a,y[tot] = b;
		head[tmp] = tot;
	}
	bool check(int a,int b)
	{
		int tmp = ((ll)a*37+b)%MOD;
		for(int i = head[tmp];i;i=nxt[i])
			if(x[i]==a&&y[i]==b)
				return true;
		return false;
	}
}hash;
ll calc(ll x,ll y)
{
	return (x+y)*(y-x+1)>>1;
}
ll Calc(ll x,ll y,ll z)
{
	if(!x || !y || z<2)return 0;
	z = min(z,x+y);
	x = min(x,z-1),y = min(y,z-1);
	ll sum = 0;
	sum = (sum+(ll)(z-y)*y%mod)%mod;
	sum = (sum+calc(z-x,y-1))%mod;
	return sum;
}
ll t1=0,t2=0,t3=0,t4=0;
void calc(const Point &p3,const Point &p4)
{
	if(inmap(p3)&&inmap(p4))
	{
		int tmp = hash.check(p3.x,p3.y)+hash.check(p4.x,p4.y);
		t2++;
		t3+=tmp;
		if(tmp>1)t4++;
	}
}
void Calc(const Point &p1,const Point &p2)
{
	int dx = p2.x-p1.x,dy = p2.y-p1.y;
	calc(Point(p1.x+dy,p1.y-dx),Point(p2.x+dy,p2.y-dx));
	calc(Point(p1.x-dy,p1.y+dx),Point(p2.x-dy,p2.y+dx));
	if(abs(dx+dy)&1)return ;
	dy = (dx+dy)>>1;
	dx-=dy;
	calc(Point(p1.x+dx,p1.y+dy),Point(p2.x-dx,p2.y-dy));
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		hash.add(p[i].x,p[i].y);
	}
	ll ans = 0;
	for(int i = 1;i<= n&&i<= m;i++)
		ans = (ans+(ll)i*(n-i+1)%mod*(m-i+1)%mod)%mod;
	for(int i = 1;i<= k;i++)
	{
		(t1+=Calc(p[i].x,n-p[i].x,p[i].y))%=mod;
		(t1+=Calc(p[i].x,n-p[i].x,m-p[i].y))%=mod;
		(t1+=Calc(p[i].y,m-p[i].y,p[i].x))%=mod;
		(t1+=Calc(p[i].y,m-p[i].y,n-p[i].x))%=mod;
		t1 = t1+min(p[i].x,p[i].y)+min(n-p[i].x,p[i].y)+min(p[i].x,m-p[i].y)+min(n-p[i].x,m-p[i].y);
		t1 = t1%mod;
		for(int j = 1;j<i;j++)
			Calc(p[i],p[j]);
	}
	ans = ((((ans-t1+mod)%mod+t2)%mod-t3/3)%mod+mod+t4/6)%mod;
	ans = (ans+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4559

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 105;
const int mod = 1e9+7;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int fac[N*N],env[N*N],Pow[N];
void init()
{
	fac[0] = env[0] = 1;
	for(int i = 1;i<= 10000;i++)
		fac[i] = (ll)fac[i-1]*i%mod;
	env[10000] = quick_pow(fac[10000],mod-2);
	for(int i = 9999;i>=1;i--)
		env[i] = (ll)env[i+1]*(i+1)%mod;
}
ll C(int n,int m)
{
	if(m>n)return 0;
	return (ll)fac[n]*env[m]%mod*env[n-m]%mod;
}
int f[N],g[N],rnk[N],s[N];
int n,m,k;
int main()
{
	init();
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)scanf("%d",&s[i]);
	int mxrnk=0;
	for(int i = 1;i<= m;i++)scanf("%d",&rnk[i]),mxrnk=max(mxrnk,rnk[i]);
	for(int i = n-mxrnk;i>= k;i--)
	{
		f[i] = C(n-1,i);
		for(int j = 1;j<= m;j++)
			f[i] = (ll)f[i]*C(n-i-1,rnk[j]-1)%mod;
		for(int j = i+1;j<= n-mxrnk;j++)
			f[i] = (f[i]-(ll)f[j]*C(j,i)%mod+mod)%mod;
	}
	int ans = 1;
	for(int i = 1;i<= m;i++)
	{
		g[0] = s[i];
		Pow[0] = 1;
		for(int j = 1;j<= n;j++)
		{
			Pow[j] = (ll)Pow[j-1]*s[i]%mod;
			g[j] = quick_pow(s[i]+1,j+1)-1;
			for(int k = 1;k<= j;k++)
				(g[j]+=mod-C(j+1,k+1)*g[j-k]%mod)%=mod;
			g[j]=(ll)g[j]*quick_pow(C(j+1,1),mod-2)%mod;
		}
		int now = 0;
		for(int j = 0,k = 1;j<rnk[i];j++,k = -k)
			now = (now+(ll)(mod+k)*C(rnk[i]-1,j)%mod*g[n-rnk[i]+j]%mod*Pow[rnk[i]-j-1]%mod)%mod;
		ans = (ll)ans*now%mod;
	}
	printf("%lld\n",(ll)ans*f[k]%mod);
	return 0;
}
Problem4561

#include <stdio.h>
#include <math.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
ll sqr(ll x){return x*x;}
struct Cir
{
	ll x,y,r;
}c[N];
ll T;
struct data
{
	ll num,x,o;
	data(){}
	data(ll _num,ll _x,ll _o):num(_num),x(_x),o(_o){}
	bool operator <(const data &s)const
	{
		double xx = c[num].y+o*sqrt(sqr(c[num].r)-sqr(T-c[num].x));
		double yy = c[s.num].y+s.o*sqrt(sqr(c[s.num].r)-sqr(T-c[s.num].x));
		if(xx!=yy)return xx<yy;
		return o<s.o;
	}
}poi[N<<1];
bool cmp(const data &a,const data &b)
{
	return a.x<b.x;
}
set<data>S;
ll f[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld%lld",&c[i].x,&c[i].y,&c[i].r);
		poi[(i<<1)-1] = data(i,c[i].x-c[i].r,1);
		poi[i<<1] = data(i,c[i].x+c[i].r,-1);
	}
	sort(poi+1,poi+2*n+1,cmp);
	set<data>::iterator it;
	for(int i = 1;i<= 2*n;i++)
	{
		T = poi[i].x;
		if(poi[i].o==1)
		{
			it = S.upper_bound(data(poi[i].num,0,-1));
			if(it==S.end())f[poi[i].num] = 1;
			else
			{
				if((*it).o==1)f[poi[i].num] = -f[(*it).num];
				else f[poi[i].num] = f[(*it).num];
			}
			S.insert(data(poi[i].num,0,-1));
			S.insert(data(poi[i].num,0,1));
		}else
		{
			S.erase(data(poi[i].num,0,-1));
			S.erase(data(poi[i].num,0,1));
		}
	}
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans = ans+f[i]*sqr(c[i].r);
	printf("%lld\n",ans);
	return 0;
}
Problem4563

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int B = 2000;
const int mod = 10000;
struct BigNum
{
	int d[B],len;
	BigNum(){memset(d,0,sizeof(d));len = 1;}
	BigNum(int x)
	{
		memset(d,0,sizeof(d));
		len = 1;
		while(x)d[len] = x%mod,x/=mod,len++;
		len--;
	}
	void print()
	{
		printf("%d",d[len]);
		for(int i = len-1;i;i--)
			printf("%04d",d[i]);
	}
	void operator +=(const BigNum &s)
	{
		len = max(len,s.len);
		for(int i = 1;i<=len;i++)
		{
			d[i] = d[i]+s.d[i];
			if(d[i]>=mod)
				d[i+1]++,d[i]%=mod;
		}
		if(d[len+1])len++;
	}
	friend BigNum operator +(const BigNum &a,const BigNum &b)
	{
		BigNum res = a;res+=b;
		return res;
	}
	void operator *=(const int &s)
	{
		int num = 0;
		for(int i = 1;i<= len;i++)
		{
			num = num+d[i]*s;
			d[i] = num%mod;
			num/=mod;
		}
		if(num)d[++len] = num;
	}
}f[205];
int main()
{
	f[0] = BigNum(1);f[1] = BigNum(0);
	int n;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
		f[i] = f[i-1]+f[i-2],f[i]*=(i-1);
	f[n].print();
	return 0;
}
Problem4564

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 3e5+5;
const int Asiz = 1005;
const int Siz = 300;
const int maxA = 1e6+5;
int cnt[maxA],bcnt[Asiz][2];
struct E
{int next,to;}e[M];
int head[N],tot=1,A[N],a[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dfn[N],DFN[N],low[N],seq[N],Dfn,size[N];
void dfs(int x,int pre)
{
	DFN[x] = low[x] = ++Dfn;
	seq[Dfn] = x;
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!DFN[e[i].to])
		{
			dfs(e[i].to,i);
			low[x] = min(low[e[i].to],low[x]);
		}else 
			low[x] = min(low[e[i].to],DFN[x]);
	}
}
void dfs2(int x,int pre)
{
	size[x] = 1;
	dfn[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!dfn[e[i].to]&&low[e[i].to]>=DFN[x])
		{
			dfs2(e[i].to,i);
			if(low[e[i].to]>DFN[x])
				size[x]+=size[e[i].to];
		}
	}
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!dfn[e[i].to]&&low[e[i].to]<DFN[x])
			dfs2(e[i].to,i);
	}
	if(low[x]!=DFN[x])
		size[seq[low[x]]]+=size[x];
}
struct Ask
{
	int l,r,pl;
	int o,p,id;
	bool operator <(const Ask &s)const
	{
		return pl<s.pl||pl==s.pl&&r<s.r;
	}
}ask[N];
int ans[N];
void Delete(int x)
{
	int tx = (a[x]-1)/Asiz+1;
	bcnt[tx][cnt[a[x]]&1]--;
	cnt[a[x]]--;
	if(cnt[a[x]])
		bcnt[tx][cnt[a[x]]&1]++;
}
void Insert(int x)
{
	int tx = (a[x]-1)/Asiz+1;
	if(cnt[a[x]])
		bcnt[tx][cnt[a[x]]&1]--;
	cnt[a[x]]++;
	bcnt[tx][cnt[a[x]]&1]++;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&A[i]);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	Dfn = 0;
	dfs2(1,0);
	for(int i = 1;i<= n;i++)a[dfn[i]]=A[i];
	int q;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].o,&ask[i].l,&ask[i].p);
		ask[i].r = dfn[ask[i].l]+size[ask[i].l]-1;
		ask[i].l = dfn[ask[i].l];
		ask[i].pl = ask[i].l/Siz;
		ask[i].id = i;
	}
	sort(ask+1,ask+q+1);
	int L = 1,R = 0;
	for(int i = 1;i<= q;i++)
	{
		while(L<ask[i].l)Delete(L),L++;
		while(L>ask[i].l)L--,Insert(L);
		while(R<ask[i].r)R++,Insert(R);
		while(R>ask[i].r)Delete(R),R--;
		x=(ask[i].p-1)/Asiz+1;
		for(int j = 1;j< x;j++)
			ans[ask[i].id]+=bcnt[j][ask[i].o];
		for(int j = (x-1)*Asiz+1;j<= ask[i].p;j++)
			if(cnt[j]&&(cnt[j]&1)==ask[i].o)
				ans[ask[i].id]++;
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4565

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<8;
const int N = 305;
ll f[N][N][S];
ll inf;
int val[S],c[S];
char s[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	for(int i = 0;i<1<<k;i++)scanf("%d%d",&c[i],&val[i]);
	memset(f,0xef,sizeof(f));inf = f[0][0][0];
	for(int i = 1;i<= n;i++)f[i][i][s[i]-'0'] = 0;
	for(int lth = 2;lth<= n;lth++)
	{
		for(int i = 1;i+lth-1<=n;i++)
		{
			int j = i+lth-1;
			int len = j-i;ll now,t;
			while(len>=k)len-=k-1;
			for(int m = j;m>i;m-=k-1)
				for(int S = 0;S<(1<<len);S++)
					if(f[i][m-1][S]!=inf)
					{
						if(f[m][j][0]!=inf)f[i][j][S<<1] = max(f[i][j][S<<1],f[i][m-1][S]+f[m][j][0]);
						if(f[m][j][1]!=inf)f[i][j][S<<1|1] = max(f[i][j][S<<1|1],f[i][m-1][S]+f[m][j][1]);
					}
			if(len==k-1)
			{
				ll g[2];
				g[0] = g[1] = inf;
				for(int S = 0;S<1<<k;S++)
					if(f[i][j][S]!=inf)
						g[c[S]]=max(g[c[S]],f[i][j][S]+val[S]);
				memcpy(f[i][j],g,sizeof(g));
			}
		}
	}
	ll ans = 0;
	for(int i = 0;i<1<<k;i++)
		ans = max(ans,f[1][n][i]);
	printf("%lld\n",ans);
	return 0;
}
Problem4566

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 4e5+5;
char s1[N>>1],s2[N>>1],s[N];
int sa[N],rnk[N],val[N],nv[N],q[N],cnt[N],h[N],a[N];
inline bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]] = i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>= 0;i--)sa[--cnt[val[q[i]]]] = q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i=j+1;k<= j;k++)nv[sa[k]] = lim;
		}
		if(lim==len)return ;
		for(i = 0;i<len;i++)val[i] = nv[i];
	}
}
void build_height(int len)
{
	for(int i = 0;i< len;i++)rnk[sa[i]]=i;
	for(int i = 0;i< len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]] = j;
		}
}
inline bool cmp(int a,int b){return h[a]>h[b];}
int fa[N];
ll st[N],en[N];
long long ans;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x] = getfa(fa[x]);
}
void calc(int x)
{
	if(!x)return ;
	int r1 = getfa(x),r2 = getfa(x-1);
	ans+=(ll)(st[r1]*en[r2]+st[r2]*en[r1])*h[x];
	st[r1]+=st[r2],en[r1]+=en[r2],fa[r2] = r1;
}

int main()
{
	scanf("%s",s1);
	int l1 = strlen(s1);
	scanf("%s",s2);
	int l2 = strlen(s2);
	for(int i = 0;i<l1;i++)
		s[i] = s1[i];
	s[l1] = 'z'+1;
	for(int i = 0;i<l2;i++)s[i+l1+1]=s2[i];
	int len = l1+l2+1;
	build_sa(len,256);
	build_height(len);
	for(int i = 0;i<len;i++)a[i]=fa[i]=i,st[i]=(sa[i]<l1),en[i] = 1-st[i];
	sort(a,a+len,cmp);
	for(int i = 0;i<len;i++)calc(a[i]);
	printf("%lld\n",ans);
	return 0;
}
Problem4568

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 20005;
struct Seg
{
	ll p[61];
	Seg(){memset(p,0,sizeof(p));}
	void init()
	{
		memset(p,0,sizeof(p));
	}
}tr[N<<2];
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,Q;
ll val[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],top[N],size[N],son[N],dfn[N],Dfn,seq[N],fa[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	seq[++Dfn] = x;
	dfn[x] = Dfn;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void insert(Seg &a,ll x)
{
	for(int i = 60;i>=0;i--)
		if((x>>i)&1)
		{
			if(!a.p[i]){a.p[i] = x;break;}
			else x^=a.p[i];
		}
}
void merge(Seg &a,Seg &b,Seg &c)
{
	for(int i = 0;i<= 60;i++)a.p[i]=b.p[i];
	for(int i = 60;i>=0;i--)if(c.p[i])insert(a,c.p[i]);
}
ll getans(const Seg &ans)
{
	ll Ans = 0;
	for(int i = 60;i>=0;i--)if((Ans^ans.p[i])>Ans)Ans = Ans^ans.p[i];
	return Ans;
}
void Build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].init();
		insert(tr[p],val[seq[l]]);
		return ;
	}
	int mid = (l+r)>>1;
	Build(p<<1,l,mid);
	Build(p<<1|1,mid+1,r);
	merge(tr[p],tr[p<<1],tr[p<<1|1]);
}
Seg ret;
void Getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		{merge(ret,ret,tr[p]);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Getans(p<<1,l,mid,a,b);
	if(b >mid)Getans(p<<1|1,mid+1,r,a,b);
}
ll Getans(int x,int y)
{
	ret.init();
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		Getans(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	Getans(1,1,n,dfn[y],dfn[x]);
	return getans(ret);
}
int main()
{
	scanf("%d%d",&n,&Q);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&val[i]);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	Build(1,1,n);
	while(Q--)
	{
		scanf("%d%d",&x,&y);
		printf("%lld\n",Getans(x,y));
	}
	return 0;
}
Problem4569

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int mod = 1e9+7;
int fa[N*20],id[N][20],idx[N*20][2];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[y] = x;
}
int pow2[20];
int main()
{
	pow2[0] = 1;
	for(int i = 1;i<= 18;i++)pow2[i]=pow2[i-1]*2;
	int n,cnt = 0,m;
	scanf("%d",&n);
	if(n==1){printf("10\n");return 0;}
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<=18;j++)
			id[i][j]=++cnt,idx[cnt][0]=i,idx[cnt][1]=j;
	scanf("%d",&m);
	int l1,r1,l2,r2;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
		for(int j = 18;j>= 0;j--)
		{
			if(l1+pow2[j]-1<=r1)
			{
				merge(id[l1][j],id[l2][j]);
				l1+=pow2[j],l2+=pow2[j];
			}
		}
	}
	for(int j = 18;j>= 1;j--)
	{
		for(int i = 1;i<= n;i++)
		{
			int k = getfa(id[i][j]);
			int s = idx[k][0];int t = idx[k][1];
			merge(id[s][t-1],id[i][j-1]);
			merge(id[s+pow2[t-1]][t-1],id[i+pow2[j-1]][j-1]);
		}
	}
	int tot = 0;
	for(int i = 1;i<= n;i++)
		if(getfa(id[i][0])==id[i][0])tot++;
	long long ans = 9;
	for(int i = 1;i< tot;i++)ans = ans*10%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4570

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const double eps = 1e-8;
const double INF = 1e20;
typedef long long ll;
struct P
{
	double x,y;
	P(double _x=0,double _y=0):x(_x),y(_y){}
	bool operator <(const P &s)const
	{
		if(x==s.x)return y>s.y;
		return x<s.x;
	}
	friend P operator -(const P &a,const P &b)
	{
		return P(a.x-b.x,a.y-b.y);
	}
	friend double operator *(const P &a,const P &b)
	{
		return a.x*b.y-a.y*b.x;
	}
}p[N],stack[N];
int top;
double slope(const P &a,const P &b)
{
	if(fabs(a.x-b.x)<eps)return -INF;
	else return (b.y-a.y)/(b.x-a.x);
}
double slope(const P &a)
{
	return -sqrt(a.y/a.x);
}
double calc(const P &a,double k)
{
	if(k>-eps)return INF;
	else return a.x+a.y-a.x*k-a.y/k;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf",&p[i].x,&p[i].y);
	sort(p+1,p+n+1);
	stack[++top] = p[1];
	for(int i = 2;i<= n;i++)
	{
		while(top>1&&(p[i]-stack[top])*(stack[top]-stack[top-1])<-eps)
			top--;
		stack[++top] = p[i];
	}
	double ans;
	if(top==1)ans = calc(stack[1],slope(stack[1]));
	else
	{
		double sp,sp1,sp2;
		ans = INF;
		sp2 = slope(stack[1],stack[2]),sp = slope(stack[1]);
		if(sp+eps>sp2)ans = min(ans,calc(stack[1],sp));
		for(int i = 2;i<top;i++)
		{
			sp1 = slope(stack[i-1],stack[i]);
			sp2 = slope(stack[i],stack[i+1]);
			sp = slope(stack[i]);
			ans = min(ans,calc(stack[i],sp1));
			if(sp1+eps>sp&&sp+eps>sp2)ans = min(ans,calc(stack[i],sp));
		}
		sp1 = slope(stack[top-1],stack[top]),sp = slope(stack[top]);
		ans = min(ans,calc(stack[top],sp1));
		if(sp1+eps>sp)ans = min(ans,calc(stack[top],sp));
	}
	printf("%.4f\n",ans);
	return 0;
}
Problem4571

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
int root[N],size[N*100],ls[N*100],rs[N*100],cnt,a[N];
void Update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	size[p] = size[pre]+1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Update(ls[p],ls[pre],l,mid,pos);
	else Update(rs[p],rs[pre],mid+1,r,pos);
}
int Getans(int L,int R,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return size[R]-size[L];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getans(ls[L],ls[R],l,mid,a,b);
	if(b >mid)ans+=Getans(rs[L],rs[R],mid+1,r,a,b);
	return ans;
}
int L,R,D;
int mx = (1<<19)-1;
int getans(int l,int r,int x,int y)
{
	if(l==r)
		return x^l;
	int mid = (l+r)>>1;
	D--;
	if(x&(1<<D))
	{
		if(Getans(L,R,0,mx,max(0,l-y),max(0,mid-y)))
			return getans(l,mid,x,y);
		else 
			return getans(mid+1,r,x,y);
	}
	else
	{
		if(Getans(L,R,0,mx,max(0,mid+1-y),max(0,r-y)))
			return getans(mid+1,r,x,y);
		else 
			return getans(l,mid,x,y);
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		Update(root[i],root[i-1],0,mx,a[i]);
	int x,y,l,r;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&l,&r);
		D = 19;
		L = root[l-1],R = root[r];
		printf("%d\n",getans(0,mx,x,y));
	}
	return 0;
}
Problem4573

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 4e5+5;
struct List
{int next,to,opt;}e[M];
struct data
{
	int t,ca,x,y,z,ans;
	bool operator <(const data &s)const
	{return t<s.t;}
}ask[N],zlt;
int head[N],TOT;
void add(int x,int y,int o)
{e[++TOT].to=y;e[TOT].next=head[x];e[TOT].opt=o;head[x]=TOT;}
int fa[M],ch[M][2],size[M],sum[M],val[M],pp[M],sta[M],tot,top;
int lt[N],rt[N],gs[N],b[M],n,m;
bool rev[M];
inline int pd(int x)
{return ch[fa[x]][1]==x;}
inline void Push_up(int p)
{sum[p]=sum[ch[p][0]]+val[p]+sum[ch[p][1]];}
void rotate(int x)
{
	int y = fa[x];
	int d = ch[y][1]==x;
	fa[x] = fa[y];
	if(fa[y])ch[fa[y]][pd(y)] = x;
	ch[y][d]=ch[x][d^1];
	if(ch[x][d^1])fa[ch[x][d^1]] = y;
	ch[x][d^1] = y;
	fa[y] = x;
	Push_up(y);Push_up(x);
	if(pp[y])pp[x]=pp[y],pp[y]=0;
}
void Push_down(int p)
{
	if(rev[p])
	{
		if(ch[p][0])rev[ch[p][0]]^=1;
		if(ch[p][1])rev[ch[p][1]]^=1;
		swap(ch[p][0],ch[p][1]);
		rev[p] = false;
	}
}
void relax(int x,int y)
{
	top = 0;
	while(x!=y)
	{
		sta[++top] = x;
		x = fa[x];
	}
	while(top)
	{
		x = sta[top--];
		Push_down(x);
	}
}
void splay(int x,int y)
{
	relax(x,y);
	while(fa[x]!=y)
	{
		if(fa[fa[x]]!=y)
		{
			if(pd(x)==pd(fa[x]))rotate(fa[x]);
			else rotate(x);
		}
		rotate(x);
	}
}
int access(int x)
{
	int y,z,p = x;
	splay(x,0);
	z = ch[x][1];
	ch[x][1] = 0;
	if(z)
	{
		fa[z] = 0;
		pp[z] = x;
	}
	Push_up(x);
	while(pp[x])
	{
		p = y = pp[x];
		splay(y,0);
		z = ch[y][1];
		if(z)
		{
			fa[z] = 0;
			pp[z] = y;
		}
		ch[y][1] = x;
		fa[x] = y;pp[x] = 0;
		Push_up(y);
		splay(x,0);
	}
	return p;
}
void make_root(int x)
{
	access(x);
	splay(x,0);
	rev[x]^=1;
}
void Link(int x,int y)
{
	make_root(y);
	splay(y,0);
	pp[y] = x;
}
void Cut(int x)
{
	make_root(1);
	access(x);
	splay(x,0);
	int y = ch[x][0];
	ch[x][0] = 0;
	if(y)
	{
		fa[y] = pp[y] = 0;
	}
	Push_up(x);
}
void Insert1(int x)
{
	int j = b[ask[x].y-1],k = b[ask[x].y];
	Cut(k);
	Link(k,ask[x].x);
}
void Delete1(int x)
{
	int j = b[ask[x].y-1],k = b[ask[x].y];
	Cut(k);
	Link(k,j);
}
void Insert0(int x)
{
	int j = gs[ask[x].x];
	val[ask[x].x] = 1;
	Push_up(ask[x].x);
	Link(ask[x].x,b[j]);
}
void Delete0(int x)
{
	Cut(ask[x].x);
}

int main()
{
	int l,r,x,y,ans;
	scanf("%d%d",&n,&m);
	tot = top = 1;
	lt[1] = 1,rt[1] = n;
	for(int i = 1;i<= m;i++)
	{
		ask[i].t = i;
		scanf("%d",&ask[i].ca);
		if(ask[i].ca==0)
		{
			scanf("%d%d",&l,&r);
			add(l,i,1),add(r+1,i,-1);
			ask[i].x=++tot;
			lt[tot]=l,rt[tot]=r;
			gs[tot] = top;
		}else if(ask[i].ca==1)
		{
			scanf("%d%d%d",&l,&r,&ask[i].x);
			l = max(l,lt[ask[i].x]),r = min(r,rt[ask[i].x]);
			if(l<=r)
			{
				add(l,i,1),add(r+1,i,-1);
				ask[i].y=++top;
			}
		}else
		{
			scanf("%d%d%d",&ask[i].z,&ask[i].x,&ask[i].y);
			l = ask[i].z;
			add(l,i,1);
		}
	}
	zlt.t=0;
    zlt.ca=1;
    zlt.x=1;
    zlt.y=1;
    ask[0]=zlt;
    for(int i = 1;i<= top;i++)b[i]=++tot;
    val[1] = 1;
	Push_up(1);
	pp[b[1]] = 1;
	for(int i = 2;i<= top;i++)pp[b[i]]=b[i-1];
	for(int i = 1;i<= n;i++)
	{
		for(int t = head[i];t;t=e[t].next)
		{
			if(ask[e[t].to].ca==0)
				{if(e[t].opt==1)Insert0(e[t].to);else Delete0(e[t].to);}
			else if(ask[e[t].to].ca==1)
				{if(e[t].opt==1)Insert1(e[t].to);else Delete1(e[t].to);}
		}
		for(int t = head[i];t;t=e[t].next)
		{
			if(ask[e[t].to].ca==2)
			{
				x = ask[e[t].to].x,y = ask[e[t].to].y;
				if(x==y){ask[e[t].to].ans = 0;continue;}
				make_root(1);
                access(x);
                splay(x,0);
                ans=sum[x];
                x=access(y);
                splay(y,0);
                ans+=sum[y];
                access(x);
                splay(x,0);
                ans-=sum[x]*2;
                ask[e[t].to].ans=ans;
			}
		}
	}
	for(int i = 1;i<= m;i++)
		if(ask[i].ca==2)printf("%d\n",ask[i].ans);
	return 0;
}
Problem4574

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 405;
const int mod = 1e9+7;
int dp[2][N][N],ans[N][N],A[N][N];
int a[N],idx[N],y[N],num[N];
int n,Q;
void solve(int l,int r,int pos)
{
	int i,j;
	for(i = l;i<= r;i++)
		for(j = l;j<= r;j++)
			dp[0][i][j]=dp[1][i][j]=0;
	int now = 1,pre = 0;
	ll k1;
	dp[0][l][r] = 1;
	for(int t = 1;t<= Q;t++)
	{
		for(i = l;i<= r;i++)
		{
			k1 = 0;
			for(j = r;j>= i;j--)
				dp[now][i][j] = k1%mod,k1 += 1ll*dp[pre][i][j]*(n-j);
		}
		for(j = l;j<= r;j++)
		{
			k1 = 0;
			for(i = l;i<= j;i++)
				dp[now][i][j]= (dp[now][i][j]+k1)%mod,k1 += 1ll*dp[pre][i][j]*(i-1);
		}
		for(j = l;j<= r;j++)
			for(i = l;i<= j;i++)
				dp[now][i][j]=(dp[now][i][j]+1ll*dp[pre][i][j]*A[i][j])%mod;
		pre^=1,now^=1;
	}
	for(i = l;i<= r;i++)
	{
		k1 = 0;
		for(j = r;j>= i;j--)
		{
			k1 += dp[pre][i][j];
			ans[j][y[pos]] = (ans[j][y[pos]]+k1)%mod;
		}
	}
}
bool cmp(int x,int y)
{
	return a[x]<a[y];
}
int main()
{
	scanf("%d%d",&n,&Q);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)idx[i]=i;
	sort(idx+1,idx+n+1,cmp);
	for(int i = 1;i<= n;i++)y[idx[i]]=i;
	for(int i = 1;i<= n;i++)num[i] = (i*(i+1))>>1;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)A[i][j] = num[i-1]+num[j-i+1]+num[n-j];
	int l,r,Ans;
	for(int i = 1;i<= n;i++)
	{
		l = i,r = i;
		while(l&&a[l]<=a[i])l--;
		while(r<=n&&a[r]<=a[i])r++;
		solve(l+1,r-1,i);
	}
	int i,j,k;
	for(i = 1;i<= n;i++)
	{
		Ans = 0;
		for(j = 1;j<= n;j++)
		{
			if(!ans[i][j])continue;
			for(k = 1;k<j;k++)
				ans[i][j] = (ans[i][j]-ans[i][k]+mod)%mod;
			Ans = (Ans+1ll*a[idx[j]]*ans[i][j])%mod;
		}
		printf("%d",Ans);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem4576

#include <stdio.h>
#include <cctype>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 262145;
int f[60][N];
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
int main()
{
	int n,x,ans = 0;
	n=read();
	for(int i = 1;i<= n;i++){x=read();f[x][i] = i+1;}
	for(int i= 2;i<= 58;i++)
		for(int j = 1;j<= n;j++)
		{
			if(!f[i][j])f[i][j] = f[i-1][f[i-1][j]];
			if(f[i][j])ans = i;
		}
	printf("%d",ans);
	return 0;
}
Problem4578

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 5e4+5;
const int INF = 0x3f3f3f3f;
int pmx[N],hmx[N],pmn[N],hmn[N],n;
struct Pos
{int x,y;}pos[N];
bool cmp1(Pos a,Pos b){return a.x<b.x;}
bool cmp2(Pos a,Pos b){return a.y<b.y;}
void init1()
{
	pmn[0] = INF,hmn[n+1] = INF;
	for(int i = 1;i<= n;i++)
	{
		pmx[i] = max(pmx[i-1],pos[i].x);
		pmn[i] = min(pmn[i-1],pos[i].x);
	}for(int i = n;i>= 1;i--)
	{
		hmx[i] = max(hmx[i+1],pos[i].x);
		hmn[i] = min(hmn[i+1],pos[i].x);
	}
}
void init2()
{
	pmn[0] = INF,hmn[n+1] = INF;
	for(int i = 1;i<= n;i++)
	{
		pmx[i] = max(pmx[i-1],pos[i].y);
		pmn[i] = min(pmn[i-1],pos[i].y);
	}for(int i = n;i>= 1;i--)
	{
		hmx[i] = max(hmx[i+1],pos[i].y);
		hmn[i] = min(hmn[i+1],pos[i].y);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&pos[i].x,&pos[i].y);
	sort(pos+1,pos+n+1,cmp1);
	init2();
	LL ans = 1e18+5;
	for(int i = 1;i< n;i++)
	{
		LL tmp = (LL)(pos[i].x-pos[1].x)*(pmx[i]-pmn[i]);
		tmp+=(LL)(pos[n].x-pos[i+1].x)*(hmx[i+1]-hmn[i+1]);
		ans = min(ans,tmp);
	}
	sort(pos+1,pos+n+1,cmp2);
	init1();
	for(int i = 1;i< n;i++)
	{
		LL tmp = (LL)(pos[i].y-pos[1].y)*(pmx[i]-pmn[i]);
		tmp+=(LL)(pos[n].y-pos[i+1].y)*(hmx[i+1]-hmn[i+1]);
		ans = min(ans,tmp);
	}
	printf("%lld\n",(LL)(pos[n].y-pos[1].y)*(hmx[1]-hmn[1])-ans);
	return 0;
}
Problem4579

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 400005;
struct E
{int next,to;}e[N];
int head[N],tot,fa[N],ask[N],size[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool ans[N],used[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(size[x]>size[y])
		fa[y] = x;
	else fa[x] = y; 
	size[x] = size[y] = size[x]+size[y];
}
int cnt = 0;
void solve(int x)
{
	for(int i = head[x];i;i = e[i].next)
		if(used[e[i].to])
			uni(e[i].to,x);
	used[x] = true;
	cnt++;
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)size[fa[i] = i] = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&ask[i]);
	for(int i = n;i>=1;i--)
	{
		solve(ask[i]);
		if(size[getfa(ask[i])]==cnt)ans[i] =true;
		else ans[i] = false;
	}
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
Problem4580

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int num[250];
int f[250][250];
int uni(int l,int r)
{
	if(f[l][r]!=0)return f[l][r];
	for(int i = l;i<r;i++)
		if(uni(l,i)==uni(i+1,r))
			f[l][r] = max(f[l][i]+1,f[l][r]);
	if(f[l][r]==0)f[l][r] = -1;
	return f[l][r];
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&num[i]);
		f[i][i] = num[i];
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)
			ans = max(ans,uni(i,j));
	printf("%d\n",ans);
	return 0;
}
Problem4581

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
int maxx[5],maxy[5],minx[5],miny[5];
int x[N],y[N];
int main()
{
	int n;
	scanf("%d",&n);
	memset(minx,0x3f,sizeof(minx));
	memset(miny,0x3f,sizeof(miny));
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
		maxx[4] = max(maxx[4],x[i]);
		for(int j = 4;j>1;j--)
			if(maxx[j]>maxx[j-1])swap(maxx[j],maxx[j-1]);
		minx[4] = min(minx[4],x[i]);
		for(int j = 4;j>1;j--)
			if(minx[j]<minx[j-1])swap(minx[j],minx[j-1]);
		maxy[4] = max(maxy[4],y[i]);
		for(int j = 4;j>1;j--)
			if(maxy[j]>maxy[j-1])swap(maxy[j],maxy[j-1]);
		miny[4] = min(miny[4],y[i]);
		for(int j = 4;j>1;j--)
			if(miny[j]<miny[j-1])swap(miny[j],miny[j-1]);
	}
	int ans = (1<<30)-1+(1<<30);
	for(int x1 = 1;x1<=4;x1++)
	for(int x2 = 1;x2<=4;x2++)
		if(minx[x1]<maxx[x2])
		for(int y1 = 1;y1<=4;y1++)
		for(int y2 = 1;y2<=4;y2++)
		if(miny[y1]<maxy[y2])
		{
			int cnt = 0;
			for(int i = 1;i<= n;i++)
				if(x[i]>=minx[x1]&&x[i]<=maxx[x2]&&y[i]>=miny[y1]&&y[i]<=maxy[y2])
					cnt++;
			if(cnt>=n-3)
				ans = min(ans,(maxx[x2]-minx[x1])*(maxy[y2]-miny[y1]));
		}
	printf("%d\n",ans);
	return 0;
}
Problem4582

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int ans[N<<1],num[N<<1];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	sort(num+1,num+n+1);
	int j = 0;
	for(int i = 1;i<=n;i++)
	{
		while(num[j]-num[i]<=k&&j<=n)j++;
		ans[i] = j-i;
	}
	int Tans = 0;
	for(int i = n;i>=1;i--)
	{
		Tans = max(Tans,ans[i]+ans[i+ans[i]]);
		ans[i] = max(ans[i],ans[i+1]);
	}
	printf("%d\n",Tans);
	return 0;
}
Problem4590

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
int opt[N],n;
int check(LL l)
{
	LL now = 0;int cnt = 0;
	for(int i = 1;i<= n;i++)
	{
		now+=opt[i];
		if(now<0)now = 0;
		if(now>=l){cnt++;now = 0;}
	}
	return cnt;
}
int main()
{
	int k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&opt[i]);
	LL l = 1,r = 1e15,lans = 0,rans = 0;
	while(l<r)
	{
		LL mid = (l+r)>>1;
		if(check(mid)>k)l = mid+1;
		else r = mid;
	}
	lans = l;
	l = 1;r = 1e15;
	while(l<r)
	{
		LL mid = (l+r)>>1;
		if(check(mid)>=k)l = mid+1;
		else r = mid;
	}
	rans = l-1;
	if(check(lans)!=k||check(rans)!=k||lans<=0||rans<=0)printf("-1\n");
	else printf("%lld %lld\n",lans,rans);
	return 0;
}
Problem4592

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std; 
#define maxn 200005 
  
struct Seg  
{  
    int l,r;  
    int lmx,rmx,ans,size,tag;  
}t[maxn<<2];  
  
int n,T;  
  
inline void add(int i,int x)  
{  
    t[i].tag=x;  
    if (x==1) t[i].lmx=t[i].rmx=t[i].ans=t[i].size=0;  
    else t[i].lmx=t[i].rmx=t[i].ans=t[i].size=t[i].r-t[i].l+1;  
}  
  
inline void release(int i) 
{
    if (t[i].tag==-1) return;  
    add(i*2,t[i].tag);add(i*2+1,t[i].tag);  
    t[i].tag=-1;  
}  
  
Seg merge(Seg x,Seg y)  
{  
    Seg ans;  
    ans.l=x.l;ans.r=y.r;  
    ans.size=x.size+y.size;  
    if (x.size==x.r-x.l+1) ans.lmx=x.size+y.lmx; else ans.lmx=x.lmx;  
    if (y.size==y.r-y.l+1) ans.rmx=y.size+x.rmx; else ans.rmx=y.rmx;  
    ans.ans=max(x.rmx+y.lmx,max(x.ans,y.ans));  
    ans.tag=-1;  
    return ans;  
}  
  
void build(int i,int l,int r)  
{  
    t[i].l=l;t[i].r=r;t[i].lmx=t[i].rmx=t[i].ans=t[i].size=0;t[i].tag=-1;  
    if (l==r) return;  
    int mid=(t[i].l+t[i].r)/2;  
    build(i*2,l,mid);build(i*2+1,mid+1,r);  
}  
  
void modify(int i,int l,int r,int d)  
{  
    if (l<=t[i].l && t[i].r<=r) {add(i,d);return;}  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (l<=mid) modify(i*2,l,r,d);  
    if (mid<r) modify(i*2+1,l,r,d);  
    t[i]=merge(t[i*2],t[i*2+1]);  
}  
  
int Query(int i,int l,int r)  
{  
    if (l<=t[i].l && t[i].r<=r) return t[i].size;  
    release(i);  
    int mid=(t[i].l+t[i].r)/2,ans=0;  
    if (l<=mid) ans+=Query(i*2,l,r);  
    if (mid<r) ans+=Query(i*2+1,l,r);  
    return ans;  
}  
  
void change(int i,int l,int r,int x)  
{  
    if (!x) return;  
    if (l<=t[i].l && t[i].r<=r && t[i].size<=x) {add(i,1);return;}  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (l<=mid)  
    {  
        int num=Query(i*2,l,r);  
        if (x>num) {modify(i*2,l,r,1);if (mid<r) change(i*2+1,l,r,x-num);}  
        else change(i*2,l,r,x);  
    }  
    else change(i*2+1,l,r,x);   
    t[i]=merge(t[i*2],t[i*2+1]);  
}  
  
Seg query(int i,int l,int r)  
{  
    if (l<=t[i].l && t[i].r<=r) return t[i];  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (r<=mid) return query(i*2,l,r);  
    else if (l>mid) return query(i*2+1,l,r);  
    else return merge(query(i*2,l,r),query(i*2+1,l,r));  
}  
  
int main()  
{  
    scanf("%d%d",&n,&T);  
    build(1,1,n);  
    while (T--)  
    {  
        int op,l1,l2,r1,r2;  
        scanf("%d%d%d",&op,&l1,&r1);  
        if (op==0) modify(1,l1,r1,0);  
        else if (op==1)  
        {  
            scanf("%d%d",&l2,&r2);  
            int num=r1-l1+1-Query(1,l1,r1);  
            modify(1,l1,r1,0);  
            change(1,l2,r2,num);  
        }  
        else   
        {  
            Seg ans=query(1,l1,r1);  
            printf("%d\n",ans.ans);  
        }  
    }  
    return 0;  
}  
Problem4593

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <ctime>
using namespace std;
struct node {int to;int next;};node bian[200005];
int first[100005],size,f[100005],h[100005],g[1000010];
int father[100005],d[100005],c[100005],n,a,b,maxc;
void inser(int x,int y) {
	size ++;
	bian[size].to = y;
	bian[size].next = first[x];
	first[x] = size;
}
void dfs(int x,int Anc) {
	father[x] = Anc;
	int _d1 = d[x],_d2 = d[x] - c[father[x]],ret = 0;
	for(int u = first[x];u;u = bian[u].next)
	{
		if(bian[u].to == Anc) continue;
		dfs(bian[u].to,x);
		if(f[bian[u].to] == h[bian[u].to])
		{
			_d1 -= c[bian[u].to];
			_d2 -= c[bian[u].to];
			ret += f[bian[u].to];
		}
		else ret += h[bian[u].to];
	}
	f[x] = ret + max(_d1,0);
	h[x] = ret + max(_d2,0);
}
void bfs(int x,int Anc) {
	father[x] = Anc;
	int _d1 = d[x],_d2 = d[x] - c[father[x]],ret = 0;
	for(int u = first[x];u;u = bian[u].next)
	{
		if(bian[u].to == Anc) continue;
		bfs(bian[u].to,x);
		if(f[bian[u].to] - h[bian[u].to] < c[bian[u].to])
		{
			_d1 -= c[bian[u].to];
			_d2 -= c[bian[u].to];
			ret += f[bian[u].to];
		}
		else ret += h[bian[u].to];
	}
	if(_d1 < 0) 
	{
		int _n = 0;g[0] = 0;
		for(int u = first[x];u;u = bian[u].next)
		{
			if(bian[u].to == Anc) continue;
			if(f[bian[u].to] - h[bian[u].to] >= c[bian[u].to]) continue;
			for(int i = _n + 1;i <= _n + c[bian[u].to];i ++)
				g[i] = 0;
			_n = _n + c[bian[u].to];
			int C = c[bian[u].to],D = f[bian[u].to] - h[bian[u].to];
			for(int i = 0;i + C <= _n;i ++)
				g[i + C] = ((g[i + C] > g[i] + D) ? g[i + C] : g[i] + D);
		}
		f[x] = ret;
		for(int i = 1;i <= _n;i ++)
			f[x] = min(f[x],max(0,_d1 + i) + ret - g[i]);
		//f[x] = ret - g[_n];
	}
	else f[x] = ret + max(_d1,0);
	if(_d2 < 0) 
	{
		int _n = 0;g[0] = 0;
		for(int u = first[x];u;u = bian[u].next)
		{
			if(bian[u].to == Anc) continue;
			if(f[bian[u].to] - h[bian[u].to] >= c[bian[u].to]) continue;
			for(int i = _n + 1;i <= _n + c[bian[u].to];i ++)
				g[i] = 0;
			_n = _n + c[bian[u].to];
			int C = c[bian[u].to],D = f[bian[u].to] - h[bian[u].to];
			for(int i = 0;i + C <= _n;i ++)
				g[i + C] = ((g[i + C] > g[i] + D) ? g[i + C] : g[i] + D);
		}
		h[x] = ret;
		for(int i = 1;i <= _n;i ++)
			h[x] = min(h[x],max(0,_d1 + i) + ret - g[i]);	
	}
	else h[x] = ret + max(_d2,0);
}
int main() {
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)
		scanf("%d",&d[i]);
	for(int i = 1;i <= n;i ++)
		scanf("%d",&c[i]),maxc = max(maxc,c[i]);
	for(int i = 2;i <= n;i ++)
	{
		scanf("%d%d",&a,&b);
		inser(a,b);
		inser(b,a);
	}
	if(maxc <= 1) dfs(1,0); else bfs(1,0);
	printf("%d",f[1]);
}
Problem4594

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int pre[N],fi[N],n,m;
struct E
{
	int x,y;
	E(int _x=0,int _y=0):x(_x),y(_y){}
	bool operator <(const E &s)const
	{
		if(x!=s.x)return x<s.x;
		return y<s.y;
	}
}e[N];
bool check(int x,int l,int r)
{
	if(x<=0)return false;
	for(int i = l+x;i<= r;i++)
	{
		if((i-l)%x!=pre[i]-l)return false;
		if(e[fi[i]].x==i&&e[fi[i]].y<l+x&&fi[i]<=m)return false;
	}
	return true;
}
bool judge(int l,int r)
{
	if(l==r)return true;
	int x=0;
	for(int i = l;i<= r;i++)
	{
		if(pre[i]>=l)continue;
		for(;fi[i]<=m&&e[fi[i]].x==i&&e[fi[i]].y<l;fi[i]++);
		if(fi[i]<=m&&e[fi[i]].x==i){pre[i]=e[fi[i]].y;++fi[i];}
	}
	pre[l] = l;
	for(int i = r;i>l;i--)
		if(pre[i]==l&&r-l+1>=(pre[i-1]-l+1)*2)
			{x = pre[i-1]-l+1;break;}
	if(!check(x,l,r)&&(r-pre[r])*2>=r-l+1&&pre[r]>=l)x = r-pre[r];
	if(check(x,l,r)&&judge(l,l+x-1)&&judge(l+x,r))return true;
	return false;
}
int main()
{
	int cas,x,y;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		bool flag = false;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			if(x<y)swap(x,y);
			e[i] = E(x,y);
			if(x==y)flag = true;
		}
		if(flag){puts("NO");continue;}
		sort(e+1,e+m+1);
		for(int i = 0;i<n;i++)pre[i] = -1;
		int j = 1;
		for(int i = 0;i< n;i++)
		{
			fi[i] = j;
			for(;e[j].x==i&&j<=m;j++);
		}
		if(judge(0,n-1))puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem4596

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 20;
const int M = 1005;
ll d[N][N];
int m[N];
int v1[N][N*N],v2[N][N*N];
int n;ll ans;
ll Gauss()
{
	ll res = 1,f = 1;
	for(int i = 1;i<n;i++)
		for(int j = 1;j<n;j++)
			(d[i][j]+=mod)%=mod;
	for(int i = 1;i<n;i++)
	{
		for(int j = i+1;j<n;j++)
		{
			ll A = d[i][i],B = d[j][i];
			while(B)
			{
				ll C = A/B;
				A%=B;
				swap(A,B);
				for(int k = i;k<n;k++)
					d[i][k] = (d[i][k]-C*d[j][k]%mod+mod)%mod;
				for(int k = i;k<n;k++)
					swap(d[i][k],d[j][k]);
				f = -f;
			}
		}
		if(!d[i][i])return 0;
		res = res*d[i][i]%mod;
	}
	return (mod+f*res)%mod;
}
int main()
{
	scanf("%d",&n);
	for(int i = 0;i< n-1;i++)
	{
		scanf("%d",&m[i]);
		for(int j = 1;j<= m[i];j++)
			scanf("%d%d",&v1[i][j],&v2[i][j]);
	}
	for(int sta = 1;sta<1<<(n-1);sta++)
	{
		memset(d,0,sizeof(d));
		int cnt = 0;
		for(int i = 0;i< n-1;i++)
			if(sta&(1<<i))
			{
				cnt++;
				for(int k = 1;k<= m[i];k++)
					d[v1[i][k]][v2[i][k]]--,  
                    d[v2[i][k]][v1[i][k]]--,  
                    d[v1[i][k]][v1[i][k]]++,  
                    d[v2[i][k]][v2[i][k]]++; 
			}
		if((n-cnt)&1)(ans+=Gauss())%=mod;
		else (ans+=mod-Gauss())%=mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4597

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int N = 1e5+5;
typedef long long ll;
int n,T;
ll tr[N<<2],lazy[N<<2];
ll sum[N],a[N],inv[10005];
ll quick_pow(ll x,ll y)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
void Push_down(int p,int l,int r)
{
	if(l==r||lazy[p]==1)return ;
	tr[p<<1] = tr[p<<1]*lazy[p]%mod;lazy[p<<1] = lazy[p<<1]*lazy[p]%mod;
	tr[p<<1|1] = tr[p<<1|1]*lazy[p]%mod;lazy[p<<1|1] = lazy[p<<1|1]*lazy[p]%mod;
	lazy[p] = 1;
}
void build(int p,int l,int r)
{
	lazy[p] = 1;
	if(l==r)
	{
		if(l!=n)tr[p] = 2ll*quick_pow(3,n-l-1)%mod*sum[l]%mod;
		else tr[p] = sum[n];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p] = (tr[p<<1]+tr[p<<1|1])%mod;
}
void Update(int p,int l,int r,int a,int b,int x)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		tr[p]=tr[p]*x%mod;
		lazy[p]=lazy[p]*x%mod;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,x);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,x);
	tr[p] = (tr[p<<1]+tr[p<<1|1])%mod;
}

int main()
{
	for(int i = 1;i<= 10000;i++)inv[i]=quick_pow(i,mod-2);
	scanf("%d%d",&n,&T);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	sum[0]=1;
	for(int i = 1;i<= n;i++)sum[i]=sum[i-1]*a[i]%mod;
	build(1,1,n);
	while(T--)
	{
		int pos;ll x;
		scanf("%d%lld",&pos,&x);
		Update(1,1,n,pos,n,inv[a[pos]]*x%mod);
		a[pos] = x;
		printf("%lld\n",tr[1]);
	}
	return 0;
}
Problem4598

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef unsigned long long ull;
typedef long long ll;
const int sed = 37;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],f[N],sum,maxd,root,n,m;
bool used[N];
void get_root(int x,int fa,int dep)
{
	maxd = max(maxd,dep);
	size[x] = 1,f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
		{
			get_root(e[i].to,x,dep+1);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int cntz[N],cntd[N],tcz[N],tcd[N],mod[N],val[N];
ull hz[N],hd[N];
void dfs(int x,int fa,ull hash,int dep)
{
	hash = hash*sed+val[x];
	if(hash==hz[dep])cntz[mod[dep]]++;
	if(hash==hd[dep])cntd[mod[dep]]++;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			dfs(e[i].to,x,hash,dep+1);
}
ll ans;
void work(int x)
{
	root = 0;
	sum = size[x];
	maxd = 0;
	get_root(x,0,1);
	if(sum<m||2*maxd<m)return ;
	x = root;
	used[x] = true;
	memset(tcz,0,sizeof(int)*(m+1));
	memset(tcd,0,sizeof(int)*(m+1));
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
		{
			memset(cntz,0,sizeof(int)*(m+1));
			memset(cntd,0,sizeof(int)*(m+1));
			dfs(e[i].to,x,val[x],2);
			cntz[m] = cntz[0],cntd[m] = cntd[0];
			cntz[m+1] = cntz[1],cntd[m+1] = cntd[1];
			ans+=cntz[0]+cntd[0];
			for(int x = 0;x<m;x++)
			{
				ans+=(ll)cntz[m-x+1]*tcd[x];
				ans+=(ll)cntd[m-x+1]*tcz[x];
			}
			for(int x = 0;x<m;x++)
				tcz[x]+=cntz[x],tcd[x]+=cntd[x];
		}
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
			work(e[i].to);
}
char P[N],s[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		tot = 0;
		memset(head,0,sizeof(head));
		ans = 0;
		memset(used,0,sizeof(used));
		scanf("%d%d",&n,&m);
		scanf("%s",s+1);
		for(int i = 1;i<= n;i++)
			val[i] = s[i]-'A'+1;
		int x,y;
		for(int i = 1;i< n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
		}
		scanf("%s",P+1);
		ull pp = 1;
		for(int i = 1,j = 1,k = m;i<= n;i++,pp = pp*sed)
		{
			mod[i] = i%m;
			hz[i] = (P[j]-'A'+1)*pp+hz[i-1];
			hd[i] = (P[k]-'A'+1)*pp+hd[i-1];
			j++;if(j==m+1)j=1;
			k--;if(k==0)k=m;
		}
		f[0] = size[1] = n;
		if(m>1)work(1);
		else 
		{
			for(int i = 1;i<= n;i++)ans+=(val[i]==P[1]-'A'+1);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4600

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
bool vis[N];
int sg[25][25];
void init(int n,int maxQ)
{
	int tmp,x = 0,y = 0;
	tmp = n;while(tmp>=2)x++,tmp/=2;
	tmp = n;while(tmp>=3)y++,tmp/=3;
	for(int i = 0;i<= x;i++)
		for(int j = 0;j<= y;j++)
		{
			memset(vis,0,sizeof(vis));
			for(int p = 1;p<= i;p++)
				for(int q = 1;q*p<=i&&q<=maxQ;q++)
				{
					tmp = -1;
					for(int k = 1;k<= q;k++)
						if(tmp==-1)tmp = sg[i-k*p][j];
						else tmp = tmp^sg[i-p*k][j];
					if(tmp!=-1)vis[tmp] = true;
				}
			for(int p = 1;p<= j;p++)
				for(int q = 1;q*p<=j&&q<=maxQ;q++)
				{
					tmp = -1;
					for(int k = 1;k<= q;k++)
						if(tmp==-1)tmp = sg[i][j-p*k];
						else tmp = tmp^sg[i][j-p*k];
					if(tmp!=-1)vis[tmp] = true;
				}
			for(int k=0;;k++)
				if(!vis[k])
					{sg[i][j] =k;break;}
		}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n,maxQ;
		scanf("%d%d",&n,&maxQ);
		init(n,maxQ);
		int ans = 0;
		int s;
		for(int i = 1;i<= n;i++)
		{
			scanf("%d",&s);
			if(!s)
			{
				int x,y,tmp;
				x = y = 0;
				tmp = i;while(tmp%2==0)x++,tmp/=2;
				tmp = i;while(tmp%3==0)y++,tmp/=3;
				ans = ans^sg[x][y];
			}
		}
		if(!ans)printf("lose\n");
		else printf("win\n");
	}
	return 0;
}
Problem4603

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
const double pi = 3.14159265358979323;
struct Point
{
	double x,y,z;
	Point(){}
	Point(double _x,double _y,double _z):x(_x),y(_y),z(_z){}
	friend Point operator +(const Point &a,const Point &b)
	{
		return Point(a.x+b.x,a.y+b.y,a.z+b.z);
	}
	friend Point operator -(const Point &a,const Point &b)
	{
		return Point(a.x-b.x,a.y-b.y,a.z-b.z);
	}
	friend Point operator *(const Point &a,double b)
	{
		return Point(a.x*b,a.y*b,a.z*b);
	}
	friend Point operator /(const Point &a,double b)
	{
		return Point(a.x/b,a.y/b,a.z/b);
	} 
	friend double operator &(const Point &a,const Point &b)
	{
		return a.x*b.x+a.y*b.y+a.z*b.z;
	}
	friend Point operator |(const Point &a,const Point &b)
	{
		return Point(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);
	}
	friend double getdis(const Point &a)
	{
		return sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
	}
}poi[N],centre;
struct Shape
{
	int num;
	Point vec[N];
}sur[N];
int n,f;
double getV(Point p,Point a,Point b,Point c)
{
	a = a-p,b = b-p,c = c-p;
	double ans = (a|b)&c;
	ans = ans/6.0;
	return fabs(ans);
}
Point getC(const Point &p,const Point &a,const Point &b,const Point &c)
{
	Point C;
	C = p+a+b+c;
	return C/4.0;
}
void getcentre()
{
	double sumv = 0;
	Point t = Point(0,0,0);
	for(int i = 1;i<= f;i++)
	{
		int num = sur[i].num;
		for(int j = 1;j<= num-2;j++)
		{
			double v = getV(centre,sur[i].vec[0],sur[i].vec[j],sur[i].vec[j+1]);
			Point c = getC(centre,sur[i].vec[0],sur[i].vec[j],sur[i].vec[j+1]);
			c = c*v,sumv+=v,t = t+c;
		}
	}
	centre = t/sumv;
}
double getAngle(Point p,Point x,Point y,Point z)
{
	x = x-p,y = y-p,z = z-p;
	x = x/getdis(x),y = y/getdis(x),z = z/getdis(x);
	Point a = x|y,b = x|z;
	double ans = (a&b)/getdis(a)/getdis(b);
	return acos(ans);
}
double getS(const Shape &x,const Point &y)
{
	double ans = -(x.num-2)*pi;
	for(int i = 0;i<x.num;i++)
		ans+=getAngle(y,x.vec[i],x.vec[(i+1)%x.num],x.vec[(i-1+x.num)%x.num]);
	return ans;
}
int main()
{
	int x;
	scanf("%d%d",&n,&f);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf%lf",&poi[i].x,&poi[i].y,&poi[i].z);
	for(int i = 1;i<= f;i++)
	{
		scanf("%d",&sur[i].num);
		for(int j = 0;j<sur[i].num;j++)
			scanf("%d",&x),sur[i].vec[j]=poi[x];
	}
	centre = Point(0,0,0);
	for(int i = 1;i<= n;i++)
		centre = centre+poi[i];
	centre = centre/(double)n;
	getcentre();
	for(int i = 1;i<= f;i++)
	{
		double ans = getS(sur[i],centre);
		ans /= 4.0*pi;
		printf("%.7lf\n",ans);
	}
	return 0;
}
Problem4605

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 4e6+5;
const double alpha = 0.81;
const int INF = 1e9+1;
struct P
{
	int mn[2],mx[2],d[2],l,r,sz;
	int& operator[](int x){return d[x];}
	P(int x,int y){l = r = 0;d[0] = x,d[1] = y;}
	P(){l=r=0;}
};
int D,pt[N];
int dcnt,tot;
namespace KD_tree
{
	P t[M];
	bool cmp(int a,int b)
	{
	return t[a][D]<t[b][D];
	}
	void update(int k)
	{
		P &l = t[t[k].l],&r = t[t[k].r];
		for(int i = 0;i<2;i++)
			t[k].mn[i] = t[k].mx[i] = t[k][i];
		for(int i = 0;i<2;i++)
		{
			if(t[k].l)t[k].mn[i] = min(t[k].mn[i],l.mn[i]);t[k].mx[i] = max(t[k].mx[i],l.mx[i]);
			if(t[k].r)t[k].mn[i] = min(t[k].mn[i],r.mn[i]);t[k].mx[i] = max(t[k].mx[i],r.mx[i]);
		}
		t[k].sz = l.sz+r.sz+1;
	}
	int NewPoint(int x,int y)
	{
		++dcnt;
		t[dcnt][0] = x;t[dcnt][1]= y;
		update(dcnt);
		return dcnt;
	}
	bool ned_rebuild(int k)
	{
		return max(t[t[k].l].sz,t[t[k].r].sz)>t[k].sz*alpha;
	}
	int query(int p,int x0,int y0,int x1,int y1)
	{
		if(!p||t[p].mn[0]>x1||t[p].mx[0]<x0||t[p].mn[1]>y1||t[p].mx[1]<y0)return 0;
		if(t[p].mn[0]>=x0&&t[p].mx[0]<=x1&&t[p].mn[1]>=y0&&t[p].mx[1]<=y1)return t[p].sz;
		int ans = 0;
		if(t[p][0]>=x0&&t[p][0]<=x1&&t[p][1]>=y0&&t[p][1]<=y1)ans++;
		return ans+query(t[p].l,x0,y0,x1,y1)+query(t[p].r,x0,y0,x1,y1);
	}
	int tmpx,tmpd,tmpf;
	void Insert(int &x,int now,const P &p)
	{
		if(!x){x = NewPoint(p.d[0],p.d[1]);return ;}
		if(p.d[now]>t[x][now])Insert(t[x].l,now^1,p);
		else Insert(t[x].r,now^1,p);
		update(x);
		if(ned_rebuild(x))tmpx = x,tmpd = now,tmpf = 0;
		else if(tmpx==t[x].l||tmpx==t[x].r)tmpf = x;
	}
	void travel(int &x)
	{
		if(!x)return ;
		pt[++tot] = x;
		travel(t[x].l),travel(t[x].r);
	}
	int build(int l,int r,int now)
	{
		if(l>r)return 0;
		int mid = (l+r)>>1,x;
		D = now;
		nth_element(pt+l,pt+mid,pt+r+1,cmp);
		x = pt[mid];
		t[x].l = build(l,mid-1,now^1);
		t[x].r = build(mid+1,r,now^1);
		update(x);
		return x;
	}
	void Insert(int &x,const P &p)
	{
		tmpx = tmpf = 0;
		Insert(x,0,p);
		if(!tmpx)return ;
		tot = 0,travel(tmpx);
		if(!tmpf){x = build(1,tot,tmpd);return ;}
		if(tmpx == t[tmpf].l)t[tmpf].l=build(1,tot,tmpd);
		else t[tmpf].r=build(1,tot,tmpd);
	}
}
struct Node
{int ls,rs,rt;}ti[M];
int ncnt,root;
void Insert(int &x,const P &p,int pos,int L = 1,int R = INF)
{
	if(!x)x = ++ncnt;
	KD_tree::Insert(ti[x].rt,p);
	if(L==R)return ;
	int mid = (L+R)>>1;
	if(pos<=mid)Insert(ti[x].ls,p,pos,L,mid);
	else Insert(ti[x].rs,p,pos,mid+1,R);
}
int query(int &x,int &x0,int &y0,int &x1,int &y1,int k,int L=1,int R=INF)
{
	if(L==R)return L;
	int rcnt = KD_tree::query(ti[ti[x].rs].rt,x0,y0,x1,y1);
	int mid = (L+R)>>1;
	if(k<=rcnt)return query(ti[x].rs,x0,y0,x1,y1,k,mid+1,R);
	else return query(ti[x].ls,x0,y0,x1,y1,k-rcnt,L,mid);
}
int n,q,ans;
int main()
{
	scanf("%d%d",&n,&q);
	int x0,y0,x1,y1,opt,k,tmp;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&x0,&y0,&k);
			x0 = x0^ans,y0 = y0^ans,k = k^ans;
			P p = P(x0,y0);
			Insert(root,p,k);
		}else
		{
			scanf("%d%d%d%d%d",&x0,&y0,&x1,&y1,&k);
			x0 = x0^ans,y0 = y0^ans,x1 = x1^ans,y1 = y1^ans,k = k^ans;
			tmp = KD_tree::query(ti[root].rt,x0,y0,x1,y1);
			if(tmp<k){printf("NAIVE!ORZzyz.\n");ans = 0;}
			else printf("%d\n",ans = query(root,x0,y0,x1,y1,k));
		}
	}
	return 0;
}
Problem4607

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e6+5;
const int M = 30;
int f[30][1<<13][3];
int cnt[M][M],deg[M],w[M][M],fa[M],d[M],g[M],id[M],n,c,m;
bool vis[M],del[M];
char a[N],b[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void Up(int &a,int b){a=a<b?a:b;}
int Cnt(int x)
{
	int cnt = 0;
	while(x)cnt++,x-=x&(-x);
	return cnt;
}
int main()
{
	scanf("%d%d",&n,&c);
	scanf("%s",a);scanf("%s",b);
	for(int i = 0;i<n;i++)
		cnt[a[i]-'a'][b[i]-'a']++,deg[a[i]-'a']++;
	for(int i = 0;i<26;i++)
		for(int j = 0;j<26;j++)
		{
			w[i][j] = deg[i]-cnt[i][j];
			if(i!=j)w[i][j]+=c;
		}
	for(int i = 0;i<26;i++)fa[i]=i,id[i]=-1;
	for(int i = 0;i<26;i++)
	{
		int k = 0;
		for(int j=0;j<26;j++)
			if(w[i][j]<w[i][k])k=j;
		d[g[i]=k]++;
		if(getfa(i)!=getfa(k))fa[fa[i]]=fa[k];
	}
	int ans = 0;
	for(int i = 0;i<26;i++)
		if(!del[getfa(i)])
		{
			del[fa[i]]=vis[i]=true;
			int j;
			for(j = g[i];!vis[j];j=g[j])vis[j]=true;
			if(g[j]==j)continue;id[j]=m;
			for(int k = g[j];k!=j;k=g[k])id[k]=m;
			m++;
		}
	if(!m)
	{
		for(int i = 0;i<26;i++)ans+=w[i][g[i]];
		printf("%d\n",ans);
		return 0;
	}
	int flag = 1;
	for(int i = 0;i<26;i++)
		if(d[i]!=1)flag = 0;
	for(int i = 0;i<= 26;i++)
		for(int S = 0;S < 1<<m;S++)
			for(int j = 0;j<2;j++)
				f[i][S][j]=INF;
	f[0][0][0]=0;
	for(int i = 0;i<26;i++)
		for(int S = 0;S< 1<<m;S++)
			for(int j = 0;j<2;j++)
				if(f[i][S][j]<INF)
				{
					for(int k = 0;k<26;k++)
					{
						int sta = S;
						if(~id[i] && k!=g[i])sta|=1<<id[i];
						if(~id[k] && (k!=g[i] || id[i]!=id[k] ))sta|=1<<id[k];
						Up(f[i+1][sta][j||k!=g[i]],f[i][S][j]+w[i][k]);
					}
				}
	ans = INF;
	for(int S = 0;S<1<<m;S++)
		for(int j = flag;j<2;j++)
			if(f[26][S][j]<INF)
				Up(ans,f[26][S][j]+(m-Cnt(S))*c);
	printf("%d\n",ans);
	return 0;
}
Problem4613

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#define fir first
#define sec second
using namespace std;
typedef long long ll;
typedef pair<ll,int> pil;
const int N = 1e6+5;
const ll INF = 1e18;
priority_queue<pil, vector<pil> , greater<pil> >Q;
struct E
{int next,to,val;}e[N];
int head[N],tot,cnt;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];
	head[x] = tot;e[tot].val = f;
}
int n,m,fa[N],a[N],deg[N],ans[N];
ll dis[N],f[N];
void dfs(int x,int pre)
{
	f[x] = x<=n?0:INF;
	for(int i = head[x];i;i=e[i].next)
	{
		fa[e[i].to] = x;
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to,i);
		if(f[e[i].to]<f[x])f[x] = f[e[i].to];
		deg[x]++;
	}
	f[x]+=e[pre].val;
}
char name[N>>1][15];
bool cmp(int a,int b)
{return dis[a]<dis[b];}
void Push(int x)
{
	if(x==n+1)return ;
	if(--deg[x])return ;
	cnt++;
	Q.push(pil(f[x],x));
}
int main()
{
	int x,d;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",name[i]+1);
		scanf("%d%d",&x,&d);
		add(x+n+1,i,d);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&d);
		add(x+n+1,i+n+1,d);
	}
	dfs(n+1,0);
	f[n+1] = INF;
	for(int i = 1;i<= n;i++)a[i]=i;
	sort(a+1,a+n+1,cmp);
	cnt = n;
	for(int i = 1;i<= n;i++)Q.push(pil(f[i],i));
	for(int i = 1;i<= n;ans[a[i++]]=cnt)
		while(!Q.empty())
		{
			pil t = Q.top();
			if(t.fir>dis[a[i]])break;
			Q.pop();
			cnt--;
			Push(fa[t.sec]);
		}
	for(int i = 1;i<= n;i++)
		printf("%s %d\n",name[i]+1,ans[i]+1);
	return 0;
}
Problem4617

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2.5e5+5;
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend void operator -=(Point &a,const Point &b)
	{a = a-b;}
	friend ll operator *(const Point &a,const Point &b)
	{return 1ll*a.x*b.y-1ll*a.y*b.x;}
	friend Point operator *(const Point &a,int k)
	{return Point(a.x*k,a.y*k);} 
	friend bool operator ==(const Point &a,const Point &b)
	{return a.x==b.x&&a.y==b.y;}
	friend bool operator !=(const Point &a,const Point &b)
	{return a.x!=b.x||a.y!=b.y;}
}a[N],b[N],c[N<<1];
int cnta,cntb,m,n,cnt,ce;
struct E
{
	Point o;int t;
	E(){}
	E(Point _o,int _t):o(_o),t(_t)
	{
		if(o.x<0)o = o*-1;
	}
}e[N<<1];
inline bool cmp1(const Point &x,const Point &y)
{return x.x==y.x?x.y<y.y:x.x<y.x;}
inline bool cmp2(const E &a,const E &b)
{return a.o*b.o<0ll;}
int get_convexhull(Point *p,int n,Point *q)
{
	int k,m;
	m = 0;
	for(int i = 0;i<n;q[m++]=p[i++])
		while(m>1&&(q[m-1]-q[m-2])*(p[i]-q[m-2])<=0)m--;
	k = m;
	for(int i = n-2;~i;q[m++]=p[i--])
		while(m>k&&(q[m-1]-q[m-2])*(p[i]-q[m-2])<=0)m--;
	return --m;
}
bool P_on_Seg(const Point &p,const Point &a,const Point &b)
{
	return (b-a)*(p-a)==0&&
	1ll*(p.x-a.x)*(p.x-b.x)+1ll*(p.y-a.y)*(p.y-b.y)<=0;
}
int getl(int l,int r,const Point &p)
{
	int ret = l++,mid;
	while(l<=r)
	{
		mid = (l+r)>>1;
		if((c[mid]-p)*(c[(mid-1+n)%n]-c[mid])<=0)l=(ret=mid)+1;
		else r = mid-1;
	}
	return ret;
}
int getr(int l,int r,const Point &p)
{
	int ret = r--,mid;
	while(l<=r)
	{
		mid = (l+r)>>1;
		if((c[mid]-p)*(c[(mid+1)%n]-c[mid])>=0)r=(ret=mid)-1;
		else l = mid+1;
	}
	return ret;
}
void solve(const Point &p)
{
	if(P_on_Seg(p,c[0],c[n-1]))
		{cnt++;return ;}
	int o = 0;
	if(p.x>0)
	{
		int l = 1,r = n-1,mid;
		while(l<=r)
		{
			mid = (l+r)>>1;
			if(c[mid]*p>=0)l=(o=mid)+1;
			else r = mid-1;
		}
	}else if(p.y>0)o = n-1;
	if(p.x>=0&&(p-c[o])*(c[o+1]-p)<0){cnt++;return ;}
	if(p.x>=0&&P_on_Seg(p,c[o],c[o+1])){cnt++;return ;}
	int l,r;
	if(p.x>0)l = getl(0,o,p),r = getr(o,n,p);
	else l = getl(m,n,p),r = getr(0,m,p);
	e[++ce] = E(p-c[l],1);
	e[++ce] = E(p-c[r],-1);
	if(cmp2(e[ce],e[ce-1]))cnt++;
}
int main()
{
	int x,y,opt;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d%d%d",&x,&y,&opt);
		if(opt)a[++cnta] = Point(x,y);
		else b[++cntb] = Point(x,y);
	}
	if(cnta==1)
	{
		printf("1");
		return 0;
	}
	sort(a+1,a+cnta+1,cmp1);
	cnt = cnta;cnta = 0;
	for(int i = 1;i<= cnt;i++)
		if(a[i]!=a[i-1]||i==1)
			a[++cnta]=a[i];
	if(cnta==1)
	{
		for(int i = 1;i<= cntb;i++)
			if(a[1]==b[i])cnt++;
		printf("%d\n",cnt);return 0;
	}
	if(cnta==2)
	{
		for(int i = 1;i<= cntb;i++)
			if(P_on_Seg(b[i],a[1],a[2]))
				cnt++;
		printf("%d\n",cnt);return 0;
	}
	n = get_convexhull(a+1,cnta,c);
	for(int i = 1;i<n;i++)c[i]-=c[0];
	for(int i = 1;i<= cntb;i++)b[i]-=c[0];
	c[0]-=c[0];
	for(int i = 0;i<n;i++)if(c[i].x>=c[m].x)m=i;
	for(int i = 0;i<n;i++)c[i+n]=c[i];
	for(int i = 1;i<= cntb;i++)solve(b[i]);
	sort(e+1,e+ce+1,cmp2);
	int ret=0,mv=0,j;
	for(int i = 1;i<= ce;i=j)
	{
		for(j=i;j<=ce&&e[i].o*e[j].o==0;j++)
			ret+=e[j].t;
		if(ret<mv)mv = ret;
	}
	printf("%d\n",cnt+mv);
	return 0;
}
Problem4619

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
struct E
{
	int pre,nxt;
	E(){}
	E(int _pre,int _nxt):pre(_pre),nxt(_nxt){}
}a[N],b[N];
bool cmp1(const E &x,const E &y)
{return x.pre<y.pre;}
bool cmp2(const E &x,const E &y)
{return x.nxt>y.nxt;}
int main()
{
	int n;
	int cnt1=0,cnt2 = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		int pr,nx;
		scanf("%d%d",&pr,&nx);
		if(nx>pr)a[++cnt1] = E(pr,nx);
		else b[++cnt2] = E(pr,nx);
	}
	sort(a+1,a+cnt1+1,cmp1);
	sort(b+1,b+cnt2+1,cmp2);
	long long ans = 0,rem = 0;
	for(int i = 1;i<= cnt1;i++)
	{
		if(rem<1ll*a[i].pre)
		{
			ans+=a[i].pre-rem;
			rem = 0;
		}
		else rem-=a[i].pre;
		rem+=a[i].nxt;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		if(rem<1ll*b[i].pre)
		{
			ans+=b[i].pre-rem;
			rem = 0;
		}
		else rem-=b[i].pre;
		rem+=b[i].nxt;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4624

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{return cp(a.x+b.x,a.y+b.y);}
	friend cp operator -(const cp &a,const cp &b)
	{return cp(a.x-b.x,a.y-b.y);}
	friend cp operator *(const cp &a,const cp &b)
	{return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
}a[N],b[N],c[N];
const int R = 505;
char s[R][R],s2[R][R];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = (len>>1);(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w(1,0),tmp;
			for(int k = 0;k<i>>1;w=w*wn,k++)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
}
int main()
{
	int row,col,h,w,len,l;
	scanf("%d%d",&row,&col);
	for(int i = 0;i<row;i++)scanf("%s",s[i]);
	for(len=1;len<=row*col*2+2;len<<=1);
	l = row*col-1;
	int cas,Ans;
	scanf("%d",&cas);
	for(int Cas = 1;Cas<=cas;Cas++)
	{
		Ans = 0;
		scanf("%d%d",&h,&w);
		for(int i = 0;i<h;i++)scanf("%s",s2[i]);
		for(int i = 0;i<row;i++)
			for(int j = 0;j<col;j++)a[i*col+j]=cp(s[i][j]=='G'?1:-1,0);
		for(int i = l+1;i<len;i++)a[i]=cp();
		for(int i = 0;i<len;i++)b[i]=cp();
		for(int i = 0;i<h;i++)
			for(int j = 0;j<w;j++)b[l-i*col-j]=cp(s2[i][j]=='G'?1:-1,0);
		for(int i = 0;i<len;i++)c[i]=cp();
		conv(a,b,c,len);
		for(int i = 0;i<len-l;i++)ans[i]=(int)(c[l+i].x+0.5);
		int px=0,py=0,t1=0,t2=0;
		for(int i = 0;i<= row-h;i++)for(int j = 0;j<= col-w;j++)
			if(ans[i*col+j]>Ans){Ans=ans[i*col+j],px=i,py=j;}
		for(int i = 0;i<h;i++)for(int j = 0;j<w;j++)
			if(s[px+i][py+j]==s2[i][j])
			{
				if(s2[i][j]=='G')t1++;else t2++;
			}
		printf("Case #%d: %d %d %d %d\n",Cas,px+1,py+1,t1,t2);
	}
	return 0;
}
Problem4625

#include <stdio.h>
#include <map>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5+5;
const int BASE = 30000;
typedef long long ll;
map<pair<int,int>,int>val,vis;
int ex[N],x[N],y[N],c[N];
int dx[]={0,0,1,-1,1,-1};
int dy[]={1,-1,0,0,1,-1};
struct E
{
	int next,to,f;
}e[N*100];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
	if(d[e[i].to]==d[s]-1&&e[i].f)
	{
		int tof = get_mxf(e[i].to,t,min(e[i].f,last));
		if(tof)
		{
			e[i].f-=tof;
			e[i^1].f+=tof;
			if(!(last-=tof))return mf;
		}
	}
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int l[N],r[N];
int main()
{
	int n,z,C,cnt = 0,ans=0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x[i],&y[i],&z,&C);
		x[i]-=z,y[i]-=z;
		c[i] = (x[i]+y[i])%3==0?C*11:C*10;
		ans+=c[i];
		if(!vis[make_pair(x[i],y[i])])
			vis[make_pair(x[i],y[i])]=i,val[make_pair(x[i],y[i])]=c[i];
		else
			val[make_pair(x[i],y[i])]+=c[i],ex[i]=true;
	}
	int idx = 0;
	for(int i = 1;i<= n;i++)
		l[i]=++idx,r[i]=++idx;
	int S = ++idx,T = ++idx;
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==0)
			add(l[i],r[i],val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==1)
			add(S,r[i],val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==2)
			add(l[i],T,val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i])
		{
			for(int j = 0;j<6;j++)
			{
				int xx = x[i]+dx[j],yy = y[i]+dy[j];
				int tmp = vis[make_pair(xx,yy)];
				if(!tmp)continue;
				if ((xx+yy+BASE) % 3 == 0 && (x[i]+y[i]+BASE)%3 == 1) add(r[i],l[tmp],INF);
            	if ((xx+yy+BASE) % 3 == 2 && (x[i]+y[i]+BASE)%3 == 0) add(r[i],l[tmp],INF);

			}
		}
	ans-=dinic(S,T);
	printf("%d.%d\n",ans/10,ans%10);
	return 0;
}
Problem4627

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int a[N],cnt;
ll sum[N],pos[N];
int c[N];
void update(int x)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]++;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int getans(int l,int r)
{
	return getans(r)-getans(l-1);
}
int upper(ll x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<=x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
int lower(ll x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,L,R;
	scanf("%d%d%d",&n,&L,&R);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum[i] = sum[i-1]+a[i];
		pos[i] = sum[i];
	}
	sort(pos+1,pos+n+2);
	cnt = 1;
	for(int i = 2;i<= n+1;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt]=pos[i];
	ll ans = 0;
	update(lower(0));
	for(int i = 1;i<= n;i++)
	{
		ans+=getans(lower(sum[i]-R),upper(sum[i]-L));
		update(lower(sum[i]));
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4628

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int M = N*64;
struct data
{
	int t,i,f;
	data(int _t=0,int _i=0,int _f=0):t(_t),i(_i),f(_f){}
	bool operator <(const data &s)const
	{
		return t<s.t;
	}
}s[N<<1];
int ans[N];
struct Trie
{
	int lazy,s,f;
	int ch[2];
}tr[M];
void Push_down(int p)
{
	int ls = tr[p].ch[0],rs = tr[p].ch[1];
	if(tr[p].lazy)
	{
		if(!tr[ls].f)
		{
			tr[ls].lazy+=tr[p].lazy;
			tr[ls].s+=tr[p].lazy;
		}
		if(!tr[rs].f)
		{
			tr[rs].lazy+=tr[p].lazy;
			tr[rs].s+=tr[p].lazy;
		}
		tr[p].lazy = 0;
	}
}
char opt[N][10],str[N][35];
char ip[N][35];
int l[N],r[N],top=1;
void Update(int now)
{
	int kind = 1;
	if(opt[now][0]=='D')kind = -1;
	int l = strlen(str[now]+1);
	int j = 1;
	for(int i = 1;i<= l;i++)
	{
		if(!tr[j].ch[0])tr[j].ch[0] = ++top;
		if(!tr[j].ch[1])tr[j].ch[1] = ++top;
		Push_down(j);
		j = tr[j].ch[str[now][i]-'0'];
	}
	tr[j].lazy++,tr[j].s++,tr[j].f+=kind;
}
int Getans(int now)
{
	int j = 1;
	for(int i = 1;i<= 32;i++)
	{
		if(!tr[j].ch[0])tr[j].ch[0]=++top;
		if(!tr[j].ch[1])tr[j].ch[1]=++top;
		Push_down(j);
		j = tr[j].ch[ip[now][i]-'0'];
	}
	return tr[j].s;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%s%s",opt[i],str[i]+1);
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",ip[i]+1,&l[i],&r[i]);
		s[(i<<1)-1] = data(l[i],i,-1);
		s[i<<1] = data(r[i],i,1);
	}
	sort(s+1,s+q*2+1);
	int j = 1;
	for(int i = 1;i<= 2*q;i++)
	{
		while(j<=s[i].t)
		{
			Update(j);
			j++;
		}
		ans[s[i].i]+=s[i].f*Getans(s[i].i);
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4629

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 505;
int ch[N][26];
char s[N];
int a[110],fail[N],last[N],w[N],cnt;
void addnew(int v)
{
	int i = 1,now = 0;
	while(s[i])
	{
		if(!ch[now][s[i]-'a'])ch[now][s[i]-'a'] = ++cnt;
		now = ch[now][s[i]-'a'];
		i++;
	}
	w[now]+=v;
}
int q[N],hd,tl;
void Build_fail()
{
	hd = 1,tl = 0;
	for(int i = 0;i<26;i++)
		if(ch[0][i])q[++tl]=ch[0][i];
	while(hd<=tl)
	{
		int x = q[hd++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[x][i];
			if(!j){ch[x][i]=ch[fail[x]][i];continue;}
			int k = fail[x];
			while(k&&!ch[k][i])k=fail[k];
			fail[j] = ch[k][i];
			w[j]+=w[fail[j]];
			if(w[fail[j]])last[j] = fail[j];
			else last[j]=last[fail[j]];
			q[++tl]=j;
		}
	}
}
int f[N][N][6];
bool used[N][N][6];
int K,m;
void dp(int n,int x,int k)
{
	if(k>K||used[n][x][k])return;
	used[n][x][k]=true;
	f[n][x][k]=w[x];
	if(n==m)return ;
	int maxn = -707185547707185547LL,maxb = 0;
	for(int i = 0;i<26;i++)
	{
		dp(n+1,ch[x][i],k);
		if(k<K)
			dp(n+1,ch[x][i],k+1);
		if(f[n+1][ch[x][i]][k]>maxn)
		{
			maxn = f[n+1][ch[x][i]][k];
			maxb = i;
		}
	}
	maxn = 707185547707185547LL;
	for(int i = 0;i<26;i++)
	{
		if(i==maxb)maxn = min(maxn,f[n+1][ch[x][i]][k]);
		else if(k<K)maxn = min(maxn,f[n+1][ch[x][i]][k+1]);
	}
	f[n][x][k]+=maxn;
}
ll di[205][205],tmp[205][205],ret[205][205];
ll ans;
void solve1(int M,bool chu)
{
	ans = 0;
	if(chu)
	{
		memset(di,0xef,sizeof(di));
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<26;j++)
				di[i][ch[i][j]]=w[ch[i][j]];
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
				ret[i][j]=di[i][j];
		M--;
		while(M)
		{
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					tmp[i][j]=-707185547707185547LL;
			if(M&1)
			{
				for(int i = 0;i<= cnt;i++)
					for(int k = 0;k<= cnt;k++)
						for(int j = 0;j<= cnt;j++)
							tmp[i][j]=max(tmp[i][j],ret[i][k]+di[k][j]);
				for(int i = 0;i<= cnt;i++)
					for(int j = 0;j<= cnt;j++)
						ret[i][j]=tmp[i][j];
			}
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					tmp[i][j]=-707185547707185547LL;
			for(int i = 0;i<= cnt;i++)
				for(int k = 0;k<= cnt;k++)
					for(int j = 0;j<= cnt;j++)
						tmp[i][j]=max(tmp[i][j],di[i][k]+di[k][j]);
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					di[i][j]=tmp[i][j];
			M>>=1;
		}
		memset(di,0xef,sizeof(di));
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<26;j++)
				di[i][ch[i][j]]=w[ch[i][j]];
	}
	else
	{
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
			{
				tmp[i][j]=-707185547707185547LL;
				for(int k = 0;k<= cnt;k++)
					tmp[i][j]=max(tmp[i][j],ret[i][k]+di[k][j]);
			}
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
				ret[i][j]=tmp[i][j];
	}
	for(int i = 0;i<= cnt;i++)
		ans = max(ans,ret[0][i]);
}
void solve2()
{
	int M = m;
	int P = M-300;
	ll res = 0;
	int st;
	for(;P<=M-250;P++)
	{
		for(int i = 0;i<= 300;i++)
			for(int j = 0;j<= cnt;j++)
				for(int k = 0;k<= K;k++)
					used[i][j][k]=false;
		m = M-P;
		dp(0,0,0);
		solve1(P,(P==M-300));
		res = max(res,f[0][0][0]+ans);
	}
	printf("%lld\n",res+1);
}
int main()
{
	int n;
	scanf("%d%d%d",&n,&m,&K);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",s+1,&a[i]);
		addnew(a[i]);
	}
	Build_fail();
	if(m>500&&K==0&&cnt<=200){solve1(m,true);printf("%lld\n",ans);}
	else if(m>500&&K!=0&&cnt<=51){solve2();}
	else
	{
		dp(0,0,0);
		printf("%d\n",f[0][0][0]);
	}
	return 0;
}
Problem4631

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int pre[N],nxt[N];
struct C
{int l,r,i;}cld[N];
bool operator <(const C &a,const C &b)
{return a.r<b.r;}
int tr[N<<2],a[N],c[N],n,m;
inline int Push_up(int x,int y)
{
	return cld[x].l>cld[y].l?x:y;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p] = l;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);build(p<<1|1,mid+1,r);
	tr[p] = Push_up(tr[p<<1],tr[p<<1|1]);
}
void update(int p,int l,int r,int pos)
{
	if(l==r){tr[p]=0;return ;}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos);
	else update(p<<1|1,mid+1,r,pos);
	tr[p] = Push_up(tr[p<<1],tr[p<<1|1]);
}
int getans(int p,int l,int r,int d)
{
	if(r<=d)return tr[p];
	int mid = (l+r)>>1,t = getans(p<<1,l,mid,d);
	if(d>mid)t = Push_up(t,getans(p<<1|1,mid+1,r,d));
	return t;
}
int ans = 0;
void Delete(int x)
{
	a[x]--;if(a[x])return ;
	int l = pre[x],r = nxt[x];
	pre[r] = l,nxt[l] = r;r = c[r-1];
	if(!r)return ;
	while(true)
	{
		int t = getans(1,1,m,r);
		if(cld[t].l<=l)return ;
		ans++;update(1,1,m,t);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),pre[i]=i-1,nxt[i]=i+1;
	int lastans = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&cld[i].l,&cld[i].r);
		cld[i].i=i;
	}
	sort(cld+1,cld+m+1);
	for(int i = 1;i<= m;i++)
		if(cld[i].r!=cld[i-1].r)
			for(int j = cld[i-1].r;j<cld[i].r;j++)c[j] = i-1;
	for(int i = cld[m].r;i<= n;i++)c[i]=m;
	build(1,1,m);
	int Q,x;
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%d",&x);x = (x+ans-1)%n+1;
		Delete(x);printf("%d\n",ans);
	}
	return 0;
}
Problem4641

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int a[N],b[N],col[N],nxt[N];
int ans[N],tot,j;
inline bool check(int x,int y)
{
	if(b[x]==-1)
	{
		if(y>=x||y==-1)return true;
	}
	return b[x]==y;
}
int main()
{
	int cas,C;
	scanf("%d%d",&cas,&C);
	while(cas--)
	{
		int n,m,x;
		scanf("%d%d",&n,&m);
		memset(col,0,sizeof(col));
		for(int i = 1;i<= n;i++)
		{
			scanf("%d",&x);
			a[i] = i-col[x];
			col[x] = i;
		}
		memset(col,0,sizeof(col));
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&x);
			if(!col[x])b[i]=-1;
			else b[i]=i-col[x];
			col[x] = i;
		}
		j = tot = 0;
		for(int i = 2;i<= m;i++)
		{
			while(j && !check(j+1,b[i]))j = nxt[j];
			if(check(j+1,b[i]))j++;nxt[i]=j;
		}
		j = 0;
		for(int i = 1;i<= n;i++)
		{
			while(j && !check(j+1,a[i]))j = nxt[j];
			if(check(j+1,a[i]))j++;
			if(j==m)
			{
				ans[++tot] = i-m+1;
				j = nxt[j];
			}
		}
		printf("%d\n",tot);
		for(int i = 1;i<= tot;i++)
			printf("%d ",ans[i]);
		puts("");
	}
	return 0;
}
Problem4650

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int sed = 237;
const int N = 3e4+5;
int u[N],v[N];
char s[N];
int hash[N],pow[N];
void pre()
{
	pow[0]=1;
	for(int i =1;i<N;i++)
		pow[i]=(ll)pow[i-1]*sed%mod;
}
int Hash(int l,int r)
{
	return (hash[r]-(ll)hash[l]*pow[r-l]%mod+mod)%mod;
}
int main()
{
	int cas,p,q,l,r,mid;
	long long ans = 0;
	scanf("%d",&cas);
	pre();
	while(cas--)
	{
		scanf("%s",s+1);int n = strlen(s+1);
		for(int i = 1;i<= n;i++)
			u[i]=v[i]=0,hash[i] = ((ll)hash[i-1]*sed+s[i]-'a')%mod;
		for(int i = 1;2*i<= n;i++)
			for(int j = 1;j+i<= n;j+=i)
			{
				l = 0,r = min(i,j);
				while(l^r)
				{
					mid = (l+r+1)>>1;
					if(Hash(j+i-mid,j+i)==Hash(j-mid,j))l=mid;
					else r = mid-1;
				}
				p = j-l+1;
				l = 0,r = min(i-1,n-j-i);
				while(l^r)
				{
					mid = (l+r+1)>>1;
					if(Hash(j+i,j+i+mid)==Hash(j,j+mid))l=mid;
					else r = mid-1;
				}
				q = j+l+1;
				if(p+i<=q)
				{
					++u[p],--v[q+i];
					--u[q-i+1];++v[p+i*2-1];
				}
			}
		ans = 0;
		for(int i = 1;i<= n;i++)
			u[i]+=u[i-1],v[i]+=v[i-1],ans+=(ll)u[i]*v[i-1];
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4651

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int P = N*25;
const int M = P*4;
const int bas = 2e9;
struct E
{int next,to;}e[M];
struct P
{int x,y,lev;}p[P];
int head[P],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
map<ll,int>pos;
int dfn[P],low[P],Dfn,cnt;
bool flag;
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	int son = 0;
	for(int i = head[x];i;i=e[i].next)
		if(p[e[i].to].lev)
		{
			if(!dfn[e[i].to])
			{
				son++;
				tarjan(e[i].to);
				low[x] = min(low[x],low[e[i].to]);
				if(p[x].lev==2)continue;
				if(dfn[x]==1&&son>=2)flag = true;
				if(dfn[x]!=1&&dfn[x]<=low[e[i].to])flag = true;
			}else
				low[x] = min(low[x],dfn[e[i].to]);
		}
}
bool vis[P];int vt;
void dfs(int x)
{
	vis[x] = true;
	if(p[x].lev)vt++;
	for(int i = head[x];i;i=e[i].next)if(!vis[e[i].to])dfs(e[i].to);
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		for(int i = 0;i<= cnt;i++)head[i]=dfn[i]=low[i]=vis[i]=0;tot=1;
		pos.clear();
		int n,m,c,tmp;cnt = 0;
		bool ans0=false;
		ll x,y;
		scanf("%d%d%d",&n,&m,&c);
		for(int i = 1;i<= c;i++)
		{
			scanf("%lld%lld",&x,&y);
			pos[x*bas+y]=i;
			p[i].x = x,p[i].y = y;p[i].lev = 0;
		}
		cnt = c;
		if(1ll*n*m-c<=1){puts("-1");continue;}
   		if(1ll*n*m==2&&!c){puts("-1");continue;}
		for(int i = 1;i<= c;i++)
			for(int nx = max(1,p[i].x-1);nx<=min(n,p[i].x+1);nx++)
				for(int ny = max(1,p[i].y-1);ny<=min(m,p[i].y+1);ny++)
				{
					if(pos[(ll)nx*bas+ny])continue;
					p[++cnt].x = nx,p[cnt].y = ny;p[cnt].lev = 1;
					pos[(ll)nx*bas+ny]=cnt;
				}
		for(int i = 1;i<= c;i++)
			for(int nx = max(1,p[i].x-2);nx<=min(n,p[i].x+2);nx++)
				for(int ny = max(1,p[i].y-2);ny<=min(m,p[i].y+2);ny++)
				{
					if(pos[(ll)nx*bas+ny])continue;
					p[++cnt].x = nx,p[cnt].y = ny;p[cnt].lev = 2;
					pos[(ll)nx*bas+ny]=cnt;
				}
		for(int i = 1;i<= cnt;i++)
		{
			if((tmp=pos[((ll)(p[i].x+1)*bas+p[i].y)]))
				add(i,tmp);
			if((tmp=pos[((ll)p[i].x*bas+p[i].y+1)]))
				add(i,tmp);
		}
		flag = false;
		for(int i = c+1;i<= cnt;i++)
		{
			if(vis[i])continue;
			vt = 0;dfs(i);
			Dfn = 0;tarjan(i);
			if(Dfn!=vt){ans0=true;break;}
		}
		if(ans0){puts("0");continue;}
		if(1ll*n*m-c==2&&Dfn==2){puts("-1");continue;}
    	if(n==1||m==1){puts("1");continue;}
    	if(flag){puts("1");continue;}
    	puts("2");
	}
	return 0;
}
Problem4652

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int mu[N],prime[N/10],cnt,f[2005],g[2005],k,stack[2005],top;
bool vis[N];
int gcd(int a,int b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
void get_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
			else
				mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i = 1;i<= k;i++)
		f[i] = f[i-1]+(gcd(i,k)==1),g[i]=g[i-1]+(gcd(i,k)==1)*mu[i];
	for(int i = 2;i<= k;i++)if(k%i==0&&mu[i])stack[++top]=i;
	for(int i = 1;i<N;i++)mu[i]+=mu[i-1];
}
map<ll,int>mp,mp2;
inline int calc_mu(int x)
{
	if(x<N)return mu[x];
	if(mp.count(x))mp[x];
	int t = 1;
	for(int i = 2,last;i<= x;i=last+1)
	{
		last = x/(x/i);
		t-=(last-i+1)*calc_mu(x/i);
	}
	return mp[x] = t;
}
inline int calc(int x)
{
	if(x<=k)return g[x];
	if(mp2.count(x))return mp2[x];
	int tmp = calc_mu(x);
	for(int i = 1;i<= top && stack[i]<=x;i++)
	{
		tmp = tmp-(mu[stack[i]]-mu[stack[i]-1])*calc(x/stack[i]);
	}
	return mp2[x] = tmp;
}
inline int F(int x)
{
	return (x/k)*f[k]+f[x%k];
}
int main()
{
	int n,m;
	scanf("%d%d%d",&n,&m,&k);
	get_mu();
	ll ans = 0;
	for(int i = 1,last;i<=min(n,m);i=last+1)
	{
		last = min(n/(n/i),m/(m/i));
		ans += (ll)(calc(last) - calc(i-1)) * F(m/i) * (n/i);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4653

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int M = 200005;
const int INF = (1<<30)+((1<<30)-1);
int maxn[N<<2],lazy[N<<2];
int p[N],tot;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Q
{
	int l,r,len;
}qu[N>>1];
bool cmp(Q a,Q b)
{
	return a.len<b.len;
}
void push_down(int p,int l,int r)
{
	if(l==r||!lazy[p])return ;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=c;
		maxn[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid) update(p<<1|1,mid+1,r,a,b,c);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int find(int x)
{
	int l = 1,r = tot+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(p[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		qu[i].l = read();
		qu[i].r = read();
		qu[i].len = qu[i].r-qu[i].l+1;
		p[++tot] = qu[i].l;p[++tot] = qu[i].r;
	}
	sort(p+1,p+tot+1);
	int tmp = tot;tot = 0;
	for(int i = 1;i<= tmp;i++)
		if(p[i]!=p[tot])
			p[++tot] = p[i];
	for(int i = 1;i<= n;i++)
		qu[i].l = find(qu[i].l),qu[i].r = find(qu[i].r);
	sort(qu+1,qu+n+1,cmp);
	int now = 0;
	int ans = INF;
	for(int i = 1;i<= n;i++)
	{
		while(maxn[1]<m)
		{
			if(now==n)break;
			now++;
			update(1,1,tot,qu[now].l,qu[now].r,1);
		}
		//if(now==n)break;
		if(maxn[1]>=m)ans = min(ans,qu[now].len-qu[i].len);
		update(1,1,tot,qu[i].l,qu[i].r,-1);
	}
	if(ans==INF)printf("-1\n");
	else printf("%d\n",ans);
	return 0;
}
Problem4654

#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
typedef long long ll;
const int N = 8005;
// ---------- decimal lib start ----------
const int PREC=3010;
class Dec{
public:
    Dec();
    Dec(int x);
    bool is_zero() const;
    string to_string(int p) const;
    friend Dec operator + (const Dec &a,const Dec &b);
    friend Dec operator - (const Dec &a,const Dec &b);
    Dec & operator += (int x);
    Dec & operator += (ll x);
    Dec & operator -= (int x);
    Dec & operator /= (int x);
    friend Dec operator - (const Dec &a);
private:
    static const int len=PREC/9+1;
    static const int mo=1000000000;
    static void append_to_string(string &s,ll x);
    bool is_neg;
    ll integer;
    int data[len];
    void init_zero();
    void init(const char *s);
};
Dec::Dec(){init_zero();}
Dec::Dec(int x){
    init_zero();
    if(x<0){is_neg=1;x=-x;}
    integer=x;
}
void Dec::init_zero(){
    is_neg=0;
    integer=0;
    memset(data,0,len*sizeof(int));
}
bool Dec::is_zero()const{
    if(integer)return 0;
    for(int i=0;i<len;i++)if(data[i])return 0;
    return 1;
}
void Dec::init(const char *s){
    init_zero();
    is_neg=0;
    integer=0;
    while(*s!=0){
        if(*s=='-'){is_neg=1;++s;break;}
        else if(*s>=48&&*s<=57)break;
        ++s;
    }
    while(*s>=48&&*s<=57){integer=integer*10+*s-48;++s;}
    if(*s=='.'){
        int pos=0,x=mo/10;
        ++s;
        while(pos<len&&*s>=48&&*s<=57){
            data[pos]+=(*s-48)*x;
            ++s;x/=10;
            if(!x){++pos;x=mo/10;}
        }
    }
}
void Dec::append_to_string(string &s,ll x){
    if(x==0){s.append(1,48);return;}
    char _[30];
    int cnt=0;
    while(x){_[cnt++]=x%10;x/=10;}
    while(cnt--){s.append(1,_[cnt]+48);}
}
string Dec::to_string(int p)const{
    string ret;
    if(is_neg&&!is_zero())ret="-";
    append_to_string(ret,integer);
    ret.append(1,'.');
    for(int i=0;i<len;i++){
        int x=mo/10,tmp=data[i];
        while(x){
            ret.append(1,48+tmp/x);
            tmp%=x;x/=10;
            if(!--p)break;
        }
        if(!p)break;
    }
    if(p>0)ret.append(p,'0');
    return ret;
}
Dec & Dec::operator +=(ll x){
    if(!is_neg){
        if(integer+x>=0){integer+=x;}
        else{
            bool last=0;
            for(int i=len-1;i>=0;i--)
                if(last||data[i]){data[i]=mo-data[i]-last;last=1;}
                else last=0;
            integer=-x-integer-last;
            is_neg=1;
        }
    }else{
        if(integer-x>=0)integer-=x;
        else{
            bool last=0;
            for(int i=len-1;i>=0;i--)
                if(last||data[i]){data[i]=mo-data[i]-last;last=1;}
                else last=0;
            integer=x-integer-last;
            is_neg=0;
        }
    }
    return *this;
}
Dec & Dec::operator +=(int x){return *this+=(ll)x;}
Dec & Dec::operator -=(int x){return *this+=(ll)-x;}
Dec & Dec::operator /=(int x){
    if(x<0){is_neg^=1;x=-x;}
    int last=integer%x;
    integer/=x;
    for(int i=0;i<len;i++){
        ll tmp=1LL*last*mo+data[i];
        data[i]=tmp/x;
        last=tmp-1LL*data[i]*x;
    }
    if(is_neg&&!integer){
        int i;
        for(i=0;i<len;i++)if(data[i]!=0)break;
        if(i==len)is_neg=0;
    }
    return *this;
}
Dec operator -(const Dec &a){
    Dec ret=a;
    if(!ret.is_neg&&!ret.integer){
        int i;
        for(i=0;i<Dec::len;i++)if(!ret.data[i])break;
        if(i<Dec::len)ret.is_neg=1;
    }else ret.is_neg^=1;
    return ret;
}
Dec operator +(const Dec &a,int x){Dec ret=a;return ret+=x;}
Dec operator -(const Dec &a,int x){Dec ret=a;return ret-=x;}
Dec operator /(const Dec &a,int x){Dec ret=a;return ret/=x;}
Dec operator +(const Dec &a,const Dec &b){
    if(a.is_neg==b.is_neg){
        Dec ret=a;
        bool last=0;
        for(int i=Dec::len-1;i>=0;i--){
            ret.data[i]+=b.data[i]+last;
            if(ret.data[i]>=Dec::mo){ret.data[i]-=Dec::mo;last=1;}
            else last=0;
        }
        ret.integer+=b.integer+last;
        return ret;
    }else if(!a.is_neg)return a- -b;
    else return b- -a;
}
Dec operator -(const Dec &a,const Dec &b){return a+-b;}
// ---------- decimal lib end ----------
ld f[15][N],y[N];
int q[N],g[15][N],end[N];
ll h[N];
inline ld slope(int a,int b)
{
	return (y[b]-y[a])/(b-a);
}
int main()
{
	int n,k,p;
	scanf("%d%d%d",&n,&k,&p);
	scanf("%lld",&h[1]);
	for(int i = 2;i<= n;i++)
	{
		scanf("%lld",&h[i]);
		if(h[i]<=h[1])n--,i--;
	}
	sort(h+1,h+n+1);
	for(int i = 2;i<= n;i++)h[i]+=h[i-1];
	for(int i = 1;i<= n;i++)f[0][i] = h[1];
	k = min(k,n-1);int W = min(k,14);
	for(int i = 1;i<= W;i++)
	{
		int l = 1,r = 0;
		for(int j = 2;j<= n;j++)
		{
			y[j-1] = h[j-1]-f[i-1][j-1];
			while(l<r&&slope(q[r-1],q[r])>=slope(q[r],j-1))r--;
			q[++r] = j-1;
			y[j+1] = h[j];
			while(l<r&&slope(q[l],j+1)<=slope(q[l+1],j+1))l++;
			f[i][j] = slope(q[l],j+1);
			g[i][j] = q[l];
		}
	}
	end[W]=n-(k-W);
	for(int i = W;i;i--)end[i-1] = g[i][end[i]];
	Dec ans = Dec(h[1]);
	for(int i = 1;i<= W;i++)ans = (ans+h[end[i]]-h[end[i-1]])/(end[i]-end[i-1]+1);
	for(int i=end[W]+1;i<=n;i++)ans=(ans+h[i]-h[i-1])/2;
    cout<<ans.to_string(p+1);
}
Problem4668

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
int fa[N],h[N],v[N],dep[N],cnt;
int getfa(int x)
{
	if(fa[x] == x) return  x;
	else return getfa(fa[x]);
}
void pre(int x)
{
	if(fa[x]==x)return ;
	pre(fa[x]);
	dep[x] = dep[fa[x]]+1;
}
int Ask(int x,int y)
{
	pre(x),pre(y);
	if(dep[x]<dep[y])swap(x,y);
	int re = 0;
	while(dep[x]>dep[y]&&x!=y)
	{
		re = max(re,v[x]);
		x = fa[x];
	}
	while(x!=y)
	{
		re = max(re,max(v[x],v[y]));
		x = fa[x],y = fa[y];
	}
	return re;
}
int main()
{
	int n,m,lastans = 0;
	int opt,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)fa[i]=i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt,&x,&y);
		x^=lastans,y^=lastans;
		int fx = getfa(x),fy = getfa(y);
		if(opt==0)
		{
			cnt++;
			if(fx!=fy)
			{
				if(h[fx]<=h[fy])
				{
					fa[fx] = fy;v[fx] = cnt;
					h[fy]+=(h[fx]==h[fy]);
				}else
				{
					fa[fy] = fx;v[fy] = cnt;
				}
			}
		}else
		{
			if(fx!=fy)printf("%d\n",lastans = 0);
			else printf("%d\n",lastans=Ask(x,y));
		}
	}
}
Problem4724

#include <stdio.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long ll;
int n,q;
ll a[N];
int main()
{
	ll sum = 0;
	scanf("%d%d",&n,&q);
	for(int i = 0;i<n;i++)
	{
		scanf("%lld",&a[i]);
		(sum+=a[i]*i)%=(n-1);
	}
	if(sum)a[sum]--;
	for(int i = 1;i<n;i++)
		a[i]+=a[i-1];
	ll tmp = 0;
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld",&tmp);
		int ans = upper_bound(a,a+n,tmp)-a;
		if(ans==n)ans=-1;
		printf("%d\n",ans);
	}
	return 0;
}
Problem4725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 10005;
ll a[N],r[N];
ll dec[N];
struct Ans
{
	int j,i;ll val;
	bool operator<(const Ans &s)const
	{
		return val<s.val;
	}
}e[N];
int getans(ll x,int n)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(e[mid].val<x)l=mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int cnt = 0,tot=0;
	a[1] = 1,a[2] = 2;
	dec[++cnt] = 0,dec[++cnt]=1;
	for(int i = 3;;i++)
	{
		if(i&1)a[i] = a[i-1]*2;
		else a[i] = a[i-1]+r[i-1];
		for(int j = i;j;j--)
			dec[++cnt] = a[i]-a[j];
		sort(dec+1,dec+cnt+1);
		cnt = unique(dec+1,dec+cnt+1)-dec-1;
		for(int j = 1;j<=cnt;j++)
			if(dec[j]!=j-1)
				{r[i] = j-1;break;}
		if(!r[i])r[i]=cnt;
		if(a[i]-a[i-1]>10000000000ll){tot=i;break;}
	}
	int tmp = 0;
	for(int i = 1;i<= tot;i++)
		for(int j = 1;j<i;j++)
			e[++tmp] = (Ans){i,j,a[i]-a[j]};
	sort(e+1,e+tmp+1);
	int n;
	ll q;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&q);
		int t = getans(q,tmp);
		if(e[t].val==q)printf("%d %d\n",e[t].j,e[t].i);
		else
		{
			ll ans = q-t+1;
			printf("%lld %lld\n",tot+ans*2-1,tot+ans*2-2);
		}
	}
	return 0;
}
Problem4726

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const double eps = 1e-7;
struct E
{int next,to;}e[N<<1];
double f[N],ans;
int head[N],tot,n,k;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int size[N];
void get_size(int x)
{
	size[x] = 1;
	bool lef = true;
	for(int i = head[x];i;i=e[i].next)
	{
		lef = false;
		get_size(e[i].to);
		size[x]+=size[e[i].to];
	}
	if(lef)f[x] = 1;
	else
	{
		for(int i = head[x];i;i=e[i].next)
			f[x] = max(f[x],min(1.0*size[e[i].to]/(size[x]-1),f[e[i].to]));
	}
	if(size[x]>k)ans = max(ans,f[x]);
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 2;i<=n;i++)
	{
		int x;scanf("%d",&x);
		add(x,i);
	}
	get_size(1);
	printf("%.7lf",ans);
	return 0;
}
Problem4727

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
bool a[N][N],b[N][N],vis[N],bo[N];
int stack[N],top,dfn[N],low[N],nxt[N],Dfn,dcc,bel[N],que[N],size[N],m,p[N],n;
bool ins[N];
void join(int x)
{
	vis[x]=true;
	for(int i = 1;i<= m;i++)if(a[que[i]][x])bo[que[i]]=true;
}
void work()
{
	int head=que[1],tail=que[1];
	int x,y,i,j;
	for(i = 2;i<= m;i++)
	{
		x = que[i];
		if(a[x][head])
		{
			nxt[x] = head;
			head = x;
			continue;
		}
		for(j=head,y=0;y!=tail&&a[j][x];y=j,j=nxt[j]);
		if(y==tail)
		{
			nxt[tail]=x;
			tail = x;
		}else
		{
			nxt[x] = j,nxt[y] = x;
		}
	}
	int mid = head;
	join(head);
	while(mid!=tail)
	{
		x = nxt[mid];
		if(a[x][head])
		{
			mid = x;join(x);
			continue;
		}
		for(i=head;i!=mid && a[i][x];j=i,i=nxt[i]);
		if(i!=mid)
		{
			nxt[j]=x,nxt[mid]=head;
			mid = x,head = i;join(x);
		}else
		{
			for(i = 1;i<= m;i++)if(!vis[que[i]] && bo[que[i]])break;
			for(j=head;j!=mid && a[j][que[i]];j = nxt[j]);
			for(y = nxt[mid];;y=nxt[y])
			{
				join(y);
				if(y==que[i])break;
			}
			nxt[mid] = head;head = j;mid = que[i];
			for(j=head,i=nxt[head];i!=head;j=i,i=nxt[i]);
			nxt[j] = x;
		}
	}
	for(int i = 1;i<= m;i++)bo[que[i]]=vis[que[i]]= false;
	nxt[tail]=head;
}
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = 1;i<=n;i++)if(a[x][i])
	{
		if(!dfn[i])
		{
			tarjan(i);
			low[x] = min(low[x],low[i]);
		}else if(ins[i])
			low[x] = min(low[x],dfn[i]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;p[dcc]=x;
		int tmp;m=0;
		do
		{
			tmp = stack[top--];
			ins[tmp]=false;
			bel[tmp]=dcc;
			size[dcc]++;que[++m]=tmp;
		}while(tmp!=x);
		work();
	}
}
int f[N],g[N];
int dp(int x)
{
	if(f[x])return f[x];
	int y,z;
	for(y=1;y<=dcc;y++)if(b[x][y])
	{
		z=dp(y);
		if(z>f[x])
		{
			g[x] = y;
			f[x] = z;
		}
	}f[x]+=size[x];
	return f[x];
}
void print(int x)
{
	if(!x)return ;
	int y;printf(" %d",x);
	for(y =nxt[x];y!=x;y=nxt[y])
	{
		printf(" %d",y);
	}
	print(p[g[bel[x]]]);
}
int main()
{
	scanf("%d",&n);
	for(int j = 2;j<=n;j++)
		for(int i = 1;i<j;i++)
		{
			scanf("%d",&a[i][j]);
			a[j][i]=!a[i][j];
		}
	for(int i = 1;i<= n;i++)if(!dfn[i])tarjan(i);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(bel[i]!=bel[j])
				b[bel[i]][bel[j]]|=a[i][j];
	for(int i = 1;i<= dcc;i++)f[i]=dp(i);
	for(int i = 1;i<= n;i++)
	{
		printf("%d",f[bel[i]]);
		print(i);printf("\n");
	}
	return 0;
}
Problem4731

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;  
#define MAXN 1000005  
#define MAXM 1000005  
#define INF 1000000000  
#define MOD 1000000007  
#define eps 1e-8  
#define ll long long  
int n,m;  
int M=1;  
int a[MAXN];  
ll c[MAXN];  
ll len[MAXN];  
int tot;  
int L[MAXN],R[MAXN];  
int ta[MAXN];  
void cal(int l,int r,int d){  
    int i,j;  
    if(!d)
        return ;  
    int t=0;  
    int lst=l;  
    for(i=l;i<=r;i++)
    {  
        t++;  
        if(t==len[d-1]||i==r)
        {  
            cal(lst,i,d-1);  
            lst=i+1;  
            t=0;  
        }  
    }  
    t=0;  
    lst=l;  
    tot=0;  
    for(i=l;i<=r;i++)
    {  
        t++;  
        if(t==len[d-1]||i==r)
        {  
            tot++;  
            L[tot]=lst;  
            R[tot]=i;  
            lst=i+1;  
            t=0;  
        }  
    }  
    for(i=tot;i>1;i--)
    {  
        for(j=L[i];j<=R[i];j++)
        {  
            c[j]-=c[j-len[d-1]];  
        }  
    }  
}  
int main()
{  
    int i;  
    scanf("%d",&n);  
    for(i=1;i<=n;i++)
    {  
        scanf("%d",&a[i]);  
    }  
    int tn=0;  
    for(i=1;i<=n;i++)
    {  
        if(a[i]!=1)
        {  
            ta[++tn]=a[i];  
        }  
    }  
    scanf("%d",&m);  
    ta[tn+1]=m;  
    for(i=1;i<=m;i++)
    {  
        scanf("%lld",&c[i]);  
    }  
    len[0]=1;  
    for(i=1;i<=tn+1;i++)
    {  
        len[i]=len[i-1]*ta[i];  
        if(len[i]>=m)
        {  
            cal(1,m,i);  
            break;  
        }  
    }  
    printf("%d\n",n);  
    for(i=1;i<=n;i++)
    {  
        printf(i==n?"%d\n":"%d ",a[i]);  
    }  
    printf("%d\n",m);  
    for(i=1;i<=m;i++)
    {  
        printf(i==m?"%lld\n":"%lld ",c[i]);  
    }  
    return 0;  
}  
Problem4753

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2505;
const double eps = 1e-8;
const double INF = 1e9;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double dp[N][N],ans,p[N],s[N],size[N],g[N];
int K;
void dfs(int x)
{
	size[x] = 0;
	dp[x][0] = 0;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		for(int j = 0;j<= size[x]+size[e[i].to];j++)g[j] = -INF;
		for(int j = 0;j<= size[x];j++)
			for(int k = 0;k<= size[e[i].to];k++)
				g[j+k] = max(g[j+k],dp[x][j]+dp[e[i].to][k]);
		for(int j = 0;j<= size[x]+size[e[i].to];j++)dp[x][j] = max(dp[x][j],g[j]);
		size[x]+=size[e[i].to];
	}
	for(int j = size[x];j>= 0;j--)
		dp[x][j+1]=dp[x][j]+p[x]-s[x]*ans;
	dp[x][0] = 0;
	size[x]++;
}
int main()
{
	int n,fa;
	scanf("%d%d",&K,&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf%d",&s[i],&p[i],&fa);
		add(fa,i);
	}
	double l = 0,r = 10001;
	while(fabs(l-r)>0.0001)
	{
		double mid = (l+r)/2;
		ans = mid;
		for(int i = 0;i<= n;i++)
			for(int j = 0;j<=n;j++)dp[i][j]=-INF;
		dfs(0);
		if(dp[0][K+1]>0)l=mid;
		else r = mid;
	}
	printf("%.3lf\n",l);
	return 0;
}
Problem4755

#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
const int mod1 = 130117;
const int mod2 = 600011;
const int seed = 37;
int a[N<<1], b[N<<1], sum[N<<1][2], num[N<<1][2], mi[N<<1][2], F[N<<1], G[N<<1];
int n, m, ans, l, r;
bool judge(int l1,int r1,int l2,int r2) 
{
    int x,y;
    int mod = mod1;
    x = (LL)(sum[r1][0]-(LL)sum[l1-1][0]*mi[r1-l1+1][0]%mod)%mod;
    y = (LL)(num[l2][0]-(LL)num[r2+1][0]*mi[r2-l2+1][0]%mod)%mod;
    (x+=mod)%=mod, (y+=mod)%=mod;
    if(x!=y) return 0;
    mod = mod2;
    x = (LL)(sum[r1][1]-(LL)sum[l1-1][1]*mi[r1-l1+1][1]%mod)%mod;
    y = (LL)(num[l2][1]-(LL)num[r2+1][1]*mi[r2-l2+1][1]%mod)%mod;
    (x+=mod)%=mod, (y+=mod)%=mod;
    if(x!=y) return 0;
    return 1;
}
inline int solve(int j,int k) 
{
    int l = 0, r = min( j, n-k+1);
    while(l < r) 
    {
        int mid = (l+r+1)>>1;
        if(judge(j-mid+1,j,k,k+mid-1)) l = mid;
        else r = mid - 1;
    }
    return l;
}
char s[N];
int main() 
{
    scanf("%d",&n);
    mi[0][0] = mi[0][1] = 1;
    for(int i=1;i<=n;++i) 
    {
        mi[i][0] = (LL)mi[i-1][0]*seed%mod1;
        mi[i][1] = (LL)mi[i-1][1]*seed%mod2;
    }
    a[0] = b[0] = 0; 
    a[2*n+2] = b[2*n+2] = 28;
    a[1] = b[1] = 27;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i) 
        a[i<<1] = s[i] - 'A' + 1,a[i<<1|1] = 27;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i) 
        b[i<<1] = s[i] - 'A' + 1,b[i<<1|1] = 27;
    int j = 0;
    for(int i=2;i<=(n<<1);++i) 
    {
        if(i <= F[j]+j) F[i] = min(F[2*j-i],j+F[j]-i);
        while(a[i-F[i]-1] == a[i+F[i]+1]) F[i] ++;
        if(i+F[i]>j+F[j]) j = i;
    }
    j = 0;
    for(int i=2;i<=(n<<1);++i) 
    {
        if(i <= j+G[j]) G[i] = min(G[2*j-i],j+G[j]-i);
        while(b[i-G[i]-1] == b[i+G[i]+1]) G[i] ++;
        if(i+G[i]>j+G[j]) j = i;
    }
    for(int i=2;i<=(n<<1);++i) ans = max(ans,max(F[i],G[i]));
    for(int i=1;i<=n;++i) 
    {
        sum[i][0] = (LL)((LL)sum[i-1][0]*seed%mod1+a[i<<1])%mod1;
        sum[i][1] = (LL)((LL)sum[i-1][1]*seed%mod2+a[i<<1])%mod2;
    }
    for(int i=n;i>=1;--i) 
    {
        num[i][0] = (LL)((LL)num[i+1][0]*seed%mod1+b[i<<1])%mod1;
        num[i][1] = (LL)((LL)num[i+1][1]*seed%mod2+b[i<<1])%mod2;
    }
    for(int i=2;i<=(n<<1);++i) 
    {
        l = i - F[i], r = i + F[i];
        l = (l+1) >> 1; r >>= 1;
        ans = max(ans,F[i]+solve(l-1,r)*2);
    }
    for(int i=2;i<=(n<<1);++i) 
    {
        l = i - G[i], r = i + G[i];
        l = (l+1) >> 1, r >>= 1;
        ans = max(ans,G[i]+solve(l,r+1)*2);
    }
    printf("%d\n",ans);
}
Problem4762

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int S = 1<<10;
struct data
{
	int f;
	void operator +=(const data &s)
	{
		f = f+s.f>=mod?f+s.f-mod:f+s.f;
	}
	void operator -=(const data &s)
	{
		f = f-s.f>=0?f-s.f:f-s.f+mod;
	}
}f[2][S][S];
int a[S];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),a[i] = (S-1)^a[i];
	int now = 1,pre = 0,i,j,k;
	f[0][0][0].f=1;
	for(i = 1;i<= n;i++)
	{
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[now][j][k].f = 0;
				if(!k)break;
			}
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[now][j|a[i]][k^(k&a[i])]+=f[pre][j][k];
				f[now][j|a[i]][k^(k&a[i])|a[i]^(a[i]&j)]-=f[pre][j][k];
				if(!k)break;
			}
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[pre][j][k] += f[now][j][k];
				if(!k)break;
			}
		//swap(now,pre);
	}
	printf("%d\n",f[pre][S-1][0].f);
	return 0;
}
Problem4763

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int MD = 320;
const int S = 65540;
const int ss = 65535;
int cnt[S];
typedef unsigned long long ull;
ull MAXN = 0;
struct Bitset
{
	ull s[470];
	int len;
	void clear()
	{memset(s,0,sizeof(s));len = 0;}
	void operator |=(const int &x){s[x>>6] |= 1ll<<(x&63);len = max(len,x>>6);}
	void operator |=(const Bitset &y)
	{
		len = max(len,y.len);
		for(int i = 0;i<=len;i++)
			s[i]|=y.s[i];
	}
	int num()
	{
		int res = 0;
		for(int i = 0;i<=len;i++)
			res+=cnt[s[i]>>48]+cnt[(s[i]>>32)&ss]+cnt[(s[i]>>16)&ss]+cnt[s[i]&ss];
		return res;
	}
	int getans()
	{
		for(int i = 0;i<470;i++)if(s[i]!=MAXN)
			for(int j = 0;j<64;j++)
				if(!(s[i]&((ull)1<<j)))
					return i*64+j;
	}
}b[325][325],ans;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int mark[N],rtnum,rt[N],n,m,flag;
int size[N],dep[N],mx[N],top[N],fa[N][18],w[N];
void dfs(int x)
{
	mx[x] = dep[x];
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			dep[e[i].to] = dep[x]+1;
			fa[e[i].to][0] = x;
			dfs(e[i].to);
			mx[x] = max(mx[x],mx[e[i].to]);
		}
	if(mx[x]-dep[x]>=MD||x==1)
	{
		mark[x] = ++rtnum;
		rt[rtnum] = x;
		mx[x] = 0;
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}

int main()
{
	int x,y;
	scanf("%d%d%d",&n,&m,&flag);
	for(int i = 0;i<64;i++)MAXN = MAXN<<1|1;
	for(int i = 0;i<S;i++)
		for(int j = i;j;j-=j&(-j))
			cnt[i]++;
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dep[1] = 1;
	dfs(1);
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
	for(int i = 1;i<= rtnum;i++)
	{
		Bitset now;
		now.clear();
		now|=w[rt[i]];b[i][i] = now;
		for(int t = fa[rt[i]][0];t;t=fa[t][0])
		{
			now|=w[t];
			if(mark[t])
			{
				b[i][mark[t]] = now;
				if(!top[rt[i]])top[rt[i]] = t;
			}
		}
	}
	int nn,last = 0;
    for(int i=1;i<=m;++i)
    {
        ans.clear();scanf("%d",&nn);
        for(int j=1;j<=nn;++j)
        {
        	scanf("%d%d",&x,&y);
            int xx,yy;
            if(flag) x^=last,y^=last;
            int z=lca(x,y);ans|=w[x];ans|=w[y];
            for(;!mark[x]&&dep[x]>dep[z];)
                x=fa[x][0],ans|=w[x];
            for(;!mark[y]&&dep[y]>dep[z];)
                y=fa[y][0],ans|=w[y];
            for(xx=x;dep[top[xx]]>=dep[z];xx=top[xx]);
            for(yy=y;dep[top[yy]]>=dep[z];yy=top[yy]);
            ans|=b[mark[x]][mark[xx]];
            ans|=b[mark[y]][mark[yy]];
            for(;xx!=yy;)
            {
                if(dep[xx]<dep[yy]) swap(xx,yy);
                xx=fa[xx][0];ans|=w[xx];
            }
        }
        int x=ans.num(),y=ans.getans();
        last=x+y;
        printf("%d %d\n",x,y);
    }
	return 0;
}
Problem4770

#include<cstdio>
#include<algorithm>
using namespace std;
#define MAXN 1010
#define MAXM 1010
typedef long long ll;
ll biao[MAXN][MAXN]={{},{0,0,0,0,0,0,0,0,0,},{0,129140164,129140165,129140167,129140171,129140179,129140195,129140227,129140291,},{0,193710246,64570084,24213786,236084373,77181450,157515737,140774228,215031499,},{0,225995287,121068906,238102183,203547108,218712265,116264831,99443036,79121964,},{0,112997644,108962016,46788094,36549268,117877184,14509798,100438248,107231500,},{0,185638986,53976556,134689163,96426552,194242540,153639990,120659378,101104631,},{0,221959657,227256424,124881873,171543395,157647025,162557411,23785165,258144187,},{0,110979829,87995657,38609442,206828800,253024756,206227824,141710270,10320181,},{0,55489915,109955160,56272067,231265411,63090854,237048705,171426005,85709662,},{0,27744958,238738659,7008635,102222843,120595225,256801988,235521295,180619543,},{0,143012643,24411822,194556475,215231251,130161896,73648531,208001599,170619964,},{0,71506322,157216049,153352677,156238751,192264872,27770309,226347497,54161031,},{0,164893325,184923874,246796406,52697789,171780083,21983921,223228206,185664220,},{0,82446663,171588386,198224372,24087433,169856546,85584783,15039313,51032118,},{0,41223332,233770283,237290397,226108046,172324917,242546032,177098806,40173324,},{0,149751830,40172257,206855876,234897786,42845559,190284536,34527590,26337201,},{0,204016079,44767891,130125758,198580206,248091586,33588797,142939578,109276637,},{0,102008040,53378114,117153053,140321556,207663118,231585645,18039713,42557731,},{0,180144184,222551860,141542926,124678758,256378666,58621640,169814611,164503795,},{0,219212256,51118260,22017057,107400239,71063488,208194809,141040710,82368253,},{0,238746292,9389787,73404282,197290983,187666354,33421568,243481387,230191654,},{0,248513310,258085441,206092103,175865014,46934405,238338656,34885039,160507772,},{0,253396819,46472091,52427070,10622380,31557757,78236842,121818911,78588165,},{0,126698410,14223592,100655489,4793966,28513326,106020021,130112147,61905360,},{0,192489369,53937637,55392462,243667232,206236595,2350355,2101084,238304638,},{0,96244685,115840796,252931583,12885294,108834416,142226001,41501066,77317254,},{0,48122343,186440092,145791627,175931570,191171533,54681626,171376190,8284899,},{0,24061172,35579780,244199696,219925978,194916377,159910040,18680912,56283054,},{0,141170750,129762427,191545910,85767863,96762108,75032252,68489928,100763661,},{0,199725539,123091219,123096044,64432902,33418232,219199667,205120656,160043295,},{0,99862770,147188326,236754524,80629277,18247771,18374728,15226623,146765106,},{0,179071549,43396121,1036568,86131407,196354204,129359671,55657413,95474816,},{0,89535775,177223515,164355065,176671379,141757722,64001077,97905256,148393376,},{0,44767888,56089100,9744293,28759687,254183618,187978963,48484166,10384133,},{0,151524108,71287253,195783672,235105036,63372602,48706668,248893454,173302144,},{0,204902218,189910711,57376262,237466820,231810127,127325080,116537614,29856382,},{0,231591273,257256954,207490218,200639665,46244374,29857601,109793313,58979680,},{0,115795637,205506176,45896798,234868496,29541064,251294633,256749187,63816439,},{0,57897819,124985457,245728025,115443775,144062289,195058805,171514012,53312683,},{0,28948910,21882968,223817069,76823424,21491759,227107331,131344269,97420818,},{0,143614619,14590716,250142242,217871110,158025913,120380172,59940904,105696964,},{0,71807310,75057742,38795205,80612780,246470934,120257251,3687048,158432457,},{0,165043819,201462147,168744597,172739460,61176618,38568071,97892751,11175058,},{0,82521910,219673862,27383363,66850809,196775038,6183180,92038631,31326683,},{0,170401119,101187108,75392768,51235977,45924565,86039077,51855151,254177214,},{0,85200560,221423464,251701329,91563073,211230946,180879303,101994951,244856176,},{0,171740444,202450882,103638399,9527704,148889553,41207463,141727928,145038853,},{0,215010386,225504065,114480260,68277350,11820640,1248372,121446262,9716295,},{0,236645357,26119321,236275454,147928086,206426334,162743844,101312146,105149937,},{0,118322679,258260157,59715480,13946009,169602037,225439100,30268418,150919282,},};
int n,m;
int main(){
    scanf("%d%d",&n,&m);
    printf("%lld\n",biao[n][m]);
}
Problem4771

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
set<int>S[N];
set<int>::iterator it;
int fa[N][18],dep[N],col[N],in[N],out[N],Dfn,seq[N],a[N];
struct E
{int next,to;}e[N];
int head[N],tot,mx;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
void dfs(int x)
{
	dep[x] = dep[fa[x][0]]+1;
	mx = max(mx,dep[x]);
	in[x] = ++Dfn;seq[Dfn] = x;
	for(int i = 1;i<= 17;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	out[x] = Dfn;
}
int lca(int x,int y)
{
	if(dep[y]>dep[x])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int tr[N*100],ls[N*100],rs[N*100],cnt,root[N],n,m;
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	ls[p] = ls[pre],rs[p] = rs[pre];
	tr[p] = tr[pre]+val;
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
}
int getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
void init()
{
	for(int i = 1;i<= cnt;i++)tr[i]=ls[i]=rs[i]=0;
	cnt = 0;
	Dfn = 0;tot = 0;
	for(int i = 1;i<= n;i++)head[i]=0,root[i]=0;
	for(int i = 1;i<= n;i++)S[i].clear();
	mx = 0;
}
bool cmp(int x,int y)
{
	return dep[x]==dep[y]?in[x]<in[y]:dep[x]<dep[y];
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)scanf("%d",&col[i]),a[i]=i;
		for(int i = 2;i<= n;i++)scanf("%d",&fa[i][0]),add(fa[i][0],i);
		dfs(1);
		sort(a+1,a+n+1,cmp);
		int tmp1,tmp2;
		for(int i = 1;i<= n;i++)
		{
			if(dep[a[i]]==dep[a[i-1]])
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[a[i]],1);
			else 
				update(root[dep[a[i]]],root[dep[a[i]]-1],1,n,in[a[i]],1);
			it = S[col[a[i]]].upper_bound(in[a[i]]);
			tmp1 = tmp2 = 0;
			if(it!=S[col[a[i]]].end())
			{
				tmp1 = (*it);
				tmp1 = seq[tmp1];
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp1,a[i])],-1);
			}
			if(it!=S[col[a[i]]].begin())
			{
				it--;
				tmp2 = (*it);
				tmp2 = seq[tmp2];
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp2,a[i])],-1);
			}
			if(tmp1&&tmp2)
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp1,tmp2)],1);
			S[col[a[i]]].insert(in[a[i]]);
		}
		int x,d,ans=0;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&d);
			x = x^ans,d = d^ans;
			ans = getans(root[min(dep[x]+d,mx)],1,n,in[x],out[x]);
			printf("%d\n",ans);
		}
		init();
	}
	return 0;
}
Problem4772

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2001;
const int mod = 1e9+7;
const int S = 1e7;
int gcd[N][N],pow[N][N],f[N][N],sum[N],b[N];
int g[S+5],tmp[S+5];
bool vis[S+5];
int prime[S/10],cnt,a[100005],n,K,p;
void Pre()
{
	sum[n] = 1;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= n;j++)
		{
			if(i==1||j==1)f[i][j] = 1;
			else if(i==j)f[i][j] = (f[i][j-1]+1)%mod;
			else if(i<j)f[i][j] = f[i][j-1];
			else f[i][j] = (f[i-j][j]+f[i][j-1])%mod;
		}
		sum[n-i]=f[i][i];
	}
	g[0] = 0,g[1] = 1;
	for(int i = 2;i<= S;i++)
	{
		if(!vis[i])
		{
			prime[++cnt]=tmp[i]=i;
			g[i] = 2*i-2;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<=S;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
			{
				tmp[i*prime[j]] = prime[j];
				g[i*prime[j]] = (ll)g[i]*g[prime[j]]%mod; 
			}else
			{
				tmp[i*prime[j]] = tmp[i]*prime[j];
				if(tmp[i]!=i)g[i*prime[j]] = (ll)g[i/tmp[i]]*g[tmp[i]*prime[j]]%mod;
				else g[i*prime[j]] = ((ll)g[i]*prime[j]+i*(prime[j]-1))%mod;
				break;
			}
		}
	}
	for(int i = 1;i<= n;i++)gcd[i][0]=gcd[0][i]=gcd[i][i]=i,gcd[i][1]=gcd[1][i]=1;
	for(int i = 2;i<= n;i++)
		for(int j = 2;j<= i;j++)
		{
			if(!gcd[i][j])gcd[i][j] = gcd[j][i-j];
			gcd[j][i] = gcd[i][j];
		}
	for(int i = 1;i<= n;i++)pow[i][0]=1,pow[i][1] = i;
	for(int i = 1;i<= n;i++)
		for(int j = 2;j<= n;j++)
			pow[i][j] = 1ll*pow[i][j-1]*i%K;
}
int F(int x,int y)
{
	if(p==1)return 1%K;
	if(p==2)return gcd[x][y]%K;
	if(p==3)return (pow[x][y]+pow[y][x]+(x^y))%K;
}
inline void add(int &x,const int &y)
{
	x+=y;
	if(x>=mod)x-=mod;
}
int Cnt[S+5];
int main()
{
	scanf("%d%d%d",&p,&n,&K);
	for(int i = 0;i<K;i++)scanf("%d",&a[i]);
	Pre();
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n-i;j++)
            for(int muli=1;muli*i+j<=n;muli++)
                for(int mulj=1;mulj*j+muli*i<=n;mulj++)
                    add(Cnt[F(i,j)],sum[muli*i+mulj*j]);
	int ans = 0;
    for(int i=0;i<K;i++) ans+=1LL*g[a[i]]*Cnt[i]%mod,ans%=mod;
    for(int i=1;i<=n;i++)
    {
        for(int muli=1;muli*i<=n;muli++)
        {
            int Tmp=1LL*muli*(muli-1)/2*(sum[muli*i]-sum[(muli+1)*i]+mod)%mod;
            add(ans,1LL*g[a[F(i,i)]]*Tmp%mod);
        }
    }
    printf("%d\n",ans);
	return 0;
}
Problem4773

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
struct E
{int next,to,val;}e[N*N];
int head[N],tot;
void add(int x,int y,int f)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;}
int f[2][N][N];
int main()
{
	int n,m,x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	memset(f,0x3f,sizeof(f));
	int now = 0,pre = 1;
	for(int i = 1;i<= n;i++)f[pre][i][i]=0;
	for(int ans = 1;ans<= n;ans++)
	{
		memset(f[now],0x3f,sizeof(f[now]));
		for(int st = 1;st<= n;st++)
			for(int pe = 1;pe<= n;pe++)
				for(int i = head[pe];i;i=e[i].next)
					f[now][st][e[i].to] = min(f[now][st][e[i].to],f[pre][st][pe]+e[i].val);
		for(int i = 1;i<= n;i++)
			if(f[now][i][i]<0)
			{
				printf("%d\n",ans);
				return 0;
			}
		swap(now,pre);
	}
	printf("0");
	return 0;
}
Problem4774

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<8;
const int N = 1e4+5;
const int INF = 0x3f3f3f3f;
int dis[S][N];
bool vis[N];
queue<int>Q;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,ans[S];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}

void spfa(int dis[])
{
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].val)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
}
int n,m,d;
bool check_sta(int s)
{
	bool flag = true;
	for(int i = 1;i<= d;i++)
		flag&= ((s>>(i-1))&1)==((s>>(2*d-i))&1);
	return flag;
}
int main()
{
	int x,y,z;
	scanf("%d%d%d",&n,&m,&d);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	memset(dis,0x3f,sizeof(dis));
	for(int i = 1;i<= d;i++)dis[1<<(i-1)][i] = 0;
	for(int i = 1;i<= d;i++)dis[1<<(2*d-i)][n-i+1] = 0;
	int end = 1<<(2*d);
	for(int s = 0;s<end;s++)
	{
		for(int i = 1;i<= n;i++)
		{
			for(int t = s;t;t=(t-1)&s)
				dis[s][i] = min(dis[s][i],dis[t][i]+dis[s^t][i]);
			if(dis[s][i]!=INF)Q.push(i),vis[i]=true;
		}
		spfa(dis[s]);
	}
	memset(ans,0x3f,sizeof(ans));
	for(int s = 0;s<end;s++)
		if(check_sta(s))
			for(int i = 1;i<= n;i++)
				ans[s] = min(ans[s],dis[s][i]);
	for(int s = 0;s<end;s++)
		for(int t = s;t;t = (t-1)&s)
			ans[s] = min(ans[s],ans[s^t]+ans[t]);
	if(ans[end-1]!=INF)printf("%d\n",ans[end-1]);
	else puts("-1");
	return 0;
}
Problem4775

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#define fir first
#define sec second
using namespace std;

const int N = 1e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,dep[N],fa[N][18];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x)
{
	dep[x] = dep[fa[x][0]]+1;
	for(int i = 1;i<= 17;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			fa[e[i].to][0] = x;
			dfs(e[i].to);
		}
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int getdis(int x,int y)
{
	return dep[x]+dep[y]-2*dep[getlca(x,y)];
}
bool used[N];
int size[N],f[N],sum,root;
void get_root(int x,int pre)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}	
void get_size(int x,int pre)
{
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
		{
			get_size(e[i].to,x);
			size[x]+=size[e[i].to];
		}
}
vector<int>E[N];
int father[N];
pair<double,double>A[N];
double w[N],d[N],pw[N],pd[N],A1[N],pA1[N],A2[N],pA2[N],A3[N],pA3[N];
void build(int x,int pre)
{
	get_size(x,0);
	sum = size[x];
	f[root = 0]=sum;
	get_root(x,0);
	x = root;
	father[x] = pre;
	used[x] = true;
	E[pre].push_back(x);
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
			build(e[i].to,x);
}
inline void Add(int x)
{
	double y = A[x].fir*(1-A[x].fir);
	w[x]+=A[x].fir,A3[x]+=y;
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		d[father[i]]+=D*A[x].fir;pd[i]+=D*A[x].fir;
		w[father[i]]+=A[x].fir;pw[i]+=A[x].fir;

		A1[father[i]]+=D*D*y;pA1[i]+=D*D*y;
		A2[father[i]]+=D*2*y;pA2[i]+=D*2*y;
		A3[father[i]]+=y;pA3[i]+=y;
	}
}
inline void Del(int x)
{
	double y = A[x].fir*(1-A[x].fir);
	w[x]-=A[x].fir,A3[x]-=y;
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		d[father[i]]-=D*A[x].fir;pd[i]-=D*A[x].fir;
		w[father[i]]-=A[x].fir;pw[i]-=A[x].fir;

		A1[father[i]]-=D*D*y;pA1[i]-=D*D*y;
		A2[father[i]]-=D*2*y;pA2[i]-=D*2*y;
		A3[father[i]]-=y;pA3[i]-=y;
	}
}
inline void update(int x,double p)
{
	double k0 = p/100.0,k1 = (100.0-p)/100.0;
	Del(x);
	A[x] = make_pair(A[x].fir*k1+A[x].sec*k0,A[x].fir*k0+A[x].sec*k1);
	Add(x);
}
inline void getans(int x)
{
	double ans1 = d[x],ans2 = A1[x];
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		ans1 += d[father[i]]-pd[i]+D*w[father[i]]-D*pw[i];
		ans2 += A1[father[i]]-pA1[i]+D*A2[father[i]]-D*pA2[i]+D*D*A3[father[i]]-D*D*pA3[i];
	}
	printf("%.13f\n",ans1*ans1+ans2);
}
int main()
{
	//freopen("x.in","r",stdin);
	//freopen("x.out","w",stdout);
	int n,m,x,y,id;
	double p;
	scanf("%d%d%d",&id,&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&x),A[i]=make_pair(x,x^1);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1);
	build(1,0);
	for(int i = 1;i<= n;i++)Add(i);
	int opt;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%lf",&x,&p);
			update(x,p);
		}else
		{
			scanf("%d",&x);
			getans(x);
		}
	}
	return 0;
}
Problem4796

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
char str[N];
int s[N];
int check(vector<int> &a)
{
	int ans = 0;
	for(int i = 0;i+1<a.size();i++)
		ans+=a[i]^a[i+1];
	return ans+1;
}
int main()
{
	scanf("%s",str);
	int n = strlen(str)/3;
	for(int i = 0;i<3*n;i++)
		s[i] = str[i]-'0';
	vector<int>ans;
	for(int i = 0;i<n;i++)
	{
		vector<int>a;
	  	a.clear();
		for(int j = -1;j<= 2;j++)
		{
			if(i==0&&j==-1)a.push_back(0);
			else a.push_back(s[i*3+j]);
		}
		if(check(a)>=3)continue;
		a[1]^=1,a[2]^=1;
		if(check(a)>=3)
		{
			s[i*3]^=1;s[i*3+1]^=1;
			ans.push_back(i*3);
			continue;
		}
		a[1]^=1,a[2]^=1;

		a[2]^=1,a[3]^=1;
		assert(check(a)>=3);
		s[i*3+1]^=1,s[i*3+2]^=1;
		ans.push_back(3*i+1);
	}
	int sz = ans.size();
	printf("%d\n",sz);
	for(int i = 0;i<sz;i++)
	{
		printf("%d",ans[i]+1);
		if(i==sz-1)printf("\n");
		else printf(" ");
	}
	return 0;
}
Problem4804

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int prime[N/10],cnt;
bool vis[N];ll F[N];
void quick_shai()
{
	F[1] = 1;
	for(int i = 2;i< N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			F[i] = i-2;
		}
		for(int j = 1;j<= cnt&&(ll)i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)
			{
				if((i/prime[j])%prime[j]!=0)
					F[i*prime[j]] = F[i/prime[j]]*(prime[j]-1)*(prime[j]-1);
				else 
					F[i*prime[j]] = F[i]*prime[j];
				break;
			}
			else 
				F[i*prime[j]] = F[i]*F[prime[j]];
		}
	}
	for(int i = 1;i<N;i++)F[i]+=F[i-1];
}
ll Solve(int n)
{
	int l,r,t; 
	ll ret=0;
	for(l = 1;l*l<= n;l++)
		t=n/l,ret+=(ll)t*t*(F[l]-F[l-1]);
	for(t = n/l;l<= n;l=r+1,t--)
		r=n/t,ret+=(ll)t*t*(F[r]-F[l-1]);
	return ret;
}
int main()
{
	int cas,n;
	quick_shai();
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d",&n);
		printf("%lld\n",Solve(n));
	}
	return 0;
}
Problem4810

#include <stdio.h>
#include <math.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int bel[N];
bitset<N>f,g;
struct Ask
{
	int opt,l,r,x,id;
	Ask(){}
	Ask(int _opt,int _l,int _r,int _x,int _id):opt(_opt),l(_l),r(_r),x(_x),id(_id){}
	bool operator<(const Ask &s)const 
	{
		if(bel[l]==bel[s.l])return r<s.r;
		return bel[l]<bel[s.l];
	}
}ask[N];
int cnt[N],ans[N],a[N];
void Del(int x)
{
	cnt[x]--;
	if(cnt[x]==0)f[x]=0,g[100000-x]=0;
}
void Add(int x)
{
	cnt[x]++;
	if(cnt[x]==1)f[x]=1,g[100000-x]=1;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int bl = sqrt(n)+1;
	for(int i = 1;i<= n;i++)bel[i] = i/bl+1;
	for(int i = 1;i<= m;i++)
	{
		int l,r,opt,x;
		scanf("%d%d%d%d",&opt,&l,&r,&x);
		ask[i] = Ask(opt,l,r,x,i);
	}
	sort(ask+1,ask+m+1);
	int l = 0,r = 0;
	for(int i = 1;i<= m;i++)
	{
		while(l<ask[i].l)Del(a[l]),l++;
		while(l>ask[i].l)l--,Add(a[l]);
		while(r<ask[i].r)r++,Add(a[r]);
		while(r>ask[i].r)Del(a[r]),r--;
		if(ask[i].opt==1)
		{
			if(((f>>ask[i].x)&f).any())ans[ask[i].id] = 1;
			else ans[ask[i].id] =0;
		}
		else if(ask[i].opt==2)
		{
			if(((g>>(100000-ask[i].x))&f).any())ans[ask[i].id] = 1;
			else ans[ask[i].id] =0;
		}
		else
		{
			for(int j = 1;j*j<=ask[i].x;j++)
				if(ask[i].x%j==0)
					if(f[j]==1&&f[ask[i].x/j]==1)
						{ans[ask[i].id] = 1;break;}
			if(ask[i].x==0&&f[0]==1)
				ans[ask[i].id] = 1;
		}
	}
	for(int i= 1;i<= m;i++)
		if(ans[i])printf("yuno\n");
		else printf("yumi\n");
	return 0;
}
Problem4811

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef unsigned long long ull;
int Opt[N],n,m,k;ull Val[N];
struct Seg
{
	ull v0,v1;
	Seg(){}
	Seg(int opt,ull x)
	{
		if(opt==1)
		{
			v0 = 0&x;
			v1 = (~0)&x;
		}else if(opt==2)
		{
			v0 = 0|x;
			v1 = (~0)|x;
		}else
		{
			v0 = 0^x;
			v1 = (~0)^x;
		}
	}
	Seg operator +(const Seg &s)const
	{
		Seg ans;
		ans.v0 = (v0&s.v1)|((~v0)&s.v0);
		ans.v1 = (v1&s.v1)|((~v1)&s.v0);
		return ans;
	}
}trl[N<<2],trr[N<<2];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],fa[N],top[N],son[N],size[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			if(size[e[i].to]>size[son[x]])son[x]=e[i].to;
			size[x]+=size[e[i].to];
		}
}
int Dfn,dfn[N],seq[N];
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		trl[p] = trr[p] = Seg(Opt[seq[l]],Val[seq[l]]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	trl[p] = trl[p<<1]+trl[p<<1|1];
	trr[p] = trr[p<<1|1]+trr[p<<1];
}
void Update(int p,int l,int r,int pos,ull val)
{
	if(l==r)
	{
		trl[p] = trr[p] = Seg(Opt[seq[pos]],val);
		Val[seq[pos]] = val;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)Update(p<<1,l,mid,pos,val);
	else Update(p<<1|1,mid+1,r,pos,val);
	trl[p] = trl[p<<1]+trl[p<<1|1];
	trr[p] = trr[p<<1|1]+trr[p<<1];
}
Seg getansL(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return trl[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getansL(p<<1,l,mid,a,b);
	else if(a>mid)return getansL(p<<1|1,mid+1,r,a,b);
	else return getansL(p<<1,l,mid,a,b)+getansL(p<<1|1,mid+1,r,a,b);
}
Seg getansR(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return trr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getansR(p<<1,l,mid,a,b);
	else if(a>mid)return getansR(p<<1|1,mid+1,r,a,b);
	else return getansR(p<<1|1,mid+1,r,a,b)+getansR(p<<1,l,mid,a,b);
}
Seg getans(int x,int y)
{
	Seg vx(3,0),vy(3,0);
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>=dep[top[y]])
		{
			vx = vx+getansR(1,1,n,dfn[top[x]],dfn[x]);
			x = fa[top[x]];
		}else
		{
			vy = getansL(1,1,n,dfn[top[y]],dfn[y])+vy;
			y = fa[top[y]];
		}
	}
	if(dep[x]>dep[y])
		return vx+getansR(1,1,n,dfn[y],dfn[x])+vy;
	else return vx+getansL(1,1,n,dfn[x],dfn[y])+vy;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d%llu",&Opt[i],&Val[i]);
	int opt,x,y;
	ull z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%llu",&x,&y,&z);
			Seg ans = getans(x,y);
			ull Ans = 0,now = 0;
			for(int j = k-1;j>=0;j--)
			{
				if((ans.v0>>j)&1)
					Ans+=1ull<<j;
				else if(((ans.v1>>j)&1)&&(now+(1ull<<j))<=z)
					Ans+=1ull<<j,now+=1ull<<j;
			}
			printf("%llu\n",Ans);
		}else
		{
			scanf("%d%d%llu",&x,&y,&z);
			Opt[x] = y;
			Update(1,1,n,dfn[x],z);
		}
	}
	return 0;
}
Problem4813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][N],g[N][N],m,n;
void dfs(int x,int fa)
{
	f[x][0] = g[x][0] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			for(int j = m;~j;j--)
				for(int k = 0;k<=j-1;k++)
				{
					if(j-k-2>=0)f[x][j] = max(f[x][j],f[e[i].to][k]+f[x][j-k-2]);
					g[x][j] = max(g[x][j],g[e[i].to][k]+f[x][j-k-1]);
					if(j-k-2>=0)g[x][j] = max(g[x][j],f[e[i].to][k]+g[x][j-k-2]);
				}
		}
	for(int i = 0;i<m;i++)f[x][i+1] = max(f[x][i],f[x][i+1]);
	for(int i = 0;i<m;i++)g[x][i+1] = max(g[x][i],g[x][i+1]);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(0,0);
	printf("%d\n",g[0][m]);
	return 0;
}
Problem4814

#include <bits/stdc++.h>

using namespace std;

#define LL long long
#define inf 0x3f3f3f3f
#define Pi acos(-1.0)
#define eps 1e-12
#define N 6020
#define M 400020

int dcmp(double x)
{
	if(fabs(x) < eps) return 0;
	return x < 0 ? -1 : 1;
}
int sgn(LL x)
{
	if(x == 0) return 0;
	return x < 0 ? -1 : 1;
}
struct point
{
	double x, y, ang;
	point(double x = 0, double y = 0) : x(x), y(y) {}
	point operator - (const point &b) const 
	{
		return point(x - b.x, y - b.y);
	}
	point operator + (const point &b) const 
	{
		return point(x + b.x, y + b.y);
	}
	point operator * (const double &k) const 
	{
		return point(x * k, y * k);
	}
	bool operator < (const point &b) const 
	{
		return ang < b.ang;
	}
	bool operator == (const point &b) const 
	{
		return x == b.x && y == b.y;
	}
	inline double len()
	{
		return sqrt(x * x + y * y);
	}
	inline void get_ang()
	{
		ang = atan2(y, x);
	}
	inline void input()
	{
		int xx, yy;
		scanf("%d%d", &xx, &yy);
		x = 1.0 * xx, y = 1.0 * yy;
	}
};
double dot(point a, point b)
{
	return a.x * b.x + a.y * b.y;
}
double cross(point a, point b)
{
	return a.x * b.y - a.y * b.x;
}
point get_intersection(point a1, point a2, point b1, point b2)
{
	point u = a1 - b1, av = a2 - a1, bv = b2 - b1;
	double t = cross(bv, u) / cross(av, bv);
	return a1 + av * t;
}
const point O = point(0, 0);
point base;
struct Seg{
	point u, v;
	int id, in;
	double ang;
	Seg(){}
	Seg(point u, point v, int in, int id, double ang) : u(u), v(v), in(in), id(id), ang(ang) {}
	bool operator < (const Seg &b) const 
	{
		if(u == b.u)
		{
			return cross(v - u, b.v - u) < 0;
		}
		point aa = get_intersection(u, v, O, base);
		point bb = get_intersection(b.u, b.v, O, base);
		return aa.len() < bb.len();
	}
}L[N];
bool cmp(Seg a, Seg b)
{
	return dcmp(a.ang - b.ang) < 0 || dcmp(a.ang - b.ang) == 0 && a.in > b.in;
}

int all, tot;
multiset<Seg> S;
multiset<Seg>::iterator it[N];
point pp[N], p[N];
point tri[N][3], t[N][4];
void add(point u, point v, int id)
{
	if(u.ang > v.ang) swap(u, v);
	L[all++] = Seg(u, v, 1, id, u.ang);
	L[all++] = Seg(v, u, 0, id, v.ang);
}
double calc(Seg s)
{
	point a = get_intersection(s.u, s.v, O, base);
	return a.len();
}
int solve(int n)
{
	sort(p, p + n);
	sort(L, L + all, cmp);
	S.clear();
	int ret = 0, i = 0, j = 0;
	for(; i < n; ++i)
	{
		while(j < all && (dcmp(L[j].ang - p[i].ang) < 0 || (dcmp(L[j].ang - p[i].ang) == 0 && L[j].in)))
		{
			base = L[j].u;
			if(L[j].in)
				it[L[j].id] = S.insert(L[j]);
			else
				S.erase(it[L[j].id]);
			++j;
		}
		if(S.empty()){++ret; continue;}
		base = p[i];
		double dis = calc(*S.begin());
		if(dcmp(p[i].len() - dis) <= 0) ++ret;
	}
	return ret;
}

int main()
{
	int V, T;
	scanf("%d%d", &V, &T);
		for(int i = 1; i <= V; ++i)
			pp[i].input();
		for(int i = 1; i <= T; ++i)
			for(int j = 0; j < 3; ++j)
				tri[i][j].input();

		int ans = 0;
		for(int i = 1; i <= V; ++i){
			int cnt = 0;
			for(int j = i + 1; j <= V; ++j){
				p[cnt++] = pp[j] - pp[i];
				p[cnt-1].get_ang();
			}
			tot = all = 0;
			for(int j = 1; j <= T; ++j){
				for(int k = 0; k < 3; ++k)
					t[j][k] = tri[j][k] - pp[i];
				t[j][3] = t[j][0];
				point u, v;
				double mx = 0;
				for(int k = 0; k < 3; ++k){
					double ang = dot(t[j][k], t[j][k+1]) / t[j][k].len() / t[j][k+1].len();
					ang = acos(ang);
					if(ang > mx)
						mx = ang, u = t[j][k], v = t[j][k+1];
				}
				u.get_ang(), v.get_ang();
				double d = fabs(u.ang - v.ang);
				if(d < Pi)
					add(u, v, tot++);
				else{
					point tmp = get_intersection(u, v, O, point(-1.0, 0));
					tmp.ang = Pi * dcmp(u.ang);
					add(u, tmp, tot++);
					tmp.ang = Pi * dcmp(v.ang);
					add(v, tmp, tot++);
				}
			}
			int ret = solve(cnt);
			ans += ret;
		}
		printf("%d\n", ans);
	return 0;
}
Problem4815

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e6+5;
const int mod = 1e9+7;
typedef long long ll;
struct P
{int l,r;}pos[2010];
int prime[N],inv[N],mu[N],g[N],f[N],w[N],sum[2010],P[N],s[N];
bool vis[N];
int cnt;
void quick_shai(int n)
{
	inv[0] = inv[1] = 1;
	for(int i = 2;i<=n;i++)
		inv[i] = (ll)(mod-mod/i)*inv[mod%i]%mod;
	cnt = 0;
	g[1] = mu[1] = 1;
	for(int i = 2;i<=n;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
			g[i] = (1-inv[i]+mod)%mod;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<=n;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
			{
				mu[i*prime[j]] = -mu[i];
				g[i*prime[j]] = (ll)g[i]*(1-inv[prime[j]]+mod)%mod;
			}
			else
			{
				mu[i*prime[j]] = 0;
				g[i*prime[j]] = g[i];
				break;
			}
		}
	}	
	f[0] = 0;
	for(int i = 1;i<=n;i++)
		f[i] = (f[i-1]+(ll)g[i]*i%mod*i%mod*i%mod)%mod;
}

int gcd(int a,int b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}

int check(int n)
{
	if(!n)return 0;
	return (s[n]+sum[P[n]])%mod;
}

int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	quick_shai(n);
	int block = sqrt(n);
	int last;
	for(int i = 1;i<= n;i++)
		P[i] = (i-1)/block+1;
	last = P[n];
	pos[1].l = 1;
	for(int i = 2;i<= n;i++)
		if(P[i-1]<P[i]){pos[P[i-1]].r = i-1,pos[P[i]].l = i;}
	pos[last].r = n;
	memset(sum,0,sizeof(sum));
	for(int i = 0;i<= n;i++)w[i]=(ll)i*i%mod;
	for(int i = 1;i<= n;i++)s[i] = (s[i-1]+w[i])%mod;
	int a,b,k;
	ll x,y;
	int Last;
	while(m--)
	{
		scanf("%d%d%lld%d",&a,&b,&x,&k);
		int c = gcd(a,b);
		y = (ll)a/c*b/c;
		x/=y;x%=mod;
		int d = (x-w[c]+mod)%mod;w[c] = x;
		for(int i = c;i<= pos[P[c]].r;i++)s[i] = (s[i]+d)%mod;
		for(int i = P[c]+1;i<= last;i++)sum[i] = (sum[i]+d)%mod;
		ll ans = 0;
		for(int i = 1;i<= k;i = Last+1)
		{
			Last = k/(k/i);
			ans = (ans+(ll)(check(Last)-check(i-1)+mod)*f[k/i]%mod)%mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4816

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
const int mod = 1e9+7;
int f[N],g[N],Invg[N];
int quick_pow(int x,ll y)
{
	int res=1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int getmul(int l,int r)
{
	return (ll)g[r]*Invg[l-1]%mod;
}
int main()
{
	f[0] = 0,f[1] = 1;
	for(int i = 2;i<N;i++)
		f[i] = (f[i-1]+f[i-2])%mod;
	for(int i = 1;i<N;i++)g[i] = f[i];
	Invg[0] = 1,g[0]=1;
	for(int i = 1;i<N;i++)
	{
		Invg[i] = quick_pow(g[i],mod-2);
		for(int j = i+i;j<N;j+=i)
			g[j] = (ll)g[j]*Invg[i]%mod;
		g[i] = (ll)g[i-1]*g[i]%mod;
		Invg[i] = (ll)Invg[i-1]*Invg[i]%mod;
	}
	int cas,n,m;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		int ans = 1,last = 1;
		if(n>m)swap(n,m);
		for(int i = 1;i<= n;i=last+1)
		{
			last = min(n/(n/i),m/(m/i));
			ans = (ll)ans*quick_pow(getmul(i,last),(ll)(n/i)*(m/i))%mod;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem4817

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int n,m;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int Son[N],dfn[N],seq[N],top[N],size[N],dep[N],fa[N],Dfn;
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[Son[x]])Son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(Son[x])dfs2(Son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=Son[x])
			dfs2(e[i].to,e[i].to);
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
int mx[N<<2],lazy[N<<2];
void build(int p,int l,int r)
{
	lazy[p] = 0;
	if(l==r)
	{
		mx[p] = dep[seq[l]];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
void Push_down(int p,int l,int r)
{
	if(l==r||!lazy[p])return ;
	mx[p<<1]+=lazy[p],mx[p<<1|1]+=lazy[p];
	lazy[p<<1]+=lazy[p],lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void Update(int p,int l,int r,int a,int b,int c)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b){mx[p]+=c;lazy[p]+=c;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,c);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,c);
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
int Getans(int p,int l,int r,int a,int b)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans = max(ans,Getans(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,Getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
int son[N][2],father[N],lx[N];
bool is_root(int x)
{
	return son[father[x]][0]!=x&&son[father[x]][1]!=x;
}
void update(int x)
{
	lx[x] = x;
	if(son[x][0])
		lx[x] = lx[son[x][0]];
}
void rotate(int x)
{
	int y = father[x],z = father[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(son[z][0]==y)son[z][0] = x;
		else son[z][1] = x;
	}
	father[y] = x,father[x] = z,father[son[x][d^1]] = y;
	son[y][d] = son[x][d^1];son[x][d^1] = y;
	update(x),update(y);
}
void splay(int x)
{
	while(!is_root(x))
	{
		int y = father[x],z = father[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)!=(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	update(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		if(son[x][1])
		{
			int y = lx[son[x][1]];
			Update(1,1,n,dfn[y],dfn[y]+size[y]-1,1);
		}
		son[x][1] = t;
		if(son[x][1])
		{
			int y = lx[son[x][1]];
			Update(1,1,n,dfn[y],dfn[y]+size[y]-1,-1);
		}
		update(x);
		t = x;x = father[x];
	}
}
int col(int x)
{
	splay(x);
	return lx[x];
}
int main()
{
	scanf("%d%d",&n,&m);
	int a,b;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		add(a,b),add(b,a);
	}
	dfs1(1),dfs2(1,1);
	build(1,1,n);
	for(int i = 1;i<= n;i++)father[i]=fa[i];
	int opt;
	while(m--)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d",&a);
			access(a);
		}else if(opt==2)
		{
			scanf("%d%d",&a,&b);
			int lca = getlca(a,b);
			int flca = fa[lca];
			int valx = Getans(1,1,n,dfn[a],dfn[a]),valy = Getans(1,1,n,dfn[b],dfn[b]);
			int vall = 0;
			if(flca)
			{
				vall = Getans(1,1,n,dfn[flca],dfn[flca]);
				if(col(lca)==col(flca))
					vall--;
			}
			printf("%d\n",valx+valy-2*vall-1);
		}else
		{
			scanf("%d",&a);
			printf("%d\n",Getans(1,1,n,dfn[a],dfn[a]+size[a]-1));
		}
	}
	return 0;
}
Problem4818

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 20170408;
const int N = 105;
const int M = 2e7+5;
int n,m,p;
struct Martix
{
	int d[N];
	Martix(){memset(d,0,sizeof(d));}
	Martix operator *(const Martix &s)const
	{
		Martix res;
		for(int i = 0;i<p;i++)
			for(int j = 0;j<p;j++)
				(res.d[i]+=(ll)d[j]*s.d[(i-j+p)%p]%mod)%=mod;
		return res;
	}
};
bool vis[M];
int prime[M/10],cnt;
void quick_prime()
{
	vis[1] = true;
	for(int i = 2;i<M;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<=cnt&&prime[j]*i<M;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	quick_prime();
	scanf("%d%d%d",&n,&m,&p);
	Martix go1,go2;
	for(int i = 1;i<= m;i++)
	{
		go1.d[i%p]++;
		if(vis[i])
			go2.d[i%p]++;
	}
	Martix a1,a2;
	a1.d[0] = a2.d[0] = 1;
	while(n)
	{
		if(n&1)
		{
			a1 = a1*go1;
			a2 = a2*go2;
		}
		go1 = go1*go1;go2 = go2*go2;
		n>>=1;
	}
	printf("%d\n",(a1.d[0]-a2.d[0]+mod)%mod);
	return 0;
}
Problem4819

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-7;
const int N = 205;
const int M = 3e4+5;
const double INF = 1e9;
struct E
{int next,to,f,from;double c;}e[M];
int head[N],tot=1;
int from[N],a[N][N],b[N][N],n;
void add(int x,int y,int f,double c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f,e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0,e[tot].c=-c;
	e[tot-1].from = x,e[tot].from = y;
}
double dis[N];
bool vis[N];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = s;i<= t;i++)dis[i] = INF;
	dis[s] = 0;
	vis[s] = true;Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=INF;
}
double mcf(int s,int t)
{
	int x = INF;
	double ans = 0;
	for(int i = from[t];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[t];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
	return ans;
}
void rebuild(double mid)
{
	memset(head,0,sizeof(head));
	tot = 1;
	int s= 0,t = 2*n+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			add(i,j+n,1,mid*b[i][j]-a[i][j]);
	for(int i = 1;i<= n;i++)
		add(s,i,1,0),add(i+n,t,1,0);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
		scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
		scanf("%d",&b[i][j]);
	double l = 0,r = 10001;
	while(fabs(r-l)>eps)
	{
		double mid = (l+r)/2;
		rebuild(mid);
		double ans = 0;
		while(spfa(0,2*n+1))ans+=mcf(0,2*n+1);
		if(ans<eps)l = mid;
		else r = mid;
	}
	printf("%.6lf\n",l);
	return 0;
}
Problem4820

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
typedef long long ll;
const int sed = 107;
const int mod = 998244353;
double f[N][N],B[N],pw2[N];
int n,m,deg;
char s[N][N];
ll h[N][N],h0[N][N],pws[N],pw0[N];
int main()
{
	scanf("%d%d",&n,&m);
	deg = n+1;
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s[i]+1);
		for(int j = 1;j<= m;j++)
		{
			h[i][j] = h[i][j-1]*sed+s[i][j];
			h0[i][j] = (h0[i][j-1]*sed+s[i][j])%mod;
		}
	}
	pw2[0] = pws[0] = pw0[0] = 1;
	for(int i = 1;i<= m;i++)
	{
		pw2[i] = pw2[i-1]*0.5;
		pws[i] = pws[i-1]*sed;
		pw0[i] = pw0[i-1]*sed%mod;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<m;k++)
			if(h[i][k]==h[j][m]-h[j][m-k]*pws[k])
			{
				ll x0 = h0[i][k];
				ll x1 = (h0[j][m]-h0[j][m-k]*pw0[k]%mod+mod)%mod;
				if(x0==x1)
					f[i][j]+=pw2[m-k];
			}
	for(int i = 1;i<= n;i++)f[i][i]++,f[i][n+1]--,f[n+1][i]++;
	B[n+1] = 1;
	for(int i = 1,l;i<= deg;i++)
	{
		for(int j = (l=i)+1;j<=deg;j++)if(fabs(f[j][i])>fabs(f[l][i]))l = j;
		for(int j = i;j<= deg;j++)swap(f[i][j],f[l][j]);
		swap(B[i],B[l]);
		double t = f[i][i];
		for(int j = i;j<= deg;j++)f[i][j]/=t;
		B[i]/=t;
		for(int j = 1;j<= deg;j++)if(j!=i)
		{
			t = f[j][i];
			for(int k = i;k<= deg;k++)f[j][k]-=f[i][k]*t;
			B[j]-=B[i]*t;
		}
	}
	for(int i = 1;i<= n;i++)printf("%.10lf\n",B[i]);
	return 0;
}
Problem4821

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct Seg
{
	double sum_x,sum_y,sum_x2,sum_xy;
	double add_x,add_y;
	double cov_x,cov_y;
	bool cover;
}tr[N<<2];
double sum_pre[N<<2],vx[N<<2],vy[N<<2];
struct Res
{
	double sum_x,sum_y,sum_x2,sum_xy;
}res;
int n,m;
void Covers(int p,int l,int r,double S,double T)
{
	if(l>r)return ;
	double len = r-l+1;
	double sum = (l+r)*len/2;
	tr[p].add_x = tr[p].add_y = false;
	tr[p].cov_x = S,tr[p].cov_y = T;
	tr[p].cover = true;
	tr[p].sum_x2 = S*S*len+sum*S+sum*S+sum_pre[r]-sum_pre[l-1];
	tr[p].sum_xy = S*T*len+sum*S+sum*T+sum_pre[r]-sum_pre[l-1];
	tr[p].sum_x = (S+l+S+r)*len/2;
	tr[p].sum_y = (T+l+T+r)*len/2;
}
void Push_Down_cover(int p,int l,int r)
{
	if(l==r)return ;
	if(tr[p].cover)
	{
		int mid =(l+r)>>1;
		Covers(p<<1,l,mid,tr[p].cov_x,tr[p].cov_y);
		Covers(p<<1|1,mid+1,r,tr[p].cov_x,tr[p].cov_y);
		tr[p].cover = false;
	}
}
void Add(int p,int l,int r,double S,double T)
{
	if(l>r)return ;
	Push_Down_cover(p,l,r);
	double len = r-l+1;
	tr[p].add_x+=S,tr[p].add_y+=T;
	tr[p].sum_x2 += 2*S*tr[p].sum_x+S*S*len;
	tr[p].sum_xy += S*tr[p].sum_y+T*tr[p].sum_x+S*T*len;
	tr[p].sum_x+=S*len,tr[p].sum_y+=T*len;
}
void Push_Down_add(int p,int l,int r)
{
	if(l==r)return ;
	if(tr[p].add_x||tr[p].add_y)
	{
		int mid =(l+r)>>1;
		Add(p<<1,l,mid,tr[p].add_x,tr[p].add_y);
		Add(p<<1|1,mid+1,r,tr[p].add_x,tr[p].add_y);
		tr[p].add_x = tr[p].add_y = 0;
	}
}
void Push_Down(int p,int l,int r)
{
	Push_Down_add(p,l,r);
	Push_Down_cover(p,l,r);
}
void Push_Up(int p)
{
	int l = p<<1,r = p<<1|1;
	tr[p].sum_x = tr[l].sum_x+tr[r].sum_x;
	tr[p].sum_y = tr[l].sum_y+tr[r].sum_y;
	tr[p].sum_x2 = tr[l].sum_x2+tr[r].sum_x2;
	tr[p].sum_xy = tr[l].sum_xy+tr[r].sum_xy;
}
void Build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].sum_x = vx[l];
		tr[p].sum_y = vy[l];
		tr[p].sum_x2 = vx[l]*vx[l];
		tr[p].sum_xy = vx[l]*vy[l];
		return ;
	}
	int mid = (l+r)>>1;
	Build(p<<1,l,mid);
	Build(p<<1|1,mid+1,r);
	Push_Up(p);
}
void Covers(int p,int l,int r,int a,int b,double S,double T)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		Covers(p,l,r,S,T);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Covers(p<<1,l,mid,a,b,S,T);
	if(b >mid)Covers(p<<1|1,mid+1,r,a,b,S,T);
	Push_Up(p);
}
void Add(int p,int l,int r,int a,int b,double S,double T)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		Add(p,l,r,S,T);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Add(p<<1,l,mid,a,b,S,T);
	if(b >mid)Add(p<<1|1,mid+1,r,a,b,S,T);
	Push_Up(p);
}
void Getans(int p,int l,int r,int a,int b)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		res.sum_x+=tr[p].sum_x,res.sum_y+=tr[p].sum_y;
		res.sum_x2+=tr[p].sum_x2,res.sum_xy+=tr[p].sum_xy;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Getans(p<<1,l,mid,a,b);
	if(b >mid)Getans(p<<1|1,mid+1,r,a,b);
}

int main()
{
	for(int i = 1;i<N;i++)sum_pre[i] = sum_pre[i-1]+(double)i*i;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lf",&vx[i]);
	for(int i = 1;i<= n;i++)scanf("%lf",&vy[i]);
	Build(1,1,n);
	int opt,l,r;
	double s,t;
	while(m--)
	{
		scanf("%d%d%d",&opt,&l,&r);
		if(opt==1)
		{
			res.sum_x = res.sum_y = 0;
			res.sum_x2 = res.sum_xy = 0;
			Getans(1,1,n,l,r);
			double len = r-l+1;
			double averx = res.sum_x/len;
			double avery = res.sum_y/len;
			printf("%.10lf\n",(res.sum_xy-len*averx*avery)/(res.sum_x2-len*averx*averx));
		}else if(opt==2)
		{
			scanf("%lf%lf",&s,&t);
			Add(1,1,n,l,r,s,t);
		}else
		{
			scanf("%lf%lf",&s,&t);
			Covers(1,1,n,l,r,s,t);
		}
	}
	return 0;
}
Problem4823

#include <cstdio>
#include <map>
#include <algorithm>
using namespace std;
const int maxn=100005,s=100005,t=100006,oo=0x3f3f3f3f;
int rd()
{
    int x=0;
    char c=getchar();
    while (c<'0'||c>'9') c=getchar();
    while (c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x;
}
int fir[maxn],cur[maxn],ne[20*maxn],to[20*maxn],w[20*maxn],dep[maxn],que[maxn],
xx[maxn],yy[maxn],ww[maxn],
n,num,r,c;
map<pair<int,int>,int> id;
void add(int u,int v,int x)
{
    num++;ne[num*2]=fir[u];fir[u]=num*2;to[num*2]=v;w[num*2]=x;
    ne[num*2+1]=fir[v];fir[v]=num*2+1;to[num*2+1]=u;w[num*2+1]=0;
}
bool bfs()
{
    int u,v,hd,tl;
    for (int i=1;i<=n;i++) dep[i]=0;
    dep[t]=0;
    dep[s]=1;
    que[hd=tl=1]=s;
    while (hd<=tl)
    {
        u=que[hd++];
        for (int i=fir[u];i;i=ne[i])
            if (w[i]&&!dep[v=to[i]])
            {
                dep[v]=dep[u]+1;
                que[++tl]=v;
            }
    }
    return dep[t];
}
int dfs(int u,int lim)
{
    if (u==t) return lim;
    int v,x,ret=0;
    for (int &i=cur[u];i&&ret<lim;i=ne[i])
        if (w[i]&&dep[v=to[i]]==dep[u]+1)
        {
            x=dfs(v,min(lim-ret,w[i]));
            ret+=x;
            w[i]-=x;
            w[i^1]+=x;
        }
    return ret;
}
int main()
{
    int u,ans=0;
    c=rd();
    r=rd();
    n=rd();
    for (int i=1;i<=n;i++)
    {
        xx[i]=rd();
        yy[i]=rd();
        ww[i]=rd();
        id[make_pair(xx[i],yy[i])]=i;
    }
    for (int i=1;i<=n;i++)
        switch (xx[i]%4)
        {
            case 0:
                if (yy[i]&1) add(s,i,ww[i]);
                else
                {
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                        add(id[make_pair(xx[i]+1,yy[i])],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(id[make_pair(xx[i],yy[i]+1)],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(id[make_pair(xx[i],yy[i]-1)],i,oo);
                }
                break;
            case 1:
                if (yy[i]&1)
                {
                    if (id.count(make_pair(xx[i]-1,yy[i])))
                        add(id[make_pair(xx[i]-1,yy[i])],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(id[make_pair(xx[i],yy[i]+1)],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(id[make_pair(xx[i],yy[i]-1)],i,oo);
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                    {
                        u=id[make_pair(xx[i]+1,yy[i])];
                        add(i,u,min(ww[i],ww[u]));
                    }
                }
                else add(s,i,ww[i]);
                break;
            case 2:
                if (yy[i]&1)
                {
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                        add(i,id[make_pair(xx[i]+1,yy[i])],oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(i,id[make_pair(xx[i],yy[i]+1)],oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(i,id[make_pair(xx[i],yy[i]-1)],oo);
                }
                else add(i,t,ww[i]);
                break;
            case 3:
                if (yy[i]&1) add(i,t,ww[i]);
                else
                {
                    if (id.count(make_pair(xx[i]-1,yy[i])))
                        add(i,id[make_pair(xx[i]-1,yy[i])],oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(i,id[make_pair(xx[i],yy[i]+1)],oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(i,id[make_pair(xx[i],yy[i]-1)],oo);
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                    {
                        u=id[make_pair(xx[i]+1,yy[i])];
                        add(u,i,min(ww[i],ww[u]));
                    }
                }
        }
    while (bfs())
    {
        for (int i=1;i<=n;i++) cur[i]=fir[i];
        cur[s]=fir[s];
        cur[t]=fir[t];
        ans+=dfs(s,oo);
    }
    printf("%d\n",ans);
}
Problem4824

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 105;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
int c[N][N],f[N][N],g[N][N],size[N],tmp[N],n;
char s[N];
void dfs(int x)
{
	if((x<<1)<=n)add(x,x<<1);
	if((x<<1|1)<=n)add(x,x<<1|1);
	g[x][1] = f[x][1] = size[x] = 1;
	for(int t = head[x];t;t=e[t].next)
	{
		int to = e[t].to;
		dfs(to);
		for(int j = 1;j<= size[to]+size[x];j++)
			tmp[j] = 0;
		for(int i = 1;i<= size[x];i++)
			for(int j = 0;j<= size[to];j++)
				if(s[to]=='>')
					(tmp[i+j]+=(ll)f[x][i]*g[to][j]%mod*c[i+j-1][i-1]%mod
							  *c[size[x]-i+size[to]-j][size[x]-i]%mod)%=mod;
				else
					(tmp[i+j]+=(ll)f[x][i]*(g[to][size[to]]-g[to][j]+mod)%mod
							  *c[i+j-1][i-1]%mod
							  *c[size[x]-i+size[to]-j][size[x]-i]%mod)%=mod;
		for (int i=1; i<=size[x]+size[to]; i++)
            f[x][i] = tmp[i]%mod, g[x][i] = (g[x][i-1]+f[x][i])%mod;
        size[x] += size[to];
	}
}
int main()
{
	scanf("%d",&n);
	scanf("%s",s+2);
	c[0][0] = 1;
	for(int i = 1;i< N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
	dfs(1);
	printf("%d\n",g[1][size[1]]);
	return 0;
}
Problem4826

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
typedef long long ll;
struct List
{
	struct E
	{
		int l,r,type,val,next;
	}e[N*3];
	int head[N],tot;
	void add(int x,int l,int r,int type,int val)
	{
		e[++tot].l = l;e[tot].r = r;e[tot].type = type;
		e[tot].val = val;
		e[tot].next = head[x];
		head[x] = tot;
	}
	void clear()
	{
		memset(head,0,sizeof(head));
		tot = 0;
	}
}ad,as;
struct Ask
{int l,r,id;}ask[N];
struct Seg
{
	ll sum[N<<2],lazy[N<<2];
	void Push_down(int p,int l,int r)
	{
		if(!lazy[p]||l==r)return ;
		int mid = (l+r)>>1;
		sum[p<<1]+=(ll)(mid-l+1)*lazy[p];
		sum[p<<1|1]+=(ll)(r-mid)*lazy[p];
		lazy[p<<1]+=lazy[p],lazy[p<<1|1]+=lazy[p];
		lazy[p] = 0;
	}
	void update(int p,int l,int r,int a,int b,int val)
	{
		if(a>b)return ;
		Push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			sum[p]+=(ll)(r-l+1)*val;
			lazy[p]+=val;
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,val);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,val);
		sum[p] = sum[p<<1]+sum[p<<1|1];
	}
	ll getans(int p,int l,int r,int a,int b)
	{
		if(a>b)return 0;
		Push_down(p,l,r);
		if(l>=a&&r<=b)return sum[p];
		ll ans = 0;
		int mid = (l+r)>>1;
		if(a<=mid)ans = ans+getans(p<<1,l,mid,a,b);
		if(b >mid)ans = ans+getans(p<<1|1,mid+1,r,a,b);
		return ans;
	}
}tr[2];
ll ans[N];
int l[N],r[N],stack[N],top,a[N];
int main()
{
	//freopen("test.in","r",stdin);
	int n,m,p1,p2;
	scanf("%d%d%d%d",&n,&m,&p1,&p2);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	top = 0;
	for(int i = 1;i<= n;i++)
	{
		while(top&&a[stack[top]]<a[i])r[stack[top]]=i-1,top--;
		stack[++top] = i;
	}
	while(top)r[stack[top]]=n,top--;
	for(int i = n;i>= 1;i--)
	{
		while(top&&a[stack[top]]<a[i])l[stack[top]]=i+1,top--;
		stack[++top] = i;
	}
	while(top)l[stack[top]]=1,top--;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].id = i;
		as.add(ask[i].r,ask[i].l,ask[i].r,1,i);
		as.add(ask[i].l-1,ask[i].l,ask[i].r,-1,i);
	}
	for(int i = 1;i<= n;i++)
	{
		ad.add(l[i]-1,r[i]+1,r[i]+1,0,p1);
		ad.add(l[i]-1,i+1,r[i],0,p2);
		ad.add(r[i]+1,l[i],i-1,1,p2);
	}
	for(int i = 1;i<= n;i++)
	{
		for(int j = ad.head[i];j;j=ad.e[j].next)
		{
			int L = ad.e[j].l,R = ad.e[j].r,typ = ad.e[j].type,vl = ad.e[j].val;
			tr[typ].update(1,1,n,max(1,L),min(R,n),vl);
		}
		if(i!=n)tr[0].update(1,1,n,i+1,i+1,p1);
		for(int j = as.head[i];j;j=as.e[j].next)
		{
			int L = as.e[j].l,R = as.e[j].r,typ = as.e[j].type,vl = as.e[j].val;
			for(int k =0;k<2;k++)
				ans[vl]+=(ll)typ*tr[k].getans(1,1,n,L,R);
		}
	}
	for(int i = 1;i<= m;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem4827

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double PI = 3.14159265358979323;
const int N = 4e5+5;
typedef long long ll;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}a[N],b[N],c[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*2*type/i),sin(PI*2*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp t,w(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = a[j+k+(i>>1)]*w;
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
ll ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i] = a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)ans[i]=(ll)(c[i].x+0.5);
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	ll c2 = 0;
	ll c11 = 0,c12 = 0;
	for(int i = 0;i< n;i++)
	{
		scanf("%d",&x);
		c2 += x*x;
		c11+=x;
		c12-=x;
		a[i].x = x;
	}
	for(int i = 0;i< n;i++)
	{
		scanf("%d",&x);
		c2 += x*x;
		c11-=x;
		c12+=x;
		b[i].x = x;
	}
	for(int i = 0;i<n;i++)
	{
		a[i+n] = a[i];
		if(i<n-i-1)swap(b[n-i-1],b[i]);
	}
	int l = 1;
	for(l=1;l<=n*4;l<<=1);
	conv(a,b,c,l);
	ll Ans = 1e18;
	for(int i = 0;i<n;i++)
		for(int j = 0;j<=m;j++)
		{
			Ans = min(Ans,c2+c11*j*2-ans[n+i-1]*2+n*j*j);
			Ans = min(Ans,c2+c12*j*2-ans[n+i-1]*2+n*j*j);
		}
	printf("%lld\n",Ans);
	return 0;
}
Problem4828

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 105;
const int B = 1e6;
int prime[N],cnt;
bool vis[N];
void get_prime()
{
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])prime[cnt++] = i;
		for(int j = 0;j<cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int S[B+5];
map<int,int>s;
int n,m,mc,k,dp[N][N];
int a[N],w[N],C[N],fl[N],maxc;
int Get(int x)
{
	if(x<=B)return S[x];
	else return s[x];
}
void Update(int x,int ans)
{
	if(x<=B)S[x] = ans;
	else s[x] = ans;
}
int calc(int n)
{
	if(n<0)return INF;
	if(n==0)return 0;
	if(n==1)return 1;
	int tmp = n,end = 1;
	for(int i = 0;i< cnt;i++)
		while(tmp%prime[i]==0)
			tmp/=prime[i],end = prime[i];
	if(tmp>1)return INF;
	if(Get(n))return Get(n);
	int lim = k+1;
	for(int i = end;i<lim-1;i++)if(n%i==0)
	{
		int t = i+1;
		tmp = n;
		for(int j = i;j>=2&&t<=lim&&tmp>1;j--)
			while(tmp%j==0)
				tmp/=j,t++;
		if(tmp==1)lim= min(lim,t);
	}
	Update(n,lim);
	return lim;
}
int tmp;
void solve(int x,int pos)
{
	if(tmp==m)return ;
	int t = calc(x);
	if(t>k/2)return ;
	for(int i = pos;i>=0;i--)if((ll)prime[i]*x<=maxc)solve(x*prime[i],i);
	for(int i = 0;i<= k-2*t;i++)
	{
		for(int j = 1;j<= m;j++)
			if(!fl[j])
			{
				int l = calc(C[j]-i-x);
				if(l+i+t<=k)fl[j]=1,tmp++;
			}
	}
}
int main()
{
	get_prime();
	scanf("%d%d%d",&n,&m,&mc);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&C[i]),maxc = max(maxc,C[i]);
	memset(dp,-1,sizeof(dp));
	dp[0][0] = mc;
	for(int i = 0;i< n;i++)
	{
		for(int j = 0;j<= i;j++)if(dp[i][j]!=-1)
		{
			if(dp[i][j]<a[i+1])continue;
			dp[i+1][j] = min(mc,max(dp[i+1][j],dp[i][j]-a[i+1]+w[i+1]));
			dp[i+1][j+1] = min(mc,max(dp[i+1][j+1],dp[i][j]-a[i+1]));
		}
		for(int j = 0;j<= n;j++)if(dp[i+1][j]!=-1)k = max(k,j);
	}
	for(int i = 1;i<= m;i++)
	{
		for(int j =0;j<k&&j<C[i];j++)fl[i]|=(calc(C[i]-j)+j<=k);
		tmp+=fl[i];
	}
	solve(1,14);
	for(int i = 1;i<= m;i++)printf("%d\n",fl[i]);
	return 0;
}
Problem4831

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5+5;
const int M = 1e6+5;
int f[2][M][2],mn[M],a[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
		f[0][0][0] = 0,f[0][0][1] = INF;
		int now = 0,nxt = 1,i,j,s,k;
		for(i = 0;i< n;i++)
		{
			for(j = 0;j<= a[i+1];j++)
				f[nxt][j][0]=f[nxt][j][1]=INF;
			for(j = a[i];j>= 0;j--)
			{
				mn[j] = min(f[now][j][0],j==a[i]?INF:mn[j+1]);
				if(j<=a[i+1])
				{
					for(s = 0;s<2;s++)
					f[nxt][a[i+1]-j][0] = min(f[nxt][a[i+1]-j][0],f[now][j][s]+j);
				}else
					f[nxt][0][1] = min(f[nxt][0][1],f[now][j][0]+a[i+1]);
			}
			for(k = a[i+1];k>=0;k--)
				f[nxt][a[i+1]-k][1] = min(f[nxt][a[i+1]-k][1],(k+1>a[i])?INF:(mn[k+1]+k));
			swap(nxt,now);
		}
		int ans1 = min(f[now][0][0],f[now][0][1]);
		for(j = 0;j<= a[n];j++)
			ans1 = min(ans1,f[now][j][0]);
		f[0][0][0] = 0,f[0][0][1] = -INF;
		now = 0,nxt = 1;
		for(i = 0;i< n;i++)
		{
			for(j = 0;j<= a[i+1];j++)
				f[nxt][j][0]=f[nxt][j][1]=-INF;
			for(j = a[i];j>= 0;j--)
			{
				mn[j] = max(f[now][j][0],j==a[i]?-INF:mn[j+1]);
				if(j<=a[i+1])
				{
					for(s = 0;s<2;s++)
					f[nxt][a[i+1]-j][0] = max(f[nxt][a[i+1]-j][0],f[now][j][s]+j);
				}else
					f[nxt][0][1] = max(f[nxt][0][1],f[now][j][0]+a[i+1]);
			}
			for(k = a[i+1];k>=0;k--)
				f[nxt][a[i+1]-k][1] = max(f[nxt][a[i+1]-k][1],(k+1>a[i])?-INF:(mn[k+1]+k));
			swap(nxt,now);
		}
		int ans2 = max(f[now][0][0],f[now][0][1]);
		for(j = 0;j<= a[n];j++)
			ans2 = max(ans2,f[now][j][0]);
		printf("%d %d\n",ans1,ans2);
	}
	return 0;
}
Problem4833

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
ll f[N],g[N];
int n,p;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res=(ll)res*x%p;
		x = (ll)x*x%p;
		y>>=1;
	}
	return res;
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&p);
		f[1] = g[1] = 1,f[2] = g[2] = 2;
		for(int i = 3;i<= n;i++)
			f[i] = ((f[i-1]<<1)+f[i-2])%p,g[i] = f[i];
		for(int i = 1;i<= n;i++)
		{
			int inv = quick_pow(g[i],p-2);
			for(int j = i+i;j<= n;j+=i)
				g[j] = (ll)g[j]*inv%p;
		}
		ll lcm = 1,ans = 0;
		for(int i = 1;i<= n;i++)
			lcm = (ll)lcm*g[i]%p,(ans+=lcm*i%p)%=p;
		printf("%lld\n",ans);
	}
}
Problem4835

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
struct E
{int next,to;}e[N<<1];
int head[N],tot,big[N],f[N],fa[N],size[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
}
void dfs(int x)
{
	f[x] = 1;size[x]=1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		size[x]+=size[e[i].to];
	}
	for(int i = head[x];i;i=e[i].next)
	{
		if(size[e[i].to]<<1==size[x])
			f[x] = (ll)f[x]*big[e[i].to]%mod*f[e[i].to]%mod;
		else
			f[x] = (ll)f[x]*size[e[i].to]%mod*f[e[i].to]%mod;
	}
}
int main()
{
	//freopen("x.in","r",stdin);
	int n,m;
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)head[i]=big[i]=fa[i]=0;tot = 0;
		int x,y;
		for(int i = 1;i<n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);fa[y] = x;
		}
		for(int i = 1;i<= n;i++)
		{
			int now = i;
			while(now)
			{
				if(fa[now]<i)big[now]++;
				now = fa[now];
			}
		}
		for(int i = 1;i<= n;i++)
			if(!fa[i])
			{
				dfs(i);
				printf("%d\n",f[i]);
				break;
			}
	}
	return 0;
}
Problem4849

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
struct data
{
	int mn,dep,lazy;
	void add(int x)
	{
		mn+=x,dep+=x,lazy+=x;
	}
}a[N];
int ef[N],et[N],n,m;
void Push_up(int p)
{
	int l = p<<1,r = p<<1|1;
	a[p].mn = ef[p]?a[p].dep:INF;
	if(l<=n)a[p].mn = min(a[p].mn,a[l].mn);
	if(r<=n)a[p].mn = min(a[p].mn,a[r].mn);
}
void Push_down(int p)
{
	if(!a[p].lazy)return ;
	int l = p<<1,r = p<<1|1;
	if(l<=n)a[l].add(a[p].lazy);
	if(r<=n)a[r].add(a[p].lazy);
	a[p].lazy = 0;
}
void relax(int p)
{
	if(!p)return ;
	relax(p>>1);
	Push_down(p);
}
void dfs(int x,bool f)
{
	Push_down(x);
	if(ef[x]&&a[x].dep==a[x].mn)
		ef[x]--;
	else
	{
		int to = (x<<1)^(a[x].mn!=a[x<<1].mn);
		dfs(to,1);
	}
	Push_up(x);
	if(f&&!++et[x])a[x].add(2);
}
int ans = 0;
void get_max_flow(int x)
{
	relax(x);
	int mc = INF,mw,c1 = 0;
	for(int i = x;i;i>>=1)
	{
		int c2 = c1+a[i].mn-a[i].dep;
		if(c2<mc)
		{
			mc = c2;
			mw = i;
		}
		c1+=et[i]>0?-1:1;
	}
	for(int i = x;i!=mw;i>>=1)
	{
		Push_up(i);
		if(!et[i]--)a[i].add(-2);
	}
	dfs(mw,0);
	for(;mw;mw>>=1)Push_up(mw);
	ans+=mc;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&ef[i]);
	for(int i = 1;i<= n;i++)a[i].dep = a[i>>1].dep+1;
	int x;
	for(int i = n;i;i--)Push_up(i);
	for(int i = 1;i<= m;i++)
	{
		if(i!=1)printf(" ");
		scanf("%d",&x);
		get_max_flow(x);
		printf("%d",ans);
	}
	return 0;
}
Problem4860

#include <cstdio>
#include <cctype>
#include <algorithm>
const int maxn=400010,inf=2000000010;
int ans,n,x,y,z,i,m,l,r,c[maxn*3],cnt;
inline int max(int a,int b)
{
	return a>b?a:b; 
}
inline void up(int&a,const int&b)
{
	if(a<b)a=b;
}
struct edge{int from,to,color;}e[maxn<<1];
struct data{int dep,sum;};
struct node{int v,lc,rc;}a[maxn*5];
int merge(int x,int y)
{
	if(!x || !y )return x|y;
	a[x].lc=merge(a[x].lc,a[y].lc);
	a[x].rc=merge(a[x].rc,a[y].rc);
	up(a[x].v,a[y].v);
	return x;
}
void add(int&i,int rl,int rr,int x,int v)
{
	if(!i)a[i=++cnt]=(node){v,0,0};
		else up(a[i].v,v);
	if(rl<rr)
	{
		int m=(rl+rr)>>1;
		if(x>m)add(a[i].rc,m+1,rr,x,v);
			else add(a[i].lc,rl,m,x,v);
	}
}
int query(int i,int rl,int rr,int l,int r)
{
	if(!i)return -inf;
	if(rl==l && rr==r)return a[i].v;
	int m=(rl+rr)>>1;
	if(l>m)return query(a[i].rc,m+1,rr,l,r);
		else if(r<=m)return query(a[i].lc,rl,m,l,r);
			else return max(query(a[i].lc,rl,m,l,m),query(a[i].rc,m+1,rr,m+1,r));
}
struct tree
{
	int xb,h[maxn],n,size[maxn],f[maxn],rt,sum,dep[maxn],ll,ss[maxn];
	bool b[maxn];
	data w[maxn];
	void addedge(int x,int y,int z)
	{
		e[++xb]=(edge){y,x,z};
		e[++xb]=(edge){x,y,z};
	}
	void dfs(int x,int fa)
	{
		size[x]=f[x]=1;
		for(int i=h[x];i<h[x+1];++i)
		{
			int y=e[i].to;
			if(y!=fa && !b[y])
			{
				dfs(y,x);
				size[x]+=size[y];
				up(f[x],size[y]);
			}
		}
		up(f[x],sum-size[x]);
		if(f[rt]>f[x])rt=x;
	}
	void got(int x,int fa,int dep,int color,int sum)
	{
		for(int y,i=h[x];i<h[x+1];++i)
		{
			y=e[i].to;
			if(y!=fa && !b[y])
			{
				if(e[i].color==color)w[++ll]=(data){dep+1,sum};
					else w[++ll]=(data){dep+1,sum+c[e[i].color]};
				got(e[i].to,x,dep+1,e[i].color,w[ll].sum);
			}
		}
	}
	void solve(int x)
	{
		b[x]=1;
		int i,rt1=0,rt2=cnt=0,j;
		for(i=h[x];i<h[x+1];++i)
		{   
			if(i>h[x] && e[i].color>e[i-1].color)rt1=merge(rt1,rt2),rt2=0;         
			if(!b[e[i].to])
			{
				w[ll=1]=(data){1,c[e[i].color]};
				got(e[i].to,x,1,e[i].color,c[e[i].color]);
				ss[i]=ll;
				for(j=1;j<=ll;++j)if(w[j].dep<=r)
				{
					if(w[j].dep>=l)up(ans,w[j].sum);
					if(w[j].dep<r)
					{
						up(ans,query(rt1,1,n,max(1,l-w[j].dep),r-w[j].dep)+w[j].sum);
						up(ans,query(rt2,1,n,max(1,l-w[j].dep),r-w[j].dep)-c[e[i].color]+w[j].sum);
					}
				}
				for(j=1;j<=ll;++j)if(w[j].dep<=r)add(rt2,1,n,w[j].dep,w[j].sum);
			}
		}
		for(i=h[x];i<h[x+1];++i)
			if(!b[e[i].to])
			{
				sum=ss[i];
				rt=0;
				dfs(e[i].to,x);
				solve(rt);
			}
	}
}t;
bool cmp(const edge&a,const edge&b)
{
	return a.from==b.from?a.color<b.color:a.from<b.from;
}
int main()
{
	a[0].v=-inf;
	scanf("%d%d%d%d",&n,&m,&l,&r);
	t.n = n;
	for(i=1;i<=m;++i)scanf("%d",&c[i]);
	for(i=1;i<n;++i)
	{
		scanf("%d%d%d",&x,&y,&z);
		t.addedge(x,y,z);
	}
	std::sort(e+1,e+((n-1)*2)+1,cmp);
	for(i=1;i<=((n-1)<<1);++i)
		if(!t.h[e[i].from])t.h[e[i].from]=i;
	t.h[n+1]=(n-1)<<1|1; 
	t.f[t.rt=0]=inf;
	t.sum=n;
	ans=-inf;
	t.dfs(1,0);
	t.solve(t.rt);
	printf("%d\n",ans);
}
Problem4861

#include <bits/stdc++.h>
const int mod = 1e9+7;
using namespace std;
typedef long long LL;
int len[105],cnt,n,m,l,ans;
char s[55][105];
inline void inc(int &x,int y) {x=(x+y)%mod;}

struct Trie{
	int ch[205][27],leef[205],fail[205];
	char s[205];
	void add() {
		scanf("%s",s+1); int n = strlen(s+1);
		int p = 0;
		for (int i=1;i<=n;i++) {
			int c = s[i] - 'a';
			if (!ch[p][c]) ch[p][c] = ++cnt;
			p = ch[p][c];
		}
		leef[p] = 1;
	}

	void set() {
		queue<int> q;
		for (int i=0;i<26;i++) if (ch[0][i])
			fail[ ch[0][i] ] = 0, q.push(ch[0][i]);

		while (!q.empty()) {
			int u=q.front(); q.pop();
			for (int i=0;i<26;i++) if (ch[u][i]) {
				int v = ch[u][i], t = fail[u];
				while (t && !ch[t][i]) t = fail[t];
				fail[v] = ch[t][i];
				leef[v] = leef[v] || leef[ fail[v] ];
				q.push(v);
			}
		}
	}

	int g(int u,char *s) {
		int len = strlen(s+1);
		for (int i=1;i<=len;i++) {
			int c = s[i]-'a';
			while (u && !ch[u][c]) u = fail[u];
			if (ch[u][c]) u = ch[u][c];
			if (leef[u]) return -1;
		}
		return u;
	}

}T;

namespace planA
{
	int F[105][5050];
	void solve() 
	{
		F[0][0] = 1;
		for (int _=0;_<l;_++)
			for (int i=0;i<=cnt;i++) if (F[_][i])
				for (int j=1;j<=n;j++) if (_+len[j]<=l) 
				{
					int ni = T.g(i,s[j]);
					if (ni == -1) continue;
					inc(F[_+len[j]][ni], F[_][i]);
				}
		for (int _=0;_<=cnt;_++) inc(ans, F[l][_]);
		cout << ans << endl;
	}
}

namespace planB
{

	struct Matrix{int a,d[205][205];}A,B,id;

	Matrix operator*(Matrix p1, Matrix p2) 
	{
		Matrix ret = id;ret.a = p1.a;
		for (int i=0;i<=p1.a;i++)
			for (int j=0;j<=p1.a;j++)
				for (int k=0;k<=p1.a;k++)
					inc(ret.d[i][j], 1LL*p1.d[i][k] * p2.d[k][j] % mod);
		return ret;
	}

	Matrix qp(Matrix A, int b) 
	{
		Matrix ret = id;
		ret.a = A.a;
		for (int i=0;i<=A.a;i++) ret.d[i][i] = 1;

		while (b) 
		{
			if (b&1) ret = ret * A;
			b >>= 1, A = A * A;
		}
		return ret;
	}

	void solve() 
	{
		int tp = cnt+1;
		A.a = B.a = 2*tp-1;
		A.d[0][0+tp] = 1;

		for (int i=0;i<=cnt;i++) B.d[i+tp][i] = 1;
		for (int i=0;i<=cnt;i++) 
		{
			for (int j=1;j<=n;j++) 
			{
				int ni = T.g(i,s[j]);
				if (ni == -1) continue;
				if (len[j] == 1)
					B.d[i+tp][ni+tp]++;
				else
					B.d[i][ni+tp]++;
			}
		}
		A = A * B;
		B = qp(B, l);
		A = A * B;
		for (int i=0;i<=cnt;i++) inc(ans, A.d[0][i]);
		cout << ans << endl;
	}
}

int main() 
{
	scanf("%d%d%d",&n,&m,&l);
	for (int i=1;i<=n;i++) 
		scanf("%s",s[i]+1), len[i] = strlen(s[i]+1);
	for (int i=1;i<=m;i++) 
		T.add();
	T.set();
	if (l <= 100) planA::solve(); else planB::solve();
	return 0;
}
Problem4866

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<26;
const int N = 60005;
unsigned short cnt[S+5];
char s[N];
int ans[N],num[N];
int pos[N],pre[N],lb[N],rb[N];
inline char nc(){
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline void read(int &x){
	char c=nc(),b=1;
	for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;
	for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;
}
inline void read(char *s){
	char c=nc(); int len=0;
	for (;!(c>='a' && c<='z');c=nc());
	for (;c>='a' && c<='z';s[++len]=c,c=nc());
}
inline void write(ll x){
	if (x>=10) write(x/10); putchar(x%10+'0');
}

inline void add(int x)
{
	cnt[x]++;
	for(register int i = 0;i<26;i++)cnt[x^(1<<i)]++;
}
inline void del(int x)
{
	cnt[x]--;
	for(register int i = 0;i<26;i++)cnt[x^(1<<i)]--;
}
inline int getans(int x){return cnt[x];}
struct Q
{
	int l,r,id;
	Q(int _l=0,int _r=0,int _id=0):l(_l),r(_r),id(_id){}
	bool operator <(const Q &s)const
	{
		return pos[l]==pos[s.l]?r<s.r:pos[l]<pos[s.l];
	}
}ask[N];
int block;
int main()
{
	//freopen("4866.in","r",stdin);
	//freopen("4866.out","w",stdout);
	int n,m,i,j,k;
	read(n),read(m);
	block = min((int)sqrt(n*28),n);
	read(s);
	for(i = 1;i<= n;i++)pre[i] = pre[i-1]^(1<<(s[i]-'a'));
	int tot = 0;
	for(i = 1;i<= n;i++)
		pos[i] = (i-1)/block+1;
	tot = pos[n];
	for(i = 1;i<= tot;i++)
		lb[i] = (i-1)*block+1,rb[i] = i*block;
	rb[tot] = n;
	for(i =1;i<= tot;i++)
	{
		add(pre[rb[i]]);
		for(j = rb[i]-1;j>=lb[i]-1;j--)
		{
			num[j+1] = num[j+2]+getans(pre[j]);
			add(pre[j]);
		}
		for(j = rb[i];j>=lb[i]-1;j--)
			del(pre[j]);
	}
	int L,R,Cnt = 0;
	for(i = 1;i<= m;i++)
	{
		read(L),read(R);
		if(pos[L]==pos[R])
		{
			add(pre[L-1]);
			for(j = L;j<= R;j++)
				ans[i]+=getans(pre[j]),add(pre[j]);
			for(j = L-1;j<= R;j++)
				del(pre[j]);
		}else
			ask[++Cnt] = Q(L,R,i);
	}
	sort(ask+1,ask+Cnt+1);
	int last = 0,pnt = 0;
	for(i = 1;i<tot;i++)
	{
		last = pnt;
		while(pnt+1<=Cnt&&pos[ask[pnt+1].l]==i)pnt++;
		int r = lb[i+1]-1;
		ll now = 0;
		add(pre[r]);
		for(j = last+1;j<= pnt;j++)
		{
			while(r<ask[j].r)now+=getans(pre[++r]),add(pre[r]);
			ans[ask[j].id] = now+num[ask[j].l];
			del(pre[lb[i+1]-1]);
			for(k = ask[j].l-1;k< rb[i];k++)
				ans[ask[j].id]+=getans(pre[k]);
			add(pre[lb[i+1]-1]);
		}
		for(j = lb[i+1]-1;j<= r;j++)del(pre[j]);
	}	
	for(i = 1;i<= m;i++)write(ans[i]),putchar('\n');
	return 0;
}
Problem4867

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
int dis[N],dfn[N],Dfn,size[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
}
void dfs(int x)
{
	dfn[x] = ++Dfn;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to);
		size[x]+=size[e[i].to];
	}
}
const int M = 2e7+5;
const int Bs = 510;
int B;
int n,Q,len;
int pos[N],_a[N],lb[Bs],rb[Bs],mx[Bs],mn[Bs],Size[Bs],cnt,tag[N];
int qo[N],ql[N],qr[N],qk[N];
int F[M];
#define f(i,j) (*(F+Size[(i)-1]+(j)-mn[(i)]))
void Build()
{
	cnt = 0;
	B = sqrt(n);
	for(int i = 1;i<= n;i+=B)
		lb[++cnt] = i,rb[cnt] = i+B-1;
	rb[cnt] = n;
	for(int i = 1;i<= cnt;i++)
		for(int j = lb[i];j<= rb[i];j++)pos[j] = i;
	for(int i = 1;i<= cnt;i++)mx[i]=-1<<30,mn[i]=1<<30;
	for(int i = 1;i<= n;i++)
		mx[pos[i]] = max(mx[pos[i]],_a[i]),mn[pos[i]] = min(mn[pos[i]],_a[i]);
	for(int i = 1;i<= Q;i++)
		if(qo[i]==2)
			mx[pos[ql[i]]]+=qk[i],mx[pos[qr[i]]]+=qk[i];
	for(int i = 1;i<= cnt;i++)
		mn[i]--,Size[i] = Size[i-1]+mx[i]-mn[i];
	for(int i = 1;i<= n;i++)f(pos[i],_a[i])++;
	for(int i = 1;i<= cnt;i++)
		for(int j = mn[i]+2;j<=mx[i];j++)
			f(i,j)+=f(i,j-1);
}
void Add(int l,int r,int d)
{
	int L = pos[l],R = pos[r];
	if(L==R)
	{
		for(int i = l;i<= r;i++)
		{
			for(int j = _a[i]+tag[L];j<= _a[i]+tag[L]+d-1;j++)
				f(L,j)--;
			_a[i]+=d;
		}
		return ;
	}
	for (int i=L+1;i<R;i++) tag[i]+=d,mn[i]+=d;
	for (int i=l;i<=rb[L];i++)
	{
		for (int j=_a[i]+tag[L];j<=_a[i]+tag[L]+d-1;j++)
			f(L,j)--;
		_a[i]+=d;
	}
	for (int i=lb[R];i<=r;i++)
	{
		for (int j=_a[i]+tag[R];j<=_a[i]+tag[R]+d-1;j++)
			f(R,j)--;
		_a[i]+=d;
	}
}
int tmp[N],pnt;

int getans(int l,int r,int K)
{
	if (K>r-l+1) return -1;
	int lbd=pos[l],rbd=pos[r];
	if (lbd==rbd)
	{
		pnt=0;
		for (int i=l;i<=r;i++) tmp[++pnt]=_a[i]+tag[lbd];
		nth_element(tmp+1,tmp+K,tmp+pnt+1);
		return tmp[K];
	}
	pnt=0;
	for (int i=l;i<=rb[lbd];i++) tmp[++pnt]=_a[i]+tag[lbd];
	for (int i=lb[rbd];i<=r;i++) tmp[++pnt]=_a[i]+tag[rbd];
	sort(tmp+1,tmp+pnt+1);
	int L=-1,R=(n+Q)*len;
	while (L+1<R)
	{
		int MID=(L+R)>>1;tot=0;
		if (L<100000 && R>100000) MID=100000;
		for (int i=lbd+1;i<rbd;i++) 
			if (MID>mn[i]) 
				tot+=f(i,min(MID,mx[i]+tag[i]));
		tot+=upper_bound(tmp+1,tmp+pnt+1,MID)-tmp-1;
		if (tot<K)
			L=MID;
		else
			R=MID;
	}
	return R;
}
int main()
{
	scanf("%d%d%d",&n,&Q,&len);
	int p,d;
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&p,&d);
		add(p,i,d);
	}
	dfs(1);
	for(int i = 1;i<= n;i++)_a[dfn[i]]=dis[i];
	for(int i = 1;i<= Q;i++)
	{
		scanf("%d%d%d",&qo[i],&p,&qk[i]);
		ql[i] = dfn[p],qr[i] = dfn[p]+size[p]-1;
	}
	Build();
	for(int i = 1;i<= Q;i++)
		if(qo[i]==2)Add(ql[i],qr[i],qk[i]);
		else printf("%d\n",getans(ql[i],qr[i],qk[i]));
	return 0;
}
Problem4878

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2e4+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int col[N],vis[N],Dfn;
void dfs(int x)
{
	Dfn++;
	for(int i = head[x];i;i=e[i].next)
		vis[col[e[i].to]] = Dfn;
	for(int i = 1;;i++)
		if(vis[i]<Dfn)
		{
			col[x] = i;
			break;
		}
	for(int i = head[x];i;i=e[i].next)
		if(!col[e[i].to])dfs(e[i].to);
}
void init()
{
	memset(vis,0,sizeof(vis));
	memset(col,0,sizeof(col));
	memset(head,0,sizeof(head)),tot = 0,Dfn = 0;
}
int main()
{
	int cas,n,m,k,x,y;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		scanf("%d%d%d",&n,&m,&k);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
		}
		for(int i = 1;i<= n;i++)
			if(!col[i])dfs(i);
		bool cola = true;
		for(int i = 1;i<= n;i++)
			if(col[i]>k)
			{
				cola = false;
				if(col[i]==k+1)x = i;
			}
		if(cola)
		{
			printf("color");
			for(int i = 1;i<= n;i++)
				printf(" %d",col[i]);
			printf("\n");
			continue;
		}
		printf("path");
		for(int i =1;i<= k+1;i++)
		{
			printf(" %d",x);
			for(int j = head[x];j;j=e[j].next)
				if(col[e[j].to]==col[x]-1)
				{x = e[j].to;break;}
		}
		printf("\n");
	}
	return 0;
}
Problem4879

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
set<int>sx[N],sy[N];
set<int>::iterator it;
int dx[]={1,0,-1,0};
int dy[]={0,1,0,-1};
int n,m,K,opt[N],d[N];
ll L,R;
char s[N];
char ask(int x,int y,int flag)
{
	if(flag)swap(x,y);
	return s[x*m+y];
}
void solve(set<int> &s,int st,int end,ll tl,int wh,bool flag)
{
	int l = st,r = end;
	if(l>r)swap(l,r);
	for(it = s.lower_bound(l);it!=s.end()&&*it<=r;)
	{
		if(flag) sx[*it].erase(sx[*it].find(wh));
        else sy[*it].erase(sy[*it].find(wh));
        if(ask(wh,*it,flag)=='#') L=max(L,tl-abs(*it-st));
        else R=min(R,tl-abs(*it-st)-1);
        s.erase(it++);
	}
}
void debug()
{
	for(int i = 0;i<n&&L<=R;i++)
	{
		for(it=sx[i].begin();it!=sx[i].end();it++)
			printf("%d ",*it);
		puts("");
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for(int i = 0;i<n;i++)
		scanf("%s",s+i*m);
	char op[10];
	for(int i = 1;i<= K;i++)
	{
		scanf("%s",op);
		if(op[0]=='l')opt[i] = 3;
		else if(op[0]=='r')opt[i] = 1;
		else if(op[0]=='u')opt[i] = 2;
		else opt[i] =0;
		scanf("%d",&d[i]);
	}
	for(int i = 0;i<n;i++)for(int j = 0;j<m;j++)sx[i].insert(j);
	for(int i = 0;i<n;i++)for(int j = 0;j<m;j++)sy[j].insert(i);
	int curx = n-1,cury = 0;ll t = 1;
	for(int i = 1;i<= K;i++)
	{
		t+=d[i];
		curx+=d[i]*dx[opt[i]],cury+=d[i]*dy[opt[i]];
	}
	R = t;
	for(int i = K;i;i--)
	{
		int tp = (opt[i]+2)%4;
		int nx = curx+d[i]*dx[tp],ny = cury+d[i]*dy[tp];
		if(tp%2)solve(sx[curx],cury,ny,t,curx,false);
		else solve(sy[cury],curx,nx,t,cury,true);
		t-=d[i],curx=nx,cury=ny;
	}
	for(int i = 0;i<n&&L<=R;i++)
		for(it=sx[i].begin();it!=sx[i].end();it++)
		{
			if(ask(i,*it,false)=='#')
			{
				L = R+1;break;
			}
		}
	if(L>R)L = R = -1;
	printf("%lld %lld\n",L,R);
	return 0;
}
Problem4880

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,X,Y;
struct Line
{
	int x,y;
	Line(){}
	Line(int _x,int _y):x(_x),y(_y){}
	bool operator <(const Line &s)const
	{
		bool pd = ((x<0)^(s.x<0));
		return pd?y*s.x>x*s.y:y*s.x<x*s.y;
	}
}k1[N],k2[N];
int tot1,tot2,L1,L2,ans1,ans2;
int cur0[2],cur1[2];
int main()
{
	int a,b;
	scanf("%d%d%d",&n,&X,&Y);n--;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a,&b);
		if(a<X)k1[++tot1] = Line(X-a,b-Y);
		else if(a>X)k2[++tot2] = Line(X-a,b-Y);
		else
		{
			if(b<Y)L1++,L2++;
			else if(b==Y)L1++;
		}
		cur1[0]+=a<=X;
		cur1[1]+=a<X;
		cur0[0]+=b<=Y;
		cur0[1]+=b<Y;
	}
	sort(k1+1,k1+tot1+1);sort(k2+1,k2+tot2+1);
	ans1 = 0,ans2 = n+4;
	for(int i = 1;i<= tot1;i++)
	{
		if(k1[i].x*k1[i].y<0)continue;
		a = i-1,b = i;
		int p1 = lower_bound(k2+1,k2+tot2+1,k1[i])-k2;
		int p2 = upper_bound(k2+1,k2+tot2+1,k1[i])-k2;
		a+=(tot2-p2+1),b+=(tot2-p1+1);
		ans1 = max(ans1,b),ans2 = min(ans2,a);
	}
	for(int i = 1;i<= tot2;i++)
	{
		if(k2[i].x*k2[i].y<0)continue;
		a = tot2-i,b = tot2-i+1;
		int p1 = lower_bound(k1+1,k1+tot1+1,k2[i])-k1;
		int p2 = upper_bound(k1+1,k1+tot1+1,k2[i])-k1;
		a+=(p1-1),b+=(p2-1);
		ans1 = max(ans1,b),ans2 = min(ans2,a);
	}
	ans1+=L1,ans2+=L2;
	ans1 = max(ans1,max(cur1[0],cur0[0]));
	ans2 = min(ans2,min(cur1[1],cur0[1]));
	printf("%d %d\n",n+1-ans1,n+1-ans2);
	return 0;
}
Problem4881

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 998244353;
int c[N],a[N],f[N];
int getans(int x)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))ans=max(ans,c[i]);
	return ans;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))c[i] = max(c[i],y);
}
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
set<int>S;
set<int>::iterator it;
set<int>::iterator tmp;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int mx = 0;
	for(int i = 1;i<= n;i++)
	{
		f[i] = getans(n-a[i])+1;
		update(n-a[i]+1,f[i]);
		mx = max(mx,f[i]);
	}
	if(mx>2)
	{
		puts("0");
		return 0;
	}
	for(int i = 1;i<= n;i++)
	{
		int mx = a[i];
		it = S.upper_bound(a[i]);
		while(it!=S.end())
		{
			mx = max(mx,*it);
			tmp = it;
			it++;S.erase(tmp);
		}
		S.insert(mx);
	}
	printf("%d\n",quick_pow(2,S.size()));
	return 0;
}
Problem4886

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250005;
int cnt,mx;
int a[N],b[N],g[N<<1],idx[N<<1],fa[N<<1],mxv[N<<1];
bool d[N<<1];
map<int,int>h;
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x]=getfa(fa[x]);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
		idx[++cnt]=a[i],idx[++cnt]=b[i];
	}
	sort(idx+1,idx+cnt+1);
	for(int i = 1;i<= cnt;i++)
		if(i==1||idx[i]!=idx[i-1])
			g[h[idx[i]]=++mx] = idx[i];
	long long ans = 0;
	for(int i = 1;i<= mx;i++)
	{
		fa[i] = i;mxv[i] = g[i];
		ans-=g[i];
	}
	for(int i = 1;i<= n;i++)
	{
		ans+=a[i]+b[i];
		int fx = getfa(h[a[i]]),fy = getfa(h[b[i]]);
		if(fx!=fy)
		{
			d[fx]|=d[fy];
			mxv[fx] = max(mxv[fx],mxv[fy]);
			fa[fy] = fx;
		}else
			d[fx] = true;
	}
	for(int i = 1;i<= mx;i++)
		if(getfa(i)==i&& !d[i])ans+=mxv[i];
	printf("%lld\n",ans);
	return 0;
}
Problem4887

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 2017;
struct Martix
{
	int d[35][35];
	int w,h;
	Martix(int _w=0,int _h=0):w(_w),h(_h){memset(d,0,sizeof(d));}
	Martix operator *(const Martix &s)const
	{
		Martix res(s.w,h);
		for(int i = 1;i<= res.w;i++)
			for(int k = 1;k<= s.h;k++)
				if(s.d[i][k])
					for(int j = 1;j<= res.h;j++)
						(res.d[i][j]+=s.d[i][k]*d[k][j]%mod)%=mod;
		return res;
	}
	friend Martix operator ^(const Martix &a,int s)
	{
		Martix res(a.w,a.h);
		Martix t = a;
		for(int i = 1;i<= a.w;i++)res.d[i][i] = 1;
		while(s)
		{
			if(s&1)res = res*t;
			t = t*t;
			s>>=1;
		}
		return res;
	}
};
int main()
{
	int n,m;
	int x,y;
	scanf("%d%d",&n,&m);
	Martix go(n+1,n+1),ans(n+1,1);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		go.d[x][y]++;
		go.d[y][x]++;
	}
	for(int i = 1;i<= n+1;i++)
		go.d[i][i]=1,go.d[n+1][i]=1;
	ans.d[1][1] = 1;
	int t;
	scanf("%d",&t);
	ans = ans*(go^t);
	int Ans = 0;
	for(int i = 1;i<= n+1;i++)(Ans+=ans.d[i][1])%=mod;
	printf("%d\n",Ans);
	return 0;
}
Problem4888

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int Max = 1e6+1e5;
int c[2][Max];
int a[N],ans[N],n;
inline int Get_bit(int x,int y)
{
	return (x>>(y-1))&1;
}
void Update(int id,int x,int y)
{
	for(int i = x;i<Max;i+=i&(-i))
		c[id][i]+=y;
}
int Getans(int id,int x)
{
	int res = 0;
	for(int i = x;i;i-=i&(-i))
		res+=c[id][i];
	return res;
}

int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		a[i]+=a[i-1];
	}
	for(int i = 1,ba = 1;i<= 20;i++)
	{
		memset(c,0,sizeof(c));
		for(int j = 1;j<= n;j++)
		{
			ans[i]+=Getans(Get_bit(a[j],i),ba+1)-Getans(Get_bit(a[j],i),a[j]%ba+1)
			+Getans(!Get_bit(a[j],i),a[j]%ba+1)+Get_bit(a[j],i);
			Update(Get_bit(a[j],i),a[j]%ba+1,1);
		}
		ba = ba<<1;
	}
	int Ans = 0;
	for(int i = 1,ba = 1;i<= 20;i++,ba<<=1)Ans+=(ans[i]&1)*ba;
	printf("%d\n",Ans);
	return 0;
}
Problem4889

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e4+5;
const int B = 500;
const int mod = 1e9+7;
int st[B],end[B],bel[N],n;
struct data
{
	int a,v;
	bool operator <(const data &s)const
	{
		if(a==s.a)return v<s.v;
		return a<s.a;
	}
}ord[B][B+5],num[N];
int sum[B][B+5];
ll tot_ans;
struct Bit_array
{
	int c[N];
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i;i-=i&(-i))
			(ans+=c[i])%=mod;
		return ans;
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			(c[i]+=y)%=mod;
	}
	int getans(int x,int y)
	{
		return (getans(y)-getans(x-1)+mod)%mod;
	}
}c1,c2;
int less_than(int x,int block)
{
	int l = 1,r = end[block]-st[block]+2;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(ord[block][mid].a<x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
int bigger_than(int x,int block)
{
	int l = 1,r = end[block]-st[block]+2;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(ord[block][mid].a<=x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
void rebuild(int i)
{
	for(int j = st[i];j<=end[i];j++)
			ord[i][j-st[i]+1] = num[j];
	sort(ord[i]+1,ord[i]+end[i]-st[i]+2);
	for(int k = 1;k<= end[i]-st[i]+1;k++)
		sum[i][k] = sum[i][k-1]+ord[i][k].v;
}
int main()
{
	int m;
	scanf("%d%d",&n,&m);
	int bsize = sqrt(0.7*n)+1;
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&num[i].a,&num[i].v);
	for(int i = 1;i<= n;i++)
	{
		tot_ans+=(c2.getans(num[i].a+1,n)+(ll)c1.getans(num[i].a+1,n)*num[i].v%mod)%mod;
		tot_ans = (tot_ans%mod+mod)%mod;
		c1.update(num[i].a,1);
		c2.update(num[i].a,num[i].v);
	}
	int bnum = 0;
	for(int i = 1;i<= n;i+=bsize)
		st[++bnum]=i,end[bnum]=i+bsize-1;
	end[bnum] = n;
	int j;
	for(int i = 1;i<= bnum;i++)
	{
		for(j = st[i];j<=end[i];j++)
			ord[i][j-st[i]+1] = num[j],bel[j]=i;
		sort(ord[i]+1,ord[i]+end[i]-st[i]+2);
		for(int k = 1;k<= end[i]-st[i]+1;k++)
			sum[i][k] = sum[i][k-1]+ord[i][k].v;
	}
	int x,y;
	//scanf("%d",&m);
	while(m--)
	{
		scanf("%d%d",&x,&y);
		if(x>y)swap(x,y);
		int L = bel[x],R = bel[y];
		if(L==R)
		{
			for(int i = x+1;i< y;i++)
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;
			for(int i = x+1;i< y;i++)
				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
			if(num[x].a<num[y].a)tot_ans+=num[x].v+num[y].v;
			else if(num[x].a>num[y].a)tot_ans-=num[x].v+num[y].v;
			swap(num[x],num[y]);
			rebuild(L);
		}else
		{
			for(int i = x+1;i<=end[L];i++)
			{
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;

				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			for(int i = st[R];i< y;i++)
			{
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;

				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			for(int i = L+1;i<= R-1;i++)
			{
				int lx = less_than(num[x].a,i);
				int bx = bigger_than(num[x].a,i);
				int ly = less_than(num[y].a,i);
				int by = bigger_than(num[y].a,i);
				tot_ans-=sum[i][lx]+(ll)lx*num[x].v%mod;
				tot_ans+=sum[i][end[i]-st[i]+1]-sum[i][bx]+(ll)(end[i]-st[i]+1-bx)*num[x].v%mod;
				tot_ans+=sum[i][ly]+(ll)ly*num[y].v%mod;
				tot_ans-=sum[i][end[i]-st[i]+1]-sum[i][by]+(ll)(end[i]-st[i]+1-by)*num[y].v%mod;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			if(num[x].a<num[y].a)tot_ans+=num[x].v+num[y].v;
			else if(num[x].a>num[y].a)tot_ans-=num[x].v+num[y].v;
			swap(num[x],num[y]);
			rebuild(L),rebuild(R);
		}
		tot_ans = (tot_ans%mod+mod)%mod;
		printf("%lld\n",tot_ans);
	}
	return 0;
}
Problem4891

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef long double ld;
int n,m,k;
ll b[100005],a[22][100005],M;
int fp,ts[100];
ll fs[100];
ll mul(ll a,ll b,ll c)
{
    if(c<=2000000000ll)return a*b%c;
    ll r=a*b-ll(ld(a)/c*b)*c;
    if(r>=c||r<=-c)r%=c;
    return r>=0?r:r+c;
}
ll pw(ll a,ll n,ll P)
{
    ll v=1;
    for(;n;n>>=1,a=mul(a,a,P))if(n&1)v=mul(v,a,P);
    return v;
}
ll gcd(ll a,ll b)
{
    if(a<0)a=-a;
    for(ll c;b;c=a,a=b,b=c%b);
    return a;
}
bool mr(ll n)
{
    ll z=n-1;
    int t=0;
    while(~z&1)z>>=1,++t;
    for(int i=0;i<15;++i)
    {
        ll a=rand()%(n-1)+1;
        ll x=pw(a,z,n);
        for(int j=0;j<t;++j)
        {
            ll y=mul(x,x,n);
            if(y==1&&x!=1&&x!=n-1)return 0;
            x=y;
        }
        if(x!=1)return 0;
    }
    return 1;
}
ll get(ll x,int c)
{
    int i=1,j=2;
    ll a=(rand()^ll(rand())<<31)%(x-1)+1,b=a;
    while(1)
    {
        a=mul(a,a,x);
        if((a+=c)>=x)a%=x;
        ll p=gcd(a-b,x);
        if(p!=1)return p;
        if((++i)==j)j<<=1,b=a;
    }
}
void calc(ll n)
{
    if(n==1)return;
    if(mr(n))
    {
        fs[fp++]=n;
        return;
    }
    for(int c=12347;;++c)
    {
        ll a=get(n,c);
        if(a!=n)
        {
            ll b=gcd(a,n/a);
            calc(a/b);
            calc(n/a/b);
            calc(b);
            return;
        }
    }
}
ll cal(ll*b,ll*a,ll M)
{
    fp=0;
    calc(M);
    std::sort(fs,fs+fp);
    fp=std::unique(fs,fs+fp)-fs;
    ll phi_M=M;
    for(int i=0;i<fp;++i)ts[i]=0,phi_M=phi_M/fs[i]*(fs[i]-1);
    ll B=1,A=1,x;
    for(int i=1;i<=m;++i)
    {
        x=b[i];
        if(fs[0]==2)for(;~x&1;x>>=1,++ts[0]);
        for(int j=(fs[0]==2);j<fp;++j)
        {
            for(ll p=fs[j],y=x/p;y*p==x;x=y,y=y/p,++ts[j]);
        }
        B=mul(B,x,M);
    }
    for(int i=1;i<=m;++i)
    {
        x=a[i];
        if(fs[0]==2)for(;~x&1;x>>=1,--ts[0]);
        for(int j=(fs[0]==2);j<fp;++j)
        {
            for(ll p=fs[j],y=x/p;y*p==x;x=y,y=y/p,--ts[j]);
        }
        A=mul(A,x,M);
    }
    B=mul(B,pw(A,phi_M-1,M),M);
    for(int i=0;i<fp;++i)
    {
        if(ts[i]<0)return -1;
        B=mul(B,pw(fs[i],ts[i],M),M);
    }
    return B;
}
int main()
{
    srand(200037);
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;++i)scanf("%lld",&b[i]);
    for(int t=1;t<=n;++t)
    	for(int i=1;i<=m;++i)
    		scanf("%lld",&a[t][i]);
    for(int i=0;i<k;++i)
    {
    	int x;
    	scanf("%d%lld",&x,&M);
        printf("%lld\n",cal(b,a[x],M));
    }
    return 0;
}
Problem4892

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
const int sed = 37;
const int N = 1e5+5;
ull Pow[N],h1[N],h2[N];
char s1[N],s2[N];
int l1,l2,T,c;
void check(int l1,int r1,int l2,int r2)
{
	while(c<=3&&l1<=r1)
	{
		if(s1[l1]!=s2[l2])l1++,l2++,c++;
		else if(s1[r1]!=s2[r2])r1--,r2--,c++;
		else break;
	}
	if(l1>r1||c>3)return ;
	if(h1[r1]-h2[r2]==(h1[l1-1]-h2[l2-1])*Pow[r1-l1+1])return ;
	int d = (r1-l1)>>1;
	check(l1,l1+d,l2,l2+d);
	check(l1+d+1,r1,l2+d+1,r2);
}
void work()
{
	l1=strlen(s1+1);
	l2=strlen(s2+1);
	for(int i = 1;i<= l1;i++)h1[i]=h1[i-1]*sed+s1[i];
	for(int i = 1;i<= l2;i++)h2[i]=h2[i-1]*sed+s2[i];
	int ans = 0;
	for(int i = 1;i<= l1-l2+1;i++)
	{
		c = 0;
		check(i,i+l2-1,1,l2);
		if(c<=3)ans++;
	}
	printf("%d\n",ans);
}
int main()
{
	Pow[0] = 1;
	for(int i = 1;i<N;i++)Pow[i] = Pow[i-1]*sed;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%s%s",s1+1,s2+1);
		work();
	}
	return 0;
}
Problem4893

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define mp(a,b) make_pair(a,b)
const int N = 1e5+5;
int a[N],b[3],c[3];
set<pair<int,pair<int,int> > >S;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		b[a[i]]++;
	}
	b[0]>>=1,b[1]>>=1,b[2]>>=1;
	for(int i = 1;i<= n;i++)
	{
		c[a[i]]++;
		if(b[0]==c[0]&&b[1]==c[1]&&b[2]==c[2])
			return printf("1\n"),0;
	}
	c[0] = c[1] = c[2] = 0;
	for(int i = 1;i<= n;i++)
	{
		c[a[i]]++;
		if(S.count(mp(c[0]-b[0],mp(c[1]-b[1],c[2]-b[2]))))
			return printf("2\n"),0;
		S.insert(mp(c[0],mp(c[1],c[2])));
	}
	printf("3\n");
	return 0;
}
Problem4896

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 6e6+5;
char s[100];
int ch[N][10],siz[N],cnt;
vector<int>num[N];
void Insert(int id)
{
	int now = 0,i = 1;
	while(s[i])
	{
		if(!ch[now][s[i]-'a'])ch[now][s[i]-'a'] = ++cnt;
		now = ch[now][s[i]-'a'];
		i++;
		siz[now]++;
		if(siz[now]>num[now].size())num[now].push_back(id);
	}
}
void Delete()
{
	int now = 0,i= 1;
	while(s[i])
	{
		now = ch[now][s[i]-'a'];
		siz[now]--;
		i++;
	}
}
int Find()
{
	int now = 0,i = 1;
	while(s[i])
	{
		now = ch[now][s[i]-'a'];
		i++;
	}
	return now;
}
int main()
{
	int n,k,a,b,c,lst=0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		if(k==3)
		{
			scanf("%s",s+1);
			scanf("%d%d%d",&a,&b,&c);
			a = ((ll)a*abs(lst)+b)%c;
			int pos = Find();
			if(num[pos].size()<=a)lst = -1;
			else lst = num[pos][a];
			printf("%d\n",lst);
		}else
		{
			scanf("%s",s+1);
			if(k==1)Insert(i);
			else Delete();
		}
	}
	return 0;
}
Problem4897

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int INF = 1e9;
int dp[N][N],dp1[N][N][N];
int mx[N][N],mn[N][N];
int n,a,b,w[N];
void DP(int l,int r)
{
	register int i,j,k,o;
	for(i = l;i<= r;i++)
		for(j = l;j<= r;j++)
			for(k = l;k<= r;k++)
				dp1[i][j][k] = INF;
	dp1[l][l][l] = 0;
	for(i = l;i<= r;i++)
	{
		if(i!=l)dp1[i][i][i] = min(dp1[i][i][i],dp[l][i-1]);
		for(j = l;j<= r;j++)
			for(k = l;k<= r;k++)
			{
				if(dp1[i][j][k]==INF)continue;
				dp1[i+1][w[j]>w[i+1]?j:i+1][w[k]<w[i+1]?k:i+1] = min(dp1[i+1][w[j]>w[i+1]?j:i+1][w[k]<w[i+1]?k:i+1] ,dp1[i][j][k]);
				for ( o = i + 1 ; o <= r ; o++ )
                	dp1[o][j][k] = min ( dp1[o][j][k] , dp1[i][j][k] + dp[i+1][o] );  
			}
	}
}
int main()
{
	scanf("%d%d%d",&n,&a,&b);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= n;i++)
	{
		mx[i][i] = mn[i][i] = w[i]; 
		for(int j = i+1;j<= n;j++)
			mx[i][j] = max(mx[i][j-1],w[j]),
			mn[i][j] = min(mn[i][j-1],w[j]);
	}
	for(int l = 1;l<= n;l++)
	{
		for(int i = 1;i<= n-l+1;i++)
		{
			int j = i+l-1;
			dp[i][j] = a+b*(mx[i][j]-mn[i][j])*(mx[i][j]-mn[i][j]);
			DP(i,j);
			for (int k = i ; k <= j ; k++ ) 
				for (int o = i ; o <= j ; o++ ) 
				{  
                	if ( w[k] < w[o] ) continue;  
                	dp[i][j] = min ( dp[i][j] , dp1[j][k][o] + a + b * (w[k]-w[o]) * (w[k]-w[o]) );  
            	}  
		}
	}
	printf ("%d\n",dp[1][n]);  
	return 0;
}
Problem4899

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 705;
const int P = 705;
const int M = 1505;
struct E
{int next,to;}e[M];
int head[M],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
double g[M],dis[N][N],f[N][P];
int d[M],n,m,p;
void dfs(int x)
{
	g[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		g[x]+=g[e[i].to]/d[x];
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int x,y;
		scanf("%d%d%d",&n,&m,&p);
		for(int i = 1;i<= m-n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);d[x]++;
		}
		for(int i = 1;i<= n;i++)dfs(i);
		for(int i = 1;i<= n;i++)
			for(int j = i+1;j<= n;j++)
				dis[i][j] = 
			(dis[i][j-1]+1.0/(d[j-1]+1)+1.0*d[j-1]/(d[j-1]+1)*g[j-1])*(d[j-1]+1);
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= p;j++)
				f[i][j]=1e18;
		f[1][1] = 0;
		int lim = (n+p-1)/p+1;
		for(int i = 1;i<= n;i++)
			for(int j = 1;j< p;j++)
				for(int k = i+1;k<= i+lim&&k<= n;k++)
					f[k][j+1] = min(f[k][j+1],f[i][j]+dis[i][k]);
		printf("%.4f\n",f[n][p]);tot=0;
		for(int i = 1;i<= m;i++)d[i]=0,head[i]=0,g[i]=0;
	}
	return 0;
}
Problem4906

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+20;
struct data
{
	ll f[4][4];
	data(){memset(f,0,sizeof(f));}
	data(ll a,ll b,ll c)
	{
		f[0][0]=f[3][3]=a;f[1][1]=b;f[2][2]=c;
		f[0][1]=max(a,b),f[1][2]=max(b,c),f[2][3]=max(c,a);
		f[0][2]=f[1][3]=f[0][3]=max(max(b,c),a);
	}
	friend data operator +(const data &a,const data &b)
	{
		data c;
		for(int l = 1;l<= 4;l++)
			for(int i = 0;i+l-1<4;i++)
			{
				int j = i+l-1;
				for(int k = i;k<= j;k++)
					c.f[i][j]=max(c.f[i][j],a.f[i][k]+b.f[k][j]);
			}
		return c;
	}
}s[N];
int fa[N],size[N],ch[N][2];
int rt,mark,A[N],B[N],C[N],L[N],n,cnt,q[N],top,tms;
ll Size[N],tot;
void Push_up(int x)
{
	s[x] = data(1ll*A[x]*L[x],1ll*B[x]*L[x],1ll*C[x]*L[x]);
	if(ch[x][0])s[x] = s[ch[x][0]]+s[x];
	if(ch[x][1])s[x] = s[x]+s[ch[x][1]];
	Size[x] = Size[ch[x][0]]+Size[ch[x][1]]+L[x];
	size[x] = size[ch[x][0]]+size[ch[x][1]]+1;
}
int Find(int x,ll pos)
{
	ll Sz1 = Size[ch[x][0]],Sz2 = Sz1+L[x];
	if((Sz1<pos||(!ch[x][0]&&!pos))&&Sz2>=pos)return x;
	else if(Sz1>=pos)return Find(ch[x][0],pos);
	else {tot+=Sz2;return Find(ch[x][1],pos-Sz2);}
}
void Insert(int &x,int ai,int bi,int ci,ll pos,int len,int last=0)
{
	if(!x)
	{
		x = ++cnt;
		s[x] = data(1ll*ai*len,1ll*bi*len,1ll*ci*len);
		L[x]=Size[x]=len;
		A[x]=ai,B[x]=bi,C[x]=ci;fa[x]=last;size[x]=1;
		return ;
	}
	ll Sz = Size[ch[x][0]]+L[x];
	if(pos<Sz)Insert(ch[x][0],ai,bi,ci,pos,len,x);
	else Insert(ch[x][1],ai,bi,ci,pos-Sz,len,x);
	Push_up(x);
	if(max(size[ch[x][0]],size[ch[x][1]])>0.7*size[x])mark=x;
}
void Update(int x,int k,ll pos,int Len)
{
	if(x==k)
	{
		L[x] = Len;
		Push_up(x);
		return ;
	}
	if(Size[ch[x][0]]>=pos)Update(ch[x][0],k,pos,Len);
	else Update(ch[x][1],k,pos-L[x]-Size[ch[x][0]],Len);
	Push_up(x);
}
void Dfs(int x)
{
	if(ch[x][0])Dfs(ch[x][0]);
	q[++top]=x;
	if(ch[x][1])Dfs(ch[x][1]);
}
void Build(int &x,int l,int r,int last)
{
	if(l>r)
	{
		x=0;
		return ;
	}
	int mid = (l+r)>>1;
	x = q[mid];fa[x] = last;
	Build(ch[x][0],l,mid-1,x);
	Build(ch[x][1],mid+1,r,x);
	Push_up(x);
}
void rebuild(int x)
{
    mark=top=0;
    Dfs(x);
    int y=fa[x];
    if(!y) Build(rt,1,top,0);
    else Build(ch[y][ch[y][1]==x],1,top,y);
}

int main()
{
	scanf("%d",&n);
	Insert(rt,0,0,0,0,0);
	ll pre = 0;
	for(int i = 1;i<= n;i++)
	{
		ll pi;int ai,bi,ci,x;
		scanf("%lld%d%d%d%d",&pi,&ai,&bi,&ci,&x);
		tot = tms = 0;
		int k = Find(rt,pi);
		if(tot+Size[ch[k][0]]+L[k]!=pi)
		{
			ll Left=tot+Size[ch[k][0]]+L[k]-pi;
            tms=0;
            Update(rt,k,pi,L[k]-Left);    
            Insert(rt,ai,bi,ci,pi,x);
            if(mark) rebuild(mark);
            Insert(rt,A[k],B[k],C[k],pi+x,Left);
		}else Insert(rt,ai,bi,ci,pi,x);
		printf("%lld\n",s[rt].f[0][3]-pre);
		pre = s[rt].f[0][3];
		if(mark)rebuild(mark);
	}
	return 0;
}
Problem4908

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=200005;
int n;
int a[N],b[N];
int Q,x[N],y[N];
int sx[N],icnt;
inline int Bin(int x)
{
	return lower_bound(sx+1,sx+icnt+1,x)-sx;
}
const int BB=505;
int B,lp[BB],rp[BB];
int pos[N],cnt;
int v[N],c[N];
int idx[N];
int pnt[BB],lc[BB][BB]; 
ll svc[BB][BB],sv[BB][BB];
int p[BB],q[BB];
ll ans[BB];
#define Size(x) (rp[x]-lp[x]+1)
inline ll Sum(int x)
{
	return sv[x][p[x]]*q[x]-svc[x][p[x]]+(svc[x][pnt[x]]-svc[x][p[x]])-(sv[x][pnt[x]]-sv[x][p[x]])*q[x];
}
ll Ans=0;
int _c[512];
int tmp[N],t2[N];
void rsort(int l,int r)
{
	for (int i=l;i<=r;i++) c[i]+=50000;

	for (int i=0;i<512;i++) _c[i]=0;
	for (int i=l;i<=r;i++) _c[c[i]&511]++;
	for (int i=1;i<512;i++) _c[i]+=_c[i-1];
	for (int i=r;i>=l;i--) tmp[_c[c[i]&511]--]=i;

	for (int i=0;i<512;i++) _c[i]=0;
	for (int i=1;i<=r-l+1;i++) _c[c[tmp[i]]>>9]++;
	for (int i=1;i<512;i++) _c[i]+=_c[i-1];
	for (int i=r-l+1;i;i--) t2[_c[c[tmp[i]]>>9]--]=tmp[i];

	for (int i=l;i<=r;i++) idx[i]=t2[i-l+1],c[i]-=50000;
}
void Build(int x)
{
	rsort(lp[x],rp[x]);
	Ans-=ans[x]; pnt[x]=0;
	for (int j=lp[x];j<=rp[x];j++)
		if (j==lp[x] || c[idx[j]]!=c[idx[j-1]])
		{
			pnt[x]++,lc[x][pnt[x]]=c[idx[j]];
			sv[x][pnt[x]]=sv[x][pnt[x]-1]+v[idx[j]];
			svc[x][pnt[x]]=svc[x][pnt[x]-1]+(ll)v[idx[j]]*c[idx[j]];
		}
		else
		{
			sv[x][pnt[x]]+=v[idx[j]];
			svc[x][pnt[x]]+=(ll)v[idx[j]]*c[idx[j]];
		}
	q[x]=0;
	p[x]=upper_bound(lc[x]+1,lc[x]+pnt[x]+1,0)-lc[x]-1;
	Ans+=(ans[x]=Sum(x));
}

void Reb(int x,int l,int r,int t)
{
	if (l>r) return;
	for (int i=lp[x];i<=rp[x];i++) c[i]-=q[x];
	for (int i=l;i<=r;i++) c[i]+=t;
	Build(x);
}
void Add(int l,int r,int t)
{
	int lb=pos[l],rb=pos[r];
	if (lb==rb)
	{
		Reb(lb,l,r,t);
		return;
	}
	Reb(lb,l,rp[lb],t);
	Reb(rb,lp[rb],r,t);
	for (int i=lb+1;i<rb;i++)
	{
		Ans-=ans[i];
		q[i]-=t;
		while (p[i]+1<=pnt[i] && lc[i][p[i]+1]<=q[i]) p[i]++;
		while (p[i]>0 && lc[i][p[i]]>q[i]) p[i]--; 
		Ans+=(ans[i]=Sum(i));
	}
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
		scanf("%d",&a[i]),sx[++icnt]=a[i];
	for (int i=1;i<=n;i++) 
		scanf("%d",&b[i]),sx[++icnt]=b[i];
	scanf("%d",&Q); 
	for (int i=1;i<=Q;i++) 
		scanf("%d%d",&x[i],&y[i]),sx[++icnt]=y[i];
	sort(sx+1,sx+icnt+1); 
	icnt=unique(sx+1,sx+icnt+1)-sx-1;
	for (int i=1;i<icnt;i++) 
		v[i]=sx[i+1]-sx[i];
	B=sqrt(icnt);
	for (int i=1;i<=icnt;i++) 
		pos[i]=(i-1)/B+1; cnt=pos[icnt];
	for (int i=1;i<=cnt;i++) 
		lp[i]=(i-1)*B+1,rp[i]=i*B; rp[cnt]=icnt;
	for (int i=1;i<=n;i++) 
		a[i]=Bin(a[i]),b[i]=Bin(b[i]),c[a[i]]++,c[b[i]]--;
	for (int i=1;i<=icnt;i++) 
		c[i]+=c[i-1];
	for (int i=1;i<=cnt;i++)
		Build(i);
	printf("%lld\n",Ans);
	for (int i=1;i<=Q;i++)
	{
		y[i]=Bin(y[i]);
		if (y[i]<a[x[i]])
			Add(y[i],a[x[i]]-1,1),a[x[i]]=y[i];
		else if (a[x[i]]<y[i])
			Add(a[x[i]],y[i]-1,-1),a[x[i]]=y[i];
		printf("%lld\n",Ans);
	}
	return 0;
}
Problem4911

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int mxK = 130;
const int mod = 10007;
const int inv2 = (mod+1)>>1;

inline void FWT(int *a,int n,int type)
{
	for(int i = 1;i<n;i<<=1)
		for(int j = 0;j<n;j+=(i<<1))
			for(int k = 0;k<i;k++)
			{
				int x = a[j+k],y = a[j+k+i];
				a[j+k] = (x+y)%mod;
				a[j+k+i] = (x-y+mod)%mod;
				if(!type)(a[j+k]*=inv2)%=mod,(a[j+k+i]*=inv2)%=mod;
			}
}
int quick_pow(int x,int y)
{int res=1;while(y){if(y&1)res=res*x%mod;x=x*x%mod;y>>=1;}return res;}
int K,kx[mxK][mxK];
int inv[mod];
void pre(int n)
{
	for(int i = 0;i<n;i++)
		kx[i][i]=1,FWT(kx[i],n,1);
	for(int i = 1;i<mod;i++)inv[i]=quick_pow(i,mod-2);
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int fa[N],size[N],top[N];
int dep[N],son[N];
vector<int>P[N];
void dfs1(int x)
{
	size[x] = 1;dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	P[tp].push_back(x);
	top[x] = tp;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct data
{
	int x,y;
	data(int num=0)
	{
		if(num)x=num,y=0;
		else x=y=1;
	}
	int val(){return y?0:x;}
	data & operator *=(int a)
	{
		if(!a)y++;
		else x = x*a%mod;
		return *this;
	} 
	data & operator /=(int a)
	{
		if(!a)y--;
		else x = x*inv[a]%mod;
		return *this;
	}
};
data Base[N][mxK];
int cnt,pos[N],rt[N];
int ps[N<<2],ls[N<<2],rs[N<<2];
int val[N<<2][mxK],lv[N<<2][mxK],rv[N<<2][mxK],sum[N<<2][mxK];
inline void update(int p)
{
	int l = ls[p],r = rs[p];
	for(int i = 0;i<K;i++)
	{
		val[p][i] = (val[l][i]+val[r][i]+rv[l][i]*lv[r][i])%mod;
		lv[p][i] = (lv[l][i]+lv[r][i]*sum[l][i])%mod;
		rv[p][i] = (rv[r][i]+rv[l][i]*sum[r][i])%mod;
		sum[p][i] = sum[l][i]*sum[r][i]%mod;
	}
}
inline void Build(int &p,int l,int r,int t)
{
	p = ++cnt;
	if(l==r)
	{
		for(int i = 0;i<K;i++)
			val[p][i]=lv[p][i]=rv[p][i]=sum[p][i]=Base[P[t][l-1]][i].val();
		pos[P[t][l-1]] = p;
		return ;
	}
	int mid = (l+r)>>1;
	Build(ls[p],l,mid,t);
	Build(rs[p],mid+1,r,t);
	update(p);ps[ls[p]]=ps[rs[p]]=p;
}
int ans[mxK],tmp[mxK];
void Update(int u)
{
	int t = top[u];
	if (fa[t])
		for (int j=0;j<K;j++)
			Base[fa[t]][j]/=(lv[rt[t]][j]+kx[0][j])%mod;
	for(int j = 0;j<K;j++)
		ans[j] = (ans[j]+mod-val[rt[t]][j])%mod;

	int x = pos[u];
	for(int i = 0;i<K;i++)
		val[x][i]=lv[x][i]=rv[x][i]=sum[x][i]=Base[u][i].val();
	x = ps[x];
	while(x)
		update(x),x=ps[x];

	if (fa[t])
		for (int j=0;j<K;j++)
			Base[fa[t]][j]*=(lv[rt[t]][j]+kx[0][j])%mod;
	for(int j = 0;j<K;j++)
		ans[j] = (ans[j]+val[rt[t]][j])%mod;
}
int n,Val[N],last[N],pnt;
inline bool cmp(int a,int b)
{
	return dep[a]>dep[b];
}
int main()
{
	//freopen("4911.in","r",stdin);
	//freopen("4911.out","w",stdout);
	int x,y,Q;
	char order[10];
	scanf("%d%d",&n,&K);
	int t = 1;
	while(t<K)t<<=1;K = t;
	pre(K);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);Val[i] = x;
		for(int j = 0;j<K;j++)Base[i][j]=data(kx[x][j]);
	}
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		if(top[i]==i)
			last[++pnt]=i;
	sort(last+1,last+pnt+1,cmp);
	for(int i = 1;i<= pnt;i++)
	{
		int x = last[i];
		Build(rt[x],1,P[x].size(),x);
		if(fa[x])
		{
			int f = fa[x];
			for(int j = 0;j<K;j++)
				Base[f][j]*=(lv[rt[x]][j]+kx[0][j])%mod;
		}
		for(int j = 0;j<K;j++)
			ans[j] = (ans[j]+val[rt[x]][j])%mod;
	}
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%s",order);
		if(order[0]=='C')
		{
			scanf("%d%d",&x,&y);
			for(int j=0;j<K;j++)
				Base[x][j]/=kx[Val[x]][j];
			Val[x]=y;
			for (int j=0;j<K;j++)
				Base[x][j]*=kx[Val[x]][j];
			while (x!=0)
				Update(x),x=fa[top[x]];
		}
		else
		{
			scanf("%d",&x);
			for(int j = 0;j<K;j++)tmp[j]=ans[j];
			FWT(tmp,K,0);
			printf("%d\n",tmp[x]);
		}
	}
	return 0;
}
Problem4915

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int main()
{
	ll l,r;
	scanf("%lld%lld",&l,&r);
	printf("4\n%lld\n",max(r/11-l+1,0ll)+max(r/29-l+1,0ll));
	return 0;
}
Problem4919

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <set>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
typedef long long ll;
int v[N],p[N],idx[N];
multiset<int>heap[N];
multiset<int>::iterator it;
struct E
{int next,to;}e[N];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
int merge(int x,int y)
{
	if(heap[x].size()<heap[y].size())swap(x,y);
	for(it = heap[y].begin();it!=heap[y].end();it++)
		heap[x].insert(*it);
	heap[y].clear();
	return x;
}	
void debug(int x)
{
	printf("Case #%d\n",x);
	for(it = heap[x].begin();it!=heap[x].end();it++)
		printf("%d ",*it);
	printf("\n");
}
int cnt;
void dfs(int x)
{
	bool lef = true;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to),lef = false;
	if(lef)idx[x] = ++cnt;
	else idx[x] = idx[e[head[x]].to];
	for(int i = e[head[x]].next;i;i=e[i].next)
		idx[x] = merge(idx[x],idx[e[i].to]);
	it = heap[idx[x]].lower_bound(v[x]);
	if(it==heap[idx[x]].end())heap[idx[x]].insert(v[x]);
	else heap[idx[x]].erase(it),heap[idx[x]].insert(v[x]);
	//debug(idx[x]);
}
int main()
{
	int n,rot;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&v[i],&p[i]);
		add(p[i],i);if(p[i]==0)rot=i;
	}
	dfs(rot);
	printf("%d\n",heap[idx[rot]].size());
	return 0;
}
Problem4921

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 998244353;
int f[N],ls[N],a[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		f[i] = gcd(f[i-1],a[i]);
	}
	for(int i = 2;i<= n;i++)
		if(f[i]==f[i-1])ls[i] = ls[i-1];
		else ls[i] = i-1;
	ls[0] = -1;
	int ans = 0,now = 0;
	for(int i = n;i>= 2;i--)
	{
		now = gcd(now,a[i]);
		for(int j = i-2;j>= 0;j=ls[j])
			ans = (ans+(ll)(j-ls[j])*gcd(now,f[j])%mod)%mod;
		if(i==n)ans = (ans-now+mod)%mod;
	}
	for(int i = 2;i<= n-1;i++)
		(ans+=f[i])%=mod;
	printf("%d\n",ans);
	return 0;
}
﻿









HOMEBack

	

			 
		 
		 
		 
		
			
		
	
한국어中文فارسیEnglishไทย
版权所有 ©2008-2012 大视野在线测评 |  | 
湘ICP备13009380号站长统计站长统计站长统计
Based on opensource project .
hustoj
F.A.Qs	Home	Discuss	ProblemSet	Status	Ranklist	Contest	入门OJ	ModifyUser   Infinity37	Logout	捐赠本站
Notice:请某些用户不要在讨论区发无意义的讨论帖。
Problem1008

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
long long mod = 100003;
long long quick(long long x,long long y)
{
    if(y==0)return 1;
    long long tmp = quick(x,y/2);
    if(y%2==1)return tmp*tmp%mod*x%mod;
    else return tmp*tmp%mod;
}
int main()
{
    long long n,m;
    scanf("%lld%lld",&m,&n);
    long long ans = quick(m,n);
    long long not_ = m*quick(m-1,n-1)%mod;
    printf("%lld\n",((ans-not_)%mod+mod)%mod);
    return 0;
}
Problem1010

#include <stdio.h>
#include <algorithm>
#include <stdlib.h>
#include <math.h>
using namespace std;
#define MaxN 50000+5
int n,l,L,R = 1;
long long sum[MaxN],F[MaxN],Y[MaxN];
int q[MaxN];
long long Z(int x){return F[x]+Y[x]*Y[x];}
long long G(int x){return Y[x]-l-1;}
double calc(int j1,int j2){return 1.0*(Z(j1)-Z(j2))/(Y[j1]-Y[j2]);}
int main()
{
    int x;
    scanf("%d%d",&n,&l);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&x);
        sum[i] = sum[i-1]+x;
        Y[i] = sum[i]+i;
    }
    for(int i = 1;i<= n;i++)
    {
        long long Gi = G(i);
        while(L+1<R&&calc(q[L],q[L+1])<=Gi*2)
            L++;
        F[i] = F[q[L]]+(Gi-Y[q[L]])*(Gi-Y[q[L]]);
        while(L+1<R&&calc(q[R-1],i)<=calc(q[R-2],q[R-1]))
            R--;
        q[R++] = i;
    }
    printf("%lld",F[n]);
    return 0;
}
Problem1014

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int sed = 37;
#define is(x) (son[fa[x]][1]==x)
typedef unsigned long long LL;
char start[N];
int digit[N];
LL power[N]={1};
struct node
{
	int root,n;
	LL hash[N];
	int val[N],fa[N],son[N][2],size[N];
	inline void update(int p)
	{
		size[p]=size[son[p][0]]+size[son[p][1]]+1;
		hash[p]=hash[son[p][0]]*power[size[son[p][1]]+1]+val[p]*power[size[son[p][1]]]+hash[son[p][1]];
	}
	inline void Build(int l,int r,int mid)
	{
		if(l<mid)		{
			int lmid=l+mid-1>>1;
			Build(l,mid-1,lmid);
			fa[lmid]=mid;
			son[mid][0]=lmid;
		}
		if(mid<r)
		{
			int rmid=mid+1+r>>1;
			Build(mid+1,r,rmid);
			fa[rmid]=mid;
			son[mid][1]=rmid;
		}
		val[mid]=digit[mid],update(mid);
	}
	inline void link(int x,int y,int d){son[y][d]=x;fa[x]=y;}
	inline void Rotate(int x)
	{
		int y=fa[x],z=fa[y],id=is(x),t=son[x][!id];
		if(t)fa[t]=y;son[y][id]=t;
		link(x,z,is(y));
		link(y,x,!id);
		update(y);
	}
	inline void Splay(int x,int k)
	{
		int y,z;
		while(fa[x]!=k)
		{
			y=fa[x];
			z=fa[y];
			if(z==k){Rotate(x);break;}
			if(is(x)==is(y))Rotate(y),Rotate(x);
			else Rotate(x),Rotate(x);
		}
		update(x);
		if(!k)root=x;
	}
	inline int Select(int rank,int k)
	{
		if(size[root]<rank)return -1;
		int x=root;
		while(size[son[x][0]]+1!=rank)
		{
			if(size[son[x][0]]+1>rank)x=son[x][0];
			else rank=rank-size[son[x][0]]-1,x=son[x][1];
		}
		Splay(x,k);
		return x;
	}
	inline void newnode(int &x,int y,int w)
	{
		x=++n;
		son[x][0]=son[x][1]=0;
		val[x]=w;
		fa[x]=y;
		size[x]=1;
	}
	inline void Insert(int x,int p)
	{
		int l=Select(x,0),r=Select(x+1,l);
		newnode(son[r][0],r,p);
		Splay(n,0);
	}
	inline void Change(int x,int p){x=Select(x,0),val[x]=p,Splay(x,0);}
	inline bool check(int a,int b,int len)
	{
		int x;
		Select(a-1,0);x=Select(a+len,root);
		if(x==-1)return 0;
		LL hash1=hash[son[x][0]];
		Select(b-1,0);x=Select(b+len,root);
		if(x==-1)return 0;
		LL hash2=hash[son[x][0]];
		return hash1==hash2;
	}
}tree;
char s[N];
int main()
{
	scanf("%s",s+1);
	int m,n=strlen(s+1);
	for(int i = 1;i<N;i++)power[i] = power[i-1]*sed;
	tree.n=n+2;
	for(int i = 2;i<= n+1;i++)
		digit[i] = s[i-1]-'a'+1;
	tree.root=(1+tree.n)>>1;
	tree.Build(1,tree.n,1+tree.n>>1);
	scanf("%d",&m);
	char a[10];
	int l,r;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",a);
		if(a[0]=='Q')
		{
			scanf("%d%d",&l,&r);
			int L = 0,R = tree.n,ans = 0;
			while(L<=R)
			{
				int mid = (L+R)>>1;
				if(tree.check(l+1,r+1,mid))L=mid+1,ans=mid;
				else R=mid-1;
			}
			printf("%d\n",ans);
		}else if(a[0]=='R')
		{
			scanf("%d%s",&l,a);
			tree.Change(l+1,a[0]-'a'+1);
		}else
		{
			scanf("%d%s",&l,a);
			tree.Insert(l+1,a[0]-'a'+1);
		}
	}
	return 0;
}
Problem1015

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 400005;
struct E
{int next,to;}e[N];
int head[N],tot,T;
int fa[N];
bool used[N];
void add_e(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;

	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int getfa(int x)
{
	if(fa[x]==x||!fa[x])
		return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void add_p(int x)
{
	int root = getfa(x);
	for(int i = head[x];i;i = e[i].next)
	{
		int q= getfa(e[i].to);
		if(used[e[i].to]&&q!=root){fa[q] = root;T--;}
	}
	return ;
}
int ask[N],ans[N],b[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		x++;y++;
		add_e(x,y);
	}
	int k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&ask[i]);
		ask[i]++;
		b[ask[i]] = 1;
	}
	for(int i = 1;i<= n;i++)
		if(b[i]==0)
		{
			T++;
			add_p(i);
			used[i] = true;
		}
	ans[k] = T;
	for(int i = k;i>=1;i--)
	{
		T++;
		add_p(ask[i]);
		used[ask[i]] =true;
		ans[i-1] = T;
	}
	for(int i = 0;i<= k;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem1016

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 1005;
const int mod = 31011;
struct E
{
	int u,v,l;
	bool operator<(const E &s)const
	{
		return l<s.l;
	}
}e[M];
int n,m;
int fa[N],U[N],vis[N];
int G[N][N],C[N][N];
vector<int>V[N];
int getfa(int x,int fa[])
{
	return fa[x]==x?x:fa[x]=getfa(fa[x],fa);
}
int gauss(int a[][N],int n)
{
	for(int i= 0;i<n;i++)
		for(int j = 0;j<n;j++)
			a[i][j]%=mod;
	int ans = 1;
	for(int i = 1;i<n;i++)
	{
		for(int j = i+1;j<n;j++)
			while(a[j][i])
			{
				int t = a[i][i]/a[j][i];
				for(int k = i;k<n;k++)
					a[i][k]=(a[i][k]-a[j][k]*t)%mod;
				for(int k = i;k<n;k++)
					swap(a[i][k],a[j][k]);
				ans = -ans;
			}
		if(a[i][i]==0)return 0;
		ans = ans*a[i][i]%mod;
	}
	if(ans<0)ans=-ans;
	return (ans+mod)%mod;
}
void solve()
{
	sort(e,e+m);
	for(int i = 1;i<= n;i++)fa[i]=i,vis[i]=0;
	int edge = -1,ans=1;
	for(int k = 0;k<= m;k++)
	{
		if(edge!=e[k].l||k==m)
		{
			for(int i = 1;i<= n;i++)
				if(vis[i])
				{
					int u = getfa(i,U);
					V[u].push_back(i);
					vis[i]=0;
				}
			for(int i = 1;i<= n;i++)
				if(V[i].size()>1)
				{
					for(int a = 1;a<=n;a++)
						for(int b = 1;b<=n;b++)
							C[a][b]=0;
					int len = V[i].size();
					for(int a = 0;a<len;a++)
						for(int b = a+1;b<len;b++)
						{
							int a1 = V[i][a],b1 = V[i][b];
							C[a][b] = (C[b][a]-=G[a1][b1]);
							C[a][a]+=G[a1][b1];
							C[b][b]+=G[a1][b1];
						}
					int tmp = gauss(C,len);
					ans = ans*tmp%mod;
					for(int a = 0;a<len;a++)
						fa[V[i][a]]=i;
				}
			for(int i = 1;i<= n;i++)
			{
				U[i] = fa[i] = getfa(i,fa);
				V[i].clear();
			}
			if(k==m)break;
			edge=e[k].l;
		}
		int a = e[k].u,b=e[k].v;
		int a1 = getfa(a,fa),b1=getfa(b,fa);
		if(a1==b1)continue;
		vis[a1]=vis[b1]=1;
		U[getfa(a1,U)]=getfa(b1,U);
		G[a1][b1]++;
		G[b1][a1]++;
	}
	bool flag = false;
	for(int i = 2;i<= n&&!flag;i++)
		if(U[i]!=U[i-1])
			flag = true;
	if(m==0)
		flag=1;
	printf("%d\n",flag?0:ans%mod);
}
int main()
{
	while(scanf("%d%d",&n,&m)!=EOF)
	{
		memset(G,0,sizeof(G));
		for(int i = 1;i<= n;i++)
			V[i].clear();
		for(int i = 0;i<m;i++)
			scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].l);
		solve();
	}
	return 0;
}
Problem1017

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2005;
int kind[N],num[N],cost[N],power[N],ind[N];
int f[N][M][N*2];
int g[N][M];
struct E
{
	int val,next,to;
}e[N<<1];
int head[N],tot,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	if(head[x]==0)
	{
		num[x] = min(num[x],m/cost[x]);
		for(int j = 0;j<=num[x];j++)
			for(int k = 0;k<= j;k++)
				f[x][j*cost[x]][k] = power[x]*(j-k);
		return ;
	}
	num[x] = 105;
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		num[x] = min(num[x],num[e[i].to]/e[i].val);
		cost[x] += cost[e[i].to]*e[i].val;
	}
	num[x] = min(num[x],m/cost[x]);
	int cnt = 0;
	memset(g,-0x3f,sizeof(g));
    g[0][0]=0;	
	for(int l = num[x];l>= 0;l--)
	{
		cnt=0;
		for(int i = head[x];i;i = e[i].next)
		{
			cnt++;
			for(int j = 0;j<= m;j++)
				for(int k = 0;k<=j;k++)
					if(l*e[i].val<=num[e[i].to])
						g[cnt][j] = max(g[cnt][j],g[cnt-1][j-k]+f[e[i].to][k][l*e[i].val]);
		}
		for(int k = 0;k<= l;k++)
			for(int j = 0;j<= m;j++)
				f[x][j][k] = max(f[x][j][k],g[cnt][j]+power[x]*(l-k));
	}	
}
int main()
{
	memset(f,-0x3f,sizeof(f));
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&power[i]);
		char ju[3];
		scanf("%s",ju);
		if(ju[0]=='B')
			scanf("%d%d",&cost[i],&num[i]);
		else
		{
			int num,x,y;
			scanf("%d",&num);
			for(int	j = 1;j<= num;j++)
			{
				scanf("%d%d",&x,&y);
				add(i,x,y);ind[x]++;
			}
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(!ind[i])
		{
			dfs(i);
			for(int j = 0;j<= m;j++)
				for(int k = 0;k<= num[i];k++)
					ans = max(ans,f[i][j][k]);
		}
	printf("%d\n",ans);
	return 0;
}
Problem1023

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 2e6+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N],fa[N],a[N],dep[N],pos[N],low[N],q[N],Dfn,ans;
void solve(int x,int y)
{
	int cnt = dep[y]-dep[x]+1,h = 1,t = 1,i;
	for(i = y;i!=x;i = fa[i])a[cnt--]=f[i];a[1] = f[x];
	cnt = dep[y]-dep[x]+1,q[1] = 1;
	for(i=1;i<=cnt;i++)a[i+cnt]=a[i];
	for(i=2;i<=cnt+(cnt>>1);i++)
	{
		if(i-q[h]>(cnt>>1))h++;
		ans = max(ans,a[i]+i+a[q[h]]-q[h]);
		while(h<=t&&a[i]-i>=a[q[t]]-q[t])
			t--;
		q[++t] = i;
	}
	for(int i = 2;i<= cnt;i++)
		f[x] = max(f[x],a[i]+min(i-1,cnt-i+1));
}
void dfs(int x)
{
	pos[x] = low[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)
	{
		if(e[i].to==fa[x])continue;
		if(!pos[e[i].to])
		{
			fa[e[i].to] = x;
			dep[e[i].to] = dep[x]+1;
			dfs(e[i].to);
		}
		low[x] = min(low[x],low[e[i].to]);
		if(low[e[i].to]>pos[x])
		{
			ans = max(ans,f[e[i].to]+f[x]+1);
			f[x] = max(f[x],f[e[i].to]+1);
		}
	}
	for(int i = head[x];i;i=e[i].next)
		if(fa[e[i].to]!=x&&pos[x]<pos[e[i].to])
			solve(x,e[i].to);
}
int main()
{
	int n,m,cnt;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int x,y;
		scanf("%d",&cnt);
		scanf("%d",&x);
		for(int j = 2;j<= cnt;j++)
		{
			scanf("%d",&y);
			add(x,y);
			x = y;
		}
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}
Problem1026

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long f[15][15];
long long get_ans(long long x)
{
	int num[15] = {},cnt = 0;
	long long ans = 0;
	while(x)
	{
		num[++cnt] = x%10;
		x/=10;
	}
	for(int i = 1;i<= num[cnt]-1;i++)
		ans+=f[cnt][i];
	for(int i = cnt-1;i>=1;i--)
		for(int j = 1;j<= 9;j++)
			ans+=f[i][j];
	for(int i = cnt-1;i>= 1;i--)
	{
		for(int j = 0;j<= num[i]-1;j++)
			if(abs(j-num[i+1])>=2)
				ans+=f[i][j];
		if(abs(num[i+1]-num[i])<2)break;
	}
	return ans;
}
int main()
{
	long long a,b;
	scanf("%lld%lld",&a,&b);
	for(int i = 0;i<= 9;i++)
		f[1][i] = 1;
	for(int i = 2;i<= 10;i++)
		for(int j = 0;j<= 9;j++)
			for(int k = 0;k<=9;k++)
				if(abs(j-k)>=2)
					f[i][j]+=f[i-1][k];
	printf("%lld",get_ans(b+1)-get_ans(a));
	return 0;
}
Problem1027

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const double eps = 1e-7;
const int N = 505;
const int INF = 0x3f3f3f3f;
struct Point
{
	double x,y;
	Point(){}
	Point(double x,double y):x(x),y(y){}
	Point operator+(const Point &a)const
	{
		return Point(x+a.x,y+a.y);
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	double operator*(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
	double operator^(const Point &a)const
	{
		return x*a.x+y*a.y;
	}
}mtr[N],req[N];
struct Line
{
	Point p,v;
	Line(){}
	Line(const Point &a,const Point &b):p(a),v(b){}
};
int map[N][N];
void display()
{
	for(int i = 1;i<= 10;i++)
	{
		for(int j = 1;j<= 10;j++)
			if(map[i][j]==INF)printf("0");
			else printf("1");
		printf("\n");
	}
}
int main()
{
	memset(map,0x3f,sizeof(map));
	int n,m;
	double c;
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= m;i++)
		scanf("%lf%lf%lf",&mtr[i].x,&mtr[i].y,&c);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf%lf",&req[i].x,&req[i].y,&c);
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<=m;j++)
		{
			bool flag=true;
			for(int k = 1;k<= n;k++)
			{
				double cro = (mtr[i]-req[k])*(mtr[j]-req[k]);
				if(cro>eps){flag = false;break;}
				if(fabs(cro)<eps&&((mtr[i]-req[k])^(mtr[j]-req[k]))>eps)
					{flag = false;break;}
			}
			if(flag)map[i][j] = 1;
		}
	for(int k = 1;k<= m;k++)
		for(int i = 1;i<= m;i++)
			for(int j = 1;j<= m;j++)
				map[i][j] = min(map[i][j],map[i][k]+map[k][j]);
	int ans = INF;
	for(int i = 1;i<= m;i++)
		ans = min(ans,map[i][i]);
	if(ans!=INF)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem1030

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'A')
const int P = 6005;
const int N = 65;
const int Len = 105;
const int mod = 10007;
char s[Len];
int f[Len][P];
struct AC_Machine
{
	int ch[P][26],cnt,fail[P],q[P],h,t;
	bool danger[P];
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)ch[0][i] = 1;
	}
	void insert()
	{
		int now = 1,i = 0;
		while(s[i])
		{
			if(!ch[now][s(i)])ch[now][s(i)] = ++cnt;
			now = ch[now][s(i)];
			i++;
		}
		danger[now] = true;
	}
	void build()
	{
		h = t,t = -1;
		q[++t] = 1,fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				if(danger[fail[to]])
					danger[to] = true;
				q[++t] = to;
			}
		}
	}
	void dp(int x)
	{
		for(int i = 1;i<= cnt;i++)
		{
			if(danger[i]||!f[x-1][i])continue;
			for(int j = 0;j<26;j++)
			{
				int k=i;
				while(!ch[k][j])k=fail[k];
				(f[x][ch[k][j]]+=f[x-1][i])%=mod;
			}
		}
	}
}AC;
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	return tmp*tmp%mod;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int ans = quick_pow(26,m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		AC.insert();
	}
	AC.build();
	f[0][1] = 1;
	for(int i = 1;i<=m;i++)AC.dp(i);
	for(int i = 1;i<= AC.cnt;i++)
		if(!AC.danger[i])
			ans = (ans-f[m][i]+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
Problem1031

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Len = 200000+5;
char s[Len];
int c[Len],sa[Len],val[Len],q[Len],newval[Len];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)c[i]=0;
	for(i = 0;i<len;i++)c[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)c[i]+=c[i-1];
	for(i = len-1;i>=0;i--)sa[--c[val[i]]] = i;
	for(int d=1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;
		for(i = 0;i<lim;i++)c[i] = 0;
		for(i = 0;i<len;i++)c[val[q[i]]]++;
		for(i = 1;i<lim;i++)c[i]+=c[i-1];
		for(i = len-1;i>= 0;i--)sa[--c[val[q[i]]]] = q[i];
		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i = j+1;k<=j;k++)newval[sa[k]] = lim;
		}
		for(int i = 0;i<len;i++)val[i] = newval[i];
		if(lim==len)break;
	}
}
int main()
{
	scanf("%s",s);
	int len = strlen(s);
	for(int i = 0;i<len;i++)
		s[i+len] = s[i];
	build_sa(2*len,256);
	for(int i = 0;i< 2*len;i++)
		if(sa[i]<len)
			printf("%c",s[sa[i]+len-1]);
	return 0;
}
Problem1036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 30005;
int W[N],n;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int maxn[N<<2],sum[N<<2];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int son[N],size[N],deep[N],top[N],fa[N],w[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] =tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i= e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void update(int p,int l,int r,int x,int c)
{
	if(l==r){sum[p] = maxn[p] = c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)
		update(p<<1,l,mid,x,c);
	else update((p<<1)+1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
	maxn[p] = max(maxn[p<<1],maxn[(p<<1)+1]);
}
int getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return maxn[p];
	int mid = (l+r)>>1;
	int ans = -0x3f3f3f3f;
	if(a<=mid)
		ans = max(ans,getmax(p<<1,l,mid,a,b));
	if(b>mid)
		ans = max(ans,getmax((p<<1)+1,mid+1,r,a,b));
	return ans;
}
int getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)
		ans += getsum(p<<1,l,mid,a,b);
	if(b>mid)
		ans += getsum((p<<1)+1,mid+1,r,a,b);
	return ans;
}
int get_ans(int x,int y,int opt)
{
	int ans;
	if(opt==1)ans = 0;
	else ans = -0x3f3f3f3f;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)ans+=getsum(1,1,n,w[top[x]],w[x]);
		else ans = max(ans,getmax(1,1,n,w[top[x]],w[x]));
		x= fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)ans+=getsum(1,1,n,w[y],w[x]);
	else ans = max(ans,getmax(1,1,n,w[y],w[x]));
	return ans;
}
int main()
{
	memset(maxn,-0x3f,sizeof(maxn));
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i< n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	for(int i = 1;i<= n;i++)
		scanf("%d",&W[i]);
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(1,1,n,w[i],W[i]);
	int q;
	scanf("%d",&q);
	char j[10];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",j,&x,&y);
		if(j[1]=='H')update(1,1,n,w[x],y);
		else if(j[1]=='S')printf("%d\n",get_ans(x,y,1));
		else printf("%d\n",get_ans(x,y,0));
	}
	return 0;
}
Problem1036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 30005;
const int N = 30005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,a[N],n;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],son[N],top[N],fa[N],dep[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to]=x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
int dfn[N],seq[N],Dfn;
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int sum[N<<2],mx[N<<2];
void Push_up(int p)
{
	sum[p] = sum[p<<1]+sum[p<<1|1];
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = mx[p] = a[seq[l]];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	Push_up(p);
}
void update(int p,int l,int r,int pos,int val)
{
	if(l==r)
	{
		mx[p] = val;
		sum[p] = val;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,val);
	else update(p<<1|1,mid+1,r,pos,val);
	Push_up(p);
}
int Getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getsum(p<<1,l,mid,a,b);
	if(b>mid)ans+=Getsum(p<<1|1,mid+1,r,a,b);
	return ans;
}
int Getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	int ans = -INF;
	if(a<=mid)ans = max(ans,Getmax(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,Getmax(p<<1|1,mid+1,r,a,b));
	return ans;
}
int getsum(int x,int y)
{
	int ans = 0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=Getsum(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	if(dep[y]>dep[x])swap(x,y);
	ans += Getsum(1,1,n,dfn[y],dfn[x]);
	return ans;
}
int getmax(int x,int y)
{
	int ans = -INF;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans = max(ans,Getmax(1,1,n,dfn[top[x]],dfn[x]));
		x = fa[top[x]];
	}
	if(dep[y]>dep[x])swap(x,y);
	ans = max(ans,Getmax(1,1,n,dfn[y],dfn[x]));
	return ans;
}
int main()
{
	int x,y,q;
	scanf("%d",&n);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	scanf("%d",&q);
	char opt[10];
	while(q--)
	{
		scanf("%s",opt);
		if(opt[0]=='C')
		{
			scanf("%d%d",&x,&y);
			update(1,1,n,dfn[x],y);
			a[x] = y;
		}
		else if(opt[1]=='M')
		{
			scanf("%d%d",&x,&y);
			printf("%d\n",getmax(x,y));
		}else
		{
			scanf("%d%d",&x,&y);
			printf("%d\n",getsum(x,y));
		}
	}
	return 0;
}
Problem1040

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N],a[N],st[N],top;
LL f[N],g[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	return fa[x] = getfa(fa[x]);
}
void dfs(int x,int fa,int ban)
{
	for(int i = head[x];i;i = e[i].next)
		if(fa!=e[i].to)
			dfs(e[i].to,x,ban);
	f[x]= a[x],g[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		if(e[i].to==ban)
			f[x]+=g[e[i].to],g[x]+=g[e[i].to];
		else 
		{
			f[x]+=g[e[i].to];
			g[x]+=max(g[e[i].to],f[e[i].to]);
		}
	}
}
int main()
{
	int n,x;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a[i],&x);
		int fx = getfa(x),fy = getfa(i);
		if(fx==fy){st[++top] = x,st[++top] = i;continue;}
		fa[fx]= fy;
		add(x,i),add(i,x);
	}
	LL t_ans = 0;
	LL ans = 0;
	for(int i = 1;i<= top;i=i+2)
	{
		ans = 0;
		dfs(st[i],0,st[i+1]);
		ans = max(ans,max(f[st[i]],g[st[i]]));
		dfs(st[i+1],0,st[i]);
		ans = max(ans,max(f[st[i+1]],g[st[i+1]]));
		t_ans+=ans;
	}
	printf("%lld\n",t_ans);
	return 0;
}
Problem1042

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c[5],n[5],s;
long long f[100005],w[5];
long long getans(int sta)
{
	int tmp = s;
	long long fh = 1;
	for(int i = 0;i<4;i++)
		if((sta&(1<<i))!=0)
			{tmp-=w[i+1];fh = -fh;}
	if(tmp>=0)return fh*f[tmp];
	else return 0;
}
int main()
{
	int tot;
	for(int i = 1;i<= 4;i++)
		scanf("%d",&c[i]);
	scanf("%d",&tot);
	while(tot--)
	{
		memset(f,0,sizeof(f));
		for(int i = 1;i<= 4;i++)
			scanf("%d",&n[i]);
		scanf("%d",&s);
		for(int i = 1;i<= 4;i++)
			w[i] = c[i]*(n[i]+1);
		f[0] = 1;
		for(int i = 1;i<= 4;i++)
			for(int j = 0;j<= s;j++)
				if(j-c[i]>=0)f[j] += f[j-c[i]];
		long long ans = f[s];
		for(int i = 1;i<1<<4;i++)
			ans+=getans(i);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem1044

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
int Max_lth,maxn = 0,suml = 0;
int lth[50005],sum[50005];
int f[2][50005],n,m;
int line[50005];
bool check(int x)
{
    int tmp=0,sum=0;
    for(int i=1;i<=n;i++)
    {
        sum+=lth[i];
        if(sum>x){tmp++;sum=lth[i];}
        if(tmp>m)return 0;
        if(lth[i]>x)return 0;
    }
    return 1;
}
void solve()
{
	int l = maxn,r = suml+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(mid))r = mid;
		else l = mid+1;
	}
	Max_lth = l;
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&lth[i]);
		sum[i] = sum[i-1]+lth[i];
		suml+=lth[i];
		maxn = max(maxn,lth[i]);
	}
	solve();
	int ans = 0;
	f[0][0] = 1;
	for(int i = 1;i<= m;i++)
	{
		int last = (i-1)&1,now = i&1;
		int l = 1,r = 1,tot = f[last][0];line[1] = 0;
		for(int j = 1;j<= n;j++)
		{
			while(l<=r&&sum[j]-sum[line[l]]>Max_lth)
				{tot = (tot-f[last][line[l++]]+mod)%mod;}
			f[now][j] = tot;
			line[++r] = j;
			tot = (f[last][j]+tot)%mod;
		}
		for(int j = n-1;j>=1;j--)
		{
			if(suml-sum[j]>Max_lth)break;
			ans = (ans+f[now][j])%mod;
		}
		memset(f[last],0,sizeof(f[last]));
	}
	printf("%d %d",Max_lth,ans);
	return 0;
}
Problem1046

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int M = 1005;
int f[N],c[N],pos[N],a[N],cnt,n,m;
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r =mid;
	}
	return l;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = max(c[i],y);
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans = max(ans,c[i]);
	return ans;
}
int t_ans = 0;
void pre()
{
	for(int i = n;i>=1;i--)
	{
		int tmp = find(a[i]);
		tmp = n-tmp+1;
		f[i] = getans(tmp-1)+1;
		update(tmp,f[i]);
		t_ans = max(t_ans,f[i]);
	}
}
void solve(int x)
{
	int last = 0;
	for(int i = 1;i<= n;i++)
		if(f[i]>=x&&a[i]>last)
		{
			printf("%d",a[i]);
			if(x!=1)printf(" ");
			last = a[i];
			x--;
			if(!x)break;
		}
	printf("\n");
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		pos[i] = a[i];
	}
	sort(pos+1,pos+n+1);
	for(int i = 1;i<= n;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt] = pos[i];
	pre();
	scanf("%d",&m);
	int x;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&x);
		if(x>t_ans)printf("Impossible\n");
		else solve(x);
	}
	return 0;
}
Problem1047

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int f[13][1005][1005];
int g[13][1005][1005];
int log[1005];
int a,b,n,ans = 0x3f3f3f3f;
void init()
{
	for(int j = 1;j<= 12;j++)
		for(int l = 1;l+(1<<j)-1<= a;l++)
			for(int i = 1;i+(1<<j)-1<= b;i++)
			{
				f[j][l][i] = max(max(f[j-1][l][i],f[j-1][l][i+(1<<(j-1))]),
								 max(f[j-1][l+(1<<(j-1))][i],f[j-1][l+(1<<(j-1))][i+(1<<(j-1))]));
				g[j][l][i] = min(min(g[j-1][l][i],g[j-1][l][i+(1<<(j-1))]),
								 min(g[j-1][l+(1<<(j-1))][i],g[j-1][l+(1<<(j-1))][i+(1<<(j-1))]));
			}
	log[1] = 0;
	for(int i = 2;i<= 1000;i++)
		log[i] = log[i>>1]+1;
}
void ask(int x,int y)
{
	int xl = x,xr = x+n-1;
	int yl = y,yr = y+n-1;
	int m_ans = 0,n_ans = 0x3f3f3f3f;
	m_ans = max(f[log[n]][xl][yl],f[log[n]][xl][yr-(1<<log[n])+1]);
	m_ans = max(m_ans,max(f[log[n]][xr-(1<<log[n])+1][yl],f[log[n]][xr-(1<<log[n])+1][yr-(1<<log[n])+1]));
	n_ans = min(g[log[n]][xl][yl],g[log[n]][xl][yr-(1<<log[n])+1]);
	n_ans = min(n_ans,min(g[log[n]][xr-(1<<log[n])+1][yl],g[log[n]][xr-(1<<log[n])+1][yr-(1<<log[n])+1]));
	ans = min(ans,m_ans-n_ans);
}
int main()
{
	memset(g,0x3f,sizeof(g));
	int x;
	scanf("%d%d%d",&a,&b,&n);
	for(int i = 1;i<= a;i++)
	{
		for(int j = 1;j<= b;j++)
		{
			scanf("%d",&x);
			f[0][i][j] = g[0][i][j] = x;
		}
	}
	init();
	for(int i = 1;i<= a-n+1;i++)
		for(int j = 1;j<= b-n+1;j++)
			ask(i,j);
	printf("%d",ans);
	return 0;
}
Problem1051

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct M
{
    int next,to;
}edge[50005];
int head[50005],tot,cnt,zn,z[50005],dep[50005],low[50005],n,m;
bool in[10005],v[10005];
void add(int x,int y)
{
    edge[++tot].to = y;
    edge[tot].next = head[x];
    head[x] = tot;
}
int pn,t[10005],ln[10005],lnn[10005];
void tarjan(int x)
{
    v[x] = true;
    z[++zn] = x;
    in[x] = true;
    dep[x] = low[x] = ++cnt;
    for(int i = head[x];i;i=edge[i].next)
    {
        if(!v[edge[i].to])
            {tarjan(edge[i].to);low[x] = min(low[x],low[edge[i].to]);}
        else if(in[edge[i].to])
            {low[x] = min(low[x],dep[edge[i].to]);}
    }
    if(dep[x]==low[x])
    {
        pn++;
        int tmp;
        do
        {
            tmp = z[zn--];
            in[tmp] = false;
            ln[tmp] = pn;
            lnn[pn]++;
        }while(tmp!=x);
    }
    return ;
}
void dfs(int x)
{
    if(x==n+1)return ;
    for(int i = head[x];i;i = edge[i].next)
    {
        if(ln[x]!=ln[edge[i].to])
            t[ln[x]]++;
    }
    dfs(x+1);
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 1;i<= m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        add(x,y);
    }
    for(int i = 1;i<= n;i++)
        if(!v[i])tarjan(i);
    dfs(1);
    int ans = 0,tmp = 0;
    for(int i = 1;i<= pn;i++)
    {
        if(t[i]==0)
        {
            if(ans)
            {
                ans = 0;
                break;
            }
            ans=lnn[i]; 
        }
    }
    printf("%d",ans);
    return 0;
}
Problem1055

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c2n[256],num[5];
bool change[5][5][5];
int Able[205][205][5];
char str[205];
bool able(int l,int r,int target)
{
	if(r-l+1==2&&change[c2n[str[l]]][c2n[str[r]]][target])return true;
	else if(r-l+1==1&&target==c2n[str[l]])return true;
	if(Able[l][r][target]!=-1)return Able[l][r][target];
	for(int i = l;i<= r-1;i++)
		for(int k = 1;k<= 4;k++)
			for(int t = 1;t<= 4;t++)
				if(change[k][t][target]&&able(l,i,k)&&able(i+1,r,t))
					return Able[l][r][target] = 1;
	return Able[l][r][target] = 0;
}
int main()
{
	c2n['W'] = 1;
	c2n['I'] = 2;
	c2n['N'] = 3;
	c2n['G'] = 4;
	char s[3];
	for(int i = 1;i<= 4;i++)scanf("%d",&num[i]);
	for(int i = 1;i<= 4;i++)
		for(int j = 1;j<= num[i];j++)
		{
			scanf("%s",s);
			change[c2n[s[0]]][c2n[s[1]]][i] = true;
		}
	scanf("%s",str+1);
	int n = strlen(str+1);
	memset(Able,-1,sizeof(Able));
	bool flag = false;
	if(able(1,n,1))printf("W"),flag = true;
	if(able(1,n,2))printf("I"),flag = true;
	if(able(1,n,3))printf("N"),flag = true;
	if(able(1,n,4))printf("G"),flag = true;
	if(!flag)printf("The name is wrong!\n");
	return 0;
}
Problem1060

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N =  500005;
LL f[N];
struct E{int to,next,val;}e[N*2];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
LL ans = 0;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			f[x] = max(f[e[i].to]+e[i].val,f[x]);
		}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			ans += f[x]-f[e[i].to]-e[i].val;
		}	
}
int main()
{
	int n,x,y,z,s;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);add(y,x,z);
	}
	dfs(s,0);
	printf("%lld",ans);
	return 0;
}
Problem1067

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
#define mod 10007
int n,m;
struct Y
{
    int year,rr;
}num[50005];
struct E
{
    int next,val,no;
}edge[50005];
int logx[50005];
int f[50005][20];
void init()
{
    for(int j = 1;j<= 19;j++)
    {
        for(int i = 1;i<=n;i++)
        {   
            if((i+(1<<(j-1)))<=n)
            {
                if(num[f[i][j-1]].rr>=num[f[i+(1<<(j-1))][j-1]].rr)
                    f[i][j] = f[i][j-1];
                else 
                    f[i][j] = f[i+(1<<(j-1))][j-1];
            }
            else f[i][j]= f[i][j-1];
        }
    }
    logx[1] = 0;
    for(int i = 2;i<= 50000;i++)
        logx[i] = logx[i>>1]+1;
    return ;
}
int check(int l,int r)
{
    if(l>r)return -1;
    int len = r-l+1;
    if(num[f[l][logx[len]]].rr>num[f[r-(1<<logx[len])+1][logx[len]]].rr)
        return f[l][logx[len]];
    else return f[r-(1<<logx[len])+1][logx[len]];
}
void ch(int st,int en)
{
    int l = 0,r = n+1,mid,poss,pose;
    while(l<r)
    {
        mid = (l+r)>>1;
        if(num[mid].year>=st)r = mid;
        else l = mid+1;
    }
    poss = l;
    l = 0;r = n+1;
    while(l<r)
    {
        mid = (l+r)>>1;
        if(num[mid].year>=en)r = mid;
        else l = mid+1;
    }
    pose = l;
    if(num[pose].year>en)
        pose--;
    //printf("%d %d\n",poss,pose);
    //printf("%d %d\n",num[poss].year,num[pose].year);
    if(num[pose].year!=en&&num[poss].year!=st)
    {
        printf("maybe\n");
        return ;
    }
    else if(num[pose].year==en&&num[poss].year!=st)
    {
        if(num[check(poss,pose)].year!=num[pose].year)
            printf("false\n");
        else printf("maybe\n");
    }
    else if(num[pose].year!=en&&num[poss].year==st)
    {
        if(num[check(poss+1,pose)].rr>=num[poss].rr)
            printf("false\n");
        else printf("maybe\n");
    }
    else
    {
        if(num[pose].rr>num[poss].rr)printf("false\n");
        else if(num[check(poss+1,pose)].year!=en)printf("false\n");
        else if(pose-poss!=en-st)printf("maybe\n");
        else printf("true\n");
    }
    return ;
}
int main()
{
    num[0].year = -0x3f3f3f3f;
    //freopen("rains.in","r",stdin);
    //freopen("rains.out","w",stdout);
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d%d",&num[i].year,&num[i].rr);
        f[i][0] = i;
    }
    /*for(int j = 1;j<= n;j++)
    {
        for(int i = head[hash(num[j].year)];i;i = edge[i].next)
            printf("%d ",edge[i].val);
        printf("\n");
    }*/
    init();
    scanf("%d",&m);
    for(int i = 1;i<= m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(x>y){printf("false\n");continue;}
        //int fx = find(x),fy = find(y);
        //printf("fx = %d fy = %d\n",fx,fy);
        //if(num[fy].rr>num[fx].rr){printf("false\n");continue;}
        //if(fx==-1||fy==-1||fy-fx!=y-x){printf("maybe\n");continue;}
        ch(x,y);
    }
    return 0;
}
Problem1070

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 605;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,f,c,from;}e[M];
int head[N],tot=1,st,end;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;e[tot].c=c;head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;e[tot].c=-c;head[y]=tot;
	e[tot-1].from=x;e[tot].from=y;
}
int dis[N],from[N];
bool v[N];
queue<int>Q;
bool spfa()
{
	for(int i = st;i<= end;i++)dis[i]=INF;
	Q.push(st);dis[st]=0;v[st]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[x]+e[i].c<dis[e[i].to])
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to]=i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[end]!=INF;
}
double ans;
void mcf()
{
	int x = INF;
	for(int i = from[end];i;i=from[e[i].from])
		x = min(e[i].f,x);
	for(int i = from[end];i;i=from[e[i].from])
		{e[i].f-=x;e[i^1].f+=x;ans+=e[i].c*x;}
}
int ti[61][10];
int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&ti[i][j]);
	st=0,end=n*(m+1)+1;
	for(int i = 1;i<= n*m;i++)
		add(st,i,1,0);
	for(int i = n*m+1;i<=n*m+n;i++)
		add(i,end,1,0);
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
				add((i-1)*n+j,n*m+k,1,ti[k][i]*j);
	while(spfa())mcf();
	printf("%.2f",ans/(double)n);
	return 0;
}
Problem1072

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1005;
const int M = 1<<10;
int f[M][N],buk[10],cnt[M];
LL p10[11];
char str[20];
void init()
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	return ;
}
int main()
{
	int d,n,t;
	init();
	p10[0] = 1;
	for(int i = 1;i<= 10;i++)
		p10[i] = p10[i-1]*10;
	scanf("%d",&t);
	while(t--)
	{
		memset(buk,0,sizeof(buk));
		memset(f,0,sizeof(f));
		scanf("%s%d",str+1,&d);
		n = strlen(str+1);
		for(int i = 1;i<= n;i++)
			buk[str[i]-'0']++;
		f[0][0] = 1;
		for(int i = 1;i<= n;i++)
		{
			for(int sta = 0;sta<1<<n;sta++)
			{
				if(cnt[sta]!=i-1)continue;
				for(int s = 1;s<= n;s++)
				{
					if((1<<(s-1))&sta)continue;
					for(int yu = 0;yu<d;yu++)
					{
						LL nm = ((str[s]-'0')*p10[i-1]+yu)%d;
						f[sta|(1<<(s-1))][nm]+=f[sta][yu];
					}
				}
			}
		}
		int ans = f[(1<<n)-1][0];
		for(int i = 0;i<=9;i++)
			for(int j = buk[i];j>=1;j--)
				ans/=j;
		printf("%d\n",ans);
	}
	return 0;
}
Problem1076

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int P = 1<<15;
const int N = 105;
double f[N][P];
int pre[N],val[N];
int main()
{
	int k,n,t,x;
	scanf("%d%d",&k,&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&val[i],&t);
		while(t)
		{
			pre[i]|=1<<(t-1);
			scanf("%d",&t);
		}
	}
	double p = 1.0/(double)n;
	for(int i = k;i>= 1;i--)
		for(int j = 0;j<1<<n;j++)
		{
			//double ans = 0;
			for(int k = 1;k<= n;k++)
				if((j&pre[k])==pre[k])
					f[i][j]+=max(f[i+1][j],f[i+1][j|(1<<(k-1))]+val[k]);
				else f[i][j]+=f[i+1][j];
			f[i][j]*=p;
		}
	printf("%.6f\n",f[1][0]);
	return 0;
}
Problem1079

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
typedef long long LL;
int f[6][16][16][16][16][16];
bool used[6][16][16][16][16][16];
int cnt[6];
int dp(int last,int a,int b,int c,int d,int e)
{
	if(!a&&!b&&!c&&!d&&!e)return 1;
	if(a<0||b<0||c<0||d<0||e<0)return 0;
	if(used[last][a][b][c][d][e])return f[last][a][b][c][d][e];
	LL ans = 0;
	ans+=(LL)(a+(last==2?-1:0))*dp(1,a-1,b,c,d,e)%mod;
	ans+=(LL)(b+(last==3?-1:0))*dp(2,a+1,b-1,c,d,e)%mod;
	ans+=(LL)(c+(last==4?-1:0))*dp(3,a,b+1,c-1,d,e)%mod;
	ans+=(LL)(d+(last==5?-1:0))*dp(4,a,b,c+1,d-1,e)%mod;
	ans+=(LL)e*dp(5,a,b,c,d+1,e-1)%mod;
	ans = ans%mod;
	used[last][a][b][c][d][e] = true;
	f[last][a][b][c][d][e] = ans;
	return ans;
}
int main()
{
	int k,x;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&x);
		cnt[x]++;
	}
	printf("%d\n",dp(0,cnt[1],cnt[2],cnt[3],cnt[4],cnt[5]));
	return 0;
}
Problem1082

#include<cstdio>
#include<cmath>
#include<ctime>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<set>
#define ll long long
#define inf 1000000000
using namespace std;
int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
bool flag;
int n,m,mid;
int a[55],b[1005],bl[1005];
ll sa;
int sb[1005];
void dfs(int ak,int bk,int w)
{
	if(bk==0)flag=1;
	while(ak<=n&&a[ak]<b[1]){w+=a[ak];ak++;}
	if(flag||ak>n)return;
	if(w+sb[mid]>sa)return;
	int t=ak,t1=ak,t2=bk,t3=w;
	if(b[bk]==b[bk+1]&&bk!=mid)t=bl[bk+1];
	for(int i=t;i<=n;i++)
		if(a[i]>=b[bk])
		{
			bl[bk]=i;a[i]-=b[bk];
			bk--;
			dfs(ak,bk,w);
			ak=t1;bk=t2;w=t3;a[i]+=b[t2];
		}
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	m=read();
	for(int i=1;i<=m;i++)b[i]=read();
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	while(b[m]>a[n])m--;
	int tot=0;
	for(int i=1;i<=n;i++)	
		if(a[i]>b[1])a[++tot]=a[i];
	n=tot;
	for(int i=1;i<=n;i++)sa+=a[i];
	for(int i=1;i<=m;i++)sb[i]=sb[i-1]+b[i];
	int l=1,r=m,ans=0;
	while(l<=r)
	{
		mid=(l+r)>>1;
		flag=0;dfs(1,mid,0);
		if(flag)ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1087

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long ans[10][82]=
{
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,9,16,8,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,16,78,140,79,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,25,228,964,1987,1974,978,242,27,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,36,520,3920,16834,42368,62266,51504,21792,3600,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,49,1020,11860,85275,397014,1220298,2484382,3324193,2882737,1601292,569818,129657,18389,1520,64,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,64,1806,29708,317471,2326320,12033330,44601420,119138166,229095676,314949564,305560392,204883338,91802548,25952226,4142000,281571,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,81,2968,65240,962089,10087628,77784658,450193818,1979541332,6655170642,17143061738,33787564116,50734210126,57647295377,49138545860,31122500764,14518795348,4959383037,1237072414,224463798,29275410,2673322,163088,6150,125,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	printf("%lld\n",ans[n][k]);
	return 0;
}
Problem1090

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
int dp[105][105];
char str[105];
int calc(int x)
{
	int cnt = 0;
	while(x)
	{
		x/=10;
		cnt++;
	}
	return cnt;
}
int Dp(int l,int r)
{
	if(r==l)return 1;
	if(dp[l][r]!=INF)return dp[l][r];
	for(int k = l;k< r;k++)
		dp[l][r] = min(dp[l][r],min(r-l+1,Dp(l,k)+Dp(k+1,r)));
	for(int k = 1;l+k<=r;k++)
	{
		bool flag = true;
		if((r-l+1)%k==0)
		{
			for(int t = 1;t<(r-l+1)/k;t++)
			{
				for(int p = 0;p<k;p++)
					if(str[l+p]!=str[l+t*k+p])
						{flag = false;break;}
				if(!flag)break;
			}
		}else continue;
		if(flag)dp[l][r] = min(dp[l][r],Dp(l,l+k-1)+2+calc((r-l+1)/k));
	}
	return dp[l][r];
}
int main()
{
	scanf("%s",str+1);
	int n = strlen(str+1);
	memset(dp,0x3f,sizeof(dp));
	printf("%d\n",Dp(1,n));
	return 0;
}
Problem1096

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
int x[N],p[N],c[N],q[N],l,r;
LL sum[N],os[N],f[N];
double calc(int j,int k)
{
	return (double)(f[k]-f[j]+sum[k]-sum[j])/(double)(os[k]-os[j]);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&x[i],&p[i],&c[i]);
	for(int i = 1;i<=n;i++)
		os[i] = os[i-1]+p[i];
	for(int i = 1;i<=n;i++)
		sum[i] = sum[i-1]+(LL)x[i]*p[i];
	for(int i = 1;i<= n;i++)
	{
		while(l<r&&calc(q[l],q[l+1])<x[i])l++;
		if(l<=r)f[i] = f[q[l]]+sum[q[l]]-sum[i]+(os[i]-os[q[l]])*x[i]+c[i];
		while(l<r&&calc(q[r-1],q[r])>calc(q[r],i))r--;
		q[++r] = i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem1097

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 200005;
const int N = 20005;
const int S = 1<<20;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M<<1];
struct H
{int pos,val;}heap[N<<2];
int head[N],tot,cnt,n,m,k;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	e[tot].val = f;
	head[y] = tot;
}
int f[25][N],v[N];
bool cmp(H a,H b){return a.val>b.val;}
void dijk(int st)
{
	memset(f[st],0x3f,sizeof(f[st]));
	memset(v,0,sizeof(v));
	f[st][st] = 0;
	heap[1].val = 0,heap[1].pos = st;
	cnt++;
	while(cnt)
	{
		int x = heap[1].pos;
		pop_heap(heap+1,heap+cnt+1,cmp);
		cnt--;
		if(v[x])continue;
		v[x] = true;
		for(int i = head[x];i;i = e[i].next)
		{
			int to = e[i].to;
			if(f[st][x]+e[i].val<f[st][to])
			{
				f[st][to] = f[st][x]+e[i].val;
				cnt++;
				heap[cnt].pos = to;heap[cnt].val = f[st][to];
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
	}
	return ;
}
int pre[25],ban[25],num[S],dp[25][S];
void init()
{
	for(int i = 0;i<S;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			num[i]++;
		}
	}
	memset(dp,-1,sizeof(dp));
	for(int i = 1;i<= k+1;i++)
		dijk(i);
	return ;
}
int dfs(int x,int y)
{
    if(dp[x][y]>=0)return dp[x][y];
    if(y==(1<<k)-1)return f[x][n];
    dp[x][y]=INF;
    for(int i= 2;i<= k+1;i++)
    	if((y&pre[i])==pre[i])
    		dp[x][y]=min(dp[x][y],f[x][i]+dfs(i,y|(1<<(i-2))));
    return dp[x][y];  
}
int main()
{
	int x,y,c,ord;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c);
	}
	init();
	scanf("%d",&ord);
	for(int i = 1;i<= ord;i++)
	{
		scanf("%d%d",&x,&y);
		ban[x]|=(1<<(y-2));
		pre[y]|=(1<<(x-2));
	}
	printf("%d\n",dfs(1,0));
	return 0;
}
Problem1103

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500000+5;
int c[N],cnt;
int in_w[N],out_w[N];
struct E{int next,to;}e[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa)
{
	in_w[x] = ++cnt;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	out_w[x] = ++cnt;
}
void update(int x,int dec)
{
	for(int i = x;i<=N;i +=(i&(-i)))
		c[i]+=dec;
	return ;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i -= (i&(-i)))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,m,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	dfs(1,0);
	for(int i = 1;i<= n;i++)
		{update(in_w[i],1);update(out_w[i],-1);}
	scanf("%d",&m);
	char ju[5];
	for(int i = 1;i<= n+m-1;i++)
	{
		scanf("%s",ju);
		if(ju[0]=='A')
		{
			scanf("%d%d",&x,&y);
			update(in_w[y],-1);update(out_w[y],1);
		}else
		{
			scanf("%d",&x);
			printf("%d\n",getans(in_w[x])-1);
		}
	}
	return 0;
}
Problem1106

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int c[N],mark[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= 2*n;i++)
	{
		scanf("%d",&x);
		if(mark[x])
		{
			ans += getans(i-1)-getans(mark[x]);
			update(mark[x],-1);
		}else
		{
			mark[x] = i;
			update(i,1);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1110

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int a[N],w[N],cnt[N],stack[N],top;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&a[i]);
	sort(a+1,a+m+1);
	int top = 0;
	for(int i = 1;i<= m;i++)
		if(i==1||a[i]!=a[i-1])
			stack[++top] = a[i];
	for(int i = 1;i<= n;i++)
		for(int j = top;j;j--)
			cnt[j]+=w[i]/stack[j],w[i]%=stack[j];
	int i,j,k;
	int ans = 0;
	for(i=1,j=1;i<=top;i++)
	{
		for(;j<=m&&a[j]==stack[i];j++)
		{
			if(cnt[i])
			{
				ans++,cnt[i]--;
				continue;
			}
			for(k=i+1;k<= top;k++)
				if(cnt[k])
					break;
			if(k==top+1)
			{
				printf("%d\n",ans);
				return 0;
			}
			for(;k>i;k--)  
                cnt[k]--,cnt[k-1]+=stack[k]/stack[k-1];  
            ++ans;--cnt[i];  
		}	
	}
	printf("%d\n",ans);
	return 0;
}
Problem1122

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
typedef long long LL;
int sum[N<<1],mn[N],Q[N<<1],l,r;
char opt[N];
LL Abs(LL x){return x>0?x:-x;}
int main()
{
	int n,p,q,x,y;
	scanf("%d%d%d%d%d",&n,&p,&q,&x,&y);
	scanf("%s",opt+1);
	for(int i = n*2;i>n;i--)
		sum[i] = sum[i+1]+(opt[i-n]=='+'?1:-1);
	for(int i = n;i>=1;i--)
		sum[i] = sum[i+1]+(opt[i]=='+'?1:-1);
	r = -1;
	for(int i = 2*n;i>=1;i--)
	{
		while(l<=r&&sum[i]>sum[Q[r]])r--;
		Q[++r] = i;
		while(l<=r&&Q[l]-i>=n)l++;
		if(i<=n)mn[i] = sum[i]-sum[Q[l]];
	}
	LL get = sum[n+1];
	LL cng = (q-p-get)/2;
	LL ans = 1e18;
	for(int i = 0;i<n;i++)
	{
		LL cost = Abs(cng)*x+(LL)y*i;
		if(i==0)
		{
			mn[1]+=p+max(cng,0ll)*2;
			if(mn[1]<0)cost += (LL)x*2*((1-mn[1])/2);
		}else
		{
			mn[n-i+1]+=p+max(cng,0ll)*2;
			if(mn[n-i+1]<0)cost += (LL)x*2*((1-mn[n-i+1])/2);
		}
		ans = min(ans,cost);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem1123

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 1000005;
typedef long long LL;
struct E
{int next,to;}e[M];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int dfn[N],low[N],top,cnt,size[N],n,m;
bool v[N];
LL ans[N];
void tarjan(int x,int l)
{
	v[x] = true;
	dfn[x] = low[x] = ++cnt;
	int tmp = 0;
	size[x] = 1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(!v[e[i].to])
		{
			tarjan(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			size[x]+=size[e[i].to];
			if(low[e[i].to]>=dfn[x])
			{
				ans[x]+=(LL)tmp*size[e[i].to];
				tmp+=size[e[i].to];
			}
		}else low[x] = min(low[x],dfn[e[i].to]);
	}
	ans[x]+=(LL)tmp*(n-tmp-1);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	tarjan(1,0);
	for(int i = 1;i<= n;i++)
		printf("%lld\n",(ans[i]+n-1)<<1);
	return 0;
}
Problem1124

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int degree[N],aim[N];
int ans1,ans2,n;
namespace Ans1
{
	int degree[N];
	bool vis[N],dead[N];
	void Solve()
	{
		static int q[N];
		int hd = 1,tl = 0;
		memcpy(degree,::degree,sizeof(degree));
		for(int i = 1;i<= n;i++)if(!degree[i])q[++tl]=i;
		while(hd<=tl)
		{
			int x = q[hd++];
			vis[x] = true;
			if(!dead[aim[x]])
			{
				dead[aim[x]] = vis[aim[x]] = true;ans1++;
				if(!--degree[aim[aim[x]]])
					q[++tl] = aim[aim[x]];
			}
		}
		for(int i =1;i<= n;i++)
			if(!vis[i])
			{
				int cnt = 0,x = i;
				while(!vis[x])
				{
					vis[x] = true;
					cnt++;
					x = aim[x];
				}
				ans1+=(cnt+1)>>1;
			}
	}
}
namespace Ans2
{
	struct E
	{int next,to;}e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	bool vis[N];
	int stack[N],top;
	void bfs(int x)
	{
		static int q[N];
		int hd = 1,tl = 0;
		q[++tl] = x;vis[x] = true;
		while(hd<=tl)
		{
			int cur = q[hd++];
			stack[++top] = cur;
			for(int i = head[cur];i;i=e[i].next)
				if(!vis[e[i].to])
					vis[e[i].to]=true,q[++tl] = e[i].to;
		}
	}
	void Solve()
	{
		for(int i = 1;i<= n;i++)
			add(i,aim[i]);
		for(int i = 1;i<= n;i++)
			if(!vis[i])
			{
				top = 0;
				bfs(i);
				if(top==1)ans2++;
				else
				{
					int cnt = 0,size = top;
					while(top)
						cnt+=degree[stack[top--]]==0;
					ans2+=size-max(1,cnt);
				}
			}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&aim[i]);
		degree[aim[i]]++;
	}
	Ans1::Solve();
	Ans2::Solve();
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem1132

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3005;
struct Point
{
	int x,y;
	double sl;
	Point(){}
	Point(int x,int y):x(x),y(y)
	{
		sl = x?(double)y/x:1e10;
	}
	bool operator<(const Point &a)const
	{
		if(x==a.x)
			return y<a.y;
		return x<a.x;
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
}a[N],poi[N];
bool cmp(const Point &a,const Point &b)
{
	return a.sl<b.sl;
}
int main()
{
	int n,tot;
	ll ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+n+1);
	for(int i = 1;i<= n;i++)
	{
		tot = 0;
		ll sumx = 0,sumy = 0;
		for(int j = i+1;j<= n;j++)
			poi[++tot]=a[j]-a[i];
		sort(poi+1,poi+tot+1,cmp);
		for(int j = 1;j<= tot;j++)
		{
			ans+=sumx*poi[j].y-sumy*poi[j].x;
			sumx+=poi[j].x;
			sumy+=poi[j].y;
		}
	}
	printf("%lld.%d",ans>>1,(ans&1)?5:0);
	return 0;
}
Problem1133

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 605;
const int K = 65;
int f[K][N];
int sum[N][N],pre[N][K];
int s(int x1,int y1,int x2,int y2)
{
	return sum[x2][y2]-sum[x1][y2]-sum[x2][y1]+sum[x1][y1];
}
int main()
{
	int n,K;
	scanf("%d%d",&n,&K);
	for(int i = 1;i<n;i++)
		for(int j = 1;i+j<= n;j++)
			scanf("%d",&sum[i][j+i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			sum[i][j] += sum[i][j-1];
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			sum[i][j]+=sum[i-1][j];
	memset(f,0xef,sizeof(f));
	f[0][0] = 0;
	for(int i = 1;i< n;i++)
		for(int j = 1;j<= K;j++)
			for(int k = 0;k<i;k++)
			{
				//f[i][j][k] = max(f[i][j][k],f[i-1][j][k]);
				int tmp = f[j-1][k]+s(k,i,i,n);
				if(tmp>f[j][i])
				{
					pre[i][j] = k;
					f[j][i] = tmp;
				}
			}
	int ans = 0xefefefef;
	int tmp = 0;
	for(int k = 0;k<= n;k++)
	{
		if(f[K][k]>ans)
			ans = f[K][k],tmp = k;
	}
	int stack[605],top=0;
	while(top<K)
	{
		stack[++top] = tmp;
		tmp = pre[tmp][K-top+1];
	}
	//printf("%d\n",ans);
	for(int i = top;i> 1;i--)
		printf("%d ",stack[i]);
	printf("%d\n",stack[1]);
	return 0;
}
Problem1143

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int M = 1e4+5;
const int INF = 0x3f3f3f3f;
int a[105][105],lk[105],n,m,u,v;
bool map[105][105],vis[105];
bool find(int x)
{
	for(int i = 1;i<= n;i++)
		if(a[x][i]&&!vis[i])
		{
			vis[i] = true;
			if(find(lk[i])||!lk[i])
			{
				lk[i] = x;
				return true;
			}
		}
	return false;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&u,&v);
		map[u][v] = true;
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				map[i][j]|=(map[i][k]&map[k][j]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(i!=j&&map[i][j])
				a[i][j] = true;
	int ans = n;
	for(int i = 1;i<= n;i++)
	{
		memset(vis,0,sizeof(vis));
		ans-=find(i);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1145

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int mod = 16777216;
typedef long long ll;
ll c[N],l[N],r[N];
int a[N],n;
ll getans(int x)
{
	ll ans =0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void update(int x,ll y)
{
	for(int i = x;i<=n;i+=i&(-i))
		(c[i]+=y+mod)%=mod;
}
int cnt1()
{
	memset(c,0,sizeof(c));
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = (ans+(l[i]*(i-2)-getans(a[i])-l[i]*(l[i]-1)/2)*((ll)n-i-r[i])%mod+mod)%mod;
		update(a[i],i-1);
	}
	return (int)ans;
}
int cnt2()
{
	memset(c,0,sizeof(c));
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = (ans+((ll)n-i-r[i])*getans(a[i])%mod+mod)%mod;
		update(a[i],l[i]);
	}
	return (int)ans;
}
int cnt3()
{
	memset(c,0,sizeof(c));
	ll ans =0;
	for(int i = n;i;i--)
	{
		ans = (ans+((ll)n-i-r[i])*(getans(a[i])-r[i]*(r[i]-1)/2)%mod+mod)%mod;
		update(a[i],a[i]-1);
	}
	return (int)ans;
}
int cnt4()
{
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans = (ans+(n-i-r[i])*(n-i-r[i]-1)*(n-i-r[i]-2)/6)%mod;
	return (int)ans;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<= n;i++)
	{
		l[i]=getans(a[i]);
		r[i]=a[i]-1-l[i];
		update(a[i],1);
	}
	ll ans = ((cnt1()+cnt2()+cnt3()-cnt4())%mod+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem1146

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
const int INF = 1e8+1;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,q;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],son[N],w[N],top[N],fa[N],cnt,id[N],d[N],dpt[N];
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x] = 1;
	dpt[x] = dpt[f]+1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==f)continue;
		dfs1(e[i].to,x);
		size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	id[cnt] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_rank(root[p],y);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,y);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,y);
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void build()
{
	for(int i = 1;i<=cnt;i++)
		build(1,1,cnt,i,d[id[i]]);
}
void get_rank(int x,int y,int k)
{
	while(top[x]!=top[y])
	{
		if(dpt[top[x]]<dpt[top[y]])swap(x,y);
		get_rank(1,1,n,w[top[x]],w[x],k);
		x = fa[top[x]];
	}
	if(dpt[x]<dpt[y])swap(x,y);
	get_rank(1,1,n,w[y],w[x],k);
}
void get_number(int x,int y,int k)
{
	int l = -INF,r = 1,ans;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		tmp = 1;
		get_rank(x,y,mid);
		if(tmp<=k){l = mid+1;ans= mid;}
		else r = mid-1;
	}
	if(ans!=1)printf("%d\n",-ans);
	else printf("invalid request!\n");
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){scanf("%d",&d[i]);d[i] = -d[i];}
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1,0);
	dfs2(1,1);
	build();
	int k,a,b;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&k,&a,&b);
		if(k==0)
		{
			change(1,1,n,w[a],d[a],-b);
			d[a] = -b;
		}else
			get_number(a,b,k);
	}
	return 0;
}
Problem1149

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int l[N],r[N],maxx,minx,n,ans;
void dfs(int x,int dep)
{
	if(x==-1){maxx = max(maxx,dep),minx = min(minx,dep);return ;}
	dfs(l[x],dep+1);
	dfs(r[x],dep+1);
}
int solve(int x,int dep)
{
	int a,b;
	if(x==-1)
	{
		if(dep==minx)return 1;
		else return 2;
	}
	a = solve(l[x],dep+1);
	b = solve(r[x],dep+1);
	if((a==1&&b==2)||(a==1&&b==3)||(a==3&&b==2))ans++;
	if(a==3&&b==3){printf("-1\n");exit(0);}
	return a|b;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&l[i],&r[i]);
	maxx = 0,minx = N*10;
	dfs(1,0);
	if(maxx-minx>=2)printf("-1\n");
	else if(maxx==minx)printf("0\n");
	else
	{
		solve(1,0);
		printf("%d\n",ans);
	}
	return 0;
}
Problem1150

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int INF = 0x3f3f3f3f;
struct Heap
{int no,val;}heap[N];
bool cmp(const Heap &a,const Heap &b)
{
	return a.val>b.val;
}
int len[N],pre[N],L[N],R[N];
int main()
{
	int n,k,y;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&y);
		len[i] = y-pre[i-1];
		pre[i] = y;
		L[i] = i-1,R[i]=i+1;
	}
	int cnt = 0;
	for(int i = 2;i<= n;i++)
	{
		heap[++cnt] = (Heap){i,len[i]};
		push_heap(heap+1,heap+cnt+1,cmp);
	}
	L[2] = 0,R[n]=0;
	int ans = 0;
	for(int i =1;i<= k;i++)
	{
		while(heap[1].val!=len[heap[1].no])
			pop_heap(heap+1,heap+cnt+1,cmp),cnt--;
		int x = heap[1].no;
		int l = L[x],r = R[x];
		pop_heap(heap+1,heap+cnt+1,cmp),cnt--;
		ans+=len[x];
		L[R[x] = R[r]]=x;
		R[L[x] = L[l]]=x;
		len[x] = (l&&r)?min(INF,len[l]+len[r]-len[x]):INF;
		len[l] = len[r] = INF;
		heap[++cnt] = (Heap){x,len[x]};
		push_heap(heap+1,heap+cnt+1,cmp);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1151

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<5;
const int N = 1e4+5;
int f[N][S],g[N][S],n,C;
bool ok[N*5][S];
struct P
{
	int pos;
	int f,l;
	int fear,love;
}c[N*5];
int mod(int x)
{
	return (x%n+n)%n;
}
int main()
{
	int x;
	scanf("%d%d",&n,&C);
	for(int i = 1;i<= C;i++)
	{
		scanf("%d%d%d",&c[i].pos,&c[i].f,&c[i].l);
		for(int j = 1;j<=c[i].f;j++)
		{
			scanf("%d",&x);
			c[i].fear|=(1<<mod(x-c[i].pos));
		}
		for(int j = 1;j<=c[i].l;j++)
		{
			scanf("%d",&x);
			c[i].love|=(1<<mod(x-c[i].pos));
		}
		for(int j = 0;j<S;j++)
			if((j&c[i].fear)||((31^j)&c[i].love))
				ok[i][j] = true,g[c[i].pos][j]++;
	}
	int ans = 0;
	for(int i = 0;i<1<<4;i++)
	{
		memset(f[0],200,sizeof(f[0]));
		f[0][i<<1] = 0;
		for(int j = 1;j<= n;j++)
			for(int k = 0;k<1<<5;k++)
				f[j][k] = max(f[j-1][(k&15)<<1],f[j-1][(k&15)<<1|1])+g[j][k];
		ans = max(ans,max(f[n][i<<1],f[n][i<<1|1]));
	}
	printf("%d\n",ans);
	return 0;
}
Problem1170

#include <stdio.h>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll mod1 = 1e9+7;
const ll mod2 = 1e9+9;
const ll base1 = 2591;
const ll base2 = 2593;
const int N = 1e3+5;
const int MOD = N*N;
ll sum1[N][N],sum2[N][N];
ll basel[3]={0,1,1},baser[3]={0,1,1};
char s[N][N];
ll ans_time,ans1,ans2;
struct Hash_list
{
	int next;
	ll hv1,hv2;
	int times;
}e[N*N];
int head[N*N],tot;
inline int& Hash(ll h1,ll h2)
{
	ll x = h1*h2%MOD;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].hv1==h1&&e[i].hv2==h2)
			return e[i].times;
	tot++;
	e[tot].next = head[x];e[tot].hv1 = h1,e[tot].hv2 = h2;
	e[tot].times = 0;head[x] = tot;
	return e[tot].times;
}
int n,m,a,b;
ll gethash1(int i,int j)
{
	return 
		((sum1[i][j]-
		sum1[i-a][j]*basel[1]-
		sum1[i][j-b]*baser[1]+
		sum1[i-a][j-b]*basel[1]%mod1*baser[1])%mod1+mod1)%mod1;
}
ll gethash2(int i,int j)
{
	return 
		((sum2[i][j]-
		sum2[i-a][j]*basel[2]-
		sum2[i][j-b]*baser[2]+
		sum2[i-a][j-b]*basel[2]%mod2*baser[2])%mod2+mod2)%mod2;
}
int main()
{
	//freopen("x.in","r",stdin);
	scanf("%d %d\n",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		fread(s[i]+1,m+1,1,stdin);
		for(int j = 1;j<= m;j++)
			sum1[i][j] = sum2[i][j] = s[i][j];
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			sum1[i][j]=(sum1[i][j]+sum1[i-1][j]*base1)%mod1,
			sum2[i][j]=(sum2[i][j]+sum2[i-1][j]*base1)%mod2;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			sum1[i][j]=(sum1[i][j]+sum1[i][j-1]*base2)%mod1,
			sum2[i][j]=(sum2[i][j]+sum2[i][j-1]*base2)%mod2;
	scanf("%d%d",&a,&b);
	printf("%d %d\n",a,b);
	for(int i = 1;i<= a;i++)
		basel[1]*=base1,basel[1]%=mod1,
		basel[2]*=base1,basel[2]%=mod2;
	for(int i = 1;i<= b;i++)
		baser[1]*=base2,baser[1]%=mod1,
		baser[2]*=base2,baser[2]%=mod2;
	ans_time = 0;
	for(int i = a;i<= n;i++)
		for(int j = b;j<= m;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			int &val = Hash(hash1,hash2);
			if(++val>ans_time)
			{
				ans_time = val;
				ans1 = hash1,ans2 = hash2;
			}
		}
	bool flag = true;
	for(int i = a;i<= n&&flag;i++)
		for(int j = b;j<= m&&flag;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			if(hash1==ans1&&hash2==ans2)
			{
				for(int k=i-a+1;k<=i;k++,puts(""))
					for(int l = j-b+1;l<=j;l++)
						putchar(s[k][l]);
				flag = false;
			}
		}
	printf("%lld\n",ans_time);
	for(int i = a;i<= n;i++)
		for(int j = b;j<= m;j++)
		{
			ll hash1 = gethash1(i,j);
			ll hash2 = gethash2(i,j);
			if(hash1==ans1&&hash2==ans2)
				printf("%d %d\n",i-a+1,j-b+1);
		}
	return 0;
}
Problem1181

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int INF = 1<<30;
int _a[N],a[N],b[N];
int s[N],ans[N];
bool cmp(int x,int y)
{
	return _a[x]>_a[y];
}
int f[2][N];
int V,n,m,tot;
bool check(int idx,int mid)
{
	for(int i = 0;i<= m;i++)
		f[0][i] = f[1][i] = INF;
	f[0][0] = 0;
	int now = 0;
	for(int i = 1;i<= min(n,21);i++)
	{
		if(i==idx)continue;
		for(int j = 0;j<= m;j++)
		{
			f[now^1][j] = INF;
			for(int k = 0;k<= j;k++)
			{
				int x = (a[idx]*k+mid)/(mid+1)-a[i];
				if(a[idx]*k%(mid+1)==0 && b[i]>b[idx] && k)
					x++;
				x = max(x,0);
				if (k && (a[i]+x)*20<V) 
					x+=(V+19-20*(a[i]+x))/20;
				f[now^1][j] = min(f[now^1][j],f[now][j-k]+x);
			}
		}
		now^=1;
	}
	return f[now][m-mid]<=V-tot;
}
int main()
{
	scanf("%d%d%d",&V,&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&_a[i]);
		b[i] = i;
		tot+=_a[i];
	}
	for(int i = 1;i<= n;i++)
	{
		_a[i]+=V-tot;
		for(int j = 1;j<= m;j++)
		{
			int mk = 0;
			for(int k = 1;k<= n;k++)
				if(_a[k]*20>=V&&(mk==0||_a[k]*(s[mk]+1)>_a[mk]*(s[k]+1)))
					mk = k;
			s[mk]++;
		}
		printf("%d",s[i]);
		if(i==n)printf("\n");else printf(" ");
		for(int j = 0;j<= n;j++)s[j]=0;
		_a[i]-=V-tot;
	}
	sort(b+1,b+n+1,cmp);
	for(int i = 1;i<= n;i++)a[i] = _a[b[i]];
	for(int i = 1;i<= n;i++)
	{
		if(a[i]*20<V){ans[b[i]]=0;continue;}
		int l = -1,r = m,mid;
		while(l+1<r)
		{
			mid = (l+r)>>1;
			if(check(i,mid))
				r = mid;
			else 
				l = mid;
		}
		ans[b[i]] = r;
	}
	for(int i = 1;i<= n;i++)
		printf("%d",ans[i]),printf("%c",i==n?'\n':' ');
	return 0;
}
Problem1187

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF=2e9;
const int MAXN=3005;
int i;
struct na
{
	int x,z;
	na(int _x,int _z):x(_x),z(_z){}
};
int n,m,x,y,z,a[21],k,p1,p2,en,t;
bool map[11][101];
int f[2][MAXN+1],ans=-INF,re[101][11];
int v[2][MAXN+1];
queue <na> q;
inline int gx(int x,int q1,int q2)
{
	k=0;
	for (register int i=m+1;i;i--) 
		k=k*3+(i==x?q1:(i==x+1?q2:a[i]));
	return k;
}
inline void up(int x,int z,int lj,int la)
{
	if (la) lj+=re[x/m+1][x%m+1];
	x++;
	k=x%2;
	if (v[k][z]!=x) v[k][z]=x,f[k][z]=-INF,q.push(na(x,z));
	if (f[k][z]<lj) f[k][z]=lj;
}
int main()
{
	int i,j,p;
	scanf("%d%d",&n,&m);
	memset(f,INF,sizeof(f));
	for (j=1;j<=n;j++)
	for (i=1;i<=m;i++)
	scanf("%d",&re[j][i]),map[i][j]=1;
	en=n*m-1;
	f[0][0]=0;
	v[0][0]=1;
	q.push(na(0,0));
	while(!q.empty())
	{
		p=0;
		na no=q.front();q.pop();
		int an=f[no.x%2][no.z];
		if(no.x%m==0) no.z*=3;
		x=no.x%m+1;y=no.x/m+1;
		for (i=1;i<=m+1;i++) a[i]=0;
		for (i=1,j=no.z;j;i++,j/=3)
		{
			a[i]=j%3;
			if (a[i]) p++;
		}
		if (a[x]==1&&a[x+1]==2)
		{
			if (ans<an+re[y][x]&&p==2) ans=an+re[y][x];
		}
		else if (a[x]==2&&a[x+1]==1) up(no.x,gx(x,0,0),an,1);
		else if (a[x]==0&&a[x+1]==0)
		{
			if (no.x!=en)
			{
				if (map[x][y+1]&&map[x+1][y]) up(no.x,gx(x,1,2),an,1);
				up(no.x,gx(x,0,0),an,0);
			}
		}
		else if (a[x]==0)
		{
			if (map[x+1][y]) up(no.x,gx(x,0,a[x+1]),an,1);
			if (map[x][y+1]) up(no.x,gx(x,a[x+1],0),an,1);
		}
		else if (a[x+1]==0)
		{
			if (map[x+1][y]) up(no.x,gx(x,0,a[x]),an,1);
			if (map[x][y+1]) up(no.x,gx(x,a[x],0),an,1);
		}
		else if (a[x]==a[x+1])
		{
			p1=p2=0;
			if (a[x]==1)
			for (j=0,i=x+2;i<=m+1;i++)
			{
				if (a[i]==1) j--;
				if (a[i]==2) j++;
				if (j>0&&!p1) p1=i,j--;
				if (j>0&&p1){p2=i;break;}
			}
			else
			for (j=0,i=x-1;i;i--)
			{
				if (a[i]==1) j++;
				if (a[i]==2) j--;
				if (j>0&&!p2) p2=i,j--;
				if (j>0&&p2){p1=i;break;}
			}
			a[p1]=1;a[p2]=2;up(no.x,gx(x,0,0),an,1);
		}
		//printf("%d\n",ans);
	}
	printf("%d\n",ans);
}
Problem1189

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define mid (l+r)/2
#define inf 0x3f3f3f3f
#define T n*n*m*m+2
const int N=25;
const int M=200000;
char s[N];
bool use[N][N],flag[N][N];
struct S{int x,y,c;}l[N*N];
struct Q{int st,en,va;}aa[M*2];
int n,m,map[N][N],f[N][N][N][N],sum,point[M],next[M*2],cur[M],dis[M],pre[M],gap[M],tot;
const int xi[4]={-1,0,0,1},yi[4]={0,-1,1,0};
inline void bfs(int xa,int ya)
{
	int i,h,t,k,x,y;
	memset(use,1,sizeof(use));
	h=t=1;l[h].x=xa;l[h].y=ya;l[h].c=0;
	while(h<=t){
		x=l[h].x;y=l[h].y;
		for(i=0;i<4;++i)
		{
			int xx=x+xi[i],yy=y+yi[i];
			if(xx>0&&xx<=n&&yy>0&&y<=m&&map[xx][yy]==1&&use[xx][yy])
			{
				l[++t].x=xx;l[t].y=yy;l[t].c=l[h].c+1;
				use[xx][yy]=false;
				f[xx][yy][xa][ya]=l[t].c;
				flag[xx][yy]=true;
			}
		}
		h+=1;
	}
}
inline void add(int x,int y,int z)
{
	tot+=1;next[tot]=point[x];point[x]=tot;
	aa[tot].st=x;aa[tot].en=y;aa[tot].va=z;
	tot+=1;next[tot]=point[y];point[y]=tot;
	aa[tot].st=y;aa[tot].en=x;aa[tot].va=0;
}
inline int ISAP(int ss,int tt)
{
	bool f;
	int minn,ans=0,i,u,y;
	memset(dis,0,sizeof(dis));
	memset(gap,0,sizeof(gap));
	memset(pre,0,sizeof(pre));
	gap[0]=tt-ss+1; u=ss;
	for(i=ss;i<=tt;++i) cur[i]=point[i];
	while(dis[ss]<tt-ss+1)
	{
		f=false;
		for(i=cur[u];i;i=next[i])
			if(aa[i].va>0&&dis[u]==dis[aa[i].en]+1)
			{
			cur[u]=i;f=true;break;
			}
		if(f)
		{
			pre[u=aa[i].en]=i;
			if(u==tt)
			{
				minn=inf;
				for(i=u;i!=ss;i=aa[pre[i]].st)
					minn=min(minn,aa[pre[i]].va);
				ans+=minn;
				for(i=u;i!=ss;i=aa[pre[i]].st)
				{
					aa[pre[i]].va-=minn;
					aa[pre[i]^1].va+=minn;
				}
				u=ss;
			}   
		}
		else
		{
			--gap[dis[u]];
			if(!gap[dis[u]]) return ans;
			y=2*tt; cur[u]=point[u];
			for(i=point[u];i;i=next[i])
				if(aa[i].va>0) y=min(y,dis[aa[i].st]);
			++gap[dis[u]=y+1];
			if(u!=ss) u=aa[pre[u]].st;
		}
	}
	return ans;
}
inline bool check(int x)
{
	int i,j,p,q;
	tot=1;
	memset(point,0,sizeof(point));
	memset(next,0,sizeof(next));
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		{
		int now=((i-1)*m+j-1)*n*m;
		if(map[i][j]==0)
		{
			for(p=1;p<x;++p)
				add(now+p+1,now+p+2,inf),add(now+p+1,T,1);
			add(now+x+1,T,1);
		}
		if(map[i][j]==1)
		{
			add(1,now+1,1);
			for(p=1;p<=n;++p)
				for(q=1;q<=m;++q)
				if(f[i][j][p][q])
					add(now+1,((p-1)*m+q-1)*n*m+f[i][j][p][q]+1,1);
		}
		}
	return ISAP(1,T)==sum;
}
int main()
{
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)
	{
		scanf("%s",&s);
		for(j=0;j<m;++j)
		{
			if(s[j]=='D') map[i][j+1]=0;
			if(s[j]=='.') map[i][j+1]=1,sum+=1;
			if(s[j]=='X') map[i][j+1]=2;
		}
	}
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		if(map[i][j]==0)
			bfs(i,j);
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
		if(!flag[i][j]&&map[i][j]==1)
		{
			printf("impossible\n");
			return 0;
		}
	int l=1,r=n*m,ans=inf;
	while(l<r)
	{
		if(check(mid)) ans=min(ans,mid),r=mid;
		else l=mid+1;
	}
	printf("%d\n",ans);
}
Problem1190

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 105;
ll f[35][1005];
int main()
{
	int n,w,x,v;
	while(scanf("%d%d",&n,&w)!=EOF)
	{
		if(n==-1&&w==-1)break;
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d",&x,&v);
			int tmp = 0;
			while(!(x&1))x>>=1,tmp++;
			for(int j = 1000;j>= x;j--)
				f[tmp][j] = max(f[tmp][j],f[tmp][j-x]+v);
		}
		for(int i = 0;i<= 30;i++)
			for(int j = 1;j<= 1000;j++)
				f[i][j]=max(f[i][j],f[i][j-1]);
		ll ans = 0;
		for(int j = 1;j<= min(1000,w);j++)ans = max(ans,f[0][j]);
		for(int i = 1;i<= 30&&(1<<i)<=w;i++)
			for(int j = min(1000,w>>i);j>= 0;j--)
			{
				for(int k = 0;k<= j;k++)
					f[i][j] = max(f[i][j],f[i][j-k]+f[i-1][min(k+k+((w>>i-1)&1),1000)]);
				ans = max(f[i][j],ans);
			}
		printf("%d\n",ans);

	}
	return 0;
}
Problem1194

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define fir first
#define sec second
const int N = 55;
const int L = 65540;
struct E
{int next,to;}e[N*N];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
vector<int>member[N];
int bel[N],cnt,dfn[N],low[N],Dfn,stack[N],top;
bool vis[N];
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	for(int i = head[x];i;i=e[i].next)
	{
		if(vis[e[i].to])continue;
		if(dfn[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}
	}
	if(dfn[x]==low[x])
	{
		++cnt;
		int tmp;
		do
		{
			tmp = stack[top--];
			bel[tmp] = cnt;
			member[cnt].push_back(tmp);
			vis[tmp] = true;
		}while(tmp!=x);
	}
}
struct AM
{
	int n,m;
	int trs[N][2],out[N];
	void Read()
	{
		int x;
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&x);
			out[x] = true;
		}
		for(int i = 0;i< n;i++)
			scanf("%d%d",&trs[i][0],&trs[i][1]);
	}
}a[N];
bool bfs(const AM &x,const AM &y)
{
	static pii q[L];
	static bool v[N][N];
	memset(v,0,sizeof(v));
	int hd=1,tl=0;
	q[++tl] = make_pair(0,0);
	v[0][0] = true;
	while(hd<=tl)
	{
		pii sta = q[hd++];
		if(x.out[sta.fir] && !y.out[sta.sec])
			return false;
		for(int i = 0;i<2;i++)
		{
			int xx = x.trs[sta.fir][i];
			int yy = y.trs[sta.sec][i];
			if(v[xx][yy])continue;
			v[xx][yy] = true;
			q[++tl] = make_pair(xx,yy);
		}
	}
	return true;
}
int f[N],ans,n;
void topo()
{
	static int q[N],deg[N];
	for(int i = 1;i<= n;i++)
		for(int j = head[i];j;j=e[j].next)
			if(bel[i]!=bel[e[j].to])
				deg[bel[e[j].to]]++;
	int hd = 1,tl = 0;
	for(int i = 1;i<= cnt;i++)
		if(!deg[i])
			q[++tl] = i;
	while(hd<=tl)
	{
		int tmp = q[hd++];
		f[tmp]+=member[tmp].size();
		for(int id = 0;id<member[tmp].size();id++)
		{
			int x = member[tmp][id];
			for(int i = head[x];i;i=e[i].next)
			{
				if(bel[e[i].to]==tmp)continue;
				f[bel[e[i].to]] = max(f[bel[e[i].to]],f[tmp]);
				if(!--deg[bel[e[i].to]])q[++tl] = bel[e[i].to];
			}
		}
		ans = max(ans,f[tmp]);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		a[i].Read();
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(i!=j&&bfs(a[i],a[j]))
				add(i,j);
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	topo();
	printf("%d\n",ans);
	return 0;
}
Problem1196

#include <cstdio> 
#include <cstring> 
#include <iostream> 
#include <algorithm> 
#define MAX 20010 
using namespace std;  
struct Edge{
 	int x,y; 	
	int cost,_cost;  	
	bool operator <(const Edge &a)const 
	{ 		
		return cost < a.cost; 	
	} 	
	void Read() 
	{ 		
		scanf("%d%d%d%d",&x,&y,&cost,&_cost); 	
	} 
}edge[MAX];  
int points,k,edges; 
int father[MAX];  
int Find(int x) 
{ 	
	if(father[x] == x)	
	return x; 	
	return father[x] = Find(father[x]); 
}  
inline bool Judge(int ans) 
{ 	
	for(int i = 1; i <= points; ++i) 		
		father[i] = i; 	
	int first = 0,added = 0; 	
	for(int i = 1; i <= edges; ++i) 
	{ 		
		int fx = Find(edge[i].x);
		int fy = Find(edge[i].y); 		
		if(fx != fy)
		 { 			
		 	if(edge[i].cost <= ans)
			{ 				
				++first,++added;
				father[fx] = fy; 			
			} 			
			else if(edge[i]._cost <= ans) 
			{ 				
				++added; 				
				father[fx] = fy;
 			} 		
		 } 	
	 } 	
	 return first >= k && added == points - 1;
  }  
int main() 
{ 	
	cin >> points >> k >> edges; 	
	for(int i = 1; i <= edges - 1; ++i)  	
		edge[i].Read(); 	
	sort(edge + 1,edge + edges + 1); 	
	int l = 0,r = 30000,ans = 30000; 	
	while(l <= r) 
	{ 		
		int mid = (l + r) >> 1; 		
		if(Judge(mid)) 			
			ans = mid,r = mid - 1; 		
		else	
			l = mid + 1; 	
	} 	
	cout << ans << endl;
 	return 0; 
 }
 
Problem1202

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int fa[105];
int pos[105];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else
	{
		int tmp = getfa(fa[x]);
		pos[x] = pos[fa[x]]+pos[x];
		return fa[x] = tmp;
	}
}
void work()
{
	memset(fa,0,sizeof(fa));
	memset(pos,0,sizeof(pos));
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	int flag = true;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		int fx = getfa(x),fy = getfa(y+1);
		if(fx==fy)
		{
			if(pos[y+1]-pos[x]!=c)flag = false;
		}
		else
		{
			fa[fy] = x;
			pos[fy] = c-pos[y+1];
		}
	}
	if(flag)printf("true\n");
	else printf("false\n");
	return ;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
		work();
	return 0;
}
Problem1208

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL INF = 1e18;
const int mod = 1e6;
struct Treap
{
	Treap *ls,*rs;
	int key,cnt,size;
	LL val;
	Treap(int x);
	void push_up();
}*root0,*root1;
Treap :: Treap(int x)
{
	ls = rs = NULL;
	key = rand();
	val = x;
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key<x->key)
			go_right(x);
	}else
	{
		insert(x->rs,y);
		if(x->rs->key<x->key)
			go_left(x);
	}
	x->push_up();
}
void dele(Treap *&x,int y)
{
	if(y<x->val)
		dele(x->ls,y);
	else if(y>x->val)
		dele(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)
			x = x->rs;
		else if(!x->rs)
			x = x->ls;
		else
		{
			go_left(x);
			dele(x->ls,y);
			if(x->ls && x->ls->key<x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
LL ans;
void ask_pro(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<y)
	{
		ans = max(ans,x->val);
		ask_pro(x->rs,y);
	}
	else ask_pro(x->ls,y);
}
void ask_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>y)
	{
		ans = min(ans,x->val);
		ask_sub(x->ls,y);
	}
	else ask_sub(x->rs,y);
}
int main()
{
	int n,a,b;
	scanf("%d",&n);
	LL sum = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a,&b);
		if(a==0&&!root1)
			insert(root0,b);
		else if(a==1&&!root0)
			insert(root1,b);
		else
		{
			if(a==0)
			{
				ans = 0;
				ask_pro(root1,b);
				int tmp1 = ans;
				ans = INF;
				ask_sub(root1,b);
				int tmp2 = ans;
				if(tmp1==0){sum+=abs(b-tmp2);dele(root1,tmp2);}
				else if(tmp2==INF){sum+=abs(b-tmp1);dele(root1,tmp1);}
				else if(abs(b-tmp1)>abs(b-tmp2)){sum+=abs(b-tmp2);dele(root1,tmp2);}
				else if(abs(b-tmp1)<abs(b-tmp2)){sum+=abs(b-tmp1);dele(root1,tmp1);}
				else{sum+=abs(b-tmp1);dele(root1,tmp1);}
			}else
			{
				ans = 0;
				ask_pro(root0,b);
				int tmp1 = ans;
				ans = INF;
				ask_sub(root0,b);
				int tmp2 = ans;
				if(tmp1==0){sum+=abs(b-tmp2);dele(root0,tmp2);}
				else if(tmp2==INF){sum+=abs(b-tmp1);dele(root0,tmp1);}
				else if(abs(b-tmp1)>abs(b-tmp2)){sum+=abs(b-tmp2);dele(root0,tmp2);}
				else if(abs(b-tmp1)<abs(b-tmp2)){sum+=abs(b-tmp1);dele(root0,tmp1);}
				else{sum+=abs(b-tmp1);dele(root0,tmp1);}
			}
		}
	}
	printf("%lld\n",sum%mod);
	return 0;
}
Problem1212

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int Len = 1<<20;
char w[Len+5];
char s[35];
	int ch[305][26],fail[305],cnt,q[305],h,t;
	bool end[305];
	int len[305];
	void init()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i] =1;
	}
	void insert()
	{
		int now = 1,i = 0;
		while(s[i])
		{
			if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
			now = ch[now][s(i)];
			i++;
		}
		len[now] = i;
	}
	void build()
	{
		int h = 0,t = -1;
		q[++t] = 1,fail[0] =1;
		while(h<=t)
		{
			int x=q[h++];
			for(int i = 0;i<26;i++)
			{
				int j=ch[x][i];
				if(!j)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[j] = ch[k][i];
				end[j]|=end[fail[j]];
				q[++t]=j;
			}
		}
	}
bool v[Len+5];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	init();
	for(int i = 1;i<=n;i++)
	{
		scanf("%s",s);
		insert();
	}
	build();
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",w+1);
		int lth = strlen(w+1);
		int now = 1,ans = 0;
		v[0]=true;
		for(int j = 1;j<=lth;j++)
		{
			while(now!=1&&!ch[now][w[j]-'a'])
				now = fail[now];
			if(ch[now][w[j]-'a'])
			{
				now = ch[now][w[j]-'a'];
				for(int tmp = now;tmp!=1;tmp = fail[tmp])
					if(len[tmp])
					{
						v[j]|=v[j-len[tmp]];
						if(v[j])break;
					}
			}
			if(v[j])ans =max(ans,j);
		}
		for(int j = 1;j<=lth;j++)v[j] = false;
		printf("%d\n",ans);
	}
	return 0;
}
Problem1226

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int S = 1<<8;
const int INF = 0x3f3f3f3f;
#define f(i,j,k) (f[i][j][k+8])
int t[N],b[N];
int f[N][S][20];
int v(int pos1,int pos2)
{
	if(pos1==0)return 0;
	return (t[pos1]^t[pos2]);
}
void work()
{
int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
		scanf("%d%d",&t[i],&b[i]);
	for(int i = 1;i<= n+1;i++)
		for(int j = 0;j<1<<8;j++)
			for(int k = -8;k<= 7;k++)
				f(i,j,k) = INF;
	f(1,0,-1) = 0;
	for(int i = 1;i<= n;i++)
		for(int s = 0;s<1<<8;s++)
			for(int k = -8;k<=7;k++)
			{
				if(!(f(i,s,k)<INF))continue;
				if(s&1)f(i+1,s>>1,k-1) = min(f(i,s,k),f(i+1,s>>1,k-1));
				else
				{
					int r = INF;
					for(int l = 0;l<= 7;l++)
						if(!(s&(1<<l)))
						{
							if(i+l>r)break;
							r = min(r,i+b[i+l]+l);
							f(i,s|(1<<l),l)=min(f(i,s|(1<<l),l),f(i,s,k)+v(i+k,i+l));
						}
				}
			}
	int ans = 0x3f3f3f3f;
	for(int i = -8;i<=-1;i++)
		ans = min(ans,f(n+1,0,i));
	printf("%d\n",ans);
	return ;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem1227

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 2147483647;
int d[N];
int sum[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		d[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=d[i];
	return ans;
}
struct P
{int x,y,l,r,u,d;}p[N];
bool cmp(const P &a,const P &b)
{
	return a.y<b.y||(a.y==b.y&&a.x<=b.x);
}
int fac[N],env[N];
int c[N][20];
void init()
{
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0]=1;
		for(int j=1;j<=10;j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j];
	}
}
int id[N],X[N];
int find(int x)
{
	int l = 1,r = id[0]+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l=mid+1;
		else r=mid;
	}
	return l;
}
int main()
{
	int n,m,w,k;
	init();
	scanf("%d%d%d",&n,&m,&w);
	for(int i = 1;i<= w;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		X[i] = p[i].x;
	}
	scanf("%d",&k);
	sort(X+1,X+w+1);
	id[id[0]=1]=X[1];
	for(int i = 2;i<= w;i++)
		if(X[i]!=X[i-1])
			id[++id[0]]=X[i];
	sort(p+1,p+w+1,cmp);
	int tmp = 0;
	for(int i = 1;i<= w;i++)p[i].x=find(p[i].x);
	for(int i = 1;i<= w;i++)
	{
		if(p[i].y==p[i-1].y)tmp++;else tmp=1;
		p[i].l=tmp;
		sum[p[i].x]++;
		p[i].u=sum[p[i].x];
	}
	tmp = 0;
	for(int i = w;i>=1;i--)
	{
		if(p[i].y==p[i+1].y)tmp++;else tmp=1;
		p[i].r=tmp;
		p[i].d=sum[p[i].x]-p[i].u;
	}
	int ans = 0;
	for(int i = 1;i<= w;i++)
	{
		update(p[i].x,c[p[i].u][k]*c[p[i].d][k]-getans(p[i].x)+getans(p[i].x-1));
		if(i>1&&p[i].y==p[i-1].y)
			ans+=c[p[i-1].l][k]*c[p[i].r][k]*(getans(p[i].x-1)-getans(p[i-1].x));
	}
	printf("%d\n",ans&mod);
	return 0;
}
Problem1231

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1<<16;
long long f[2][N][17];
int cnt[N],s[17];
int abs(int x){return x<0?-x:x;}
void init()
{
	for(int i = 0;i<N;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	return ;
}
int main()
{
	int n,k;
	init();
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&s[i]);
	for(int i = 0;i< n;i++)
		f[1][1<<i][i+1] = 1;
	for(int i = 2;i<= n;i++)
	{
		int I = i&1,I_=(i-1)&1;
		for(int sta = 0;sta<1<<n;sta++)
		{
			if(cnt[sta]!=i-1)continue;
			for(int l = 1;l<= n;l++)
			{
				if(!(sta&(1<<(l-1))))continue;
				for(int t = 1;t<= n;t++)
				{
					if(sta&(1<<(t-1)))continue;
					if(abs(s[t]-s[l])<=k)continue;
					f[I][sta|(1<<(t-1))][t]+=f[I_][sta][l];
				}
			}
		}
		memset(f[I_],0,sizeof(f[I_]));
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=f[n&1][(1<<n)-1][i];
	printf("%lld\n",ans);
	return 0;
}
Problem1251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
struct Splay 
{
	Splay *ls,*rs,*fa;
	int lazy_add,max_val,val;
	int size;
	bool lazy_rev;
	Splay(int x);
	void push_down();
	void push_up();
}*null = new Splay(0xefefefef),*root = null;
Splay :: Splay (int x)
{
	ls = rs = fa = null;
	lazy_add = lazy_rev = 0;
	max_val = val = x;
	size = null?1:0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	max_val = max(max(ls->max_val,rs->max_val),val);
}
void Splay :: push_down()
{
	if(this==null)return ;
	if(lazy_add)
	{
		if(ls!=null)
		{
			ls->lazy_add += lazy_add;
			ls->max_val+=lazy_add;
			ls->val+=lazy_add;
		}
		if(rs!=null)
		{
			rs->lazy_add += lazy_add;
			rs->max_val+=lazy_add;
			rs->val+=lazy_add;
		}
		lazy_add = 0;
	}
	if(lazy_rev)
	{
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		ls->lazy_rev^=1;
		rs->lazy_rev^=1;
		lazy_rev = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *tar)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y = y-x->ls->size;
			if(y==1)
				break;
			y--;
			x = x->rs;
		}
	}
	splay(x,tar);
}
void update()
{
	int l,r,c;
	scanf("%d%d%d",&l,&r,&c);
	Find(root,l,null);
	Find(root,r+2,root);
	root->rs->ls->val+=c;
	root->rs->ls->max_val+=c;
	root->rs->ls->lazy_add+=c;
	//root->rs->push_up();
	//root->push_up();
}
void reverse()
{
	int l,r;
	scanf("%d%d",&l,&r);
	Find(root,l,null);
	Find(root,r+2,root);
	Splay *tmp = root->rs->ls;
	tmp->lazy_rev^=1;
	swap(tmp->ls,tmp->rs);
}
void get_max()
{
	int l,r;
	scanf("%d%d",&l,&r);
	Find(root,l,null);
	Find(root,r+2,root);
	printf("%d\n",root->rs->ls->max_val);
}
/*
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}*/
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = new Splay(0);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa = x;
	if(x->rs!=null)x->rs->fa = x;
	x->push_up();
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int opt;
	root = new Splay(Inv);
	root->rs = new Splay(Inv);
	build(root->rs->ls,1,n);
	root->rs->ls->fa = root->rs;
	root->rs->fa =root;
	root->rs->push_up();
	root->push_up();
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)update();
		else if(opt==2)reverse();
		else get_max();
	}
	return 0;
}
Problem1261

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double INF = 1e9+1;
double dp[35][35][35];
int rt[35][35][35];
int d[35],n;
double k,c;
double dfs(int l,int r,int dep)
{
	if(l==r)
		return (k*(dep+1)+c)*d[l];
	if(r<l)return 0;
	if(dp[l][r][dep]<1e9+1)return dp[l][r][dep];
	for(int i = l;i<= r;i++)
	{
		double tmp1 = dfs(l,i-1,dep+1);
		double tmp2 = dfs(i+1,r,dep+1);
		if(tmp1+tmp2+(k*(dep+1)+c)*d[i]<dp[l][r][dep])
		{
			dp[l][r][dep] = tmp1+tmp2+(k*(dep+1)+c)*d[i];
			rt[l][r][dep] = i;
		}
	}
	return dp[l][r][dep];
}
/*void print(int l,int r,int dep)
{
	if(l==r)
	{
		printf("%d")
	}
	int t = rt[l][r][dep];

}*/
int main()
{
	int sum = 0;
	for(int i = 0;i<= 31;i++)
		for(int j = 0;j<= 31;j++)
			for(int k = 0;k<= 31;k++)
				dp[i][j][k] = INF;
	scanf("%d%lf%lf",&n,&k,&c);
	for(int i = 1;i<= n;i++)
		{scanf("%d",&d[i]);sum+=d[i];}
	double ans = dfs(1,n,0);
	ans = ans/(double)sum;
	printf("%.3f",ans);
	//print(1,n,0);
	return 0;
}
Problem1264

#include<stdio.h>
int pos[20005][6];
int dna2[100005];
int cnt[20005];
int a[1000005];
int f[100005];
int find(int x,int end)
{
	int l=1,r = end+1,mid;
	while(l<r)
	{
		mid = (l+r)/2;
		if(f[mid]>=x)
		{
			r = mid;
		}else
		{
			l = mid+1;
		}
	}
	return l;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= 5*n;i++)
	{
		int x;
		scanf("%d",&x);
		pos[x][5-cnt[x]] = i;
		cnt[x]++;
	}
	for(int i = 1;i<= 5*n;i++)
	{
		scanf("%d",&dna2[i]);
		for(int j = 1;j<=5;j++)
		{
			a[(i-1)*5+j] = pos[dna2[i]][j];
		}
	}
	int ans = 0;
	for(int i = 1;i<= 25*n;i++)
	{
		if(a[i]>f[ans])
		{
			ans++;
			f[ans] = a[i];
		}else
		{
			f[find(a[i],ans)] = a[i];
		}
	}
	printf("%d",ans);
	return 0;
}
Problem1266

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 3e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;};
int d[N],dis[N];
bool v[N];
queue<int>Q;
struct G
{
	E e[M];
	int head[N],tot;
	void init()
	{
		memset(head,0,sizeof(head));
		tot=1;
	}
	void addE(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].f = f;
		head[x] = tot;
	}
	void addF(int x,int y,int f)
	{
		e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;head[x]=tot;
		e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;head[y]=tot;
	}
	void spfa(int s)
	{
		memset(dis,0x3f,sizeof(dis));
		dis[s]=0;v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f+dis[x]<dis[e[i].to])
				{
					dis[e[i].to]=dis[x]+e[i].f;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
		}
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[t]=0;
		Q.push(t);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(d[e[i].to]==-1&&e[i^1].f)
				{
					d[e[i].to]=d[x]+1;
					Q.push(e[i].to);
				}
		}
		return d[s]!=-1;
	}
	int get_maxflow(int s,int t,int mf)
	{
		if(s==t)return mf;
		int last = mf;
		for(int i = head[s];i;i=e[i].next)
			if(d[e[i].to]==d[s]-1&&e[i].f)
			{
				int tof = get_maxflow(e[i].to,t,min(e[i].f,last));
				if(tof)
				{
					e[i].f-=tof;
					e[i^1].f+=tof;
					if(!(last-=tof))return mf;
				}
			}
		d[s]=-1;
		return mf-last;
	}
	int dinic(int s,int t)
	{
		int ans=0,nowflow;
		while(bfs(s,t))
			while((nowflow=get_maxflow(s,t,INF)))
				ans+=nowflow;
		return ans;
	}
}G,F;
int x[M],y[M],c[M],t[M];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x[i],&y[i],&t[i],&c[i]);
		G.addE(x[i],y[i],t[i]),G.addE(y[i],x[i],t[i]);
	}
	G.spfa(1);
	printf("%d\n",dis[n]);
	F.init();
	for(int i = 1;i<= m;i++)
	{
		if(dis[x[i]]+t[i]==dis[y[i]])
			F.addF(x[i],y[i],c[i]);
		if(dis[y[i]]+t[i]==dis[x[i]])
			F.addF(y[i],x[i],c[i]);
	}
	int ans = F.dinic(1,n);
	printf("%d\n",ans);
	return 0;
}
Problem1269

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct splay
{
	splay *ls,*rs,*fa;
	bool rev;
	int size;char c;
	splay(char c);
	void push_up();
	void push_down();
	void reverse();
}*null=new splay(0),*root=null;
splay :: splay(char C)
{
	ls = rs = fa = null;
	rev = false;
	size = C?1:0;
	c = C;
}
void splay :: push_up()
{
	size = ls->size+(c!=0)+rs->size;
}
void splay :: push_down()
{
	if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = false;
	}
}
void splay :: reverse()
{
	rev^=1;
	swap(ls,rs);
}
void go_left(splay *x)
{
	splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa=y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void go_right(splay *x)
{
	splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void Splay (splay *x,splay *tar)
{
	while(true)
	{
		splay *y = x->fa,*z = x->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(y==x->ls)go_right(x);
			else go_left(x);
			break;
		}else
		{
			if(x==y->ls)
			{
				if(y==z->ls)go_right(y);
				go_right(x);
			}else
			{
				if(y==z->rs)go_left(y);
				go_left(x);
			}
		}
	}
}
void find(splay *x,int y,splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;x=x->rs;
		}
	}
	Splay(x,z);
}
char s[1<<21];
void build(splay *&x,int l,int r)
{
	if(l>r)return ;
	int mid = (l+r)>>1;
	x = new splay(s[mid]);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa=x;
	if(x->rs!=null)x->rs->fa=x;
	x->push_up();
}
int pointer;
int main()
{
	char opt[20];
	int m,lth;
	scanf("%d",&m);
	root=new splay('\n');
	root->rs=new splay('\n');
	root->rs->fa= root;
	root->push_up();
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='M')
			scanf("%d",&pointer);
		else if(opt[0]=='I')
		{
			scanf("%d",&lth);
			do s[0]=getchar();while(s[0]=='\n'||s[0]=='\r');
			if(lth^1)gets(s+1);
			find(root,pointer+1,null);
			find(root,pointer+2,root);
			build(root->rs->ls,0,lth-1);
			root->rs->ls->fa=root->rs;
			root->rs->push_up();
			root->push_up();
		}else if(opt[0]=='D')
		{
			scanf("%d",&lth);
			find(root,pointer+1,null);
			find(root,pointer+lth+2,root);
			root->rs->ls=null;
			root->rs->push_up();
			root->push_up();
		}else if(opt[0]=='R')
		{
			scanf("%d",&lth);
			find(root,pointer+1,null);
			find(root,pointer+lth+2,root);
			root->rs->ls->reverse();
		}else if(opt[0]=='G')
		{
			find(root,pointer+2,null);
			printf("%c\n",root->c);
		}else if(opt[0]=='P')
			pointer--;
		else pointer++;
	}
	return 0;
}
Problem1293

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 0x7fffffff
using namespace std;
int n,k,cnt,ans=inf;
int head[65];
int next[1000005],v[1000005],a[1000005];
inline int read()
{
    char ch=getchar();
    int f=1,x=0;
    while(!(ch>='0'&&ch<='9')){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+(ch-'0');ch=getchar();}
    return x*f;
}
bool cal(int x)
{
	int mx=0;
	for(int i=1;i<=k;i++)
	{
		while(v[head[i]]>x)
		{
		    if(!next[head[i]])return 0;
			head[i]=next[head[i]];
			}
		if(v[head[i]]<=x)mx=max(mx,x-v[head[i]]);
	}
	ans=min(ans,mx);
	return 1;
}
int main()
{
	n=read();k=read();
	for(int i=1;i<=k;i++)
	{
		int x=read();
		for(int j=1;j<=x;j++)
		{
			int y=read();
			v[++cnt]=y;
			next[cnt]=head[i];
			head[i]=cnt;
			a[cnt]=y;
		}
	}
	sort(a+1,a+cnt+1);
	for(int i=cnt;i>0;i--)
	{
		if(a[i]!=a[i+1])
		if(!cal(a[i]))break;
	}
	printf("%d",ans);
	return 0;
}
Problem1296

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int map[55][55];
int stack[55],top;
int f[2501];
int g[55][55][55][2];
int w[55][55];
int main()
{
	int n,m,t;
	scanf("%d%d%d",&n,&m,&t);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%1d",&map[i][j]);
	for(int x = 1;x<= n;x++)
		for(int y = 1;y<= m;y++)
		{
			for(int i = min(m,t);i>=1;i--)
			{
				g[x][y][i][0] = max(g[x][y][i][0],g[x][y-1][i][0]+(map[x][y]==0));
				g[x][y][i][0] = max(g[x][y][i][0],g[x][y-1][i-1][1]+(map[x][y]==0));
				g[x][y][i][1] = max(g[x][y][i][1],g[x][y-1][i][1]+(map[x][y]==1));
				g[x][y][i][1] = max(g[x][y][i][1],g[x][y-1][i-1][0]+(map[x][y]==1));
			}
		}
	for(int x = 1;x<=n;x++)
		for(int i = 1;i<= min(m,t);i++)
		{
			int num = 0;
			for(int y = 1;y<= m;y++)
			{
				num = max(num,g[x][y][i][0]);
				num = max(num,g[x][y][i][1]);
			}
			w[x][i] = num;
		}
	for(int x = 1;x<=n;x++)
		for(int j = t;j>=0;j--)
			for(int i = 1;i<= min(m,t);i++)
				if(j>=i)f[j] = max(f[j],f[j-i]+w[x][i]);
	printf("%d\n",f[t]);
	return 0;
}
Problem1305

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 405;
const int M = 4e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int cntb[N],cntg[N];
char map[N][N];
void debug()
{
	for(int i = 0;i<= 7;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].f);
		printf("\n");
	}
}
void build(int n,int mid,int k)
{
    tot=1;memset(head,0,sizeof(head));
    for(int i=1;i<=n;i++)add(0,i*2-1,mid);
    for(int i=1;i<=n;i++)add(i*2-1,i*2,k);
    for(int i=1;i<=n;i++)add(n*2+i*2,n*2+i*2-1,k);
    for(int i=1;i<=n;i++)add(n*2+i*2-1,4*n+1,mid);
    for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
		{
			if(map[i][j]=='N')
				add(i*2,n*2+j*2,1);
			else
				add(i*2-1,2*n+j*2-1,1);
		}
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%s",map[i]+1);
	int st = 0,end = 4*n+1;
	int l = 0,r = n,ans=0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		build(n,mid,k);
		if(dinic(st,end)>=n*mid)l=mid+1,ans=mid;
		else r = mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1324

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x]=tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y]=tot;
}
int d[N],n,m;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_MF(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow&&d[e[i].to]==d[s]-1)
		{
			int tof = get_MF(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,NF;
	while(bfs(s,t))
		while((NF=get_MF(s,t,INF)))
			ans+=NF;
	return ans;
}
int getid(int x,int y)
{
	return (x-1)*m+y;
}
int main()
{
	int x,sum=0;
	scanf("%d%d",&n,&m);
	int st = 0,end = n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			sum+=x;
			if((i+j)&1)add(getid(i,j),end,x);
			else
			{
				add(st,getid(i,j),x);
				if(i!=1)add(getid(i,j),getid(i-1,j),INF);
				if(j!=1)add(getid(i,j),getid(i,j-1),INF);
				if(i!=n)add(getid(i,j),getid(i+1,j),INF);
				if(j!=m)add(getid(i,j),getid(i,j+1),INF);
			}
		}
	printf("%d\n",sum-dinic(st,end));
	return 0;
}
Problem1342

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int a[N],ans[N],top;
int Q[N],P[N],hq,tq,hp,tp;
int main()
{
	int n,m,c;
	scanf("%d%d%d",&n,&m,&c);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	hq = 0,tq = -1,hp = 0,tp = -1;
	//Q[0] = P[0] = 1;
	for(int i = 1;i<= n;i++)
	{
		while(hq<=tq&&a[Q[tq]]<=a[i])tq--;
		Q[++tq] = i;
		while(hp<=tp&&a[P[tp]]>=a[i])tp--;
		P[++tp] = i;
		while(hq<=tq&&Q[hq]<i-m+1)hq++;
		while(hp<=tp&&P[hp]<i-m+1)hp++;
		if(i>=m&&a[Q[hq]]-a[P[hp]]<=c)
			ans[++top] = i-m+1;
	}
	for(int i = 1;i<= top;i++)
		printf("%d\n",ans[i]);
	if(top==0)printf("NONE\n");
	return 0;
}
Problem1369

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int f[N][16];
void dp(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dp(e[i].to,x);
	for(int t = 1;t<= 15;t++)
	{
		f[x][t] = t;
		for(int i = head[x];i;i = e[i].next)
		{
			if(fa==e[i].to)continue;
			int tmp = 0x3f3f3f3f;
			for(int k = 1;k<= 15;k++)
			{
				if(t==k)continue;
				tmp = min(tmp,f[e[i].to][k]);
			}
			f[x][t] = f[x][t]+tmp;
		}
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dp(1,0);
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= 15;i++)
		ans = min(ans,f[1][i]);
	printf("%d\n",ans);
	return 0;
}
Problem1396

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
struct Seg_Tree
{
	int minn[N<<2],lazy[N<<2];
	void build(int p,int l,int r)
	{
		lazy[p]=minn[p]=INF;
		if(l==r)return ;
		int mid = (l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
	}
	void push_down(int p,int l,int r)
	{
		if(lazy[p]==INF||l==r)return ;
		minn[p<<1] = min(minn[p<<1],lazy[p]);
		minn[p<<1|1] = min(minn[p<<1|1],lazy[p]);
		lazy[p<<1] = min(lazy[p<<1],lazy[p]);
		lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
		lazy[p] = INF;
	}
	void update(int p,int l,int r,int a,int b,int x)
	{
		push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			minn[p] = min(minn[p],x);
			lazy[p] = min(lazy[p],x);
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,x);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,x);
		minn[p]=min(minn[p<<1],minn[p<<1|1]);
	}
	int getans(int p,int l,int r,int x)
	{
		push_down(p,l,r);
		if(l==r)return minn[p];
		int mid=(l+r)>>1;
		if(x<=mid)return getans(p<<1,l,mid,x);
		else return getans(p<<1|1,mid+1,r,x);
	}
}T1,T2;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1];
	bool end[N<<1];
	int cnt,last;
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p = last,np=++cnt,q,nq;
		last = np,len[np]=len[p]+1;
		end[np] = true;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	void getans(int n)
	{
		for(int i = 1;i<= cnt;i++)
			end[fa[i]] = false;
		for(int i = 1;i<= cnt;i++)
			if(end[i])
			{
				int l = len[i]-len[fa[i]],r = len[i];
				T1.update(1,1,n,l,r,r-l+1);
				if(l>1)T2.update(1,1,n,1,l-1,r);
			}
		for (int i=1;i<=n;i++)
			printf("%d\n",min(T1.getans(1,1,n,i),T2.getans(1,1,n,i)-i+1));
	}
}sam;
char s[N];
int main()
{
	sam.init();
	scanf("%s",s+1);
	int lth = strlen(s+1);
	for(int i = 1;i<=lth;i++)
		sam.insert(s[i]-'a');
	T1.build(1,1,lth);
	T2.build(1,1,lth);
	sam.getans(lth);
	return 0;
}
Problem1396

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
struct Seg_Tree
{
	int mn[N<<2],lazy[N<<2];
	void build(int p,int l,int r)
	{
		lazy[p] = mn[p] = INF;
		if(l==r)return ;
		int mid = (l+r)>>1;
		build(p<<1,l,mid);
		build(p<<1|1,mid+1,r);
	}
	void push_down(int p,int l,int r)
	{
		if(lazy[p]==INF||l==r)return ;
		mn[p<<1] = min(mn[p<<1],lazy[p]);
		mn[p<<1|1] = min(mn[p<<1|1],lazy[p]);
		lazy[p<<1] = min(lazy[p<<1],lazy[p]);
		lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
		lazy[p] = INF;
	}	
	void Update(int p,int l,int r,int a,int b,int c)
	{
		push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			lazy[p] = min(lazy[p],c);
			mn[p] = min(mn[p],c);
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)Update(p<<1,l,mid,a,b,c);
		if(b >mid)Update(p<<1|1,mid+1,r,a,b,c);
		mn[p] =min(mn[p<<1],mn[p<<1|1]);
	}
	int Getans(int p,int l,int r,int x)
	{
		push_down(p,l,r);
		if(l==r)return mn[p];
		int mid = (l+r)>>1;
		if(x<=mid)return Getans(p<<1,l,mid,x);
		else return Getans(p<<1|1,mid+1,r,x);
	}
}t1,t2;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1];
	bool end[N<<1];
	int cnt,last;
	void init()
	{
		cnt = last = 1;
	}
	void insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np] = len[p]+1;
		end[np] =true;
		for(;p&&!trs[p][x];p = fa[p])trs[p][x] = np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] =q;
			else
			{
				fa[nq =++cnt] =fa[q];
				len[nq] = len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p =fa[p])trs[p][x] = nq;
			}
		}
	}
	void getans(int n)
	{
		for(int i = 1;i<= cnt;i++)
			end[fa[i]] =false;
		for(int i = 1;i<= cnt;i++)
			if(end[i])
			{
				int l =len[i]-len[fa[i]],r = len[i];
				t1.Update(1,1,n,l,r,r-l+1);
				if(l>1)t2.Update(1,1,n,1,l-1,r);
			}
		for(int i = 1;i<= n;i++)
			printf("%d\n",min(t1.Getans(1,1,n,i),t2.Getans(1,1,n,i)-i+1));
	}
}sam;
char s[N];
int main()
{
	sam.init();
	scanf("%s",s+1);
	int n = strlen(s+1);
	t1.build(1,1,n);
	t2.build(1,1,n);
	for(int i = 1;i<= n;i++)
		sam.insert(s[i]-'a');
	sam.getans(n);	
	return 0;
}
Problem1406

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int stack[50005],ans[10000005];
int main()
{
	int top = 0,cnt = 0;
	ll n;
	scanf("%lld",&n);
	for(ll i = 1;i*i<=n;i++)
		if(n%i==0)
			stack[++top]=n/i;
	for(int i = 1;i<= top;i++)
	{
		for(ll j = stack[i];j<=n;j+=stack[i])
		{
			if((j-2)%(n/stack[i])==0)
				ans[++cnt] = (j-1)%n;
			if((j+2)%(n/stack[i])==0)
				ans[++cnt] = (j+1)%n;
		}
	}
	sort(ans+1,ans+cnt+1);
	top = 0;
	for(int i = 1;i<= cnt;i++)
		if(ans[i]!=ans[top])
			ans[++top]=ans[i];
	for(int i = 1;i<= top;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem1408

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int mod = 10000;
int p[N],e[N];
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{
	int k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
		scanf("%d%d",&p[i],&e[i]);
	int ans1=0,ans2=0,ans3,tmp1,tmp2;
	for(int i = 1;i<= k;i++)
	{
		if(p[i]==2)continue;
		tmp1 = (ans1+ans2*(p[i]-1)%mod)%mod;
		tmp2 = (ans2+(ans1+1)*(p[i]-1)%mod)%mod;
		ans1 = tmp1,ans2 = tmp2;
	}
	int m = 1;
	for(int i = 1;i<= k;i++)
		m = m*quick_pow(p[i]%mod,e[i])%mod;
	ans3 = (((m-1)-ans1-ans2)%mod+mod)%mod;
	printf("%d\n%d\n%d\n",ans1,ans2,ans3);
	return 0;
}
Problem1415

#include <stdio.h>
#include <queue>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const double eps = 1e-8;
struct Edge{int next,to;}e[N<<1];
int head[N],tot,cnt[N],v[N],dis[N];
int step[N][N];
double f[N][N];
queue <int>Q;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void spfa(int sta)
{
	memset(v,0,sizeof(v));
	memset(dis,0x3f,sizeof(dis));
	Q.push(sta);
	v[sta] = true;
	dis[sta] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i = e[i].next)
		{
			if(dis[x]+1<dis[e[i].to]||(dis[x]+1==dis[e[i].to]&&x<step[sta][e[i].to]))
			{
				step[sta][e[i].to] = x;
				dis[e[i].to] = dis[x]+1;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
		}
	}
	return ;
}
double dfs(int x,int y)
{
	if(x==y)return f[x][y] = 0;
	if(f[x][y]>eps)return f[x][y];
	if(step[y][x]==y||step[y][step[y][x]]==y)return f[x][y] = 1.0;
	int tmp = step[y][step[y][x]];
	double ans = dfs(tmp,y);
	for(int i=head[y];i;i = e[i].next)
		ans+=dfs(tmp,e[i].to);
	ans = ans/(double)(cnt[y]+1)+1;
	f[x][y] = ans;
	return ans;
}
int main()
{
	int n,E,c,m;
	scanf("%d%d%d%d",&n,&E,&c,&m);
	int x,y;
	for(int i = 1;i<= E;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
		cnt[x]++;cnt[y]++;
	}
	for(int i = 1;i<= n;i++)
		spfa(i);
	//printf("warning\n");
	memset(f,0xc2,sizeof(f));
	printf("%.3f",dfs(c,m));
	return 0;
}
Problem1419

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const double eps = 5e-7;
double f[2][N];
int main()
{
	int a,b;
	scanf("%d%d",&a,&b);
	for(int i = 1;i<=a;i++)
	{
		int I = i&1,I_ = (i-1)&1;
		f[I][0] = i;
		for(int j = 1;j<=b;j++)
		f[I][j] = 
			max(0.0,(double)i/(double)(i+j)*(f[I_][j]+1)+(double)j/(double)(i+j)*(f[I][j-1]-1));
	}
	printf("%.6f",f[a&1][b]-eps);
	return 0;
}
Problem1433

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 2e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
queue<int>Q;
int d[N],map[N][N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans=0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF)))
			ans+=nowflow;
	return ans;
}
int is_sch[N];
void debug()
{
	for(int i = 0;i<=7;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].flow);
		printf("\n");
	}
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 1;
}
void work()
{
	init();
	int n,x,num=0;
	scanf("%d",&n);
	int st = 0,end = 2*n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&is_sch[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(is_sch[i])
			{if(!x)add(st,i,1),num++;}
		else if(!is_sch[i])add(st,i,1),num++;
	}
	for(int i = 1;i<= n;i++)if(is_sch[i])add(i+n,end,1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			scanf("%d",&map[i][j]);
			if((map[i][j]&&is_sch[j])||(i==j&&is_sch[i]))
				add(i,j+n,1);
		}
	int ans = dinic(st,end);
	if(ans>=num)printf("^_^\n");
	else printf("T_T\n");
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem1444

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'A')
const int N = 105;
const double eps = 1e-6;
const double EPS = 1e-4;
int p[15],q[15],cnt;
int ch[N][15],n,m,l,pos[N];
char s[15];
int fail[N],danger[N];
void init()
{
	cnt = 1;
	for(int i = 0;i<m;i++)
		ch[0][i] = 1;
}
void insert(int id)
{
	int now = 1,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
		now = ch[now][s(i)];
		i++;
	}
	danger[now] = true;
	pos[id] = now;
}
int Q[N],h,t;
void build()
{
	h = 0,t = -1;
	Q[++t]=1,fail[0]=1;
	while(h<=t)
	{
		int x=Q[h++];
		for(int i = 0;i<m;i++)
		{
			int j = ch[x][i];
			if(j)
			{
				Q[++t] = j;
				int r = fail[x];
				while(!ch[r][i])r = fail[r];
				fail[j] = ch[r][i];
				danger[j]|=danger[fail[j]];
			}
			else ch[x][i] = ch[fail[x]][i];
		}
	}
}
struct Matrix 
{
	int w,h;
	double d[105][105];
	Matrix(){}
	Matrix(int _w,int _h):w(_w),h(_h){memset(d,0,sizeof(d));}
	void operator*=(const Matrix &S)
	{
		Matrix res(w,S.h);
		for(int i = 1;i<=res.w;i++)
			for(int j = 1;j<=res.h;j++)
			{
				res.d[i][j] = 0;
				for(int k = 1;k<=h;k++)
					res.d[i][j]+=d[i][k]*S.d[k][j];
			}
		*this = res;		
	}
};
void debug(const Matrix &f)
{
	for(int i = 1;i<= 6;i++)
	{
		for(int j = 1;j<= 6;j++)
			printf("%5.2f",f.d[i][j]);
		printf("\n");
	}
}
int main()
{
	scanf("%d%d%d",&n,&l,&m);
	for(int i = 0;i< m;i++)
		scanf("%d%d",&p[i],&q[i]);
	init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		insert(i);
	}
	build();
	Matrix f(cnt,cnt);
	for(int i= 1;i<= cnt;i++)
	{
		if(danger[i])
			f.d[i][i]=1;
		else
			for(int j =0;j<m;j++)
				f.d[i][ch[i][j]]+=(double)p[j]/(double)q[j];
	}
	for(int i = 1;i<= 50;i++)
		f*=f;
	for(int i = 1;i<= n;i++)
		printf("%.2f\n",f.d[1][pos[i]]);
	return 0;
}
Problem1452

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 301;
struct T
{
	int c[N][N];
	T()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y,int v)
	{
		for(int i= x;i<N;i+=i&(-i))
			for(int j = y;j<N;j+=j&(-j))
				c[i][j]+=v;
	}
	int getans(int x,int y)
	{
		int ans= 0;
		for(int i= x;i>0;i-=i&(-i))
			for(int j = y;j>0;j-=j&(-j))
				ans+=c[i][j];
		return ans;
	}
}tree[105];
int map[N][N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&map[i][j]);
			tree[map[i][j]].update(i,j,1);
		}
	int q,opt,a,b,c,d,v;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&a,&b,&v);
			tree[map[a][b]].update(a,b,-1);
			tree[v].update(a,b,1);
			map[a][b] = v;
		}else
		{
			int ans = 0;
			scanf("%d%d%d%d%d",&a,&b,&c,&d,&v);
			ans = ans+tree[v].getans(b,d);
			ans = ans-tree[v].getans(b,c-1);
			ans = ans-tree[v].getans(a-1,d);
			ans = ans+tree[v].getans(a-1,c-1);
			printf("%d\n",ans);
		}
	}
	return 0;
}
Problem1457

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int P = 105;
const int C = 10005;
const int N = 1005;
int sg[P][P];
int vis[C];
void Init()
{
	int cnt = 0;
	for(int i = 1;i<= 100;i++)
		for(int j = 1;j<=100;j++)if(i!=j)
		{
			++cnt;
			for(int k = 1;k<i;k++)if(j!=(i-k))vis[sg[i-k][j]]=cnt;
			for(int k = 1;k<j;k++)if(i!=(j-k))vis[sg[i][j-k]]=cnt;
			for(int k = min(i,j)-1;k>=1;k--)vis[sg[i-k][j-k]]=cnt;
			for(int k = 0;k<C;k++)
				if(vis[k]!=cnt)
					{sg[i][j]=k;break;}
		}
}
int main()
{
	Init();
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		bool flag = false;
		int n,x,y,ans = 0;
		scanf("%d",&n);
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d",&x,&y);
			if(!x || !y|| x==y)flag = true;
				ans^=sg[x][y];
		}
		if(flag)printf("^o^\n");
		else 
		{
			if(ans>0)printf("^o^\n");
			else printf("T_T\n");
		}
	}
	return 0;
}
Problem1458

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e4+5;
const int M = 8e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
}
queue<int>Q;
int d[N],st,end;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int r[105],c[105],map[105][105];
int R[105],C[105];
int main()
{
	int m,n,k;
	scanf("%d%d%d",&m,&n,&k);
	int st = 0,end = n*m+1;
	for(int i = 1;i<= m;i++)r[i]=n,scanf("%d",&R[i]);
	for(int i = 1;i<= n;i++)c[i]=m,scanf("%d",&C[i]);
	int x,y;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y]++;
		r[x]--;c[y]--;
	}
	int ans = 0;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			if(!map[i][j])
				ans++,add(i,j+m,1);
	for(int i = 1;i<=m;i++)if(r[i]<R[i]){printf("JIONG!\n");return 0;}
	for(int i = 1;i<=n;i++)if(c[i]<C[i]){printf("JIONG!\n");return 0;}
	for(int i = 1;i<=m;i++)add(st,i,r[i]-R[i]);
	for(int i = 1;i<=n;i++)add(i+m,end,c[i]-C[i]);
	ans-=dinic(st,end);
	//for(int i = head[0];i;i=e[i].next)
	//	if(e[i].flow)
	//		{printf("JIONG!\n");return 0;}
	printf("%d\n",ans);
	return 0;
}
Problem1484

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 5005;
const int INF = 0x7f7f7f7f;
LL a[N],b[N];
LL Abs(LL a){return a>0?a:-a;}
void work()
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	int n,d;
	scanf("%d%d",&n,&d);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	if(Abs(a[n]-a[1])>(LL)(n-1)*d){printf("impossible\n");return ;}
	b[1]=a[1];
	for(int i = 2;i<= n;i++)
		b[i] = b[i-1]-d;
	LL s,x,delta,minx,tmp;
	while(a[n]!=b[n])
	{
		s = 0,minx = INF;
		delta = INF,tmp = -INF;
		for(int i=n;i>1;i--)
		{
			if(a[i]>b[i])s++,minx = min(minx,a[i]-b[i]);
			else s--;
			if(tmp<s&&b[i-1]+d>b[i])
				tmp = s,x = i,delta = minx;
		}
		delta = min(delta,b[x-1]+d-b[x]);
		for(int i = x;i<= n;i++)b[i]+=delta;
	}
	LL ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=Abs(b[i]-a[i]);
	printf("%lld\n",ans);
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)work();
	return 0;
}
Problem1491

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
double map[N][N],sol[N][N];
double imp[N];
int main()
{
	for(int i = 1;i<N;i++)
		for(int j = 1;j<N;j++)
			map[i][j] = 1e9;
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		map[x][y] = map[y][x] = c;
		sol[x][y] = sol[y][x] = 1;
	}
	for(int k = 1;k<= n;k++)
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= n;j++)
			{
				if(i==j||j==k||i==k)continue;
				if(map[i][k]+map[k][j]<map[i][j])
				{
					map[i][j] = map[i][k]+map[k][j];
					sol[i][j] = sol[i][k]*sol[k][j];
				}else if(map[i][k]+map[k][j]==map[i][j])
					sol[i][j]+=sol[i][k]*sol[k][j];
			}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int v = 1;v<= n;v++)
			{
				if(i==j||j==v||i==v)continue;
				if(map[i][v]+map[v][j]!=map[i][j]||sol[i][j]<=0)continue;
				imp[v] += sol[i][v]*sol[v][j]/sol[i][j];
			}
	for(int i = 1;i<= n;i++)
		printf("%.3f\n",imp[i]);
	return 0;
}
Problem1492

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef double db;
typedef pair<db,db>PA;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
db f[N];
struct P
{
	db a,b,rate,slope;
	int pos;
	bool operator<(const P &s)const
	{
		return slope<s.slope;
	}
}q[N],nq[N];
PA p[N],np[N];
int st[N],top,n;
double getslope(PA x,PA y)
{
	if(x.first==y.first)
		return y.second>=x.second?INF:-INF;
	return (y.second-x.second)/(y.first-x.first);
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)
	{
		f[mid] = max(f[mid],f[mid-1]);
		p[mid].first = f[mid]/(q[mid].a+q[mid].b/q[mid].rate);
		p[mid].second = f[mid]/(q[mid].a*q[mid].rate+q[mid].b);
		return ;
	}
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if(q[i].pos<=mid)
			nq[l1++] = q[i];
		else nq[l2++] = q[i];
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	CDQ(l,mid);
	top = 0;
	for(int i = l;i<= mid;i++)
	{
		while(top>1&&getslope(p[st[top-1]],p[st[top]])<getslope(p[st[top]],p[i]))
			st[top--] = 0;
		st[++top] = i;
	}
	for(int i = mid+1;i<= r;i++)
	{
		while(top>1&&getslope(p[st[top-1]],p[st[top]])<q[i].slope)
			st[top--] =0;
		f[q[i].pos] = max(f[q[i].pos],q[i].a*p[st[top]].first+q[i].b*p[st[top]].second);
	}
	CDQ(mid+1,r);
	l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if((p[l1]<p[l2]||l2>r)&&l1<=mid)
			np[i] = p[l1++];
		else np[i] = p[l2++];
	memcpy(p+l,np+l,sizeof(p[0])*(r-l+1));
}
int main()
{
	scanf("%d%lf",&n,&f[0]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf%lf",&q[i].a,&q[i].b,&q[i].rate);
		q[i].slope = -q[i].a/q[i].b;
		q[i].pos = i;
	}
	sort(q+1,q+n+1);
	CDQ(1,n);
	printf("%.3lf",f[n]);
	return 0;
}
Problem1493

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
int n,m;
struct col_seg
{
	int cnt,lc,rc;
	col_seg(int x)
	{
		cnt = 1;
		if(!x)
			cnt = 0;
		lc = rc = x;
	}
	col_seg();
	col_seg uni(col_seg x,col_seg y)
	{
		col_seg re(0);
		re.lc = x.lc?x.lc:y.lc;
		re.rc = y.rc?y.rc:x.rc;
		re.cnt = x.cnt+y.cnt-(x.rc==y.lc);
		return re;
	}
};
col_seg operator + (const col_seg x,const col_seg y)
{
	col_seg re(0);
	re.lc = x.lc?x.lc:y.lc;
	re.rc = y.rc?y.rc:x.rc;
	re.cnt = x.cnt+y.cnt-(x.rc==y.lc);
	return re;
}
struct Splay
{
	int num,size;
	Splay *ls,*rs,*fa;
	col_seg *col;
	int lazy_r,lazy_c;
	Splay(int x);
	void push_up();
	void push_down();
}*null = new Splay(0),*root = null;
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	num = x;
	size = x?1:0;
	lazy_r = lazy_c = 0;
	col = new col_seg(x);
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	*col = (*ls->col)+col_seg(num)+(*rs->col);
}
void Splay :: push_down()
{
	if(lazy_r)
	{
		ls->lazy_r ^= 1;
		rs->lazy_r ^= 1;
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		swap(ls->col->lc,ls->col->rc);
		swap(rs->col->lc,rs->col->rc);
		lazy_r = 0;
	}
	if(lazy_c)
	{
		if(ls!=null)
		{	
			ls->num = ls->lazy_c = lazy_c;
			*ls->col = col_seg(lazy_c);
		}
		if(rs!=null)
		{
			rs->num = rs->lazy_c = lazy_c;
			*rs->col = col_seg(lazy_c);
		}
		lazy_c = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	x->push_down();
	y->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
void R()
{
	int x;
	scanf("%d",&x);
	Find(root,n-x+1,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
	Find(root,1,null);
	Find(root,2,root);
	root->rs->ls = tmp;
	tmp->fa = root->rs;
	root->rs->push_up();
	root->push_up();
}
void F()
{
	Find(root,2,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	tmp->lazy_r ^= 1;
	swap(tmp->ls,tmp->rs);
	swap(tmp->col->lc,tmp->col->rc);
}
void S()
{
	int x,y;
	scanf("%d%d",&x,&y);
	if(x==y)return ;
	else if(x>y)swap(x,y);
	Find(root,x+1,null);
	Find(root,y+1,root);
	swap(root->rs->num,root->num);
}
void P()
{
	int x,y,z;
	scanf("%d%d%d",&x,&y,&z);
	if(x<=y)
	{
		Find(root,x,null);
		Find(root,y+2,root);
		Splay *tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
	}else
	{
		Find(root,x,null);
		Find(root,n+2,root);
		Splay *tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
		Find(root,1,null);
		Find(root,y+2,root);
		tmp = root->rs->ls;
		tmp->num = tmp->lazy_c = z;
		*tmp->col = col_seg(z);
	}
}
void C()
{
	Find(root,1,null);
	Find(root,n+2,root);
	Splay *tmp = root->rs->ls;
	int z = tmp->col->cnt-(tmp->col->lc==tmp->col->rc);
	if(!z)z++;
	printf("%d\n",z);
}
void CS()
{
	int x,y;
	scanf("%d%d",&x,&y);
	if(x<=y)
	{
		Find(root,x,null);
		Find(root,y+2,root);
		Splay *tmp = root->rs->ls;
		printf("%d\n",tmp->col->cnt);
	}
	else
	{
		Find(root,x,null);
		Find(root,n+2,root);
		Splay *tmp = root->rs->ls;
		col_seg stmp = *tmp->col;
		Find(root,1,null);
		Find(root,y+2,root);
		tmp = root->rs->ls;
		stmp = stmp+(*tmp->col);
		printf("%d\n",stmp.cnt);
	}
}
int main()
{
	int x,c;
	char opt[10];
	scanf("%d%d",&n,&c);
	Insert(root,Inv,null);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	Insert(root,Inv,null);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='R')R();
		else if(opt[0]=='F')F();
		else if(opt[0]=='S')S();
		else if(opt[0]=='P')P();
		else if(opt[0]=='C'&&!opt[1])C();
		else CS();
	}
	return 0;
}
Problem1497

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
const int M = 4e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF)))
			ans+=nowflow;
	return ans;
}
int p[N];
int main()
{
	int n,m,sum=0;
	scanf("%d%d",&n,&m);
	int s = 0,end = n+m+1;
	for(int i = 1;i<= n;i++)scanf("%d",&p[i]);
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		sum+=z;
		add(s,i+n,z);
		add(i+n,x,INF),add(i+n,y,INF);
	}
	for(int i = 1;i<= n;i++)
		add(i,end,p[i]);
	printf("%d\n",sum-dinic(s,end));
	return 0;
}
Problem1499

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int INF = 0x3f3f3f3f;
using namespace std;
const int N = 205;
struct pos{
	int x,y;
	pos(int a,int b){x = a;y = b;}
	pos(){}
};
int f[N][N],g[N][N],L,R;
char map[N][N];
pos line[N];
int n,m;
int dis(pos t,pos z)
{
	return abs(t.x-z.x)+abs(t.y-z.y);
}
int getans(pos t,int len)
{
	while(L<=R&&dis(t,line[L])>len)L++;
	if(L>R)return -INF;
	return f[line[L].x][line[L].y]+dis(t,line[L]);
}
void Insert(pos t)
{
	while(L<=R&&dis(t,line[R])<=f[t.x][t.y]-f[line[R].x][line[R].y])R--;
	line[++R] = t;
}
void go_up(int lth)
{
	for(int j = 1;j<= m;j++) 
	{
		L = 1,R = 0;
		for(int i = n;i;i--)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_down(int lth)
{
	for(int j = 1;j<= m;j++)
	{
		L = 1,R = 0;
		for(int i = 1;i<= n;i++)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_left(int lth)
{
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = 0;
		for(int j = m;j;j--)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
void go_right(int lth)
{
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = 0;
		for(int j = 1;j<=m;j++)
		{
			if(map[i][j]=='.')
			{
				pos tmp(i,j);
				g[i][j] = max(f[i][j],getans(tmp,lth));
				Insert(tmp);
			}else
			{L = 1,R = 0;}
		}
	}
	memcpy(f,g,sizeof(f));
}
int main()
{
	int sx,sy,t,x,y,z;
	scanf("%d%d%d%d%d",&n,&m,&sx,&sy,&t);
	for(int i = 1;i<= n;i++)
		scanf("%s",map[i]+1);
	memset(f,128,sizeof(f));
	memset(g,128,sizeof(g));
	f[sx][sy] = 0;
	for(int i = 1;i<= t;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(z==1)go_up(y-x+1);
		else if(z==2)go_down(y-x+1);
		else if(z==3)go_left(y-x+1);
		else go_right(y-x+1);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			ans = max(ans,f[i][j]);
	printf("%d\n",ans);
	return 0;
}
Problem1500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Minm = 0xefefefef;
const int Inv = 20000307;
struct Max_s
{
	int l_max,r_max,all_max,sum;
	void init(int x,int y)
	{
		if(x>0)l_max = r_max = all_max = sum = x*y;
		else
		{
			l_max = r_max = all_max = x;
			sum = x*y;
		}
	}
	void uni(const Max_s &x,const Max_s &y)
	{
		all_max = max(x.all_max,y.all_max);
		all_max = max(all_max,x.r_max+y.l_max);
		l_max = max(x.l_max,x.sum+y.l_max);
		r_max = max(y.r_max,y.sum+x.r_max);
		sum = x.sum+y.sum;
	}
};
struct Splay
{
	Splay *ls,*rs,*fa;
	int size,num,max_num;
	int lazy_c,lazy_r;
	Max_s ms;
	Splay(int x);
	Splay();
	void push_up();
	void push_down();
}*null = new Splay(),*root = null,*Z,*tmp;
int Y;
Splay :: Splay ()
{
	num = max_num = Minm;
	size = 0;
	fa = ls = rs = this;
	ms.init(Minm,0);
}
Splay :: Splay (int x)
{
	num = max_num = x;
	size = 1;
	ls = rs = fa = null;
	ms.init(x,1);
	lazy_c = Inv,lazy_r = 0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
	max_num = max(max(ls->max_num,rs->max_num),num);
	ms.init(num,1);
	ms.uni(ls->ms,ms);
	ms.uni(ms,rs->ms);
}
void Splay :: push_down()
{
	if(this==null)return ;
	else
	{
		if(lazy_c!=Inv)
		{
			ls->lazy_c = rs->lazy_c = lazy_c;
			ls->num = ls->max_num = lazy_c;
			rs->num = rs->max_num = lazy_c;
			ls->ms.init(lazy_c,ls->size);
			rs->ms.init(lazy_c,rs->size);
			lazy_c = Inv;
		}
		if(lazy_r!=0)
		{
			ls->lazy_r^=1;
			rs->lazy_r^=1;
			swap(ls->ls,ls->rs);
			swap(rs->ls,rs->rs);
			swap(ls->ms.l_max,ls->ms.r_max);
			swap(rs->ms.l_max,rs->ms.r_max);
			lazy_r = 0;
		}
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x)
{
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==Z)break;
		if(z==Z)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(x);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(x);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x)
{
	while(true)
	{
		x->push_down();
		if(Y<=x->ls->size)x = x->ls;
		else
		{
			Y-=x->ls->size;
			if(Y==1)break;
			Y--;
			x = x->rs;
		}
	}
	splay(x);
}
void Insert(Splay *&x,int y,Splay *from)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = from;
		Z = null;
		splay(x);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
void Free(Splay *x)
{
	if(x==null)return ;
	Free(x->ls);
	Free(x->rs);
	free(x);
}
void INSERT()
{
	int tot,pos;
	scanf("%d%d",&pos,&tot);
	Y = pos+1;Z = null;Find(root);
	Y = pos+2;Z = root;Find(root);
	tmp = root;root = null;
	int x;
	for(int i = 1;i<= tot;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	tmp->rs->ls = root;
	root->fa = tmp->rs;
	root = tmp;
	root->rs->push_up();
	root->push_up();
}
void DELETE()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	tmp = root->rs->ls;
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
	Free(tmp);
}
void update()
{
	int pos,tot,c;
	scanf("%d%d%d",&pos,&tot,&c);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	root->rs->ls->lazy_c = c;
	tmp = root->rs->ls;
	tmp->num = tmp->max_num = c;
	tmp->ms.init(c,tmp->size);
	root->rs->push_up();
	root->push_up();
}
void reverse()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	tmp = root->rs->ls;
	tmp->lazy_r ^=1;
	swap(tmp->ls,tmp->rs);
	swap(tmp->ms.l_max,tmp->ms.r_max);
}
void get_sum()
{
	int pos,tot;
	scanf("%d%d",&pos,&tot);
	Y = pos;Z = null;Find(root);
	Y = pos+tot+1;Z = root;Find(root);
	printf("%d\n",root->rs->ls->ms.sum);
}
void get_max()
{
	Y = 1;Z = null;Find(root);
	Y = root->size;Z = root;Find(root);
	printf("%d\n",root->rs->ls->ms.all_max);
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	Insert(root,0,null);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		Insert(root,x,null);
	}
	char opt[20];
	Insert(root,0,null);
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='G')get_sum();
		else if(opt[0]=='I')INSERT();
		else if(opt[0]=='D')DELETE();
		else if(opt[0]=='R')reverse();
		else
		{
			if(opt[2]=='K')update();
			else get_max();
		}
	}
	return 0;
}
/*
那时候，日子也正长
过了今天，还有明天，过了今年，还有明年。
过了春还有夏，过了秋还有冬。
过了冬又能望见来年春到,依旧桃花满梢油菜黄。
*/
Problem1500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define maxn 1001000
#define inf 2147483646
using namespace std;
int c[maxn][2],fa[maxn];
int a[maxn],key[maxn],sum[maxn],la[maxn],ra[maxn],ma[maxn],cov[maxn],size[maxn];
int q[maxn];
bool rev[maxn];
int n,m,tot,num,rot,st,ed,tail;

void update(int x)
{
        if (!x) return;
        la[x]=max(la[c[x][0]],sum[c[x][0]]+key[x]+max(0,la[c[x][1]]));
        ra[x]=max(ra[c[x][1]],sum[c[x][1]]+key[x]+max(0,ra[c[x][0]]));
        ma[x]=max(max(ma[c[x][0]],ma[c[x][1]]),key[x]+max(0,ra[c[x][0]])+max(0,la[c[x][1]]));
        sum[x]=sum[c[x][0]]+sum[c[x][1]]+key[x];
        size[x]=size[c[x][0]]+size[c[x][1]]+1;
}

void reverse(int x)
{
        if (!x) return;
        swap(c[x][0],c[x][1]);
        swap(la[x],ra[x]);
        rev[x]^=1;
}

void recover(int x,int z)
{
        if (!x) return ;
        key[x]=cov[x]=z;
        sum[x]=size[x]*z;
        la[x]=ra[x]=ma[x]=max(z,sum[x]);
}

void down(int x)
{
        if (!x) return;
        if (rev[x])
        {
                reverse(c[x][0]);
                reverse(c[x][1]);
                rev[x]=0;
        }
        if (cov[x]!=-inf)
        {
                recover(c[x][0],cov[x]);
                recover(c[x][1],cov[x]);
                cov[x]=-inf;
        }
}

void relax(int x,int rot)
{
        if (x!=rot) relax(fa[x],rot);
        down(x);
}

void rotate(int x,int &rot)
{
        int y=fa[x],z=fa[y];
        int p=(c[y][1]==x),q=p^1;
        if (y==rot) rot=x; 
        else if (c[z][0]==y) c[z][0]=x; else c[z][1]=x;
        fa[x]=z; fa[y]=x; fa[c[x][q]]=y;
        c[y][p]=c[x][q]; c[x][q]=y;
        update(y);
}

void splay(int x,int &rot)
{
        relax(x,rot);
        while (x!=rot)
        {
                int y=fa[x], z=fa[y];
                if (y!=rot)
                        if ((c[y][0]==x)xor(c[z][0]==y)) rotate(x,rot); 
                    else rotate(y,rot);
                rotate(x,rot);
        }
        update(x);
}

int pick()
{
        if (tail) return q[tail--];
        else return ++num;
}

int setup(int x)
{
        int t=pick();
        key[t]=a[x];
        cov[t]=-inf;
        rev[t]=0;
        la[t]=ra[t]=ma[t]=-inf;
        return t;
}

int build(int l,int r)
{
        int mid=(l+r)>>1,left=0,right=0;
        if (l<mid)      left=build(l,mid-1);
        int t=setup(mid);
        if (r>mid)      right=build(mid+1,r);
        if (left)       c[t][0]=left,fa[left]=t;
        if (right)c[t][1]=right,fa[right]=t;
        update(t);
        return t;
}

int find(int t,int k)
{
        down(t);
        if (k==size[c[t][0]]+1) return t;
        if (k<size[c[t][0]]+1) return find(c[t][0],k);
        if (k>size[c[t][0]]+1) return find(c[t][1],k-size[c[t][0]]-1);
}

void del(int &x)
{
        if (!x) return;
        q[++tail]=x;
        fa[x]=0;
        del(c[x][0]);
        del(c[x][1]);
        la[x]=ra[x]=ma[x]=-inf;
        x=0;
}

int main()
{
        scanf("%d %d",&n,&m);
        for (int i=2;i<=n+1;i++)
        {
                scanf("%d",&a[i]);      
        }
        a[st=1]=0; a[ed=n+2]=0;
        ra[0]=la[0]=ma[0]=-inf;
        rot=build(1,n+2);
        char sign[20];
        int x,y,l,r,z,ans;
        for (int i=1;i<=m;i++)
        {
                scanf("%s",&sign);
                if (sign[0]=='I')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x+1); r=find(rot,x+2);
                        splay(r,rot); splay(l,c[rot][0]);
                        for (int j=1;j<=y;j++) 
                                scanf("%d",&a[j]);
                        int tmp=build(1,y);
                        fa[tmp]=l; c[l][1]=tmp;                 
                        update(l); update(r);
                }
                if (sign[0]=='D')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x);  r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        del(c[l][1]);
                        update(l); update(r);
                }                       
                if (sign[0]=='M'&&sign[2]=='K')
                {
                        scanf("%d %d %d",&x,&y,&z);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        recover(c[l][1],z);
                }
                if (sign[0]=='R')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        reverse(c[l][1]);
                }
                if (sign[0]=='G')
                {
                        scanf("%d %d",&x,&y);
                        l=find(rot,x); r=find(rot,x+y+1);
                        splay(r,rot); splay(l,c[rot][0]);
                        ans=sum[c[l][1]];
                        printf("%d\n",ans);
                }
                if (sign[0]=='M'&&sign[2]=='X')
                {
                        splay(ed,rot); splay(st,c[rot][0]);
                        ans=ma[c[st][1]];
                        printf("%d\n",ans);
                }
        }
        return 0;
}
Problem1503

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Treap
{
	Treap *ls,*rs;
	int val,size,cnt,key;
	Treap(){}
	Treap(int x)
	{
		ls = rs = NULL;
		val = x;
		size = cnt = 1;
		key = rand();
	}
	void push_up()
	{
		size = cnt;
		if(ls)size+=ls->size;
		if(rs)size+=rs->size;
	}
}*root = NULL;
int DEC = 0,PER = 0,go_away;
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs= y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x= y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&now,int x)
{
	if(!now) {now = new Treap(x);return ;}
	if(now->val==x)now->cnt++;
	else if(x<now->val)
	{
		Insert(now->ls,x);
		if(now->ls->key > now->key)
			go_right(now);
	}
	else 
	{
		Insert(now->rs,x);
		if(now->rs->key > now->key)
			go_left(now);
	}
	now->push_up();
}
int Delete(Treap *&now,int x)
{
	int ans = 0;
	if(!now)return 0;
	if(now->val+DEC>=x)
	{
		ans = Delete(now->ls,x);
		now->size-=ans;
	}
	else
	{
		if(now->ls)ans+=now->ls->size;
		ans+= now->cnt;
		now = now->rs;
		ans=ans+Delete(now,x);
	}		
	if(now)now->push_up();
	return ans;
}
int get_rank(Treap *x,int k)
{
	if(x->ls!=NULL&&k<=x->ls->size)return get_rank(x->ls,k);
	if(x->ls!=NULL)k-=x->ls->size;
	if(k<=x->cnt)return x->val;
	k-=x->cnt;
	return get_rank(x->rs,k);
}
int main()
{
	int n,Min,k;
	scanf("%d%d",&n,&Min);
	char ju[3];
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",ju,&k);
		if(ju[0]=='I')
		{
			if(k>=Min)
				Insert(root,k-DEC);
		}else if(ju[0]=='A')DEC+=k;
		else if(ju[0]=='S')
		{
			DEC-=k;
			int tmp = Delete(root,Min);
			go_away+=tmp;
		}
		else 
		{
			if(root==NULL||k>root->size)printf("-1\n");
			else printf("%d\n",get_rank(root,root->size-k+1)+DEC);
		}
	}
	printf("%d\n",go_away);
	return 0;
}
Problem1505

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 101;
const int INF = 1e9;
double g[N][N],f[N][N][N];
int l_k[N][N][N],l_j[N][N][N];
int main()
{
	double k1,k2;
	int n,m;
	scanf("%lf%lf%d%d",&k1,&k2,&m,&n);
	for(int i = 0;i<N;i++)
		for(int j = 0;j<N;j++)
			g[i][j] = INF;
	for(int i = 0;i<N;i++)
		for(int j = 0;j<N;j++)
			for(int k = 0;k<N;k++)
				f[i][j][k] = INF;
	g[0][0] = 0;
	for(int i = 1;i<= 100;i++)
		for(int j = 1;j<= i;j++)
			for(int k = j-1;k<i;k++)
				g[i][j] = min(g[i][j],g[k][j-1]+(double)(i-k)*(i-k)*k2);
	f[0][0][0] = 0;
	for(int k = 1;k<= 100;k++)
		for(int i = 1;i<= m;i++)
			for(int j = 1;j<= n;j++)
				for(int lk = l_k[k][i-1][j];lk<k;lk++)
					for(int lj = l_j[k][i-1][j];lj<j;lj++)
						if(f[lk][i-1][lj]+(k-lk)*(k-lk)*k1+g[k-lk][j-lj]<f[k][i][j])
						{
							f[k][i][j] = f[lk][i-1][lj]+(double)(k-lk)*(k-lk)*k1+g[k-lk][j-lj];
							l_k[k][i][j] = lk;
							l_j[k][i][j] = lj;
						}
	printf("%.1f\n",f[100][m][n]);
	return 0;
}
Problem1507

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Splay
{
	Splay *ls,*rs,*fa;
	char c;
	int size;
	Splay(char S);
	void push_up();
}*null =new Splay(0),*root = null;
Splay :: Splay (char S)
{
	ls = rs = fa = null;
	c = S;
	size = c?1:0;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
char s[1<<21];
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = new Splay(s[mid]);
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)
		x->ls->fa = x;
	if(x->rs!=null)
		x->rs->fa = x;
	x->push_up();
}
int now;
void print(Splay *x)
{
	if(x==null)return ;
	print(x->ls);
	putchar(x->c);
	print(x->rs);
}
int main()
{
	int m,x;
	char opt[105];
	scanf("%d",&m);
	root = new Splay('\n');
	root->rs = new Splay('\n');
	root->rs->fa = root;
	root->push_up();
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d",&x);
			for(int j= 0;j<x;j++)
			{
				do s[j] = getchar();while(s[j]<32||s[j]>126);
			}
			Find(root,now+1,null);
			Find(root,now+2,root);
			build(root->rs->ls,0,x-1);
			root->rs->ls->fa = root->rs;
			root->rs->push_up();
			root->push_up();
		}
		else if(opt[0]=='D')
		{
			scanf("%d",&x);
			Find(root,now+1,null);
			Find(root,min(now+2+x,root->size),root);
			root->rs->ls = null;
			root->rs->push_up();
			root->push_up();
		}
		else if(opt[0]=='G')
		{
			scanf("%d",&x);
			Find(root,now+1,null);
			Find(root,min(now+2+x,root->size),root);
			print(root->rs->ls);
			puts("");
		}
		else if(opt[0]=='M')
			scanf("%d",&now);
		else if(opt[0]=='P')
			now--;
		else now++;
	}
	return 0;
}
Problem1512

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+100;
const int M = 1e6+100;
const int INF = 36500;
struct E
{int next,to;};
bool v[N],ins[N],tag[N];
int stack[N],dep[N],low[N],dfn,bel[N],scc,top;
int ind[N],f[N];
queue<int>Q;
struct G
{
	int head[N],tot;
	E e[N];
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}	
	void tarjan(int x)
	{
		v[x] = ins[x] = true;
		stack[++top] = x;
		dep[x] = low[x] = ++dfn;
		for(int i = head[x];i;i = e[i].next)
		{
			if(!v[e[i].to])
				{tarjan(e[i].to);low[x] = min(low[x],low[e[i].to]);}
			else if(ins[e[i].to])
				{low[x] = min(low[x],dep[e[i].to]);}
		}
		if(dep[x]==low[x])
		{
			scc++;
			int tmp = -1;
			do
			{
				tmp = stack[top--];
				ins[tmp] = false;
				bel[tmp] = scc;
			}while(tmp!=x);
		}
	}
	void topo(int n)
	{
		f[bel[n+1]] = 1;
		if(tag[bel[n+1]])f[bel[n+1]]+=INF;
		for(int i = 1;i<= scc;i++)
			if(ind[i]==0)
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i = e[i].next)
			{
				f[e[i].to]+=f[x];
				if(f[e[i].to]>INF)f[e[i].to]=INF+1;
				if(!--ind[e[i].to])
				{
					if(tag[e[i].to]&&f[e[i].to]>0)f[e[i].to] = INF+1;
					Q.push(e[i].to);
				}
			}
		}
	}
}g1,g2;
void rebuild(int n)
{
	for(int i = 1;i<= n+1;i++)
	{
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			int u = i,t = g1.e[j].to;
			if(bel[u]==bel[t]){tag[bel[u]] = true;continue;}
			g2.add(bel[u],bel[t]);
			ind[bel[t]]++;
		}
	}
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		g1.add(y,x);
	}
	for(int i = 1;i<= n+1;i++)
		if(!v[i])
			g1.tarjan(i);
	rebuild(n);
	g2.topo(n);
	int maxn = 0;
	for(int i = 1;i<= n;i++)
		if(f[bel[i]]>maxn)
			maxn = f[bel[i]];
	if(maxn>36500)printf("zawsze\n");
	else printf("%d\n",maxn);
	top = 0;
	for(int i = 1;i<= n;i++)
		if(f[bel[i]]==maxn)
			stack[++top] = i;
	printf("%d\n",top);
	for(int i = 1;i<= top;i++)
		printf("%d ",stack[i]);
	printf("\n");
	return 0;
}
Problem1513

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e3+5;
int S,D,lx,rx,sy,xy;
struct X_seg
{
	int val[N],lazy[N];
	void update(int p,int l,int r,int a,int b,int k)
	{
		val[p] = max(val[p],k);
		if(l>=a&&r<=b){lazy[p] = max(lazy[p],k);return ;}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,k);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,k);
	}
	int getans(int p,int l,int r,int a,int b)
	{
		if(l>=a&&r<=b)return val[p];
		int mid = (l+r)>>1;
		int ans = lazy[p];
		if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
		if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
		return ans;
	}
};
struct Y_seg
{
	X_seg val[N],lazy[N];
	void update(int p,int l,int r,int a,int b,int y)
	{
		val[p].update(1,1,S,xy,sy,y);
		if(l>=a&&r<=b){lazy[p].update(1,1,S,xy,sy,y);return ;}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,y);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,y);
	}
	int getans(int p,int l,int r,int a,int b)
	{
		if(l>=a&&r<=b)return val[p].getans(1,1,S,xy,sy);
		int mid = (l+r)>>1;
		int ans = lazy[p].getans(1,1,S,xy,sy);
		if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
		if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
		return ans;
	}
}M;
int main()
{
	int n,d,s,x,y,t;
	scanf("%d%d%d",&D,&S,&n);
	for(int i =1;i<= n;i++)
	{
		scanf("%d%d%d%d%d",&d,&s,&t,&x,&y);
		lx = x+1,rx = x+d,xy = y+1,sy = y+s;
		int ans = M.getans(1,1,D,lx,rx);
		M.update(1,1,D,lx,rx,ans+t);
	}
	xy = 1,sy = S;
	printf("%d\n",M.getans(1,1,D,1,D));
	return 0;
}
Problem1529

#include <stdio.h> 
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int main()
{
	int n,x;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)fa[i] = i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		uni(x,i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i)
			ans++;
	printf("%d\n",ans);
	return 0;
}
Problem1537

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct P
{int x,y,p;}pos[N];
int id[N],n,m,k,f[N];
bool cmp(P a,P b)
{
	if(a.y!=b.y)
		return a.y<b.y;
	return a.x<b.x;
}
struct Tree
{
	int c[N];
	Tree()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			c[i] = max(c[i],y);
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans = max(ans,c[i]);
		return ans;
	}
}C;
int find(int x)
{
	int l = 1,r = k+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l= mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%d",&pos[i].x,&pos[i].y,&pos[i].p);
		id[i] = pos[i].x;
	}
	sort(id+1,id+k+1);
	sort(pos+1,pos+k+1,cmp);
	int ans = 0;
	for(int i = 1;i<= k;i++)
	{
		f[i] = C.getans(find(pos[i].x))+pos[i].p;
		ans = max(ans,f[i]);
		C.update(find(pos[i].x),f[i]);
	}
	printf("%d\n",ans);
	return 0;
}
Problem1552

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#define pa pair<int,int>
#define inf 1000000000
#define ll long long 
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,root,top;
int ans[100005],s[100005];
int fa[100005],c[100005][2];
int v[100005],mn[100005],size[100005],pos[100005];
bool rev[100005];
struct data{int pos,v;}a[100005];
inline bool operator<(const data &a,const data &b)
{return a.pos<b.pos;}
inline bool cmp(const data &a,const data &b)
{return a.v<b.v||(a.v==b.v&&a.pos<b.pos);}
void update(int x)
{
	int l=c[x][0],r=c[x][1];
	mn[x]=v[x];pos[x]=x;
	if(mn[l]<mn[x]){mn[x]=mn[l];pos[x]=pos[l];}
	if(mn[r]<mn[x]){mn[x]=mn[r];pos[x]=pos[r];}
	size[x]=size[l]+size[r]+1;
}
void pushdown(int x)
{
    int l=c[x][0],r=c[x][1];
	rev[x]^=1;rev[l]^=1;rev[r]^=1;
	swap(c[x][0],c[x][1]);
}
void rotate(int x,int &k)
{
    int y=fa[x],z=fa[y],l,r;
    if(c[y][0]==x)l=0;else l=1;r=l^1;
    if(y==k)k=x;
    else {if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
    fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
    c[y][l]=c[x][r];c[x][r]=y;
    update(y);update(x);
}
void splay(int x,int &k)
{
	top=0;s[++top]=x;
    for(int i=x;fa[i];i=fa[i])
        s[++top]=fa[i];
    for(int i=top;i;i--)
        if(rev[s[i]])pushdown(s[i]);
    while(x!=k)
    {
        int y=fa[x],z=fa[y];
        if(y!=k)
        {    
            if(c[y][0]==x^c[z][0]==y)
                rotate(x,k);
            else rotate(y,k);
        }
        rotate(x,k);
    }
}
int find(int x,int rk)
{
	if(rev[x])pushdown(x);
	int l=c[x][0],r=c[x][1];
	if(size[l]+1==rk)return x;
	else if(size[l]>=rk)return find(l,rk);
	else return find(r,rk-size[l]-1);
}
int querymn(int L,int R)
{
	int x=find(root,L),y=find(root,R+2);
	splay(x,root);splay(y,c[x][1]);
	int z=c[y][0];
	return pos[z];
}
void rever(int L,int R)
{
	int x=find(root,L),y=find(root,R+2);
	splay(x,root);splay(y,c[x][1]);
	int z=c[y][0];
	rev[z]^=1;
}
void build(int l,int r,int f)
{
	if(l>r)return;
	if(l==r)
	{
		fa[l]=f;size[l]=1;
		mn[l]=v[l]=a[l].v;pos[l]=l;
		if(l<f)c[f][0]=l;
		else c[f][1]=l;
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid-1,mid);build(mid+1,r,mid);
	fa[mid]=f;v[mid]=a[mid].v;update(mid);
	if(mid<f)c[f][0]=mid;
	else c[f][1]=mid;
}
int main()
{
    n=read();
    a[1].v=a[n+2].v=inf;mn[0]=inf;
	for(int i=2;i<=n+1;i++)
	{
		scanf("%d",&a[i].v);
		a[i].pos=i;
	}
	sort(a+2,a+n+2,cmp);
	for(int i=2;i<=n+1;i++)a[i].v=i-1;
	sort(a+2,a+n+2);
	build(1,n+2,0);
	root=(n+3)>>1;
	for(int i=1;i<=n;i++)
	{
		int x=querymn(i,n);
		splay(x,root);
		ans[i]=size[c[x][0]];
		rever(i,ans[i]);
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d",ans[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem1565

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1,ind[N],d[N],f[N];
int ans,m,n,st,end;
bool Can[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
	ind[x]++;
}
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i].flow&&d[e[i].to]==-1&&Can[e[i].to])
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int dinic(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow&&last)
		{
			int tof = dinic(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}else d[e[i].to]=-1;
		}
	d[s] = -1;
	return mf-last;
}
int get_maxflow(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=dinic(s,t,INF);
	return ans;
}
void topo()
{
	for(int i = st;i<=end;i++)
		if(!ind[i])
			Q.push(i);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		if(f[x]>0)ans+=f[x];
		Can[x] = true;
		for(int i=head[x];i;i=e[i].next)
			if(i&1)
				if(!--ind[e[i].to])
					Q.push(e[i].to);
	}
}
void debug()
{
	for(int i = st;i<= end;i++)
	{
		printf("%d:",i);
		for(int j = head[i];j;j=e[j].next)
			printf("%d(%d) ",e[j].to,e[j].flow);
		printf("\n");
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	st = 0,end = n*m+1;
	for(int i = 1;i<end;i++)
	{
		scanf("%d",&f[i]);
		if(f[i]>0)add(st,i,f[i]);
		else add(i,end,-f[i]);
		int k,r,c;
		scanf("%d",&k);
		while(k--)
		{
			scanf("%d%d",&r,&c);
			add(r*m+c+1,i,INF);
		}
		if(i%m)
			add(i,i+1,INF);
	}
	topo();
	ans-=get_maxflow(st,end);
	printf("%d\n",ans);
	return 0;
}
Problem1570

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5010;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1,n,m,T;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(s);
	d[s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
vector<int>to[N],val[N];
int main()
{
	scanf("%d%d%d",&n,&m,&T);
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		to[x].push_back(y);
		val[x].push_back(z);
	}
	int st=0,ed=N-1,ans =0;
	add(st,1,T);
	for(int day = 1;;day++)
	{
		for(int i = 1;i<= n;i++)
			for(int j = 0;j<to[i].size();j++)
				add(n*(day-1)+i,n*day+to[i][j],val[i][j]);
		for(int i = 1;i<= n;i++)
			add(n*(day-1)+i,n*day+i,INF);
		add(n*day+n,ed,INF);
		if((ans+=dinic(st,ed))==T)
		{
			printf("%d\n",day);
			return 0;
		}
	}
	return 0;
}
Problem1579

#include <queue>
#include <stack>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <limits.h>
#include <string.h>
#include <string>
#include <algorithm>

using namespace std;

const int MAX = 10010;
struct NODE{int to,len;NODE *next;};
NODE *p[MAX],node[MAX*10];
int cou;
int dis[25][MAX],L;
void init()
{
	cou = 0;
	memset(node,'\0',sizeof(node));
	memset(p,'\0',sizeof(p));
}
void Add(int x,int y,int w)
{
	node[cou].len = w;
	node[cou].to = y;
	node[cou].next = p[x];
	p[x] = &node[cou++];
}
struct cmp{
	bool operator()(int a,int b)
	{
		return dis[L][a] > dis[L][b];
	}
};
void Dijkstra(int s,int n,int *dis)
{
	bool used[MAX];
	memset(used,0,sizeof(used));
	used[s] = true;
	dis[s] = 0; int now = s;
	for(int i=0; i<n-1; i++)
	{
		NODE *head = p[now];
		while( head )
		{
			if( dis[head->to] > dis[now] + head->len )
				dis[head->to] = dis[now] + head->len;
			head = head->next;
		}
		int mmin = INT_MAX;
		for(int k=1; k<=n; k++)
			if( !used[k] && mmin > dis[k] )
				mmin = dis[now = k];
		used[now] = true;
	}
}
void Dijkstra1(int s,int n,int l)
{
	priority_queue<int,vector<int>,cmp> q;
	bool used[MAX];
	memset(used,0,sizeof(used));
	used[s] = true;
	int now = s;
	dis[l][s] = 0;
	q.push(s);
	while( !q.empty() )
	{
		int now = q.top(); used[now] = true;
		NODE *head = p[now]; q.pop();
		while( head )
		{
			if( dis[l][head->to] > min( dis[l-1][now],dis[l][now] + head->len ) )
			{
				dis[l][head->to] = min( dis[l-1][now],dis[l][now] + head->len );
				q.push(head->to);
			}
			head = head->next;
		}
	}
}

int main()
{
	int n,m,K,x,y,w;
	
	while( ~scanf("%d%d%d",&n,&m,&K) )
	{
		while( m-- )
		{
			scanf("%d%d%d",&x,&y,&w);
			Add(x,y,w); Add(y,x,w);
		}
		for(int k=0; k<=K; k++)
			for(int i=1; i<=n; i++)
				dis[k][i] = 500000000;
		Dijkstra(1,n,dis[0]);
		
		for(L=1; L<=K; L++)
			Dijkstra1(1,n,L);
		printf("%d\n",dis[K][n]);
	}

return 0;
}
Problem1588

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
struct Treap{
	Treap *ls,*rs;
	int key,val,cnt,size;
	Treap(int x)
	{
		ls = rs = NULL;
		key = rand();
		cnt = size = 1;
		val = x;
	}
	void push_up()
	{
		size = cnt;
		if(ls)size+=ls->size;
		if(rs)size+=rs->size;
	}
}*root = NULL;
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y>x->val)
	{
		Insert(x->rs,y);
		if(x->rs->key > x->key)
			go_left(x);
	}
	else
	{
		Insert(x->ls,y);
		if(x->ls->key > x->key)
			go_right(x);
	}
	x->push_up();
}
int get_pre(Treap *x,int y)
{
	if(!x)return -0x3f3f3f3f;
	if(x->val>y)return get_pre(x->ls,y);
	else return max(x->val,get_pre(x->rs,y));
}
int get_suc(Treap *x,int y)
{
	if(!x)return 0x3f3f3f3f;
	if(x->val<y)return get_suc(x->rs,y);
	else return min(x->val,get_suc(x->ls,y));
}
int main()
{
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(i==1){ans+=x;Insert(root,x);}
		else
		{
			int tmp = get_pre(root,x),minn = INF;
			if(tmp!=-INF) minn = x-tmp;
			tmp = get_suc(root,x);
			if(tmp!=INF)minn = min(minn,tmp-x);
			ans+=minn;
			Insert(root,x);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1597

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 50005;
struct LAND{int wid,lth;}ld[N];
int line[N],L,R;
int l[N],w[N];
LL f[N];
bool cmp(LAND a,LAND b)
{
    if(a.lth!=b.lth)return a.lth>b.lth;
    return a.wid<b.wid;
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
        scanf("%d%d",&ld[i].wid,&ld[i].lth);
    sort(ld+1,ld+n+1,cmp);
    int cnt = 0;
    for(int i = 1;i<= n;i++)
    {
        if(cnt==0||ld[i].wid>w[cnt])
        {
            cnt++;
            w[cnt] = ld[i].wid;
            l[cnt] = ld[i].lth;
        }
    }
    int L = 1,R = 1;line[L] =0;
    for(int i = 1;i<= cnt;i++)
    {
        while(L<R&&(LL)(l[line[L+1]+1]-l[line[L]+1])*w[i]<f[line[L]]-f[line[L+1]])
            L++;
        f[i] = f[line[L]]+(LL)l[line[L]+1]*w[i];
        while(L<R&&(LL)(l[line[R]+1]-l[i+1])*(f[line[R]]-f[line[R-1]])>(LL)(l[line[R-1]+1]-l[line[R]+1])*(f[i]-f[line[R]]))
            R--;
        line[++R] = i;
    }
    printf("%lld\n",f[cnt]);
    return 0;
}
Problem1645

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 40005;
typedef long long LL;
struct L
{int pos,h,f;}line[N<<1];
int cnt,id[N],x[N],y[N],v[N],tp[N];
bool cmp(L a,L b)
{
	return a.pos<b.pos;
}
bool cmi(int a,int b)
{
	return v[a]<v[b];
}
int sum[N<<2],lazy[N<<2];
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	int mid = (l+r)>>1;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	sum[p<<1]+=lazy[p]*(mid-l+1);
	sum[p<<1|1]+=lazy[p]*(r-mid);
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sum[p]+=(r-l+1)*c;
		lazy[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int getans(int p,int l,int r)
{
	push_down(p,l,r);
	if(l==r)
	{
		if(sum[p])return l;
		else return l-1;
	}
	int mid = (l+r)>>1;
	if(!sum[p<<1|1])return getans(p<<1,l,mid);
	else return getans(p<<1|1,mid+1,r);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&v[i]);
		id[i] = i;
	}
	sort(id+1,id+n+1,cmi);
	for(int i = 1;i<= n;i++)
		tp[id[i]] = i;
	for(int i = 1;i<= n;i++)
	{
		line[++cnt].pos = x[i];line[cnt].h = tp[i];line[cnt].f = 1;
		line[++cnt].pos = y[i],line[cnt].h = tp[i];line[cnt].f =-1;
	}
	sort(line+1,line+cnt+1,cmp);
	int last = 0;
	LL ans = 0;
	for(int i = 1;i<= cnt;i++)
	{
		ans+=(LL)v[id[last]]*(line[i].pos-line[i-1].pos);
		update(1,1,n,1,line[i].h,line[i].f);
		last = getans(1,1,n);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem1672

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int Mn = 86399+5;
const int N = 1e4+5;
const LL INF = 1e18;
struct C
{int s,t,c;}cl[N];
bool cmp(C a,C b)
{
	return a.s<b.s;
}
LL f[Mn],t[Mn<<2];
void build(int p,int l,int r)
{
	t[p] = INF;
	if(l==r)
	{
		f[l] = INF;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
}
void push_down(int p,int l,int r)
{
	if(t[p]==INF)return ;
	if(l==r){f[l] = min(f[l],t[p]);t[p] = INF;return ;}
	t[p<<1] = min(t[p],t[p<<1]);
	t[p<<1|1] = min(t[p],t[p<<1|1]);
	t[p] = INF;
}
void update(int p,int l,int r,int a,int b,LL c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		t[p] = min(t[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	return ;
}
LL getans(int p,int l,int r,int x)
{
	push_down(p,l,r);
	if(x<=0)return 0;
	if(l==r)return f[l];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int main()
{
	int n,m,e;
	scanf("%d%d%d",&n,&m,&e);
	m++,e++;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&cl[i].s,&cl[i].t,&cl[i].c);
		cl[i].s++;cl[i].t++;
	}
	sort(cl+1,cl+n+1,cmp);
	build(1,1,e);
	update(1,1,e,1,m,0);
	for(int i = 1;i<= n;i++)
	{
		int s = cl[i].s,t = cl[i].t,v = cl[i].c;
		LL tmp = getans(1,1,e,s-1);
		if(tmp>=INF){printf("-1\n");return 0;}
		update(1,1,e,s,t,tmp+v);
	}
	printf("%lld\n",getans(1,1,e,e));
	return 0;
}
Problem1688

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 1<<16;
int cow[N];
int sta[M],cnt;
void init(int k)
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i,c = 0;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			c++;
		} 
		if(c==k)
			sta[++cnt] = i;
	}
	return ;
}
int main()
{
	int n,d,k;
	scanf("%d%d%d",&n,&d,&k);
	init(k);
	for(int i = 1;i<= n;i++)
	{
		int c,x;
		scanf("%d",&c);
		for(int j = 1;j<= c;j++)
		{
			scanf("%d",&x);
			cow[i]|=(1<<(x-1));
		}
	}
	int t_ans = 0;
	for(int i= 1;i<= cnt;i++)
	{
		int ans = 0;
		for(int j = 1;j<= n;j++)
		{
			if((cow[j]|sta[i])!=sta[i])continue;
			else ans++;
		}
		t_ans = max(ans,t_ans);
	}
	printf("%d\n",t_ans);
	return 0;
}
Problem1692

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
char s[N];
int cnt[N],q[N],v[N],nv[N],sa[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int lim,int len)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl=1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
int main()
{
	int n;
	char ch;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
	{
		ch = getchar();while(ch<'A'||ch>'Z')ch = getchar();
		s[i]=ch;
	}
	int len = n;
	s[len]='$';
	for(int i = n-1;i>=0;i--)
		s[++len]=s[i];
	len++;
	build_sa(256,len);
	build_rank(len);
	int l = 0,r = n+1;
	for(int i = 0;i<n;i++)
	{
		if(r>=len||rnk[l]<rnk[r])
			{printf("%c",s[l]);l++;}
		else {printf("%c",s[r]);r++;}
		if(i%80==79)printf("\n");
	}
	return 0;
}
Problem1717

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int maxN = 1000001;
int cnt[maxN],q[N],sa[N],h[N],rnk[N],v[N],nv[N];
int s[N],n,k;
bool is_same(int a,int b,int ln,int len)
{
	return (v[a]==v[b])&&((a+ln>len&&b+ln>len)||(a+ln<len&&b+ln<len&&v[a+ln]==v[b+ln]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]] = i;
	for(int d = 1;;d++)
	{
		int ln = 1<<(d-1),id = 0;
		for(i = len-ln;i<len;i++)q[id++]=i;
		for(i = 0;i<len;i++)if(sa[i]>=ln)q[id++]=sa[i]-ln;

		for(i = 0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[v[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],ln,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
bool check(int mid,int len)
{
	int tmp = 0;
	for(int i = 1;i<len;i++)
	{
		if(h[i]>=mid)tmp++;
		else tmp = 0;
		if(tmp>=k-1)return true;
	}
	return false;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 0;i< n;i++)scanf("%d",&s[i]);
	build_sa(n,maxN);
	build_rank(n);
	build_height(n);
	int l = 0,r = n,ans=0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(check(mid,n))l=mid+1,ans=mid;
		else r = mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
Problem1725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<12;
const int mod = 100000000;
int f[13][N];
int map[13];
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<m;j++)
		{
			scanf("%d",&x);
			map[i] |= (x^1)<<j;
		}
	f[0][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		for(int last = 0;last< 1<<m;last++)
		{
			if((last&map[i-1])||(last&(last<<1))||(last&(last>>1)))continue;
			for(int now = 0;now<1<<m;now++)
			{
				if((now&map[i])||(now&(now<<1))||(now&(now>>1)))continue;
				if(now&last)continue;
				f[i][now] = (f[i][now]+f[i-1][last])%mod;
			}
		}
	}
	int ans = 0;
	for(int i = 0;i<1<<m;i++)
		ans = (ans+f[n][i])%mod;
	printf("%d\n",ans);
	return 0;
}
Problem1742

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
long long f[N][N][2];
int pos[N],n,s;
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%d",&pos[i]);
	pos[++n] = s;
	sort(pos+1,pos+n+1);
	s = find(s);
	memset(f,0x3f,sizeof(f));
	f[s][1][0] = f[s][1][1] = 0;
	for(int len = 2;len <= n;len++)
	{
		for(int l = 1;l+len-1<= n;l++)
		{
			int r = l+len-1;
			f[l][len][1] = min(f[l][len][1],min(f[l+1][len-1][1]+(n-len+1)*(pos[l+1]-pos[l]),f[l+1][len-1][0]+(n-len+1)*(pos[r]-pos[l])));
			f[l][len][0] = min(f[l][len][0],min(f[l][len-1][0]+(n-len+1)*(pos[r]-pos[r-1]),f[l][len-1][1]+(n-len+1)*(pos[r]-pos[l])));
		}
	}
	printf("%lld\n",min(f[1][n][0],f[1][n][1]));
	return 0;
}
Problem1778

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
const double eps = 1e-9;
double f[N][N],cnt[N],ans[N];
int n,m,x,y;
double p,q;
void swapn(int x,int y)
{
	for(int i = 1;i<= n+1;i++)
		swap(f[x][i],f[y][i]);
	return ;
}
void work()
{
	for(int i = 1;i<= n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swapn(xn,i);
		for(int line = i+1;line<=n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = i;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n;i>= 1;i--)
	{
		for(int j = n;j>i;j--)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%lf%lf",&p,&q);
	double rate = p/q;
	if(rate>1)rate = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		f[x][y]+=1;f[y][x]+=1;
		cnt[x]+=1;cnt[y]+=1;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(fabs(cnt[j])>eps)
				f[i][j]/=cnt[j];
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			f[i][j]*=rate-1;
	for(int i = 1;i<= n;i++)
		f[i][i]+=1;
	f[1][n+1] = rate;
	work();
	for(int i = 1;i<= n;i++)
		printf("%.9f\n",fabs(ans[i]));	
	return 0;
}
Problem1782

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,c[N],w[N],son[N],size[N],cnt,p[N],top[N],end[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void dfs1(int x,int fa)
{
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
void dfs2(int x,int fa,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],x,tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&e[i].to!=son[x])
			dfs2(e[i].to,x,e[i].to);
	end[x] = cnt;
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs1(1,0);
	dfs2(1,0,1);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d",&p[i]);
		printf("%d\n",getans(w[p[i]]));
		update(w[p[i]],1);
		update(end[p[i]]+1,-1);
	}
	return 0;
}
Problem1798

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int M = 100005;
int mod;
int mul_tag[N<<2],add_tag[N<<2];
int sum[N<<2];
void build(int p,int l,int r)
{
	mul_tag[p] = 1,add_tag[p] = 0;
	if(l==r)
	{
		scanf("%d",&sum[p]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = (sum[p<<1]+sum[p<<1|1])%mod;
}
void push_down(int p,int l,int r)
{
	if(l==r||(mul_tag[p]==1&&add_tag[p]==0))return ;
	int mid = (l+r)>>1;
	sum[p<<1] = ((LL)sum[p<<1]*mul_tag[p]%mod+(LL)add_tag[p]*(mid-l+1)%mod)%mod;
	sum[p<<1|1] = ((LL)sum[p<<1|1]*mul_tag[p]%mod+(LL)add_tag[p]*(r-mid)%mod)%mod;
	mul_tag[p<<1] = (LL)mul_tag[p<<1]*mul_tag[p]%mod;
	mul_tag[p<<1|1] = (LL)mul_tag[p<<1|1]*mul_tag[p]%mod;
	add_tag[p<<1] = ((LL)add_tag[p<<1]*mul_tag[p]+add_tag[p])%mod;
	add_tag[p<<1|1] = ((LL)add_tag[p<<1|1]*mul_tag[p]+add_tag[p])%mod;
	mul_tag[p] = 1;
	add_tag[p] = 0;	
}
void update(int p,int l,int r,int a,int b,int c,int opt)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		if(opt)
			{add_tag[p]+=c;sum[p] = (sum[p]+(LL)c*(r-l+1)%mod)%mod;}
		else
		{
			add_tag[p] = (LL)add_tag[p]*c%mod;
			mul_tag[p] = (LL)mul_tag[p]*c%mod;
			sum[p] = (LL)sum[p]*c%mod;
		}
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c,opt);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c,opt);
	sum[p] = (sum[p<<1]+sum[p<<1|1])%mod;
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans = (ans+getans(p<<1,l,mid,a,b))%mod;
	if(b>mid)ans = (ans+getans(p<<1|1,mid+1,r,a,b))%mod;
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&mod);
	build(1,1,n);
	int opt,l,r,c;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt<=2)
		{
			opt--;
			scanf("%d%d%d",&l,&r,&c);
			update(1,1,n,l,r,c,opt);
		}else
		{
			scanf("%d%d",&l,&r);
			printf("%d\n",getans(1,1,n,l,r));
		}
	}
	return 0;
}
Problem1806

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,ans,f[2][4][4][4][4];
inline int Get_Char()
{
	char c;
	do c=getchar(); while(c!='M'&&c!='F'&&c!='B');
	switch(c)
	{
		case 'M':return 1;
		case 'F':return 2;
		case 'B':return 3;
	}
}
inline int Score(int x,int y)
{
	if(x==0) return 1;
	return x==y?1:2;
}
inline int Score(int x,int y,int z)
{
	int temp=x*y*z;
	switch(temp)
	{
		case 6:return 3;
		case 1:
		case 8:
		case 27:return 1;
		case 0:return Score(y,z);
		default: return 2;
	}
}
int main()
{
	scanf("%d",&n);
	memset(f,0xef,sizeof f);
	f[0][0][0][0][0]=0;
	for(int i=1;i<=n;i++)
	{
		int temp=Get_Char();
		memset(f[i&1],0xef,sizeof(f[i&1]));
		for(int a1=0;a1<=3;a1++)
			for(int a2=(a1?1:0);a2<=3;a2++)
				for(int b1=0;b1<=3;b1++)
					for(int b2=(b1?1:0);b2<=3;b2++)
						if(f[~i&1][a1][a2][b1][b2]>=0)
						{
							f[i&1][a2][temp][b1][b2]=max(f[i&1][a2][temp][b1][b2]
														,f[~i&1][a1][a2][b1][b2]+Score(a1,a2,temp));
							f[i&1][a1][a2][b2][temp]=max(f[i&1][a1][a2][b2][temp]
														,f[~i&1][a1][a2][b1][b2]+Score(b1,b2,temp));
						}
	}
	for(int a1=0;a1<=3;a1++)
		for(int a2=(a1?1:0);a2<=3;a2++)
			for(int b1=0;b1<=3;b1++)
				for(int b2=(b1?1:0);b2<=3;b2++)
					ans=max(ans,f[n&1][a1][a2][b1][b2]);
	printf("%d\n",ans);
	return 0;
}
Problem1816

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 60
#define inf 0x3f3f3f3f
using namespace std;
int n,m,a[N],ans;
bool check(int mid)
{
    int remain=min(m,mid);
    for(int i=1;i<=n;i++)
    {
        if(a[i]>=mid)continue;
        remain-=mid-a[i];
        if(remain<0)return 0;
    }
    return 1;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    int l=0,r=inf,mid,ans;
    while(l<=r)
    {
        if(r-l<=3)
        {
            ans=0;
            for(int i=l;i<=r;i++)
                if(check(i))ans=i;
            printf("%d\n",ans);
            return 0;
        }
        mid=(l+r)>>1;
        if(check(mid))l=mid;
        else r=mid-1;
    }
    printf("%d\n",ans);
    return 0;
}
Problem1821

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
using namespace std;
struct E	
{
	int x,y;
	double val;
	bool operator < (const E &s) const
	{
		return val < s.val;
	}
}edge[2000005];
int tot,fa[1005];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])
		return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int x[1005],y[1005];
int main()
{
	//freopen("group.in","r",stdin);
	//freopen("group.out","w",stdout);
	int n,k;
	scanf("%d%d",&n,&k);
	int cnt = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	for(int i = 1;i<= n;i++)
	{
		for(int j = i+1;j<= n;j++)
		{
			edge[++tot].x = i;
			edge[tot].y = j;
			edge[tot].val = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
			edge[++tot].x = j;
			edge[tot].y = i;
			edge[tot].val = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
		}
	}
	double ans = 0;
	std::sort(edge+1,edge+tot+1);
	for(int i = 1;i<= tot;i++)
	{
		int fx = getfa(edge[i].x);
		int fy = getfa(edge[i].y);
		if(fx==fy)continue;
		if(cnt>=n-k)
		{
			ans = edge[i].val;
			break;
		}
		cnt++;
		uni(fx,fy);
	}
	printf("%.2lf",ans);
	return 0;
}
Problem1823

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2e4+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool ins[N];
int dfn[N],low[N],stack[N],top,cnt,bel[N],dcc;
void tarjan(int x)
{
	low[x] = dfn[x] = ++cnt;
	stack[++top] = x;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
int getnum(char s[10])
{
	int now = 1;
	int ans = 0;
	while(s[now])
	{
		ans=ans*10+s[now]-'0';
		now++;
	}
	return ans*2;
}
void work()
{
	memset(head,0,sizeof(head));
	memset(dfn,0,sizeof(dfn));
	memset(bel,0,sizeof(bel));
	tot = cnt = dcc = top = 0;
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	char s1[10],s2[10];
	for(int i=1;i<=m;i++)
	{
		scanf("%s%s",s1,s2);
		x = getnum(s1),y = getnum(s2);
		if(s1[0]=='m')x++;
		if(s2[0]=='m')y++;
		add(x^1,y);
		add(y^1,x);
	}
	for(int i = 2;i<= 2*n+1;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i = 1;i<= n;i++)
	{
		if(bel[i<<1]==0||bel[i<<1|1]==0)continue;
		if(bel[i<<1]==bel[i<<1|1])
			{printf("BAD\n");return ;}
	}
	printf("GOOD\n");
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)work();
	return 0;
}
Problem1828

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
int mn[N<<2],lazy[N<<2];
struct Q
{
	int l,r;
}ask[N];
bool cmp(Q a,Q b)
{
	return a.r<b.r;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		scanf("%d",&mn[p]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
}
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	mn[p<<1] = mn[p<<1]+lazy[p];
	mn[p<<1|1] = mn[p<<1|1]+lazy[p];
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		mn[p]--;
		lazy[p]--;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b);
	if(b>mid)update(p<<1|1,mid+1,r,a,b);
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return mn[p];
	int mid = (l+r)>>1;
	int ans = INF;
	if(a<=mid)ans = min(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)ans = min(ans,getans(p<<1|1,mid+1,r,a,b));
	mn[p] = min(mn[p<<1],mn[p<<1|1]);
	return ans;
}
int main()
{
	int n,m,ans = 0;
	scanf("%d%d",&n,&m);
	build(1,1,n);
	for(int i = 1;i<= m;i++)
		scanf("%d%d",&ask[i].l,&ask[i].r);
	sort(ask+1,ask+m+1,cmp);
	for(int i = 1;i<= m;i++)
	{
		if(getans(1,1,n,ask[i].l,ask[i].r)>=1)
		{
			update(1,1,n,ask[i].l,ask[i].r);
			ans++;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem1833

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL f[15][10][10];
LL p10[15],ans[10][2];
void solve(LL x,int opt)
{
	if(x==0)return ;
	int num[15] = {};
	int cnt = 0;
	LL tmp = x;
	while(x)
	{
		num[++cnt] = x%10;
		x/=10;
	}
	for(int i = 1;i<=num[cnt]-1;i++)
		for(int j = 0;j<= 9;j++)
			ans[j][opt]+=f[cnt][i][j];
	ans[num[cnt]][opt]+=tmp%p10[cnt-1]+1;
	for(int i = cnt-1;i>=1;i--)
		for(int j = 1;j<= 9;j++)
			for(int k = 0;k<= 9;k++)
				ans[k][opt]+=f[i][j][k];
	for(int i = cnt-1;i>=1;i--)
	{
		for(int j = 0;j<= num[i]-1;j++)
			for(int k = 0;k<= 9;k++)
				ans[k][opt]+=f[i][j][k];
		ans[num[i]][opt]+=tmp%p10[i-1]+1;
	}
	return ;
}
int main()
{
	p10[0] = 1;
	for(int i = 1;i<= 12;i++)p10[i] = p10[i-1]*10;
	LL a,b;
	scanf("%lld%lld",&a,&b);
	for(int i = 0;i<= 9;i++)
		for(int j = 0;j<=9;j++)
			if(i==j)f[1][i][j] = 1;
	for(int i = 2;i<= 12;i++)
		for(int j = 0;j<= 9;j++)
			for(int k = 0;k<= 9;k++)
			{
				for(int l = 0;l<= 9;l++)
					f[i][j][k]+=f[i-1][l][k];
				if(k==j)f[i][j][k]+=p10[i-1];		
			}
	solve(a-1,0);
	solve(b,1);
	for(int i = 0;i< 9;i++)printf("%lld ",ans[i][1]-ans[i][0]);
	printf("%lld\n",ans[9][1]-ans[9][0]);
	return 0;
}
Problem1834

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 5e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int nxt,to,fr,f,c;}e[M];
int head[N],tot=1,from[N];
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].nxt=head[x];head[x]=tot;
	e[tot].f=f,e[tot].c=c,e[tot].fr=x;
	e[++tot].to=x;e[tot].nxt=head[y];head[y]=tot;
	e[tot].f=0,e[tot].c=-c,e[tot].fr=y;
}
bool v[N];
int dis[N],S,T;
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	Q.push(S);
	v[S] = true;dis[S] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].nxt)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans =0,mxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	mxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int a[M],b[M],C[M],W[M];
int main()
{
	//freopen("x.in","r",stdin);
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i= 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a[i],&b[i],&C[i],&W[i]);
		add(a[i],b[i],C[i],0);
	}
	S = 1,T = n;
	while(spfa())mcf();
	printf("%d",mxf);
	add(0,1,k,0);
	S = 0;
	memset(from,0,sizeof(from));
	ans = mxf = 0;
	for(int i = 1;i<= m;i++)
		add(a[i],b[i],INF,W[i]);
	while(spfa())mcf();
	printf(" %d\n",ans);
	return 0;
}
Problem1854

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
int fa[N];
int vis[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		int fx = getfa(x),fy = getfa(y);
		if(fx==fy)
			vis[fx] = true;
		else
		{
			if(fx>fy){vis[fy] = true;fa[fy] = fx;}
			else {vis[fx] = true;fa[fx] = fy;}
		}
	}
	for(int i = 1;i<= N+1;i++)
		if(!vis[i])
			{printf("%d\n",i-1);break;}
	return 0;
}
Problem1855

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int T = 2005;
const int P = 2005;
int asi[T],bsi[T],api[T],bpi[T];
int f[T][P];
int line[P],L,R;
int main()
{
	memset(f,128,sizeof(f));
	int t,maxp,w;
	scanf("%d%d%d",&t,&maxp,&w);
	for(int i = 1;i<= t;i++)
		scanf("%d%d%d%d",&api[i],&bpi[i],&asi[i],&bsi[i]);
	for(int i = 1;i<= t;i++)
	{
		
		for(int j = 0;j <= asi[i];j++)f[i][j] = -api[i]*j;
		for(int j = 0;j <= maxp;j++)
			f[i][j] = max(f[i][j],f[i-1][j]);
		int t = i-w-1;
		if(t>=0)
		{
			L = 1,R = 0;
			for(int j = 0;j<=maxp;j++)
			{
				while(L<=R&&j-line[L]>asi[i])L++;
				int tmp = f[t][j]+j*api[i];
				while(L<=R&&tmp>=f[t][line[R]]+line[R]*api[i])
					R--;
				line[++R]= j;
				if(L<=R)f[i][j] = max(f[i][j],f[t][line[L]]+line[L]*api[i]-j*api[i]);
			}
			L = 1,R = 0;
			for(int j = maxp;j>= 0;j--)
			{
				while(L<=R&&line[L]-j>bsi[i])L++;
				int tmp = f[t][j]+j*bpi[i];
				while(L<=R&&tmp>=f[t][line[R]]+line[R]*bpi[i])
					R--;
				line[++R]= j;
				if(L<=R)f[i][j] = max(f[i][j],f[t][line[L]]+line[L]*bpi[i]-j*bpi[i]);
			}
		}
	}
	int ans = -1e9;
	for(int i = 0;i<= maxp;i++)
		ans = max(ans,f[t][i]);
	printf("%d",ans);
	return 0;
}
Problem1861

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Inv = 20000307;
const int N = 2e5;
struct Splay
{
	Splay *ls,*rs,*fa;
	int size,num;
	Splay (int x);
	void push_up();
}*null = new Splay(0),*root,*tree[N];
int a[N],n,m;
Splay :: Splay (int x)
{
	ls = rs = fa = null;
	size = x?1:0;
	num = x;
}
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)root = x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)
				go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void Find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		if(x->ls->size>=y)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
int get_rank(Splay *x)
{
	int ans = x->ls->size;
	for(;x!=root;x = x->fa)
		if(x==x->fa->rs)
			ans+=x->fa->ls->size+1;
	return ans;
}
void Insert(Splay *x,int y)
{
	Find(root,y,null);
	Find(root,y+1,root);
	root->rs->ls = x;
	x->fa = root->rs;
	root->rs->push_up();
	root->push_up();
}
void Delete(int y)
{
	Find(root,y,null);
	Find(root,y+2,root);
	root->rs->ls = null;
	root->rs->push_up();
	root->push_up();
}
void build(Splay *&x,int l,int r)
{
	if(r<l)return ;
	int mid = (l+r)>>1;
	x = tree[a[mid]];
	build(x->ls,l,mid-1);
	build(x->rs,mid+1,r);
	if(x->ls!=null)x->ls->fa = x;
	if(x->rs!=null)x->rs->fa = x;
	x->push_up();
}
void init()
{
	root = new Splay(Inv);
	root->rs = new Splay(Inv);
	build(root->rs->ls,1,n);
	root->rs->ls->fa = root->rs;
	root->rs->push_up();
	root->rs->fa = root;
	root->push_up();
}
void top()
{
	int pos;
	scanf("%d",&pos);
	int tmp = get_rank(tree[pos]);
	Delete(tmp);
	Insert(tree[pos],1);
}
void bot()
{
	int pos;
	scanf("%d",&pos);
	int tmp = get_rank(tree[pos]);
	Delete(tmp);
	Insert(tree[pos],n);
}
void Change()
{
	int x,y;
	scanf("%d%d",&x,&y);
	int tmp = get_rank(tree[x]);
	Delete(tmp);
	Insert(tree[x],tmp+y);
}
void Ask()
{
	int x;
	scanf("%d",&x);
	printf("%d\n",get_rank(tree[x])-1);
}
void Query()
{
	int x;
	scanf("%d",&x);
	Find(root,x+1,null);
	printf("%d\n",root->num);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		tree[i] = new Splay(i);
	init();
	char opt[10];
	for(int i = 1;i<=m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')Query();
		else if(opt[0]=='A')Ask();
		else if(opt[0]=='T')top();
		else if(opt[0]=='B')bot();
		else if(opt[0]=='I')Change();
	}
	return 0;
}
Problem1861

#include<iostream>
#include<cstdio>
#include<cstring>
#define inf 1000000000
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,rt,sz;
int c[80005][2],fa[80005],deep[80005];
int a[80005],size[80005],v[80005],pos[80005];
void update(int k)
{
	size[k]=size[c[k][0]]+size[c[k][1]]+1;
}
void rotate(int x,int &k)
{
	int y=fa[x],z=fa[y],l,r;
	if(c[y][0]==x)l=0;else l=1;r=l^1;
	if(y==k)k=x;
	else {if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
	fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
	c[y][l]=c[x][r];c[x][r]=y;
	update(y);update(x);
}
void splay(int x,int &k)
{
	while(x!=k)
	{
		int y=fa[x],z=fa[y];
		if(y!=k)
		{	
			if(c[y][0]==x^c[z][0]==y)
				rotate(x,k);
			else rotate(y,k);
		}
		rotate(x,k);
	}
}
void build(int l,int r,int f)
{
	if(l>r)return;
	int now=l,last=f;
	if(l==r)
	{
		v[now]=a[l];size[now]=1;fa[now]=last;
		if(l<f)c[last][0]=now;
		else c[last][1]=now;
		return;
	}
	int mid=(l+r)>>1;now=mid;
	build(l,mid-1,mid);build(mid+1,r,mid);
	v[now]=a[mid];fa[now]=last;update(now);
	if(mid<f)c[last][0]=now;
	else c[last][1]=now;
}
int find(int k,int rank)
{
	int l=c[k][0],r=c[k][1];
	if(size[l]+1==rank)return k;
	else if(size[l]>=rank)return find(l,rank);
	else return find(r,rank-size[l]-1);
}
void del(int k)
{
	int x,y,z;
	x=find(rt,k-1);y=find(rt,k+1);
	splay(x,rt);splay(y,c[x][1]);
	z=c[y][0];c[y][0]=0;fa[z]=size[z]=0;
	update(y);update(x);
}
void move(int k,int val)
{
	int x,y,z=pos[k],rank;
	splay(z,rt);rank=size[c[z][0]]+1;
	del(rank);
	if(val==inf)x=find(rt,n),y=find(rt,n+1);
	else if(val==-inf)x=find(rt,1),y=find(rt,2);
	else x=find(rt,rank+val-1),y=find(rt,rank+val);
	splay(x,rt);splay(y,c[x][1]);
	size[z]=1;fa[z]=y;c[y][0]=z;
	update(y);update(x);
}
int main()
{
	n=read();m=read();
	for(int i=2;i<=n+1;i++)
		a[i]=read(),pos[a[i]]=i;
	build(1,n+2,0);
	rt=(3+n)>>1;
	char ch[10];int S,T;
	for(int i=1;i<=m;i++)
	{
		scanf("%s",ch);S=read();
		switch(ch[0])
		{
		case 'T':move(S,-inf);break;
		case 'B':move(S,inf);break;
		case 'I':T=read();move(S,T);break;
		case 'A':splay(pos[S],rt);printf("%d\n",size[c[pos[S]][0]]-1);break;
		case 'Q':printf("%d\n",v[find(rt,S+1)]);break;
		}
	}
	return 0;
}
Problem1878

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int M = 200005;
int a[N],last[1000005],next[N];
int num[N],c[N];
struct ask{int x,y,ans,no;}A[M];
bool cmp(ask a,ask b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
bool cmp1(ask a,ask b){return a.no<b.no;}
void update(int x)
{
	if(x==0)return ;
	for(int i = x;i<=N;i+=i&(-i))
		c[i]++;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		if(last[a[i]]!=0)next[last[a[i]]] = i;
		else update(i);
		last[a[i]] = i;
	}
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&A[i].x,&A[i].y);
		A[i].no = i;
	}
	sort(A+1,A+m+1,cmp);
	int l = 1;
	for(int i = 1;i<= m;i++)
	{
		while(l<A[i].x)
		{
			update(next[l]);
			l++;
		}
		int tmp = getans(A[i].y);
		A[i].ans = tmp-getans(A[i].x-1);
	}
	sort(A+1,A+m+1,cmp1);
	for(int i = 1;i<= m;i++)
		printf("%d\n",A[i].ans);
	return 0;
}
Problem1901

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int INF = 1e9+1;
int n,m;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	size = cnt = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(x->val<y)
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}else
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)
		Delete(x->ls,y);
	else if(y>x->val)
		Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)
			tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_rank(root[p],y);return ;}
	int mid=(l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,y);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,y);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF;int ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans = mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int a[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	char opt[3];int x,y,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')
		{
			scanf("%d%d%d",&x,&y,&k);
			get_number(x,y,k);
		}else
		{
			scanf("%d%d",&x,&k);
			change(1,1,n,x,a[x],k);
			a[x] = k;
		}
	}
	return 0;
}
Problem1911

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
LL sum[N];
LL f[N];
int Q[N],L,R,n,a,b,c,x;
LL Y(int x)
{
    return f[x]+sum[x]*sum[x]*a;
}
int main()
{
    //memset(f,128,sizeof(f));
    scanf("%d%d%d%d",&n,&a,&b,&c);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&x);
        sum[i] = sum[i-1]+x;
    }
    L = R = 1;
    Q[L] = 0;
    for(int i = 1;i<= n;i++)
    {
        while(L<R&&-(sum[i]*2*a+b)>(double)(Y(Q[L])-Y(Q[L+1]))/(double)(sum[Q[L+1]]-sum[Q[L]]))
            L++;
        f[i] = f[Q[L]]+
               (sum[i]-sum[Q[L]])*(sum[i]-sum[Q[L]])*a+(sum[i]-sum[Q[L]])*b+c;
        while(L<R&&(double)(Y(Q[R-1])-Y(Q[R]))/(double)(sum[Q[R]]-sum[Q[R-1]])>(double)(Y(Q[R])-Y(i))/(double)(sum[i]-sum[Q[R]]))
            R--;
        Q[++R] = i;
    }
    printf("%lld",f[n]);
    return 0;
}
Problem1912

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot = 1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = 1;
	head[x] = tot;
}
int max_dep,end;
int pre[N],prp[N];
void dfs(int x,int fa,int pe,int dep)
{
	pre[x] = pe;
	prp[x] = fa;
	if(dep>max_dep)
	{
		max_dep = dep;
		end = x;
	}
	for(int i = head[x];i;i =e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,i,dep+e[i].val);
}
int md[N],stack[N],top;
bool cmp(int a,int b){return a>b;}
void dp(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			dp(e[i].to,x);
			md[x] = max(md[x],md[e[i].to]+e[i].val);
		}
	top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&md[e[i].to]+e[i].val>=0)
			stack[++top] = md[e[i].to]+e[i].val;
	sort(stack+1,stack+top+1,cmp);
	if(top>=2)max_dep = max(max_dep,stack[1]+stack[2]);
	else if(top>=1)max_dep = max(max_dep,stack[1]);
}
int main()
{
	int n,k,x,y;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0,0,0);
	int tmp = end;
	max_dep = 0;
	dfs(end,0,0,0);
	int len1 = max_dep;
	if(k==1)printf("%d\n",2*(n-1)-max_dep+1);
	else
	{
		max_dep = 0;
		while(tmp!=end)
		{
			e[pre[end]].val = -1;
			e[pre[end]^1].val = -1;
			end = prp[end];
		}
		dp(1,0);
		printf("%d\n",2*(n-1)-len1+1-max_dep+1);
	}
	return 0;
}
Problem1917

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,c[N],g[N],mrk[N],Ans[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	c[y]--;
}
int ans = 0;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			int tmp = min(c[x],c[e[i].to]);
			c[x]-=tmp,c[e[i].to]-=tmp,ans+=tmp<<1;
			if(c[e[i].to])g[x]=e[i].to;
		}
}
void solve(int x,int fa)
{
	Ans[x]=ans;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			if(c[x]){c[x]--,ans++,mrk[x]=0;}
			else if(g[e[i].to]){c[g[e[i].to]]--,ans++,mrk[x]=1;}
			else {c[e[i].to]++,ans--,mrk[x]=2;}
			solve(e[i].to,x);
			if(mrk[x]==0){c[x]++,ans--;}
			else if(mrk[x]==1){c[g[e[i].to]]++,ans--;}
			else {c[e[i].to]--,ans++;}
		}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		x++,y++;
		add(x,y),add(y,x);
	}
	ans = (n-1)<<1;
	dfs(1,0);solve(1,0);
	for(int i = 1;i<= n;i++)
		printf("%d\n",Ans[i]);
	return 0;
}
Problem1927

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,f,c,from;}e[M];
int head[N],tot=1;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	e[tot].f=f;e[tot].c=c;e[tot].from=x;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;
	e[tot].f=0;e[tot].c=-c;e[tot].from=y;
}
queue<int>Q;
int dis[N],from[N];bool v[N];
 bool spfa(int s,int t)
{
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	v[s]=true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to]=i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to]=true;
				}
			}
	}
	return dis[t]!=INF;
}
int ans,st,end;
void mcf()
{
	int x = INF;
	for(int i = from[end];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[end];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int a[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	st = 0,end = 2*n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		add(st,i,1,0);
		add(i+n,end,1,0);
		add(0,i+n,1,a[i]);
	}
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(x>y)swap(x,y);
		add(x,y+n,1,z);
	}
	while(spfa(st,end))mcf();
	printf("%d\n",ans);
	return 0;
}
Problem1930

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f,c;}e[N*N];
int head[N<<1],tot = 1;
void add(int x,int y,int f,int c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].f = f,e[tot].c = c;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	e[tot].f = 0;e[tot].c = -c;
}
int dis[N<<1],n;bool vis[N<<1];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = s;i<= t;i++)dis[i] = -1;
	dis[s] = 0;
	vis[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]<dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=-1;
}
bool visit[N<<1];
int getflow(int p,int s,int t,int mf)
{
	if(p==t)return mf;
	visit[p] = true;
	int last = mf;
	for(int i = head[p];i;i=e[i].next)
		if(e[i].f&&dis[p]+e[i].c==dis[e[i].to]&&(!visit[e[i].to]||e[i].to==t))
		{
			int tof = getflow(e[i].to,s,t,min(last,e[i].f));
			e[i].f-=tof;
			e[i^1].f+=tof;
			last-=tof;
			if(!last)
				return mf;
		}
	return mf-last;
}
int Maxcost(int s,int t)
{
	int res = 0;
	while(spfa(s,t))
	{
		memset(visit,0,sizeof(visit));
		res+=getflow(s,s,t,INF)*dis[t];
	}
	return res;
}
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
	void read()
	{
		scanf("%d%d",&x,&y);
	}
	bool operator <(const Point &s)const
	{
		return x<s.x||(x==s.x&&y<s.y);
	}
}p[N];
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		p[i].read();
	sort(p+1,p+n+1);
	add(0,1,2,0);
	int S = 1,T = 2*n+2;
	for(int i = 1;i<= n;i++)
		add(S,i<<1,1,0),
		add(i<<1|1,T,1,0),
		add(i<<1,i<<1|1,1,1),
		add(i<<1,i<<1|1,1,0);
	for(int i = 1;i<= n;i++)
	{
		int Min = INF;
		for(int j = i+1;j<= n;j++)
		{
			if(p[j].y<Min&&p[j].y>=p[i].y)
				add(i<<1|1,j<<1,2,0);
			if(p[j].y>=p[i].y)
				Min = min(Min,p[j].y);
		}
	}
	printf("%d\n",Maxcost(0,T));
	return 0;
}
Problem1935

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const int M = 500005;
int id[N*3],n,m;
struct Tree
{
	int c[N];
	Tree()
	{
		memset(c,0,sizeof(c));
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			c[i]+=y;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans+=c[i];
		return ans;
	}
}C;
struct A
{int x,y,no,ans;}ask[M<<2];
bool cmp(A a,A b)
{return a.y<b.y;}
bool fir(A a,A b)
{return a.no<b.no;}
struct T
{int x,y;}tr[N];
bool cmt(T a,T b)
{
	if(a.y!=b.y)
		return a.y<b.y;
	return a.x<b.x;
}
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l = mid+1;
		else r = mid;
	}
	if(id[l]>x)return --l;
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&tr[i].x,&tr[i].y);
		tr[i].x+=2;tr[i].y+=2;
		id[i] = tr[i].x;
	}
	sort(tr+1,tr+n+1,cmt);
	sort(id+1,id+n+1);
	int a,b,c,d,cnt = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		a+=2,b+=2,c+=2,d+=2;
		ask[++cnt].x = c;ask[cnt].y = d;ask[cnt].no = cnt;
		ask[++cnt].x = a-1;ask[cnt].y = d;ask[cnt].no = cnt;
		ask[++cnt].x = c;ask[cnt].y = b-1;ask[cnt].no = cnt;
		ask[++cnt].x = a-1;ask[cnt].y = b-1;ask[cnt].no = cnt;
	}
	sort(ask+1,ask+cnt+1,cmp);
	int j = 1;
	for(int i = 1;i<= cnt;i++)
	{
		while(tr[j].y<=ask[i].y&&j<=n)
		{
			C.update(find(tr[j].x),1);
			j++;
		}
		ask[i].ans = C.getans(find(ask[i].x));
	}
	sort(ask+1,ask+cnt+1,fir);
	for(int i = 1;i<= m;i++)
	{
		int t = (i-1)*4;
		printf("%d\n",ask[t+1].ans-ask[t+2].ans-ask[t+3].ans+ask[t+4].ans);
	}
}
Problem1951

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL mod[5] = {0,2,3,4679,35617};
LL fac[5][40000];
LL env[5][40000];
LL c(int n,int m,int modn)
{
    LL tmp = fac[modn][m]*fac[modn][n-m]%mod[modn];
    return fac[modn][n]*env[modn][tmp]%mod[modn];
}
LL lucas(int n,int m,int m_n)
{
    LL ans = 1;
    while(n&&m&&ans) 
    {
        ans = (ans*c(n%mod[m_n],m%mod[m_n],m_n))%mod[m_n];
        n /= mod[m_n];
        m /= mod[m_n];
    }
    return ans;
}
LL xx,yy,d;
void ex_gcd(LL a,LL b)
{
    if(b==0)
    {
        xx = 1;
        yy = 0;
        d = a;
        return ;
    }
    ex_gcd(b,a%b);
    LL tmp = xx;
    xx = yy;
    yy = tmp-a/b*xx;
}
LL M[15],Mt = 999911658ll,ans;
LL a[15],envM[5];
LL remain()
{
    LL ans = 0;
    for(int i = 1;i<= 4;i++)
        ans =(ans+envM[i]*a[i]*M[i]%Mt)%Mt;
    return ans;
}
LL p = 0;
void div(LL x)
{
    LL i;
    for(i = 1;i*i<= x;i++)
    {
        //printf("%lld:\n",i);
        if(x%i==0)
        {
            for(int j = 1;j<= 4;j++)
            {
                a[j] = lucas(x,i,j);
                //printf("%lld ",a[j]);
            }
            p = (p+remain())%Mt;
            //printf("\nnow_ans = %lld\n",p);
            //printf("%lld:\n",x/i);
            if(i*i!=x)
            {
                for(int j = 1;j<= 4;j++)
                {
                    a[j] = lucas(x,x/i,j);
                    //printf("%lld ",a[j]);
                }
                p = (p+remain())%Mt;
                //printf("\nnow_ans = %lld\n",p);
            }
        }
    }
}
LL quick(LL x,LL y)
{
    if(y==0)return 1;
    LL tmp = quick(x,y/2);
    if(y%2==1)return tmp*tmp%(Mt+1)*x%(Mt+1);
    else return tmp*tmp%(Mt+1);
}
int main()
{
    long long n,g;
    scanf("%lld%lld",&n,&g);
    for(int i = 1;i<= 4;i++)
    {
        M[i] = Mt/mod[i];
        ex_gcd(M[i],mod[i]);
        xx = (xx%mod[i]+mod[i])%mod[i];
        envM[i] = xx;
    }
    for(int i = 1;i<= 4;i++)
    {
        fac[i][0] = env[i][1] = 1;
        for(LL j = 1;j<= mod[i]+1;j++)
        {
            //if(j==0){fac[i][j] = 1;env[i][j] = 1;continue;}
            fac[i][j] = fac[i][j-1]*j%mod[i];
            if(j!=1)env[i][j] = ((mod[i]-mod[i]/j)*env[i][mod[i]%j])%mod[i];
        }
    }
    /*for(int i = 1;i<= 4;i++)
    {
        for(LL j = 1;j<= 4;j++)
        {
            printf("%lld %lld:%lld\n",fac[i][j],env[i][j],j*env[i][j]%mod[i]);
        }
    }*/
    div(n);
    p = p+Mt;
    printf("%lld\n",quick(g,p));
    return 0;
}
Problem1976

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 7e4+5;
const int M = 7e5+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot=1;
void add(int x,int y,int f1,int f2)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f1;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=f2;
}
queue<int>Q;
int pos[45][45][45];
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int main()
{
	int n,id = 0;
	scanf("%d",&n);
	int st = 0,end = n*n*n+1;
	for(int i=1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
				pos[i][j][k]=++id;
	for(int i= 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
			{
				if(i!=n)add(pos[i][j][k],pos[i+1][j][k],1,1);
				if(j!=n)add(pos[i][j][k],pos[i][j+1][k],1,1);
				if(k!=n)add(pos[i][j][k],pos[i][j][k+1],1,1);
			}
	char ch;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= n;k++)
			{
				ch = getchar();while(ch!='P'&&ch!='N'&&ch!='?')ch = getchar();
				if(ch=='P')
				{
					if((i+j+k)&1)add(st,pos[i][j][k],INF,0);
					else add(pos[i][j][k],end,INF,0);
				}else if(ch=='N')
				{
					if((i+j+k)&1)add(pos[i][j][k],end,INF,0);
					else add(st,pos[i][j][k],INF,0);
				}
			}
	int ans = dinic(st,end);
	printf("%d",3*n*n*(n-1)-ans);
	return 0;
}
Problem1997

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 2e6+5;
struct E
{int next,to;}e[M];
int head[N],tot,c[N],pos[N],u[10005],v[10005];
inline void add(int x,int y)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;}
int dfn[N],Dfn,low[N],bel[N],stack[N],top,dcc;
bool ins[N];
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
void init()
{
	memset(head,0,sizeof(head));
	memset(low,0,sizeof(low));
	memset(dfn,0,sizeof(dfn));
	tot = Dfn = dcc = top = 0;
}
struct data
{
	int l,r;
	data(int _l=0,int _r=0):l(_l),r(_r){}
}qj[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n,m;
		scanf("%d%d",&n,&m);
		init();
		for(int i = 1;i<= m;i++)scanf("%d%d",&u[i],&v[i]);
		for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
		for(int i = 1;i<= n;i++)pos[c[i]] = i;
		if(m>3*n-6){puts("NO");continue;}
		int cnt = 0,x,y;
		for(int i = 1;i<= m;i++)
		{
			x = pos[u[i]],y = pos[v[i]];
			if(x>y)swap(x,y);
			if(y-x==1||(x==1&&y==n))continue;
			qj[++cnt] = data(x,y);
		}
		m = cnt;
		for(int i = 1;i<= m;i++)
			for(int j = i+1;j<= m;j++)
				if((qj[i].l<qj[j].l&&qj[j].l<qj[i].r&&qj[i].r<qj[j].r)||
					(qj[j].l<qj[i].l&&qj[i].l<qj[j].r&&qj[j].r<qj[i].r))
				{
					add(i<<1,j<<1|1);
					add(i<<1|1,j<<1);
					add(j<<1,i<<1|1);
					add(j<<1|1,i<<1);
				}
		for(int i = 2;i<= (m<<1|1);i++)
			if(!dfn[i])tarjan(i);
		bool flag = true;
		for(int i = 1;i<= m&&flag;i++)
			if(bel[i<<1]==bel[i<<1|1])flag = false;
		if(flag)puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem1999

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 5e5+5;
struct E
{int next,to,val;}e[M<<1];
int head[M],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].val  = f;
	e[tot].next = head[x];
	head[x] = tot;
}
queue <int>Q;
int pre[M];
int path[M],cnt,v[M];
LL dis[M],dep[M],Mdep[M],lth[M];
int line[M],L,R;
int end,n,s;
void bfs(int s)
{
	Q.push(s);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!dis[e[i].to]&&e[i].to!=s)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(dis[e[i].to]>dis[end])end = e[i].to;
				Q.push(e[i].to);
			}
	}
	int st = end;
	memset(dis,0,sizeof(dis));
	Q.push(st);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!dis[e[i].to]&&e[i].to!=st)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				pre[e[i].to] = x;
				if(dis[e[i].to]>dis[end])end = e[i].to;
				Q.push(e[i].to);
			}
	}
	int x = end;
	while(x!=st)
	{
		path[++cnt] = x;
		lth[cnt] = dis[end]-dis[x];
		v[x] = true;
		x = pre[x];
	}
	path[++cnt] = x;
	v[x] = true;
	lth[cnt] = dis[end]-dis[x];
	return ;
}
void get_Maxdep(int st,int no)
{
	dep[st] = 0;
	Q.push(st);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		Mdep[no] = max(Mdep[no],dep[x]);
		for(int i = head[x];i;i = e[i].next)
			if(!v[e[i].to]&&!dep[e[i].to])
				dep[e[i].to] = dep[x]+e[i].val,Q.push(e[i].to);
	}
}
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c);
		add(y,x,c);
	}
	bfs(1);
	for(int i = 1;i<= cnt;i++)
		get_Maxdep(path[i],i);
	int j = 1;
	LL ans = 1e18+1;
	L = 0,R = -1;
	for(int i = 1;i<= cnt;i++)
	{
		while(L<=R&&lth[i]-lth[line[L]]>s)L++;
		while(i>=j&&lth[i]-lth[j]>s)j++;
		while(L<=R&&Mdep[i]>=Mdep[line[R]])R--;
		line[++R] = i;
		ans = min(ans,max(Mdep[line[L]],max(lth[j],lth[cnt]-lth[i])));
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2001

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 0x3f3f3f3f;
typedef long long ll;
int fa[N],Fa[N];
void Init(int n)
{
	for(int i = 1;i<=n;i++)fa[i] = i;
}
int getfa(int x)
{
	return fa[x]==x?x:(fa[x]=getfa(fa[x]));
}
struct P
{
	int x,y,w,k,id;
	bool operator<(const P &s)const 
		{return w<s.w;}
}e[20][N];
struct C
{
	int x,to;
}chg[N];
int pos[N],dis[N],pa[N];
void init(int m)
{
	for(int i = 1;i<= m;i++)
		dis[e[0][i].id] = e[0][i].w;
}
void solve(int d,int L,int R,int n,int m,ll ans = 0ll)
{
	for(int i = 1;i<= m;i++)
	{
		P &a = e[d][i],a2 = e[d-1][i];
		a = (P){a2.x,a2.y,dis[a2.id],0,a2.id};
		pos[a.id] = i;
	}
	if(L==R)
	{
		C &b = chg[L];
		e[d][pos[b.x]].w = dis[b.x] = b.to;
		Init(n);
		sort(e[d]+1,e[d]+m+1);
		for(int i = 1;i<= m;i++)
		{
			P &tmp = e[d][i];
			int x = getfa(tmp.x),y = getfa(tmp.y);
			if(x==y)continue;
			fa[y] = x;
			ans+=tmp.w;
		}
		printf("%lld\n",ans);
		return ;
	}
	int mid = (L+R)>>1;
	for(int i = L;i<=R;i++)e[d][pos[chg[i].x]].k = 1;
	Init(n);
	sort(e[d]+1,e[d]+m+1);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			a.k = 2;
		}
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==1)e[d][i].w = -INF;
	Init(n);
	sort(e[d]+1,e[d]+m+1);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k!=0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			if(a.k!=1)a.k = 3;
		}
	Init(n);
	for(int i = 1;i<= m;i++)
		if(e[d][i].k==3)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			fa[y] = x;
			ans+=a.w;
		}
	int newn = 0,newm = 0;
	for(int i = 0;i<= n;i++)Fa[i] = 0;
	for(int i = 1;i<= n;i++)
	{
		int x = getfa(i);
		if(!Fa[x])Fa[x] = ++newn;
	}
	for(int i = 1;i<= m;i++)
		if(e[d][i].k!=0)
		{
			P &a = e[d][i];
			int x = getfa(a.x),y = getfa(a.y);
			if(x==y)continue;
			e[d][++newm] = (P){Fa[x],Fa[y],a.w,a.k,a.id};
		}
	solve(d+1,L,mid,newn,newm,ans);
	solve(d+1,mid+1,R,newn,newm,ans);
}
int main()
{
	int n,m,q;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&e[0][i].x,&e[0][i].y,&e[0][i].w);
		e[0][i].id = i;
	}
	for(int i = 1;i<= q;i++)
		scanf("%d%d",&chg[i].x,&chg[i].to);
	init(m);
	solve(1,1,q,n,m);
	return 0;
}
Problem2002

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 2e5+5;
struct Splay{
	Splay *fa,*ls,*rs;
	int size;
	void push_up();
	Splay();
}*null = new Splay(),tree[M];
void Splay :: push_up()
{
	size = ls->size+rs->size+1;
}
Splay :: Splay()
{
	ls = rs = fa = null;
	size = 1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==x->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void link(Splay *x,Splay *y)
{
	access(x);
	splay(x);
	x->ls->fa = null;
	x->ls = null;
	x->fa = y;
	x->push_up();
}
int main()
{
	null->ls = null->rs = null->fa = null;
	null ->size = 0;
	int n,x;
	Splay *root;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(i+x<=n)
			tree[i].fa = &tree[i+x];
	}
	int m,p,y;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&p);
		if(p==1)
		{
			scanf("%d",&x);x++;
			access(&tree[x]);
			splay(&tree[x]);
			printf("%d\n",tree[x].size);
		}else
		{
			scanf("%d%d",&x,&y);x++;
			if(x+y<=n)root = &tree[x+y];
			else root = null;
			link(&tree[x],root);
		}
	}
	return 0;
}
Problem2004

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<set>
#include<ctime>
#include<vector>
#include<queue>
#include<algorithm>
#include<map>
#include<cmath>
#define mod 30031
#define inf 1000000000
#define rad 100000000
#define pa pair<int,int>
#define ll long long 
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int bin[20];
int n,K,P,cnt;
int v[205];
struct M{
	ll v[205][205];
	M(){
		memset(v,0,sizeof(v));
	}
	friend M operator*(M a,M b){
		M c;
		for(int i=1;i<=cnt;i++)
			for(int j=1;j<=cnt;j++)
			{
				for(int k=1;k<=cnt;k++)
					c.v[i][j]+=a.v[i][k]*b.v[k][j];
				c.v[i][j]%=mod;
			}
		return c;
	}
	friend M operator^(M a,int b){
		M ans;
		for(int i=1;i<=cnt;i++)ans.v[i][i]=1;
		for(int i=b;i;i>>=1,a=a*a)
			if(i&1)ans=ans*a;
		return ans;
	}
}a,b,ans;
int lowbit(int x)
{
	return x&(-x);
}
void dfs(int now,int num,int sta)
{
	if(num==K)
	{
		v[++cnt]=sta;
		return;
	}
	for(int i=now-1;i;i--)
		dfs(i,num+1,sta+bin[i-1]);
}
void pre()
{
	for(int i=1;i<=cnt;i++)
		for(int j=1;j<=cnt;j++)
		{
			int x=(v[i]<<1)^bin[P]^v[j];
			if(x==lowbit(x))
			    b.v[i][j]=1;
		}
}
int main()
{
	bin[0]=1;for(int i=1;i<20;i++)bin[i]=bin[i-1]<<1;
	n=read();K=read();P=read();
	dfs(P,1,bin[P-1]);
	pre();
	ans.v[1][1]=1;
	M t=b^(n-K);
	ans=ans*t;
	printf("%d\n",ans.v[1][1]);
	return 0;
}
Problem2005

#include<stdio.h>
typedef long long LL;
long long f[100005];
LL min(LL a,LL b)
{
    if(a>b)return b;
    return a;
}
int main()
{
    LL n,m;
    scanf("%lld%lld",&n,&m);
    LL tmp = min(n,m);
    LL ans = 0;
    for(LL i = tmp;i>=1;i--)
    {
        f[i] = (n/i)*(m/i);
        for(LL j = 2;j<= n/i;j++)
        {
            f[i] = f[i] - f[i*j];
        }
        ans = ans+f[i]*(2*i-1);
    }
    printf("%lld",ans);
    return 0;
}
Problem2007

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
//int map[N][N][4];
struct E{int to,next,val;}e[N*N*9];
int head[N*N],tot,cnt,st,end,n;
struct H{int v;long long p;}P[N*N*4];
void go_up(int x)
{
	int i = x;
	while((i>>1)>=1&&P[i].v<P[i>>1].v)
	{
		swap(P[i],P[i>>1]);
		i = i>>1;
	}
}
int getnum(int i,int j){return (i-1)*n+j;}
bool cmp(H a,H b){return a.v>b.v;}
void go_down(int x)
{
	int i = x;
	while(((i<<1)|1)<=cnt)
	{
		if(P[i].v>P[i<<1].v&&P[i].v>P[(i<<1)|1].v)
		{
			swap(P[i],P[i<<1].v>P[(i<<1)|1].v?P[(i<<1)|1]:P[i<<1]);
			i = P[i<<1].v>P[(i<<1)|1].v?((i<<1)|1):(i<<1);
		}else if(P[i].v>P[i<<1].v)
		{
			swap(P[i],P[i<<1]);
			i = i<<1;
		}
		else if(P[i].v>P[i<<1|1].v)
		{
			swap(P[i],P[i<<1|1]);
			i = i<<1|1;
		}
		else break;
	}
	if((i<<1)<=cnt&&P[i<<1].v<P[i].v)
		swap(P[i],P[i<<1]);
}
void insert(int per,long long lth)
{
	H tmp;
	tmp.v = lth;tmp.p = per;
	P[++cnt] = tmp;
	go_up(cnt);
}
int pop()
{
	int tmp = P[1].p;
	swap(P[1],P[cnt]);
	cnt--;
	go_down(1);
	return tmp;
}
long long f[N*N];
bool in[N*N];
void dijk()
{
	memset(f,0x3f,sizeof(f));
	f[st] = 0;
	P[1].v = 0,P[1].p = st;
	cnt++;
	//insert(st,0);
	while(cnt)
	{
		int x = P[1].p;
		pop_heap(P+1,P+cnt+1,cmp);
		cnt--;
		if(in[x])continue;
		in[x] = true;
		for(int i = head[x];i;i = e[i].next)
		{
			int y = e[i].to;
			if(f[x]+e[i].val<f[y])
			{
				f[y] = f[x]+e[i].val;
				cnt++;
				P[cnt].p = y;P[cnt].v = f[y];
				push_heap(P+1,P+cnt+1,cmp);
				//insert(y,f[y]);
			}
		}
	}
	return ;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void show_edge(int x)
{
    for(int i = head[x];i;i = e[i].next)
        printf("%d %d:%d\n",x,e[i].to,e[i].val);
}
int main()
{
	scanf("%d",&n);
	int a;
	st = n*n+1,end = n*n+2;
    for(int i=1;i<=n;i++){scanf("%d",&a);add(st,getnum(1,i),a);}
    for(int i=1;i<n;i++)
        for(int j=1;j<=n;j++) 
            {scanf("%d",&a);add(getnum(i,j),getnum(i+1,j),a);}
    for(int i=1;i<=n;i++)
        {scanf("%d",&a);add(getnum(n,i),end,a);}
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        add(getnum(i,1),end,a);
        for(int j=2;j<=n;j++) {scanf("%d",&a);add(getnum(i,j),getnum(i,j-1),a);}
        scanf("%d",&a);
    	add(st,getnum(i,n),a);
    }
    for(int i=1;i<=n;i++) scanf("%d",&a);
    for(int i=1;i<n;i++)
        for(int j=1;j<=n;j++) 
        	{scanf("%d",&a);add(getnum(i+1,j),getnum(i,j),a);}
    for(int i=1;i<=n;i++) scanf("%d",&a);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        for(int j=2;j<=n;j++){scanf("%d",&a);add(getnum(i,j-1),getnum(i,j),a);}
        scanf("%d",&a);
    }
	dijk();
	printf("%lld\n",f[end]);
	return 0;
}
Problem2038

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 50100;
int n,q,size;
int pos[N],c[N];
ll s[N];
ll sqr(ll x){return x*x;}
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
struct Ask
{
	int l,r,bel;
	ll up,dwn;
	bool operator <(const Ask &s)const
	{
		if(pos[l]==pos[s.l])return r<s.r;
		else return l<s.l;
	}
}ask[N];
bool cmp(const Ask &a,const Ask &b)
{
	return a.bel<b.bel;
}
ll ans;
void update(int x,int add)
{
	ans-=sqr(s[c[x]]);
	s[c[x]]+=add;
	ans+=sqr(s[c[x]]);
}

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	size = sqrt(n)+1;
	for(int i = 1;i<= n;i++)
		pos[i] = i/size;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].bel = i;
	}
	sort(ask+1,ask+m+1);
	int l = 1,r = 0;
	for(int i = 1;i<= m;i++)
	{
		while(r<ask[i].r)r++,update(r,1);
		while(r>ask[i].r)update(r,-1),r--;
		while(l>ask[i].l)l--,update(l,1);
		while(l<ask[i].l)update(l,-1),l++;
		if(ask[i].l==ask[i].r)
			ask[i].up = 0,ask[i].dwn = 1;
		else
		{
			ask[i].up = ans-(ask[i].r-ask[i].l+1);
			ask[i].dwn = (ll)(ask[i].r-ask[i].l+1)*(ask[i].r-ask[i].l);
			ll g = gcd(ask[i].up,ask[i].dwn);
			ask[i].up/=g,ask[i].dwn/=g;
		}
	}
	sort(ask+1,ask+m+1,cmp);
	for(int i = 1;i<= m;i++)
		printf("%lld/%lld\n",ask[i].up,ask[i].dwn);
	return 0;
}
Problem2049

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
struct Splay
{
	Splay *ls,*rs,*fa;
	bool rev;
	Splay();
	void reverse();
	void push_down();
}*null = new Splay(),tree[N];
void Splay :: push_down()
{
	if(fa->ls==this||fa->rs==this)
		fa->push_down();
	if(rev)
	{
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		ls->rev^=1;
		rs->rev^=1;
		rev = 0;
	}
}
Splay :: Splay()
{
	ls = rs = fa = null;
	rev = false;
}
void Splay :: reverse()
{
	swap(ls,rs);
	rev^=1;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void splay(Splay *x)
{
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else 
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
Splay* find_root(Splay *x)
{
	while(x->fa!=null)
		x = x->fa;
	return x;
}
void link(Splay *x,Splay *y)
{
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	x->fa = null;
	y->ls = null;
}
int main()
{
	null->ls = null->rs = null->fa = null;
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	char opt[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		scanf("%d%d",&x,&y);
		if(opt[0]=='C')link(&tree[x],&tree[y]);
		else if(opt[0]=='D')cut(&tree[x],&tree[y]);
		else
		{
			Splay *tmp = find_root(&tree[x]);
			if(tmp==find_root(&tree[y]))printf("Yes\n");
			else printf("No\n");
		}
	}
	return 0;
}
Problem2055

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f,c,from;
}e[M];
int head[N],tot = 1;
int in[N],out[N],ans;
void add(int x,int y,int lr,int ur,int c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].f = ur-lr,e[tot].c = c,e[tot].from = x;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	e[tot].f = 0;e[tot].c = -c;e[tot].from = y;
	out[x]+=lr,in[y]+=lr;
	ans+=lr*c;
}
bool vis[N];
int dis[N],from[N];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = 1;i<= t;i++)dis[i] = INF,vis[i] = false;
	Q.push(s);
	dis[s] = 0;
	vis[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=INF;
}
void get_mcf(int s,int t)
{
	int x = INF;
	for(int i = from[t];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[t];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=x*e[i].c;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int SS = n+n+2,TT = n+n+3,S = n+n+4,T = n+n+5;
	add(SS,n+n+1,0,m,0);
	for(int i = 1;i<= n;i++)
		add(n+n+1,i,0,INF,0),add(i+n,TT,0,INF,0);
	int x;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		add(i,i+n,x,x,0);
	}
	for(int i = 1;i< n;i++)
		for(int j = 1;j<=n-i;j++)
		{
			scanf("%d",&x);
			if(x==-1)continue;
			add(n+i,i+j,0,INF,x);
		}
	add(TT,SS,0,INF,0);
	for(int i = 1;i<= TT;i++)
		if(in[i]<out[i])
			add(i,T,0,out[i]-in[i],0);
		else if(out[i]<in[i])
			add(S,i,0,in[i]-out[i],0);
	while(spfa(S,T))get_mcf(S,T);
	printf("%d\n",ans);
	return 0;
}
Problem2064

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1<<10;
const int INF = 0x3f3f3f3f;
int cnt[M];
int f[M][M],logn[15];
int a[15],b[15],suma[M],sumb[M];
void dfs(int k,int state,int *t,int s,int *ans)
{
    if(k==t[0]+1)return ;
    ans[state<<(t[0]-k)]=s;
    dfs(k+1,state*2+1,t,s+t[k+1],ans);
    dfs(k+1,state*2,t,s,ans);
}
void init()
{
	for(int i = 0;i<M;i++)
	{
		int tmp = i;
		while(tmp)
		{
			tmp-=tmp&(-tmp);
			cnt[i]++;
		}
	}
	for(int i = 2;i<= 10;i++)
		logn[i] = logn[i>>1]+1;
	dfs(0,0,a,0,suma);
    dfs(0,0,b,0,sumb);
}
int main()
{
	//memset(f,0x3f,sizeof(f));
	scanf("%d",&a[0]);
	for(int i = 1;i<= a[0];i++)
		scanf("%d",&a[i]);
	scanf("%d",&b[0]);
	for(int i = 1;i<= b[0];i++)
		scanf("%d",&b[i]);
	init();
	for(int i = 1;i<1<<a[0];i++)
	{
		for(int j = 1;j<1<<b[0];j++)
		{
			for(int k = 1;k<= a[0];k++)
			{
				int tmp = 1<<(k-1);
				if((i&tmp)>0)f[i][j] = max(f[i][j],f[i-tmp][j]);
			}
			for(int k = 1;k<= b[0];k++)
			{
				int tmp = 1<<(k-1);
				if((j&tmp)>0)f[i][j] = max(f[i][j],f[i][j-tmp]);
			}
			if(suma[i]==sumb[j])f[i][j]++;
		}
	}
	printf("%d\n",a[0]+b[0]-2*f[(1<<a[0])-1][(1<<b[0])-1]);
	return 0;
}
Problem2073

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 17;
const int S = 1<<16;
int w[N],t[N],cnt,v[S],f[S];
int gt[S],n,W;
void init()
{
	for(int i = 0;i<1<<n;i++)
	{
		int Gw = 0,Gt = 0;
		for(int j = 0;j<n;j++)
			if(i&(1<<j))
			{
				Gw+=w[j+1];
				Gt = max(Gt,t[j+1]);
			}
		if(Gw<=W)
		{
			gt[++cnt] = Gt;
			v[i] = cnt;
		}
	}
}
int main()
{
	memset(f,0x3f,sizeof(f));
	scanf("%d%d",&W,&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&t[i],&w[i]);
	init();
	f[0] = 0;
	for(int i = 0;i<1<<n;i++)
	{
		for(int k = i;k;k = (k-1)&i)
			if(v[k])
				f[i] = min(f[i],f[i-k]+gt[v[k]]);
	}
	printf("%d\n",f[(1<<n)-1]);
	return 0;
}
Problem2079

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		uni(x,y);
	}
	bool flag = true;
	for(int i = 1;i<= n;i++)
		if(fa[i]==0)
			flag = false;
	if(flag)printf("TAK\n");
	else printf("NIE\n");
	return 0;
}
Problem2084

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int s[N],a[N<<1];
int no[N<<1],p[N<<1];
long long ans;
int maxp,id;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%1d",&s[i]);
	int len = 0;
	for(int i = 1;i<=n;i++)
	{
		a[++len]=s[i];
		no[len]=i;
		if(i!=n)a[++len]=-1;
	}
	maxp = 1,id = 1;
	for(int i = 1;i<= len;i++)
	{
		if(i<=maxp)p[i]=min(p[id*2-i],maxp-i);
		while(i+p[i]<=len&&i-p[i]>=1&&(a[i+p[i]]+a[i-p[i]]==1||a[i+p[i]]+a[i-p[i]]==-2))p[i]++;
		p[i]--;
		if(i+p[i]>maxp){maxp = i+p[i];id = i;}
		ans+=(no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1])-(no[i]?no[i]:no[i+1])+1;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2086

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
int stack[N],top;
int a[N];
LL sum[N];
int main()
{
	int n,m,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	while(m--)
	{
		scanf("%d",&k);
		for(int i = 1;i<= n;i++)
			sum[i] = sum[i-1]+a[i]-k;
		for(int i = 1;i<= n;i++)
			if(sum[i]<sum[stack[top]])
				stack[++top] = i;
		int ans = 0;
		for(int i = n;i>=0;i--)
		{
			while(top&&sum[i]>=sum[stack[top-1]])top--;
			ans = max(ans,i-stack[top]);
		}
		if(m)printf("%d ",ans);
		else printf("%d\n",ans);
	}
	return 0;
}
Problem2095

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2005;
const int EM = 1e6+5;
const int INF = 0x3f3f3f3f;
struct Edge
{
	int x,y,a,b;
	Edge(int x=0,int y=0,int a=0,int b=0):x(x),y(y),a(a),b(b){}
}ed[M];
struct E
{int next,to,f;}e[EM];
int head[N],tot=1,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int fa[N],cnt;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
	cnt--;
}
int dgr[N],S,T;
bool judge(int ans)
{
	memset(fa,0,sizeof(fa));cnt=n;
	memset(head,0,sizeof(head));tot = 1;
	memset(dgr,0,sizeof(dgr));
	for(int i = 1;i<= m;i++)
	{
		if(ed[i].b<=ans)
		{
			uni(ed[i].x,ed[i].y);
			dgr[ed[i].x]++;
			dgr[ed[i].y]--;
			add(ed[i].x,ed[i].y,1);
		}
		else if(ed[i].a<=ans)
		{
			uni(ed[i].x,ed[i].y);
			dgr[ed[i].x]--;
			dgr[ed[i].y]++;
		}
	}
	if(cnt>=2)return false;
	for(int i = 1;i<= n;i++)
	{
		if(dgr[i]&1)return false;
		if(dgr[i]>0)
			add(S,i,dgr[i]>>1);
		else add(i,T,(-dgr[i])>>1);
	}
	dinic(S,T);
	for(int i =head[S];i;i=e[i].next)
		if(e[i].f)
			return false;
	return true;
}
int main()
{
	scanf("%d%d",&n,&m);
	S = 0,T = n+1;
	int x,y,a,b,max_num = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&a,&b);
		if(a>b)swap(a,b),swap(x,y);
		ed[i]=Edge(x,y,a,b);
		max_num = max(max_num,b);
	}
	int l = 1,r = max_num+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(judge(mid))r = mid;
		else l = mid+1;
	}
	if(l!=max_num+1)printf("%d\n",l);
	else printf("NIE\n");
	return 0;
}
Problem2096

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3000005;
int q1[N],q2[N],l1,l2,r1,r2;
int a[N];
int main()
{
	int n,k,ans = 0;
	scanf("%d%d",&k,&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&a[q1[r1]]<a[i])r1--;q1[++r1] = i;
		while(l2<=r2&&a[q2[r2]]>a[i])r2--;q2[++r2] = i;
		while(a[q1[l1]]-a[q2[l2]]>k)
		{
			j++;
			while(l1<=r1&&q1[l1]<j)l1++;
			while(l2<=r2&&q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2097

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int stack[N],cnt,a[N];
bool cmp(int a,int b){return a>b;}
int dp(int x,int fa,int lim)
{
	int top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			a[e[i].to] = dp(e[i].to,x,lim);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			stack[++top] = a[e[i].to];
	sort(stack+1,stack+top+1,cmp);
	int max_dep = 0;
	if(top)
	{
		int i;
		for(i = 1;i<= top;i++)
		{
			if(stack[i]+1>lim)
				cnt++;
			else if(i<top&&stack[i]+stack[i+1]+2>lim)
				cnt++;
			else break;
		}
		if(i<=top)max_dep = stack[i]+1;
	}
	return max_dep;
}
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	int L = 0,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		cnt = 0;
		dp(1,0,mid);
		if(cnt>k)L = mid+1;
		else R = mid;
	}
	printf("%d\n",L);
	return 0;
}
Problem2115

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2e5+5;
const int N = 5e4+5;
typedef long long ll;
struct E
{
	int to,next;
	ll val;
}e[N<<1];
int head[N],tot;
void add(int x,int y,ll f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
ll sum[N];
void dfs(int x,int f)
{
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=f)
	{
		sum[e[i].to] = sum[x]^e[i].val;
		dfs(e[i].to,x);
	}
}
int st[M],end[M];
ll a[M],p[70],dis[M];
bool on_tree[M];
int father[N];
int getfa(int x)
{
	if(father[x]==x)return x;
	else return father[x] = getfa(father[x]);
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)father[i] = i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%lld",&st[i],&end[i],&dis[i]);
		int fx = getfa(st[i]),fy = getfa(end[i]);
		if(fx==fy)continue;
		add(st[i],end[i],dis[i]);
		on_tree[i] = true;
		father[fx] = fy;
	}
	dfs(1,0);
	ll ans = sum[n];
	int tot = 0;
	for(int i = 1;i<= m;i++)
		if(!on_tree[i])
			a[++tot] = sum[st[i]]^sum[end[i]]^dis[i];
	for(int i = 1;i<= tot;i++)
		for(int j = 63;j>= 0;j--)
			if((a[i]>>j)&1)
			{
				if(!p[j]){p[j] = a[i];break;}
				else a[i]^=p[j];
			}
	for(int i = 63;i>= 0;i--)if((ans^p[i])>ans)ans = ans^p[i];
	printf("%lld\n",ans);
	return 0;
}
Problem2121

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int dp[155][35],f[155],p[155][35],len[35],bin[25],n,m;
bool ok[155][155];
char s[35][25],str[155];

int main()
{
	scanf("%s",str+1);
	m = strlen(str+1);
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s[i]+1);
		len[i] = strlen(s[i]+1);
	}
	bin[0] = 1;
	for(int i = 1;i<= 22;i++)
		bin[i] = bin[i-1]<<1;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<= len[j];k++)
				if(str[i]==s[j][k])
					p[i][j]|=bin[k];
	for(int i = m;i;i--)
	{
		for(int j = 1;j<= n;j++)dp[i-1][j] = 1;
		for(int j = i;j<= m;j++)
		for(int k = 1;k<= n;k++)
		{
			dp[j][k]=(dp[j-1][k]<<1)&p[j][k];
            for (int x=i; x<j; x++) if (ok[x+1][j]) dp[j][k]|=dp[x][k];
			if  (dp[j][k]&bin[len[k]]) ok[i][j]=1;
		}
	}
	for(int i = 1;i<= m;i++)
	{
		f[i] = f[i-1]+1;
		for(int j = 1;j<= i;j++)
			if(ok[j][i])
				f[i] = min(f[i],f[j-1]);
	}
	printf("%d\n",f[m]);
	return 0;
}
Problem2124

#include<iostream>  
#include<cstdio>  
#include<cstring>  
#define ll long long  
#define mod 1000000007  
#define N 10005  
using namespace std;  
  
int n,a[N],pw[N];  
struct bit_node
{  
	int c[N];  
	void clr()
	{ memset(c,0,sizeof(c)); }  
	void add(int x)
	{  
		int i; for (i=x; i<=n; i+=i&-i) c[i]=(c[i]+pw[i-x])%mod;  
	}  
	int getsum(int x)
	{  
		int i,t=0; for (i=x; i; i^=i&-i) t=((ll)c[i]*pw[x-i]+t)%mod;  
		return t;  
	}  
	int qry(int x,int y)
	{  
		int p=getsum(x-1),q=getsum(y);  
		return (q-(ll)p*pw[y-x+1]%mod+mod)%mod;  
	}  
}bit1,bit2;  
int main()
{  
	int cas,i;
	scanf("%d",&cas);  
	pw[0]=1;
	for(i=1; i<=10000; i++) 
		pw[i]=(ll)pw[i-1]*12347%mod;  
	while (cas--)
	{  
		scanf("%d",&n); 
		int x;  
		for (i=1; i<=n; i++) 
			scanf("%d",&a[i]);  
		bit1.clr(); bit2.clr();  
		for (i=1; i<=n; i++)
		{  
			x=min(a[i]-1,n-a[i]);  
			if (x && bit1.qry(a[i]-x,a[i]-1)!=bit2.qry(n-a[i]-x+1,n-a[i])) break;  
			bit1.add(a[i]); bit2.add(n-a[i]+1);  
		}  
		puts((i>n)?"N":"Y");  
	}  
	return 0;  
}  
Problem2125

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,m,q;
namespace Cactus
{
	struct E
	{int next,to,val;}e[N];
	int head[N],tot=1;
	int fa[N],dep[N],dfn[N],Dfn;
	bool on_ring[N];
}
namespace RST
{
	struct E
	{
		int next,to,dis,val;
	}e[N];
	int head[N],tot=1,size[N],dis[N],n;
	int fa[N][18],dep[N];
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void getinfo(int x,int pre)
	{
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<= 17;i++)
			fa[x][i] =fa[fa[x][i-1]][i-1];
		if(x<=::n)
		{
			for(int i = head[x];i;i=e[i].next)
				if(i^pre^1)
				{
					if(e[i].to<=::n)e[i].dis = e[i].val = abs(Cactus::dep[e[i].to]-Cactus::dep[x]);
					else e[i].val = e[i].dis = 0;
				}
		}else
		{
			for(int i = head[x];i;i=e[i].next)
				if(i^pre^1)
				{
					e[i].dis = (Cactus::dep[e[i].to]-Cactus::dep[fa[x][0]]+size[x])%size[x];
					e[i].val = min(e[i].dis,size[x]-e[i].dis);
				}
		}
		for(int i = head[x];i;i=e[i].next)
			if(pre^i^1)
			{
				fa[e[i].to][0] = x;
				dis[e[i].to] = dis[x]+e[i].val;
				getinfo(e[i].to,i);
			}
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 17;i>= 0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 17;i>= 0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	int go_up(int x,int d)
	{
		for(int i = 17;i>= 0;i--)
			if((d>>i)&1)x = fa[x][i];
		return x;
	}
	int getans(int x,int y)
	{
		int lca = getlca(x,y);
		if(lca<=::n)return dis[x]+dis[y]-dis[lca]*2;
		else
		{
			int tx = go_up(x,dep[x]-dep[lca]-1);
			int ty = go_up(y,dep[y]-dep[lca]-1);
			int tmp = ((Cactus::dep[tx]-Cactus::dep[ty])%size[lca]+size[lca])%size[lca];
			return dis[x]+dis[y]-dis[tx]-dis[ty]+min(tmp,size[lca]-tmp);
		}
	}
}
namespace Cactus
{
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
	}
	void dfs(int x,int pre)
	{
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)if(i^pre^1)
		{
			if(!dfn[e[i].to])
			{
				fa[e[i].to] = x;
				dep[e[i].to] = dep[x]+e[i].val;
				on_ring[x] = false;
				dfs(e[i].to,i);
				if(!on_ring[x])
					RST::add(x,e[i].to);
			}else
			{
				if(dfn[e[i].to]>dfn[x])
					continue;
				int tmp = x;
				++RST::n;
				while(true)
				{
					RST::add(RST::n,tmp);
					on_ring[tmp] = true;
					if(tmp==e[i].to)break;
					tmp = fa[tmp];
				}
				RST::size[RST::n] = dep[x]-dep[e[i].to]+e[i].val;
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	RST::n = n;
	int x,y,z;
	while(m--)
	{
		scanf("%d%d%d",&x,&y,&z);
		Cactus::add(x,y,z);
	}
	Cactus::dfs(1,0);
	RST::getinfo(1,0);
	while(q--)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",RST::getans(x,y));
	}
	return 0;
}
Problem2130

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int mx[N<<2],lmx[N<<2],rmx[N<<2];
int F[N<<2];
void Push_up(int p)
{
	lmx[p] = lmx[p<<1];
	rmx[p] = rmx[p<<1|1];
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
int sa[N],sb[N],sc[N],a[N],b[N],c[N],pb[N],pc[N],K[N],f[N];
void update(int p,int r,int v)
{
	lmx[p] = rmx[p] = F[p] = v;
	mx[p] = v+sb[r];
}
void build(int p,int l,int r)
{
	F[p] = -1;
	if(l==r)
	{
		lmx[p] = rmx[p] = f[l];
		mx[p] = f[l]+sb[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	Push_up(p);
}
void Update(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b)
	{
		if(lmx[p]<=v)return ;
		if(rmx[p]>=v){update(p,r,v);return ;}
	}
	int mid = (l+r)>>1;
	if(F[p]!=-1)
		update(p<<1,mid,F[p]),update(p<<1|1,r,F[p]),F[p]=-1;
	if(a<=mid)Update(p<<1,l,mid,a,b,v);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,v);
	Push_up(p);
}
int main()
{
	char opt[3];
	scanf("%s",opt);
	int cas,i;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		for(i = 1;i<= n;i++)scanf("%d",&K[i]);
		for(i = 1;i<= n;i++)scanf("%d",&a[i]);
		for(i = 1;i<= n;i++)scanf("%d",&b[i]),pb[b[i]]=i;
		for(i = 1;i<= n;i++)scanf("%d",&c[i]),pc[c[i]]=i;
		for(i = 1;i<= n;i++)scanf("%d",&sa[i]),sa[i]+=sa[i-1];
		for(i = 1;i<= n;i++)scanf("%d",&sb[i]),sb[i]+=sb[i-1];
		for(i = 1;i<= n;i++)scanf("%d",&sc[i]),sc[i]+=sc[i-1];
		f[0] = sc[n];
		for(int i = 1;i<= n;i++)
			if(K[b[i]]==1)
				f[i] = min(f[i-1],sc[pc[b[i]]-1]);
			else
				f[i] = f[i-1];
		build(1,0,n);
		int ans = mx[1];
		for(int i = 1;i<= n;i++)
		{
			if(K[a[i]]==1)
			{
				Update(1,0,n,pb[a[i]],n,-1<<30);
				Update(1,0,n,0,n,sc[pc[a[i]]-1]);
			}else
				Update(1,0,n,pb[a[i]],n,sc[pc[a[i]]-1]);
			ans = max(ans,sa[i]+mx[1]);
		}
		printf("%d",ans);
		puts("");
	}
	return 0;
}
Problem2134

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10000005;
int a[N];
int main()
{
	int n,A,B,C;
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a+1); 
	for(int i=2;i<=n;i++) 
		a[i] = ((long long)a[i-1]*A+B)%100000001; 
	for(int i=1;i<=n;i++) 
		a[i] = a[i]%C+1; 
	double ans = 1.0/(double)max(a[1],a[n]);
	for(int i = 2;i<= n;i++)
		ans+=1.0/(double)max(a[i],a[i-1]);
	printf("%.3f\n",ans);
	return 0;
}
Problem2141

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,key,size;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->rs)x = x->ls;
		else if(!x->ls)x = x->rs;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int get_less(Treap *x,int y)
{
	int tmp = 0;
	if(!x)return tmp;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return tmp;
	}else if(y<x->val)return get_less(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_less(x->rs,y);
	}
}
int get_lessnqul(Treap *x,int y)
{
	int tmp = 0;
	if(!x)return tmp;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		tmp+=x->cnt;
		return tmp;
	}else if(y<x->val)return get_lessnqul(x->ls,y);
	else 
	{
		tmp+=x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_lessnqul(x->rs,y);
	}
}
int get_bigger(int p,int l,int r,int a,int b,int y)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)return r-l+1-get_lessnqul(root[p],y);
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=get_bigger(p<<1,l,mid,a,b,y);
	if(b >mid)ans+=get_bigger(p<<1|1,mid+1,r,a,b,y);
	return ans;
}
int get_smaller(int p,int l,int r,int a,int b,int y)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)return get_less(root[p],y);
	int mid=(l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=get_smaller(p<<1,l,mid,a,b,y);
	if(b >mid)ans+=get_smaller(p<<1|1,mid+1,r,a,b,y);
	return ans;
}
void update(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,a,b);
	else update(p<<1|1,mid+1,r,pos,a,b);
}
void build(int p,int l,int r,int pos,int num)
{
	Insert(root[p],num);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
int a[N];
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		build(1,1,n,i,a[i]);
	int ans = 0;
	for(int i=1;i<=n;i++)
		ans+=get_bigger(1,1,n,1,i-1,a[i]);
	int x,y;
	scanf("%d",&m);
	while(m--)
	{
		printf("%d\n",ans);
		scanf("%d%d",&x,&y);
		if(a[x]==a[y]||x==y)continue;
		int flag =((x<y&&a[x]>a[y])||(x>y&&a[x]<a[y]));
		ans+=flag;
		ans-=get_bigger(1,1,n,1,x-1,a[x])+get_smaller(1,1,n,x+1,n,a[x]);
		ans-=get_bigger(1,1,n,1,y-1,a[y])+get_smaller(1,1,n,y+1,n,a[y]);
		update(1,1,n,x,a[x],a[y]);update(1,1,n,y,a[y],a[x]);
		swap(a[x],a[y]);
		ans+=get_bigger(1,1,n,1,x-1,a[x])+get_smaller(1,1,n,x+1,n,a[x]);
		ans+=get_bigger(1,1,n,1,y-1,a[y])+get_smaller(1,1,n,y+1,n,a[y]);
		ans-=(1-flag);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2143

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
#define fir first
#define sec second
#define mp make_pair
#define N 160
#define inf 1000000000

const int dx[4]={-1,1,0,0};
const int dy[4]={0,0,-1,1};
int m,n,len;
int stix1,stix2,stix3,stiy1,stiy2,stiy3,t1,t2,t3;
int a[N][N],b[N][N],dis[N][N][N<<1];
bool vis[N][N][N<<1];
struct node{ int x,y,z,d; };
priority_queue<node> q;
bool operator <(const node &u,const node &v){ return u.d>v.d; }
void solve(int sx,int sy)
{
	while (!q.empty()) q.pop();
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++)
			for (int k=0; k<=len; k++)
			{
				vis[i][j][k]=0; 
				dis[i][j][k]=inf;
			}
	dis[sx][sy][0]=0;
	node u,v; u.x=sx; u.y=sy; u.z=u.d=0; 
	q.push(u);
	while (!q.empty() && !(vis[stix1][stiy1][0] && vis[stix2][stiy2][0] && vis[stix3][stiy3][0]))
	{
		u=q.top(); q.pop();
		if (vis[u.x][u.y][u.z]) continue; vis[u.x][u.y][u.z]=1;
		if (u.z)
		{
			for (int k=0; k<4; k++)
			{
				int i=u.x+dx[k];int j=u.y+dy[k];
				if (i>0 && i<=m && j>0 && j<=n && u.d<dis[i][j][u.z-1])
				{
					dis[i][j][u.z-1]=v.d=u.d;
					v.x=i; v.y=j; v.z=u.z-1; q.push(v);
				}
			}
			v=u; v.z--;
			if (v.d<dis[v.x][v.y][v.z]){ dis[v.x][v.y][v.z]=v.d; q.push(v); }
		} else 
		{
			v=u; v.z=a[v.x][v.y]; v.d+=b[v.x][v.y];
			if (v.d<dis[v.x][v.y][v.z])
			{
				dis[v.x][v.y][v.z]=v.d; q.push(v);
			}
		}
	}
}
int main()
{
	scanf("%d%d",&m,&n);
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++)
		{
			scanf("%d",&a[i][j]); 
			a[i][j]=min(a[i][j],max(i-1,m-i)+max(j-1,n-j)+1);
			len=max(len,a[i][j]);
		}
	for (int i=1; i<=m; i++)
		for (int j=1; j<=n; j++) 
			scanf("%d",&b[i][j]);
	scanf("%d%d%d%d%d%d",&stix1,&stiy1,&stix2,&stiy2,&stix3,&stiy3);
	solve(stix1,stiy1); 
	t2+=dis[stix2][stiy2][0]; t3+=dis[stix3][stiy3][0];
	solve(stix2,stiy2); 
	t1+=dis[stix1][stiy1][0]; t3+=dis[stix3][stiy3][0];
	solve(stix3,stiy3); 
	t1+=dis[stix1][stiy1][0]; t2+=dis[stix2][stiy2][0];
	int ans=min(min(t1,t2),t3);
	if (ans<inf)
	{
		puts((ans==t1)?"X":(ans==t2)?"Y":"Z");
		printf("%d\n",ans);
	} else puts("NO");
	return 0;
}

Problem2146

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
typedef long long ll;
struct P
{
	ll x,y;
	P(){}
	P(ll x,ll y):x(x),y(y){}
	bool operator <(const P &s)const
	{
		if(x!=s.x)
			return x< s.x;
		return y<s.y;
	}
}p[N];
int n;
ll max_y=-INF,min_y=INF,area;
void get_area()
{
	static P *stack[N];
	int i,top=0;
	for(i=1;i<=n;i++)
	{
		if(!top||p[i].y>=stack[top]->y)
			stack[++top] = &p[i];
		if(p[i].y==max_y)
			break;
	}
	for(i++;i<=n;i++)
	{
		while(p[i].y>stack[top]->y)
			stack[top--]=NULL;
		stack[++top] = &p[i];
	}
	for(i = 2;i<= top;i++)
		area+=min(stack[i]->y,stack[i-1]->y)*(stack[i]->x-stack[i-1]->x);
	top = 0;
	for(i=1;i<= n;i++)
	{
		if(!top||p[i].y<=stack[top]->y)
			stack[++top] = &p[i];
		if(p[i].y==min_y)
			break;
	}
	for(i++;i<=n;i++)
	{
		while(p[i].y<stack[top]->y)
			stack[top--]=NULL;
		stack[++top] = &p[i];
	}
	for(i = 2;i<= top;i++)
		area-=max(stack[i]->y,stack[i-1]->y)*(stack[i]->x-stack[i-1]->x);
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld",&p[i].x,&p[i].y);
		max_y = max(max_y,p[i].y);
		min_y = min(min_y,p[i].y);
	}
	sort(p+1,p+n+1);
	printf("%lld\n",(max_y-min_y+p[n].x-p[1].x)<<1);
	get_area();
	printf("%lld\n",area);
	return 0;
}
Problem2152

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 2e4+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool used[N];
int sum,root,size[N],f[N];
void get_root(int x,int fa)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int dep[N];
LL cnt[4];
void get_dep(int x,int fa)
{
	cnt[dep[x]]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		dep[e[i].to] = (dep[x]+e[i].val)%3;
		get_dep(e[i].to,x);
	}
}
LL cal(int x,int now)
{
	dep[x] = now%3;
	cnt[1] = cnt[0] = cnt[2] = 0;
	get_dep(x,0);
	return cnt[1]*cnt[2]*2+cnt[0]*cnt[0];
}
LL ans;
void work(int x)
{
	ans+=cal(x,0);
	used[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		if(used[e[i].to])continue;
		ans-=cal(e[i].to,e[i].val);
		sum = size[e[i].to];
		root = 0;
		get_root(e[i].to,0);
		work(root);
	}
}
LL gcd(LL a,LL b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z),add(y,x,z);
	}
	f[0] = 0x3f3f3f3f;
	sum = n;
	get_root(1,0);
	work(root);
	LL t = gcd(ans,(LL)n*n);
	printf("%lld/%lld\n",ans/t,n*n/t);
	return 0;
}
Problem2154

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
const int mod = 20101009;
int mu[N],prime[N/10],cnt;
bool vis[N];
ll sum[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
				mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = (sum[i-1]+(ll)i*i*mu[i])%mod;
}
ll Sum(ll x)
{
	x %= mod;
	return x*(x+1)%mod*10050505%mod;
}
ll F(int x,int y)
{
	int last;
	ll ans = 0;
	for(int i = 1;i<=x&&i<=y;i=last+1)
	{
		last = min(x/(x/i),y/(y/i));
		(ans+=Sum(x/i)*Sum(y/i)%mod*(sum[last]-sum[i-1]))%=mod;
	}
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int last;
	quick_mu();
	ll ans = 0;
	for(int i = 1;i<= n&&i<= m;i=last+1)
	{
		last = min(n/(n/i),m/(m/i));
		(ans+=F(n/i,m/i)*(Sum(last)-Sum(i-1)))%=mod;
	}
	printf("%lld\n",(ans%mod+mod)%mod);
	return 0;
}
Problem2157

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int INF = 0x3f3f3f3f;
int minn[N<<2],maxn[N<<2],sum[N<<2];
bool f[N<<2];
struct E{int next,to;}e[N<<1];
int w[N],deep[N],son[N],size[N],fa[N],top[N],cnt;
int x[N],y[N],val[N];
int head[N],tot,n;
void add(int x,int y)
{
    e[++tot].to = y;
    e[tot].next = head[x];
    head[x] = tot;
}
bool v[N];
void dfs1(int x,int dep)
{
    v[x] = true;
    deep[x] = dep;
    size[x]++;
    for(int i = head[x];i;i = e[i].next)
    {
        int tmp = e[i].to;
        if(!v[tmp])
        {
            dfs1(tmp,dep+1);
            fa[tmp] = x;
            size[x]+=size[tmp];
            if(size[tmp]>size[son[x]])son[x] = tmp;
        }
    }
}
void dfs2(int x,int tp)
{
    top[x] = tp;
    w[x] = ++cnt;
    if(son[x]!=0)dfs2(son[x],tp);
    for(int i = head[x];i;i = e[i].next)
        if(e[i].to!=fa[x]&&e[i].to!=son[x])
            dfs2(e[i].to,e[i].to);
}
int quan[N];
void push_up(int p)
{
    minn[p] = min(minn[p<<1],minn[(p<<1)+1]);
    maxn[p] = max(maxn[p<<1],maxn[(p<<1)+1]);
    sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
void push_down(int p,int l,int r)
{
    if(l==r){f[p] = 0;return ;}
    f[p<<1] ^=1;
    f[(p<<1)+1] ^=1;
    sum[p<<1] = -sum[p<<1];sum[(p<<1)+1] = -sum[(p<<1)+1];
    swap(minn[p<<1],maxn[p<<1]);swap(minn[(p<<1)+1],maxn[(p<<1)+1]);
    minn[p<<1] = -minn[p<<1];maxn[p<<1] = -maxn[p<<1];
    minn[(p<<1)+1] = -minn[(p<<1)+1];maxn[(p<<1)+1] = -maxn[(p<<1)+1];
    f[p] = false;
}
int getans(int p,int l,int r,int a,int b,int opt)
{
    if(f[p])push_down(p,l,r);
    if(l>=a&&r<=b)
    {
        if(opt==1)return sum[p];
        else if(opt==2)return maxn[p];
        else return minn[p];
    }
    int ans;
    if(opt==1)ans= 0;
    else if(opt==2)ans = -INF;
    else ans = INF;
    int mid = (l+r)>>1;
    if(a<=mid)
    {
        if(opt==1)ans += getans(p<<1,l,mid,a,b,opt);
        else if(opt==2)ans = max(ans,getans(p<<1,l,mid,a,b,opt));
        else ans = min(ans,getans(p<<1,l,mid,a,b,opt));
    }
    if(b>mid)
    {
        if(opt==1)ans += getans((p<<1)+1,mid+1,r,a,b,opt);
        else if(opt==2)ans = max(ans,getans((p<<1)+1,mid+1,r,a,b,opt));
        else ans = min(ans,getans((p<<1)+1,mid+1,r,a,b,opt));
    }
    return ans;
}
void update(int p,int l,int r,int x,int c)
{
    if(f[p])push_down(p,l,r);
    if(l==r)
    {
        minn[p] = maxn[p] = sum[p] = c;
        return ;
    }
    int mid = (l+r)>>1;
    if(x<=mid)update(p<<1,l,mid,x,c);
    else update((p<<1)+1,mid+1,r,x,c);
    push_up(p);
}
void up_N(int p,int l,int r,int a,int b)
{
    if(f[p])push_down(p,l,r);
    if(l>=a&&r<=b)
    {
        f[p]^=1;
        minn[p] = -minn[p];maxn[p] = -maxn[p];sum[p] = -sum[p];
        swap(minn[p],maxn[p]);
        return ;
    }
    int mid = (l+r)>>1;
    if(a<=mid)up_N(p<<1,l,mid,a,b);
    if(b>mid)up_N((p<<1)+1,mid+1,r,a,b);
    push_up(p);
}
int qurey(int x,int y,int opt)
{
    int ans;
    if(opt==1)ans= 0;
    else if(opt==2)ans = -INF;
    else ans = INF;
    while(top[x]!=top[y])
    {
        if(deep[top[x]]<deep[top[y]])
            swap(x,y);
        if(opt==1)ans += getans(1,1,n,w[top[x]],w[x],opt);
        else if(opt==2) ans = max(ans,getans(1,1,n,w[top[x]],w[x],opt));
        else if(opt==3) ans = min(ans,getans(1,1,n,w[top[x]],w[x],opt));
        else up_N(1,1,n,w[top[x]],w[x]);
        x = fa[top[x]];
    }
    if(x==y)return ans;
    if(deep[x]<deep[y])swap(x,y);
    if(opt==1)ans += getans(1,1,n,w[son[y]],w[x],opt);
    else if(opt==2) ans = max(ans,getans(1,1,n,w[son[y]],w[x],opt));
    else if(opt==3) ans = min(ans,getans(1,1,n,w[son[y]],w[x],opt));
    else up_N(1,1,n,w[son[y]],w[x]);
    return ans;
}
int main()
{
    int m,xx,yy;
    scanf("%d",&n);
    for(int i = 1;i<n;i++)
    {
        scanf("%d%d%d",&x[i],&y[i],&val[i]);
        x[i]++;y[i]++;
        add(x[i],y[i]);
        add(y[i],x[i]);
    }
    dfs1(1,1);
    dfs2(1,1);
    for(int i = 1;i<n;i++)
    {
        if(deep[x[i]]>deep[y[i]])update(1,1,n,w[x[i]],val[i]);
        else update(1,1,n,w[y[i]],val[i]);
    }
    scanf("%d",&m);
    char ju[5];
    for(int i = 1;i<= m;i++)
    {
        scanf("%s%d%d",ju,&xx,&yy);
        if(ju[0]=='C')
        {
            if(deep[x[xx]]>deep[y[xx]])update(1,1,n,w[x[xx]],yy);
            else update(1,1,n,w[y[xx]],yy);
        }else if(ju[0]=='N')
            qurey(xx+1,yy+1,4);
        else if(ju[0]=='S')
            printf("%d\n",qurey(xx+1,yy+1,1));
        else if(ju[1]=='A')
            printf("%d\n",qurey(xx+1,yy+1,2));
        else printf("%d\n",qurey(xx+1,yy+1,3));
    }
    return 0;
}
Problem2163

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e4+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
queue<int>Q;
int d[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int in[N],out[N];
int main()
{
	int node = 0;
	int S = 0,T;
	int n,m,F,sum=0;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)in[i]=++node;
	for(int i = 1;i<= n;i++)out[i]=++node;
	T = ++node;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&F);sum+=F;
		add(S,in[i],F),add(out[i],T,F);
	}
	int u,v;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&u,&v,&F);
		add(in[u],out[v],F);
	}
	printf("%d\n",sum-dinic(S,T));
	return 0;
}
Problem2176

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e7+5;
unsigned char s[N];
int mp(int n)
{
	int i,j,k,N = n<<1;
	i = 1,j = 2;
	while(i<n&&j<n)
	{
		k = 0;
		while(s[i+k]==s[j+k])k++;
		if(k==n)return min(i,j);
		if(s[i+k]>s[j+k])i = max(j+1,i+k+1);
		else j = max(i+1,j+k+1);
	}
	if(i<n)return i;else return j;
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
		s[i+n]=s[i];
	int st = mp(n);
	for(int i = st;i<st+n;i++)
		printf("%c",s[i]);
	return 0;
}
Problem2179

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
typedef double db;
typedef long long ll;
using namespace std;
const int N = 2e5;
const db PI = 3.14159265358979323;
struct cp
{
	db x,y;
	cp(){}
	cp(db x,db y):x(x),y(y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
int ans[N<<1];
void FFT(cp *a,int len,int type)
{
	int t=0;
	for(int i=0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j=len>>1;(t^=j)<j;j>>=1);
	}
	for(int i=2;i<=len;i<<=1)
	{
		cp wn=cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j=0;j<len;j+=i)
		{
			cp t,w(1,0);
			for(int k=0;k<(i>>1);k++,w=w*wn)
			{
				t=w*a[j+k+(i>>1)];
				a[j+k+(i>>1)]=a[j+k]-t;
				a[j+k]=a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i=0;i<len;i++)a[i].x/=len;
}
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i=0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i=0;i<len;i++)
	ans[i]=(int)(c[i].x+0.1);
}
char A[N],B[N];
int Ans[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",A);scanf("%s",B);
	int tmp = 0;
	for(int i = n-1;i>= 0;i--)
		x[n-i-1]=cp(A[i]-'0',0);
	tmp = 0;
	for(int i = n-1;i>=0;i--)
		y[n-i-1]=cp(B[i]-'0',0);
	//n = n*2;
	int t=1;
	while(t<=n)t = t<<1;
	n= t<<1;
	conv(x,y,z,n);
	int len = 0;
	ll x = 0;
	for(int i = 0;i<n;i++)
	{
		x+=ans[i];
		Ans[i]=x%10,x/=10;
	}
	for (;n&&!Ans[n];n--);
	printf("%d",Ans[n--]);
	for (int i=n;i>=0;i--) printf("%01d",Ans[i]);
	puts("");
	return 0;
}
Problem2179

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 4e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(){}
	cp(double x,double y):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y); 
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp&b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int type,int len)
{
	int t=0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp tmp,w = cp(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,1,len);FFT(b,1,len);
	for(int i = 0;i<len;i++)
		c[i] = a[i]*b[i];
	FFT(c,-1,len);
	for(int i = 0;i<len;i++)
		ans[i] = (int)(c[i].x+0.1);
}
int Ans[N];
char s[N],A[N],B[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s);
	for(int i = n-1;i>=0;i--)
		x[n-i-1]=cp(s[i]-'0',0);
	scanf("%s",s);
	for(int i = n-1;i>=0;i--)
		y[n-i-1]=cp(s[i]-'0',0);
	int l;
	for(l=1;l<=n;l=l<<1);
	l =l<<1;
	conv(x,y,z,l);
	long long x = 0;
	for(int i = 0;i<l;i++)
	{
		x = x+ans[i];
		Ans[i] = x%10,x/=10;
	}
	for(;l&&!Ans[l];l--);
	printf("%d",Ans[l--]);
	for(int i = l;i>=0;i--)
		printf("%01d",Ans[i]);
	printf("\n");
	return 0;
}
Problem2186

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int Maxn = 10000000+5; 
long long fac[Maxn],ans[Maxn],rev[Maxn];
int prime[Maxn/10],t_p;
bool v[Maxn];
long long mod;
int n,m;
void quick_prime()
{
	for(int i = 2;i< Maxn;i++)
	{
		if(!v[i])
		{
			t_p++;
			prime[t_p] = i;
		}
		for(int j = 1;j<= t_p&&prime[j]*i<Maxn;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j]==0)
				break;
		}
	}
	fac[1]=1; 
	int i; 
    for(i=2;i<=Maxn;i++)  
        fac[i]=fac[i-1]*i%mod;  
    rev[1]=1;  
    for(i=2;i<=Maxn&&i<mod;i++)  
        rev[i]=(mod-mod/i)*rev[mod%i]%mod;  
    ans[1]=1;  
    for(i=2;i<=Maxn;i++)  
    {  
        if(!v[i])  
            ans[i]=ans[i-1]*(i-1)%mod*rev[i%mod]%mod;  
        else  
            ans[i]=ans[i-1];  
    }
}
int main()
{
	int T;
	scanf("%d%lld",&T,&mod);
	quick_prime();
	while(T--)
	{
		scanf("%d%d",&n,&m);
		long long t_ans = fac[n];
		t_ans = t_ans*ans[m]%mod;
		printf("%lld\n",t_ans);
	}
	return 0;
}
Problem2194

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef double db;
const int N = 4e5+5;
const db PI = 3.14159265358979323;
int ans[N];
struct cp
{
	db x,y;
	cp(){}
	cp(db x,db y):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn=cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp tmp,w(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k]=a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)
		ans[i]=(int)(c[i].x+0.1);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 0;i< n;i++)scanf("%lf%lf",&x[i].x,&y[i].x);
	for(int i = 0;i<n/2;i++)swap(y[i],y[n-i-1]);
	int len = 1;
	while(len<=n)len<<=1;
	len<<=1;
	conv(x,y,z,len);
	for(int i = -1;i<n-1;i++)
		printf("%d\n",ans[i+n]);
	return 0;
}
Problem2213

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Q = 27;
const int N = 1e6+5;
int f[Q][Q],L[Q][Q],tot[Q],C[Q][Q],sec[Q][Q];
char s[N];
int ans;
void update(int x,int y)
{
	if(C[x][y]!=tot[y])ans = max(ans,f[x][y]-L[x][y]);
	else ans = max(ans,f[x][y]-sec[x][y]);
	if(f[x][y]<L[x][y])
	{
		if(C[x][y]==tot[y])L[x][y] = f[x][y];
		else
		{
			sec[x][y] = L[x][y];
			L[x][y] = f[x][y];
			C[x][y] = tot[y];
		}
	}else if(f[x][y]<sec[x][y])
		if(C[x][y]!=tot[y])
			sec[x][y] = L[x][y];
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	memset(sec,0x3f,sizeof(sec));
	for(int i = 1;i<= n;i++)
	{
		s[i] = s[i]-'a';
		tot[s[i]]++;
		for(int j = 0;j<26;j++)
		{
			if(j==s[i])continue;
			f[j][s[i]]--;
			update(j,s[i]);
			f[s[i]][j]++;
			update(s[i],j);
		}
	}
	printf("%d\n",ans);
}
Problem2215

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const int M = 50000050;
inline int p0(int i){return i*2;}
inline int p1(int i){return i*2+1;}
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<1)+(x<<3) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct E
{int next,to;}e[M];
int head[N<<1],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool v[N<<1],ins[N<<1],r[N][N];
int stack[N<<1],top,dep[N<<1],low[N<<1],bel[N<<1],dfn,scc;
void tarjan(int x)
{
	v[x] = true;
	low[x] = dep[x] = ++dfn;
	stack[++top] =x ;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!v[e[i].to])
			{tarjan(e[i].to);low[x] = min(low[x],low[e[i].to]);}
		else if(ins[e[i].to])
			{low[x] = min(low[x],dep[e[i].to]);}
	}
	if(low[x]==dep[x])
	{
		scc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = scc;
		}while(tmp!=x);
	}
}
void Read()
{
	scanf("%d",&n);
	int k,x;
	for(int i = 1;i<= n;i++)
	{
		k = read();
		for(int j = 1;j<= k;j++)
			{x = read();r[i][x] = r[x][i] = true;}
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<i;j++)
		{
			if(r[i][j])add(p1(i),p0(j)),add(p1(j),p0(i));
			else add(p0(i),p1(j)),add(p0(j),p1(i));
		}
}
int ans[N],cnt[N],dir[N],Ans;
void work()
{
	for(int i = 2;i<= 2*n+1;i++)
		if(!v[i])
			tarjan(i);
	for(int i = 1;i<= n;i++)if(bel[p1(i)]==bel[p0(i)])return ;
	int cnt1 = 0,cnt0 = 0;
	for(int i = 1;i<= n;i++)
	{
		ans[i] = (bel[p0(i)]>bel[p1(i)]);
		if(ans[i])cnt1++;else cnt0++;
	}
	Ans = (cnt1&&cnt0);
	int t0 = 0,t1 = 0;
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])
		{
			for(int j = 1;j<= n;j++)
				if(i!=j&&!ans[j]&&!r[i][j])
					cnt[i]++,dir[i] = j;
		}
		else
		{
			for(int j = 1;j<= n;j++)
				if(i!=j&&ans[j]&&r[i][j])
					cnt[i]++,dir[i] = j;
		}
	}
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])
		{
			if(!cnt[i]&&cnt1>1)Ans++;
			if(!cnt[i])t1++;
			if(cnt[i]==1&&((cnt[dir[i]]==1&&dir[dir[i]]==i&&i<dir[i])||!cnt[dir[i]]))
				Ans++;
		}
		else
		{
			if(!cnt[i]&&cnt0>1)Ans++;
			if(!cnt[i])t0++;
			if(cnt[i]==1&&((cnt[dir[i]]==1&&dir[dir[i]]==i&&i<dir[i])||!cnt[dir[i]]))
				Ans++;
		}
	}
	Ans+=t0*t1;
}
int main()
{
	Read();
	work();
	printf("%d\n",Ans);
	return 0;
}
Problem2216

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
struct E
{int l,r,p;}que[N];
int a[N],n;
double f[N],g[N];
double cal(int j,int i)
{
	return a[j]+sqrt(abs(i-j))-a[i];
}
int L,R;
int find(E a,int x)
{
	int l = a.l,r = a.r;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(cal(a.p,mid)>cal(x,mid))l = mid+1;
		else r = mid;
	}
	return l;
}
void work(double *F)
{
	L = 0,R = -1;
	for(int i = 1;i<= n;i++)
	{
		que[L].l++;
		while(L<=R&&que[L].l>que[L].r)L++;
		if(L>R||cal(i,n)>cal(que[R].p,n))
		{
			while(L<=R&&cal(que[R].p,que[R].l)<cal(i,que[R].l))
				R--;
			if(L>R)
				que[++R] = (E){i,n,i};
			else
			{
				int t = find(que[R],i);
				que[R].r = t-1;
				que[++R] = (E){t,n,i};
			}
		}
		F[i] = cal(que[L].p,i);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	work(f);
	for(int i = 1;i<=(n>>1);i++)swap(a[i],a[n-i+1]);
	work(g);
	for(int i = 1;i<= n;i++)
		printf("%d\n",max(0,(int)ceil(max(g[n-i+1],f[i]))));
	return 0;
}
Problem2217

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e6+5;
int ansl[N],ansr[N];
char s[N>>1];
int ex2[N>>1];
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	scanf("%s",s+1);
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		sum+=s[i]=='W'?1:2;
		ansr[sum] = i;
		ansl[sum] = 1;
	}
	for(int i = n;i>=1;i--)
		if(s[i]=='T')
			ex2[i] = ex2[i+1]+1;
	for(int i = 1;i<= 2*n;i++)
	{
		if(i>sum)break;
		if(!ansl[i])
		{
			int tmp = ansr[i+1];
			if(ex2[1]<ex2[tmp])
			{
				ansr[i] = tmp+ex2[1];
				ansl[i] = 2+ex2[1];
				continue;
			}
			if(tmp+ex2[tmp]==n+1)continue;
			ansr[i] = tmp+ex2[tmp];
			ansl[i] = 1+ex2[tmp];
		}
	}
	int x;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&x);
		if(!ansl[x])
			printf("NIE\n");
		else 
			printf("%d %d\n",ansl[x],ansr[x]);
	}
	return 0;
}
Problem2219

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 100005;
const ll INF = 0x7fffffffffffffffll;
int cas,num;
ll A,B,K;
ll prime[10005];
struct Hash
{
	#define mod 100007
	int head[mod],nxt[N],id[N],tot;
	ll val[N];
	void clear()
	{
		tot = 0;
		memset(head,0,sizeof(head));
	}
	int Insert(ll x,int k)
	{
		int tmp = x%mod;
		for(int i = head[tmp];i;i=nxt[i])
			if(val[i]==x)
				return id[i];
		if(k==-1)return -1;
		val[++tot] = x;
		id[tot] = k;
		nxt[tot] = head[tmp];
		head[tmp] = tot;
	}
}hmp;
ll quick_pow(ll x,ll y,ll p=INF)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res = res*x%p;
		x = x*x%p;
		y>>=1;
	}
	return res;
}
bool check(int x,ll p,ll k)
{
	for(int i = 1;i<= num;i++)
		if(quick_pow(x,k/prime[i],p)==1)
			return false;
	return true;
}
void get_fac(ll p)
{
	num = 0;
	for(ll i = 2;i*i<= p;i++)
		if(p%i==0)
		{
			prime[++num] = i;
			while(p%i==0)p/=i;
		}
	if(p>1)prime[++num] = p;
}
ll get_root(ll p,ll x)
{
	get_fac(x);
	for(int i = 2;;i++)
		if(check(i,p,x))return i;
}
void ex_gcd(ll a,ll b,ll &x,ll &y,ll &d)
{
	if(b==0)
	{
		d = a;
		x = 1;
		y = 0;
		return ;
	}
	ex_gcd(b,a%b,y,x,d);
	y-=a/b*x;
}
ll get_inv(ll a,ll b)
{
	ll x,y,d;
	ex_gcd(a,b,x,y,d);
	b/=d;
	return (x%b+b)%b;
}
ll BSGS(ll a,ll g,ll p)
{
	hmp.clear();
	ll m = sqrt(p)+1,tmp=1;
	for(int i = 0;i<m;i++,tmp=tmp*g%p)hmp.Insert(tmp,i);
	ll Inv = get_inv(tmp,p);
	int k;
	for(int i = 0;i<m;i++,a=a*Inv%p)
	{
		k = hmp.Insert(a,-1);
		if(k!=-1)return m*i+k;
	}
}
ll gcd(ll a,ll b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
ll solve(ll a,ll b,ll p,ll t)
{
	ll MOD = quick_pow(p,t),ret=0,phi,g,ind,tmp;
	b = b%MOD;
	if(!b)return quick_pow(p,t-((t-1)/a+1));
	while(b%p==0)ret++,b/=p;
	if(ret%a)return 0;
	t-=ret;
	MOD = quick_pow(p,t);
	phi = MOD-MOD/p;
	g = get_root(MOD,phi);ind = BSGS(b,g,MOD);
	tmp = gcd(a,phi);
	if(ind%tmp)return 0;
	return tmp*quick_pow(p,ret-ret/a);
}
int main()
{
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%lld%lld%lld",&A,&B,&K);
		ll ans = 1;
		K = 2*K+1;
		for(ll i= 2;i*i<= K;i++)
			if(K%i==0)
			{
				int ret = 0;
				while(K%i==0)K/=i,ret++;
				ans*=solve(A,B,i,ret);
			}
		if(K>1&&ans)ans*=solve(A,B,K,1);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem2223

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 1e7+5;
int root[N];
int ls[M],rs[M],sum[M];
int cnt,n,m,lim;
void update(int l,int r,int rt1,int &rt2,int v)
{
	rt2 = ++cnt;
	sum[rt2] = sum[rt1]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[rt2] = ls[rt1],rs[rt2] = rs[rt1];
	if(v<=mid)update(l,mid,ls[rt1],ls[rt2],v);
	else update(mid+1,r,rs[rt1],rs[rt2],v);
}
int ask(int L,int R)
{
	int l,r,tmp = (R-L+1)>>1;
	int rt1 = root[L-1],rt2 = root[R];
	l = 1,r = lim;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[rt2]-sum[rt1]<=tmp)return 0;
		if(sum[ls[rt2]]-sum[ls[rt1]]>tmp)
		{
			r = mid;
			rt1 = ls[rt1],rt2 = ls[rt2];
		}else if(sum[rs[rt2]]-sum[rs[rt1]]>tmp)
		{
			l = mid+1;
			rt1 = rs[rt1],rt2 = rs[rt2];
		}
		else return 0;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&lim);
	for(int i = 1;i<= n;i++)
	{
		int x;
		scanf("%d",&x);
		update(1,lim,root[i-1],root[i],x);
	}
	scanf("%d",&m);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		int tmp = ask(x,y);
		if(tmp!=0)printf("yes %d\n",tmp);
		else printf("no\n");
	}
	return 0;
}
Problem2226

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int phi[1000005],a[100005],tot;
long long f[1000005];
bool not_prime[1000005];
void oula(int n)
{
	for(int i = 2;i<= n;i++)
	{
		if(!not_prime[i])
		{
			a[++tot] = i;
			phi[i] = i-1;
		}
		for(int j = 1;j<= tot&&a[j]*i<=n;j++)
		{
			not_prime[i*a[j]] = true;
			if(i%a[j]==0){phi[i*a[j]] = phi[i]*a[j];break;}
			else phi[i*a[j]] = phi[i]*(a[j]-1);
		}
	}
}
long long ans(int i)
{
	long long re = 0;
	for(int j = 1;j*j<= i;j++)
	{
		if(i%j==0&&j*j!=i)
			{re+=f[i/j]+f[j];}
		else if(j*j==i)
			re+=f[j];
	}
	return re;
}
int main()
{
	int T,x;
	scanf("%d",&T);
	oula(1000001);
	f[1] = 1;
	for(int i = 1;i<= 1000001;i++)
		if(i!=1)f[i] = (long long)i*phi[i]/2;
	for(int i = 1;i<= T;i++)
	{
		scanf("%d",&x);
		printf("%lld\n",ans(x)*x);
	}
	return 0;
}
Problem2229

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200;
const int M = 6005;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot=1,a[N],b[N],d[N],n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f;
}
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int ans[N][N];
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] =-1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
void reset()
{
	for(int i = 2;i<= tot;i+=2)
		e[i].f = e[i^1].f = (e[i].f+e[i^1].f)>>1;
}
bool v[N];
void dfs(int x)
{
	v[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!v[e[i].to])
			dfs(e[i].to);
}
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(v,0,sizeof(v));
	dfs(s);
	for(int i = 1;i<= n;i++)
		if(v[i])
			for(int j = 1;j<= n;j++)
				if(!v[j])
					ans[i][j] = ans[j][i] = min(ans[i][j],tmp);
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(v[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)
		a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 1;
	memset(ans,0x3f,sizeof(ans));
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		int u,v,c;
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)a[i]=i;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d%d",&u,&v,&c);
			add(u,v,c);
		}
		solve(1,n);
		int q;
		scanf("%d",&q);
		for(int i = 1;i<= q;i++)
		{
			scanf("%d",&c);int Ans =0;
			for(int j = 1;j<= n;j++)
				for(int k = j+1;k<= n;k++)
					Ans+=(ans[j][k]<=c);
			printf("%d\n",Ans);
		}
		if(cas)printf("\n");
	}
	return 0;
}
Problem2243

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
struct T
{int lc,rc,num,f;}t[N<<3];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int deep[N],top[N],fa[N],son[N],size[N],w[N],c[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	size[x]++;
	deep[x] =dep;
	for(int i= head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void init(int no,int l,int r)
{
	t[no].f = -1;
	if(l==r)
	{
		t[no].num = 1;
		return ;
	}
	int mid= (l+r)>>1;
	init(no<<1,l,mid);
	init((no<<1)+1,mid+1,r);
	return ;
}
void push_down(int p)
{
	t[p<<1].num = t[(p<<1)+1].num = 1;
	t[p<<1].f = t[(p<<1)+1].f = t[p].f;
	t[p<<1].lc = t[(p<<1)+1].lc = t[p].lc;
	t[p<<1].rc = t[(p<<1)+1].rc = t[p].f;
	t[p].f = -1;
}
void update(int p,int l,int r,int a,int b,int c)
{
	if(t[p].f!=-1)push_down(p);
	if(l>=a&&r<=b)
		{t[p].lc = t[p].rc = t[p].f = c;t[p].num = 1;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)
		update(p<<1,l,mid,a,b,c);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b,c);
	if(t[p<<1].rc==t[(p<<1)+1].lc)t[p].num = t[p<<1].num+t[(p<<1)+1].num-1;
	else t[p].num = t[p<<1].num+t[(p<<1)+1].num;
	t[p].lc = t[p<<1].lc;t[p].rc = t[(p<<1)+1].rc;
}
T getans(int p,int l,int r,int a,int b)
{
	if(t[p].f!=-1)push_down(p);
	if(l>=a&&r<=b)
		return t[p];
	int mid = (l+r)>>1;
	T x,y,c;
	if(b<=mid)
		c = getans(p<<1,l,mid,a,b);
	else if(a>mid)
		c = getans((p<<1)+1,mid+1,r,a,b);
	else
	{
		x = getans(p<<1,l,mid,a,b);y = getans((p<<1)+1,mid+1,r,a,b);
		c.lc = x.lc;c.rc = y.rc;
		c.num = x.num+y.num;
		if(x.rc==y.lc)c.num--;
	}
	return c;
}
int t_ans;
void get_update(int x,int y,int c,int opt)
{
	T ta;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)update(1,1,n,w[top[x]],w[x],c);
		else
		{
			ta = getans(1,1,n,w[top[x]],w[x]);
			t_ans+=ta.num;
			if(ta.lc==getans(1,1,n,w[fa[top[x]]],w[fa[top[x]]]).lc)t_ans--;
		}
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)update(1,1,n,w[y],w[x],c);
	else
	{
		ta = getans(1,1,n,w[y],w[x]);
		t_ans+=ta.num;
	} 
}
int main()
{
	int m,x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	init(1,1,n);
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)get_update(i,i,c[i],1);
	char j[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",j);
		if(j[0]=='C')
		{
			scanf("%d%d%d",&x,&y,&z);
			get_update(x,y,z,1);
		}else
		{
			t_ans = 0;
			scanf("%d%d",&x,&y);
			get_update(x,y,0,0);
			printf("%d\n",t_ans);
		}
	}
	return 0;
}
Problem2251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
int s[N];
int sa[N],q[N],v[N],nv[N],cnt[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i=0;i<lim;i++)cnt[i]=0;
	for(i=0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i=len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim=0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j  =0;
			if(i)j=max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
		scanf("%1d",&s[i]);
	build_sa(n,2);
	build_rank(n);
	build_height(n);
	int l,r;
	for(int i = 0;i< n;i++)
		for(int j = h[i]+1;sa[i]+j-1<n;j++)
		{
			for(l=i;l>=0&&h[l]>=j;l--);
			for(r=i+1;r<n&&h[r]>=j;r++);
			if(r-l>1)printf("%d\n",r-l);
		}
	return 0;
}
Problem2257

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e7+5;
int divs[N];
bool cmp(const int &a,const int &b){return a>b;}
int main()
{
	int n,k,x,top = 0;
	scanf("%d%d",&n,&k);
	while(n--)
	{
		scanf("%d",&x);
		for(int i = 1;i*i<= x;i++)
			if(x%i==0)
			{
				divs[++top] = i;
				if(i*i!=x)divs[++top]=x/i;
			}
	}
	sort(divs+1,divs+top+1,cmp);
	int cnt = 1;
	for(int i = 1;i<= top;i++)
	{
		if(divs[i]!=divs[i-1])cnt=1;
		else cnt++;
		if(cnt>=k){printf("%d\n",divs[i]);break;}
	}
	return 0;
}
Problem2260

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2505;
const int INF = 0x3f3f3f3f;
const double eps = 1e-7;
struct E
{int u,v;double val;}e[M];
int p[N],num[N],pre[N],vis[N],mark[N];
double c[N],in[N];
double work(int root,int n,int m)
{
	double ans = 0;
	while(true)
	{
		for(int i = 1;i<= n;i++)in[i] = INF;
		for(int i = 1;i<= m;i++)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].val<in[v])
			{
				in[v] = e[i].val;
				pre[v] = u;
			}
		}
		for(int i = 1;i<= n;i++)
		{
			if(i==root)continue;
			if(fabs(in[i]-INF)<eps)return -1;
		}
		memset(mark,-1,sizeof(mark));
		memset(vis,-1,sizeof(vis));
		in[root] = 0;int cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			ans+=in[i];
			int v=i;
			while(v!=root&&mark[v]==-1&&vis[v]!=i)
			{
				vis[v] = i;
				v = pre[v];
			}
			if(v!=root&&mark[v]==-1)
			{
				++cnt;
				for(int u = pre[v];u!=v;u = pre[u])
					mark[u] = cnt;
				mark[v] = cnt;
			}
		}
		if(cnt==0)break;
		for(int i = 1;i<= n;i++)
			if(mark[i]==-1)mark[i]=++cnt;
		for(int i = 1;i<=m;i++)
		{
			int u = e[i].u,v = e[i].v;
			e[i].u = mark[u],e[i].v = mark[v];
			if(e[i].u!=e[i].v)
				e[i].val-=in[v];
		}
		n=cnt,root = mark[root];
	}
	return ans;
}
int main()
{
	int n,m=0;
	scanf("%d",&n);
	int tmp = n;n = 1;
	double x;int t;
	for(int i = 1;i<= tmp;i++)
	{
		scanf("%lf%d",&x,&t);
		if(t)
		{
			p[i]=++n;
			e[++m] = (E){1,n,x};
			c[n] = x;num[n] = t;
		}
	}
	int a,b,k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%lf",&a,&b,&x);
		if(p[a]&&p[b])
		{
			e[++m] = (E){p[a],p[b],x};
			c[p[b]] = min(c[p[b]],x);
		}
	}
	double ans = work(1,n,m);
	for(int i = 2;i<= n;i++)
		if(num[i]>1)ans+=c[i]*(num[i]-1);
	printf("%.2f\n",ans);
	return 0;
}
Problem2275

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll f[100];
int main()
{
	ll n;
	scanf("%lld",&n);
	f[0] = 0,f[1] = 1;
	int cnt = 1;
	while(f[cnt]<=n)
	{
		++cnt;
		f[cnt] = f[cnt-1]+f[cnt-2];
	}
	while(cnt)
	{
		if(f[cnt]==n)
			return printf("%lld\n",n),0;
		if(n>f[cnt])
			n-=f[cnt];
		cnt--;
	}
	return 0;
}
Problem2276

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
int q1[N],q2[N],l1,l2,r1,r2;
int m[N],x[N];
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&m[i],&x[i]);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&m[i]>m[q1[r1]])r1--;q1[++r1] = i;
		//while(l2<=r2&&x[i]<x[q2[r2]])r2--;q2[++r2] = i;
		while(m[q1[l1]]>x[i]&&j<=n)
		{
			j++;
			while(l1<=r1&&q1[l1]<j)l1++;
			//while(l2<=r2&&q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2277

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 250005;
LL gcd(LL x,LL y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
LL stack[N],top,a[N],n,k;
int main()
{
	scanf("%lld%lld",&n,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%lld",&a[i]);
		if(i!=k)stack[++top] = gcd(a[i],n);
	}
	sort(stack+1,stack+top+1);
	int tmp = top,top = 0;
	for(int i = 1;i<= tmp;i++)
		if(stack[top]!=stack[i])
			stack[++top] = stack[i];
	LL m = gcd(n,a[k]);
	LL ans = m;
	for(LL i = 1;i*i<=m;i++)
	{
		if(m%i==0)
		{
			int j;
			for(j = 1;j<= top;j++)
				if(stack[j]%i==0)
					break;
			if(j==top+1){ans = min(ans,i);break;}
			LL k = m/i;
			for(j = 1;j<= top;j++)
				if(stack[j]%k==0)
					break;
			if(j==top+1)ans = min(ans,k);
		}
	}
	printf("%lld\n",n/ans);
	return 0;
}
Problem2278

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<cmath>
#include<algorithm>
#include<iomanip>
#include<vector>
#include<map>
#include<set>
#include<bitset>
#include<queue>
#include<stack>
using namespace std;
#define MAXN 100010
#define MAXM 2000010
#define INF 1000000000
#define MOD 1000000007
#define eps 1e-8
#define ll long long
struct vec{
    int to;
    int fro;
};
vec mp[MAXM];
int tai[MAXN],cnt=1;
bool vis[MAXM];
int st[MAXN],tp;
bool ist[MAXN];
vector<int>ans[MAXM];
int ANS;
int n,m;
int d[MAXN];
inline void be(int x,int y){
    mp[++cnt].to=y;
    mp[cnt].fro=tai[x];
    tai[x]=cnt;
}
inline void bde(int x,int y){
    be(x,y);
    be(y,x);
}
void dfs(int x){
    int y;
    if(ist[x]){
        int t=0;
        ANS++;
        while(t!=x){
            ist[t=st[tp--]]=0;
            ans[ANS].push_back(t);
        }
    }
    for(int &i=tai[x];i;i=mp[i].fro){
        y=mp[i].to;
        if(!vis[i]){
            vis[i]=vis[i^1]=1;
            ist[st[++tp]=x]=1;
            dfs(y);
        }
    }
}
int main(){
    int i,j,x,y,t,tt;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d%d%d%d",&x,&y,&t,&tt);
        if(t^tt){
            bde(x,y);
            d[x]++;
            d[y]++;
        }
    }
    for(i=1;i<=n;i++){
        if(d[i]&1){
            printf("NIE\n");
            return 0;
        }
    }
    for(i=1;i<=n;i++){
        dfs(i);
    }
    printf("%d\n",ANS);
    for(i=1;i<=ANS;i++){
        printf("%d ",ans[i].size());
        for(j=0;j<ans[i].size();j++){
            printf("%d ",ans[i][j]);
        }
        printf("%d\n",ans[i][0]);
    }
    return 0;
}

/*

*/
Problem2278

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2000010;
const int N = 100010;
struct E
{
	int next,to;
}e[M];
int head[N],tot = 1;
vector<int>Ans[M];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[M],ins[N],vis[N];
int stack[M],top,cnt,j;
void dfs(int x)
{
	vis[x] = true;
	if(ins[x])
	{
		cnt++;
		Ans[cnt].push_back(x);
		while(stack[top]!=x)
		{
			Ans[cnt].push_back(stack[top]);
			ins[stack[top]] = false;
			top--;
		}
		ins[stack[top]] = false;
		Ans[cnt].push_back(stack[top]);
		top--;
	}
	for(j = head[x];j;j = head[x])
	{
		head[x] = e[j].next;
		if(!used[j])
		{
			used[j] = used[j^1] = true;
			ins[x] = true;
			stack[++top] = x;
			dfs(e[j].to);
		}
	}
}
int d[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int x,y,u,w;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		if(u==w)continue;
		d[x]++,d[y]++;
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]&1)
		{
			printf("NIE\n");
			return 0;
		}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			dfs(i);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		printf("%d",Ans[i].size()-1);
		for(int k = 0;k<Ans[i].size();k++)
			printf(" %d",Ans[i][k]);
		printf("\n");
	}
	return 0;
}
Problem2278

#include <stdio.h>
#include <cctype>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2000010;
const int N = 100010;
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
inline int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
struct E
{
	int next,to;
}e[M];
int head[N],tot = 1;
vector<int>Ans[M];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[M],ins[N],vis[N];
int stack[M],top,cnt,j;
void dfs(int x)
{
	vis[x] = true;
	if(ins[x])
	{
		cnt++;
		Ans[cnt].push_back(x);
		while(stack[top]!=x)
		{
			Ans[cnt].push_back(stack[top]);
			ins[stack[top]] = false;
			top--;
		}
		ins[stack[top]] = false;
		Ans[cnt].push_back(stack[top]);
		top--;
	}
	for(j = head[x];j;j = head[x])
	{
		head[x] = e[j].next;
		if(!used[j])
		{
			used[j] = used[j^1] = true;
			ins[x] = true;
			stack[++top] = x;
			dfs(e[j].to);
		}
	}
}
int d[N];
int main()
{
	int n,m;
	n = read();m = read();
	int x,y,u,w;
	for(int i = 1;i<= m;i++)
	{
		x = read();y = read();u = read();w = read();
		if(u==w)continue;
		d[x]++,d[y]++;
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]&1)
		{
			printf("NIE\n");
			return 0;
		}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			dfs(i);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		printf("%d",Ans[i].size()-1);
		for(int k = 0;k<Ans[i].size();k++)
			printf(" %d",Ans[i][k]);
		printf("\n");
	}
	return 0;
}
Problem2286

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250010;
typedef long long ll;
struct E
{int next,to,val;};
int dep[N],fa[N][22],dfn[N],Dfn;
vector<int>to[N];
vector<int>val[N];
ll f[N],mn[N];
int stack[N],top,num[N];
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].val=f;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].val=f;
	}
	void dfs(int x,int f,int dp)
	{
		fa[x][0] = f;
		dep[x] = dp;
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=f)
			{
				mn[e[i].to] = min(mn[x],(ll)e[i].val);
				dfs(e[i].to,x,dp+1);
			}
	}
	void init(int n)
	{
		for(int j = 1;j<= 21;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 21;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 21;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
}tree;
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
void add(int x,int y)
{
	if(x==y)return ;
	to[x].push_back(y);
	to[y].push_back(x);
}
void dfs(int x,int ff)
{
	ll tmp = 0;
	int sz = to[x].size();
	f[x] = mn[x];
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
		{
			dfs(t,x);
			tmp+=f[t];
		}
	}
	if(tmp&&tmp<=f[x])f[x]=tmp;
	to[x].clear();
}
int main()
{
	int n,m,k;
	scanf("%d",&n);
	int x,y,c;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		tree.add(x,y,c);
	}
	mn[1]=1ll<<60;
	tree.dfs(1,0,1);
	tree.init(n);
	scanf("%d",&m);
	while(m--)
	{
		scanf("%d",&k);
		for(int i = 1;i<= k;i++)
			scanf("%d",&num[i]);
		sort(num+1,num+k+1,cmp);
		int tmp = k;
		num[k=1] = num[1];
		for(int i = 2;i<= tmp;i++)
			if(tree.getlca(num[k],num[i])!=num[k])
				num[++k]=num[i];
		top = 0;
		stack[++top]=1;
		for(int i = 1;i<= k;i++)
		{
			int v = num[i];
			int lca = tree.getlca(stack[top],v);
			while(true)
			{
				if(dep[lca]>=dep[stack[top-1]])
					{add(lca,stack[top--]);break;}
				add(stack[top-1],stack[top]);
				top--;
			}
			if(stack[top]!=lca)stack[++top]=lca;
			if(stack[top]!=v)stack[++top] = v;
		}
		for(int i = 1;i<=top-1;i++)
			add(stack[i],stack[i+1]);
		dfs(1,0);
		printf("%lld\n",f[1]);
	}
	return 0;
}
Problem2301

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int mu[N],prime[N],cnt,sum[N];
bool vis[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i= 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+mu[i];
}
typedef long long ll;
ll calc(int x,int y)
{
	if(x<0||y<0)return 0;
	ll ans = 0;
	int last = 0;
	for(int i = 1;i<=x&&i<=y;i = last+1)
	{
		last = min(y/(y/i),x/(x/i));
		ans+=(ll)(x/i)*(y/i)*(sum[last]-sum[i-1]);
	}
	return ans;
}
int main()
{
	quick_mu();
	int a,b,c,d,k;
	int t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d%d%d",&a,&b,&c,&d,&k);
		ll ans = 0;
		ans+=calc(b/k,d/k);
		ans-=calc((a-1)/k,d/k);
		ans-=calc(b/k,(c-1)/k);
		ans+=calc((a-1)/k,(c-1)/k);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem2302

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
typedef long long ll;
int f[N][N];
int cnt[N],sum[N];
int C[N][N],n,m,x,y,mod;
void Init()
{
	memset(f,0,sizeof(f));
	memset(cnt,0,sizeof(cnt));
	memset(sum,0,sizeof(sum));
	C[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		C[i][0] = 1;
		for(int j = 1;j<=i;j++)
			C[i][j] = (C[i-1][j-1]+C[i-1][j])%mod;
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	//init();
	while(cas--)
	{
		scanf("%d%d%d",&n,&m,&mod);
		Init();
		sum[0] = n-m;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			cnt[y]++;
		}
		bool flag = false;
		for(int i = 1;i<= n;i++)
		{
			sum[i] = sum[i-1]+cnt[i];
			if(sum[i]<i)
			{
				puts("NO");
				flag = true;
				break;
			}
		}
		if(flag)continue;
		f[0][0]=1;
		for(int i = 1;i<= n;i++)
			for(int j = i;j<= sum[i];j++)
				for(int k = j-i+1;k>= cnt[i];k--)
					(f[i][j]+=(ll)f[i-1][j-k]*C[sum[i]-cnt[i]-j+k][k-cnt[i]]%mod)%=mod;
		printf("YES %d\n",f[n][n]);
	}
	return 0;
}
Problem2303

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e6+5;
const int mod = 1e9;
int fa[N],g[N];
struct P
{int x,y,z;}p[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	int tmp = getfa(fa[x]);
	g[x]^=g[fa[x]];
	return fa[x] = tmp;
}
int n,m,q;
int calc()
{
	for(int i = 1;i<= n+m;i++)fa[i]=i,g[i]=0;
	fa[m+1] = 1;
	for(int i = 1;i<= q;i++)
	{
		int u= getfa(p[i].x),v = getfa(p[i].y+m);
		int tmp = g[p[i].x]^g[p[i].y+m]^p[i].z;
		if(u!=v){fa[u]=v,g[u]=tmp;}
		else if(tmp)return 0;
	}
	int ans = -1;
	for(int i=1;i<=m+n;i++)
		if(getfa(i)==i)
		{
			if(ans==-1)ans=1;
			else
			{
				ans = ans<<1;
				if(ans>=mod)
					ans-=mod;
			}
		}
	return ans;
}
int main()
{
	scanf("%d%d%d",&m,&n,&q);
	bool f[2] = {true,true};
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&p[i].x,&p[i].y,&p[i].z);
		if(p[i].x==1&&p[i].y==1)
			{f[p[i].z] = false,i--,q--;continue;}
		if(!(p[i].x&1||p[i].y&1))p[i].z^=1;
	}
	int ans = 0;
	if(f[1])ans= calc();
	if(f[0])
	{
		for(int i = 1;i<= q;i++)
			if(p[i].x>1&&p[i].y>1)
				p[i].z^=1;
		ans+=calc();
	}
	if(ans>=mod)ans-=mod;
	printf("%d\n",ans);
	return 0;
}
Problem2306

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
int n,m,s;
double p,ans,f[N][N],g[N][N],a[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%lf",&a[i]);
	scanf("%d%lf",&s,&p);
	memset(f,0xc2,sizeof(f));
	for(int i = 1;i<= n;i++)
		f[i][i] = 0;
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		f[x][y] = a[y];
	}
	double pow = p;
	int T=70;
	while(T--)
	{
		memset(g,0xc2,sizeof(g));
		for(int k = 1;k<= n;k++)
			for(int i = 1;i<= n;i++)
				for(int j= 1;j<= n;j++)
					g[i][j]=max(g[i][j],f[i][k]+f[k][j]*pow);
		memcpy(f,g,sizeof(f));
		pow*=pow;
	}
	ans = 0;
	for(int i = 1;i<= n;i++)
		ans = max(ans,f[s][i]);
	printf("%.1lf",ans*p+a[s]);
	return 0;
}
Problem2314

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int mod = 1032992941;
ll f[N][2],g[N][2],h[N][2];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	f[x][0] = 1,g[x][0] = INF,h[x][0] = 0;
	f[x][1] = g[x][1] = h[x][1] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			int mn = min(f[e[i].to][0],min(g[e[i].to][0],h[e[i].to][0]));
			ll tmp = 0;
			if(f[e[i].to][0]==mn)tmp+=f[e[i].to][1];
			if(g[e[i].to][0]==mn)tmp+=g[e[i].to][1];
			if(h[e[i].to][0]==mn)tmp+=h[e[i].to][1];
			f[x][0]+=mn,f[x][1]=f[x][1]*tmp%mod;

			mn = min(min(g[x][0]+f[e[i].to][0],g[x][0]+g[e[i].to][0]),h[x][0]+f[e[i].to][0]);
			tmp = 0;
			if(g[x][0]+f[e[i].to][0]==mn)tmp+=(g[x][1]*f[e[i].to][1])%mod;
			if(g[x][0]+g[e[i].to][0]==mn)tmp+=(g[x][1]*g[e[i].to][1])%mod;
			if(h[x][0]+f[e[i].to][0]==mn)tmp+=(h[x][1]*f[e[i].to][1])%mod;
			g[x][0] = mn;
			g[x][1] = tmp%mod;

			h[x][0]+=g[e[i].to][0];
			h[x][1] = h[x][1]*g[e[i].to][1]%mod;
		}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	int ans1,ans2=0;
	ans1 = min(f[1][0],g[1][0]);
	if(f[1][0]==ans1)ans2+=f[1][1];
	if(g[1][0]==ans1)ans2+=g[1][1];
	ans2%=mod;
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2329

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct pas_seq
{
	int sum,lmax,rmax,lmin,rmin;
	void exc()
	{
		sum = -sum;
		swap(lmax,lmin);
		swap(rmax,rmin);
		lmax=-lmax,rmax=-rmax;
		lmin=-lmin,rmin=-rmin;
	}
	void rev()
	{
		swap(lmax,rmax);
		swap(lmin,rmin);
	}
	pas_seq(int x,int siz)
	{
		sum =siz*x;
		if(x==1)
			lmax=rmax=sum,lmin=rmin=0;
		else 
			lmin=rmin=sum,lmax=rmax=0;
	}
	friend pas_seq operator+(const pas_seq &a,const pas_seq &b)
	{
		pas_seq res(0,0);
		res.sum = a.sum+b.sum;
		res.lmax = max(a.lmax,a.sum+b.lmax);
		res.rmax = max(b.rmax,b.sum+a.rmax);
		res.lmin = min(a.lmin,a.sum+b.lmin);
		res.rmin = min(b.rmin,b.sum+a.rmin);
		return res;
	}
};
struct Splay
{
	Splay *ls,*rs,*fa;
	int cng,exc,size,val;
	bool rev;
	pas_seq *seq;
	Splay(int x);
	void push_up();
	void push_down();
}*null = new Splay(0),*root=null;
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	cng = exc = rev = 0;
	val = x,size = (val==0?0:1);
	seq = new pas_seq(x,size);
}
void Splay :: push_up()
{
	size = ls->size+(val==0?0:1)+rs->size;
	*seq = (*ls->seq)+pas_seq(val,1)+(*rs->seq);
}
void Splay :: push_down()
{
	if(cng)
	{
		ls->val = ls->cng = cng;
		rs->val = rs->cng = cng;
		*ls->seq = pas_seq(cng,ls->size);
		*rs->seq = pas_seq(cng,rs->size);
		ls->rev = ls->exc = 0;
		rs->rev = rs->exc = 0;
		cng = 0;
	}
	if(rev)
	{
		ls->rev^=1;
		rs->rev^=1;
		ls->seq->rev();
		rs->seq->rev();
		swap(ls->ls,ls->rs);
		swap(rs->ls,rs->rs);
		rev = 0;
	}
	if(exc)
	{
		ls->exc^=1;
		rs->exc^=1;
		ls->val=-ls->val;
		rs->val=-rs->val;
		ls->seq->exc();
		rs->seq->exc();
		exc = 0;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa= x;
	y->push_up();
	if(root==y)root=x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->push_down();
	x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(root==y)root=x;
}
void splay(Splay *x,Splay *tar)
{
	while(true)
	{
		Splay *y = x->fa,*z = y->fa;
		if(y==tar)break;
		if(z==tar)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void find(Splay *x,int y,Splay *z)
{
	while(true)
	{
		x->push_down();
		if(y<=x->ls->size)
			x = x->ls;
		else
		{
			y-=x->ls->size;
			if(y==1)break;
			y--;
			x = x->rs;
		}
	}
	splay(x,z);
}
void Insert(Splay *&x,int y,Splay *z)
{
	if(x==null)
	{
		x = new Splay(y);
		x->fa = z;
		x->push_up();
		splay(x,null);
		return ;
	}
	x->push_down();
	Insert(x->rs,y,x);
}
char s[N];
int main()
{
	int n,m,l,r;
	char opt[10];
	scanf("%d%d",&n,&m);
	scanf("%s",s+1);
	Insert(root,-2,null);
	for(int i = 1;i<= n;i++)
		Insert(root,s[i]=='('?1:-1,null);
	Insert(root,2,null);
	while(m--)
	{
		scanf("%s%d%d",opt,&l,&r);
		find(root,l,null);
		find(root,r+2,root);
		Splay *tmp = root->rs->ls;
		if(opt[0]=='R')
		{
			scanf("%s",opt);
			int v = opt[0]=='('?1:-1;
			tmp->cng = tmp->val = v;
			*tmp->seq = pas_seq(v,tmp->size);
			tmp->exc = tmp->rev = 0;
		}else if(opt[0]=='S')
		{
			tmp->rev^=1;
			swap(tmp->ls,tmp->rs);
			tmp->seq->rev();
		}else if(opt[0]=='I')
		{
			tmp->exc^=1;
			tmp->val=-tmp->val;
			tmp->seq->exc();
		}else
		{
			l=(int)ceil(abs(tmp->seq->lmin)/2.0);
	           	r=(int)ceil(abs(tmp->seq->rmax)/2.0);
            		printf("%d\n",l+r);
		}
	}
	return 0;
}
Problem2333

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int INF = 0x3f3f3f3f;
int n,m,r1,r2;
struct Ask
{
	int o,x,y;
	void scanA()
	{
		char opt[3];
		scanf("%s",opt);
		if(opt[0]=='U')
			o = 1,scanf("%d%d",&x,&y);
		else if(opt[0]=='A')
		{
			if(opt[1]=='1')o = 2,scanf("%d%d",&x,&y);
			else if(opt[1]=='2')o = 3,scanf("%d%d",&x,&y);
			else o = 4,scanf("%d",&x);
		}else
		{
			if(opt[1]=='1')o = 5,scanf("%d",&x);
			else if(opt[1]=='2')o = 6,scanf("%d",&x);
			else o =7;
		}
	} 
}ask[N];
int maxn[N<<2],lazy[N<<2];
int fa[N<<2],ed[N<<2],next[N<<2],w[N<<2],save[N<<2],a[N];
int tot;
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int y)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		maxn[p]+=y;
		lazy[p]+=y;
		return ;
	}
	int mid=(l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,y);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,y);	
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)return maxn[p];
	int mid=(l+r)>>1,ans = -INF;
	if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		maxn[p] = save[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int id;
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		fa[i] = i,ed[i] = i;
	scanf("%d",&m);
	for(int i= 1;i<= m;i++)
	{
		ask[i].scanA();
		if(ask[i].o==1)
		{
			r1 = getfa(ask[i].x),r2 = getfa(ask[i].y);
			if(r1==r2)continue;
			fa[r2] = r1;
			next[ed[r1]] = r2;
			ed[r1] = ed[r2];
		}
	}
	for(int i = 1;i<= n;i++)
		if(getfa(i)==i)
			for(int j = i;j;j = next[j])
			{
				id++;
				w[j] = id;
				save[id] = a[j];
			}
	build(1,1,n);
	for(int i= 1;i<= n;i++)
		fa[i] = i,ed[i] = i;
	for(int i = 1;i<= m;i++)
	{
		if(ask[i].o==1)
		{
			r1=getfa(ask[i].x),r2=getfa(ask[i].y);
			if(r1==r2)continue;
			fa[r2] = r1;
			ed[r1] = ed[r2];
		}
		else if(ask[i].o==2)update(1,1,n,w[ask[i].x],w[ask[i].x],ask[i].y);
		else if(ask[i].o==3)update(1,1,n,w[getfa(ask[i].x)],w[ed[getfa(ask[i].x)]],ask[i].y);
		else if(ask[i].o==4)update(1,1,n,1,n,ask[i].x);
		else if(ask[i].o==5)printf("%d\n",getans(1,1,n,w[ask[i].x],w[ask[i].x]));
		else if(ask[i].o==6)printf("%d\n",getans(1,1,n,w[getfa(ask[i].x)],w[ed[getfa(ask[i].x)]]));
		else printf("%d\n",getans(1,1,n,1,n));
	}
	return 0;
}
Problem2337

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned int UI;
const int N = 105;
const double eps = 1e-8;
int n;
double f[N][N],ans[N],cnt[N];
struct E
{int next,to,val;}e[N*N*2];
int head[N],tot;
void add(int x,int y,int f)
{
	cnt[x]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void work()
{
	for(int i = 1;i< n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(f[xn],f[i]);
		for(int line = i+1;line<= n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = 1;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n-1;i>= 1;i--)
	{
		for(int j = i+1;j<= n;j++)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	int m,x,y;
	UI c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%u",&x,&y,&c);
		add(x,y,c);
		if(x!=y)add(y,x,c);
	}
	double t_ans = 0;
	for(int pos = 0;pos<32;pos++)
	{
		memset(f,0,sizeof(f));
		for(int i = 1;i< n;i++)
			for(int j = head[i];j;j = e[j].next)
			{
				if(e[j].val&(1<<pos))f[i][e[j].to]+=1.0,f[i][n+1]+=1.0;
				else f[i][e[j].to]-=1.0;
			}
		for(int i = 1;i< n;i++)
			f[i][i]+=cnt[i];
		memset(ans,0,sizeof(ans));
		work();
		t_ans+=ans[1]*(1<<pos);
	}
	printf("%.3f\n",t_ans);
	return 0;
}
Problem2338

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1505;
struct Point
{
	ll x,y;
	Point(){}
	Point(ll x,ll y):x(x),y(y){}
	bool operator ==(const Point &a)const
	{
		return (a.x==x&&a.y==y);
	}
	Point operator -(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	ll operator *(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
}poi[N];
struct Line
{
	Point *p1,*p2;
	Point midp;
	ll len;
	bool operator==(const Line &a)const
	{
		return (a.len==len&&a.midp==midp);
	}
	bool operator<(const Line &a)const
	{
		if(a.len==len)
		{
			if(a.midp.x==midp.x)
				return midp.y<a.midp.y;
			return midp.x<a.midp.x;
		}
		return len<a.len;
	}
}line[(N*N)>>1];
ll dis(const Point &p1,const Point &p2)
{
	return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);
}
ll Abs(ll x)
{
	return x>0?x:-x;
}
int tot;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld",&poi[i].x,&poi[i].y);
		for(int j = 1;j<i;j++)
		{
			line[++tot].len = dis(poi[i],poi[j]);
			line[tot].p1 = &poi[i];
			line[tot].p2 = &poi[j];
			line[tot].midp = Point(poi[i].x+poi[j].x,poi[i].y+poi[j].y);
		}
	}
	sort(line+1,line+tot+1);
	int i,j;
	ll ans = 0;
	for(i = 1;i<= tot;i++)
	{
		for(j = i-1;j&&line[j]==line[i];j--)
			ans = max(ans,Abs( ((*line[i].p1)-(*line[j].p1))*((*line[i].p1)-(*line[j].p2)) ) );
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2342

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int p[N],q[N];
char s[N];
set<int>t;
bool cmp(int a,int b)
{
	return a-p[a]<b-p[b];
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	s[0]='#';
	int maxp = 0,id = 0;
	for(int i = 1;i<= n;i++)
	{
		if(maxp>=i)p[i]=min(p[id*2-i],maxp-i);
		else p[i]=0;
		for(;s[i+p[i]+1]==s[i-p[i]];p[i]++);
		if(p[i]+i>maxp)maxp = p[i]+i,id=i;
	}
	for(int i = 1;i<= n;i++)q[i]=i;
	sort(q+1,q+n+1,cmp);
	int now = 1,ans = 0;
	for(int i = 1;i<= n;i++)
	{
		while(now<=n&&q[now]-p[q[now]]<=i)
		{
			t.insert(q[now]);
			now++;
		}
		set<int>::iterator tmp=t.upper_bound(i+p[i]/2);
		if(tmp!=t.begin())
		{
			ans=max(ans,(*--tmp-i)*4);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem2393

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3005;
int t,vis[N];
ll l,r,n,m;
ll a[N];
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
void getnum(ll x,ll y)
{
	if(y>r)
		return ;
	if(x>1)
		a[++m]=y;
	if(x>t)
		return ;
	getnum(x+1,y*10+2);
	getnum(x+1,y*10+9);
}
ll ans;
void dfs(ll x,ll y,ll z)
{
	if(x>n)
	{
		if(y&1)
			ans+=r/z-(l-1)/z;
		else
			if(y)
				ans-=r/z-(l-1)/z;
		return ;
	}
	dfs(x+1,y,z);
	ll next = a[x]*z/gcd(a[x],z);
	if(next<=r)
		dfs(x+1,y+1,next);
	return ;
}
int b[N];
int main()
{
	scanf("%lld%lld",&l,&r);
	t = (int)(log10(r)+1);
	getnum(1,0);
	sort(a+1,a+m+1);
	for(int i = 1;i<= m;i++)
		if(!vis[i])
		{
			b[++n] = a[i];
			for(int j = i+1;j<= m;j++)
				if(a[j]%a[i]==0)
					vis[j] = 1;
		}
	for(int i = 1;i<= n;i++)
		a[n-i+1]=b[i];
	dfs(1,0,1);
	printf("%lld\n",ans);
	return 0;
}
Problem2427

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 105;
const int M = 505;
struct E
{
	int next,to;
}edge[N],e[N];
int h1[N],h2[N],tot1,tot2,ind[N];
void add1(int x,int y)
{
	edge[++tot1].to = y;
	edge[tot1].next = h1[x];
	h1[x] = tot1;
}
void add2(int x,int y)
{
	ind[y]++;
	e[++tot2].to = y;
	e[tot2].next = h2[x];
	h2[x] = tot2;
}
int dep[N],low[N],dfn,stack[N],top,scc,id[N],W[N],V[N];
int w[N],v[N],n,m;
bool ins[N],vis[N];
void tarjan(int x)
{
	vis[x] = true;
	low[x] = dep[x] = ++dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = h1[x];i;i = edge[i].next)
	{
		if(!vis[edge[i].to])
			{tarjan(edge[i].to);low[x] = min(low[x],low[edge[i].to]);}
		else if(ins[edge[i].to])
			low[x] = min(low[x],dep[edge[i].to]);
	}
	if(low[x]==dep[x])
	{
		scc++;
		int tmp;
		do{
			tmp = stack[top--];
			ins[tmp] = false;
			id[tmp] = scc;
			W[scc]+=w[tmp],V[scc]+=v[tmp];
		}while(tmp!=x);
	}
}
bool map[N][N];
void rebuild()
{
	for(int i = 1;i<= n;i++)
		for(int j = h1[i];j;j = edge[j].next)
			if(id[i]!=id[edge[j].to]&&!map[id[i]][id[edge[j].to]])
			{
				add2(id[i],id[edge[j].to]);
				map[id[i]][id[edge[j].to]] = true;
			}
}
int f[N][M];
void dp(int x,int fa)
{
	if(W[x]<=m)f[x][W[x]] = V[x];
	for(int i = h2[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dp(e[i].to,x);
	for(int i = h2[x];i;i = e[i].next)
		for(int j = m;j>=0;j--)
			for(int k = 0;k<= j;k++)
				if(f[x][j-k]!=-1&&f[e[i].to][k]!=-1)
					f[x][j] = max(f[x][j],f[x][j-k]+f[e[i].to][k]);
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&v[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(x==0)continue;
		add1(x,i);
	}

	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	//printf("warning\n");
	rebuild();
	int root = 0;
	for(int i = 1;i<= scc;i++)
		if(ind[i]==0)
			add2(root,i);
	memset(f,-1,sizeof(f));
	int ans = 0;
	dp(root,-1);
	for(int i = m;i>=0;i--)
		ans = max(f[root][i],ans);
	printf("%d\n",ans);
	return 0;
}
Problem2434

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 1e5+5;
char s[N];
struct Gragh
{int next,to;}e[N<<1];
int head[N],tot,Dfn;
void add(int x,int y)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;}
struct P
{int no,x;};
int dfn[N],end[N];
void dfs(int x)
{
	dfn[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	end[x] = Dfn;
}
int c[N],id[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
vector<P>ask[N];
int ans[N];
struct AC_Machine
{
	int ch[N][26],sum[N],fail[N],from[N];
	int q[N],h,t,cnt;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i] = 1;
	}
	void insert()
	{
		scanf("%s",s);
		int now = 1,i = 0,num = 0;
		while(s[i])
		{
			if(s[i]=='P')
			{
				num++;
				id[num] = now;
				sum[now]++;i++;continue;
			}
			if(s[i]=='B'){now = from[now];i++;continue;}
			if(!ch[now][s(i)])
				{ch[now][s(i)]=++cnt;from[cnt]=now;}
			now = ch[now][s(i)];
			i++;
		}
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1,fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				q[++t] = to;
				add(fail[to],to);
			}
		}
	}
}AC;
int main()
{
	AC.insert();
	AC.build();
	dfs(1);
	int m,x,y;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		ask[y].push_back((P){i,x});
	}
	int num = 0,n = strlen(s)-1,now = 1;
	for(int i =0;i<=n;i++)
	{
		if(s[i]=='P')
		{
			num++;
			int sz = ask[num].size();
			for(int j = 0;j<sz;j++)
			{
				int x = id[ask[num][j].x];
				ans[ask[num][j].no] = getans(end[x])-getans(dfn[x]-1);
			}
			continue;
		}
		if(s[i]=='B'){update(dfn[now],-1);now = AC.from[now];continue;}
		now = AC.ch[now][s(i)];
		update(dfn[now],1);
	}
	for(int i = 1;i<= m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem2442

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long LL;
LL sum[N],f[N];
int line[N],l,r;
int main()
{
	int n,k,x;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		sum[i] = sum[i-1]+x;
	}
	line[0] = 0;
	for(int i = 1;i<= n+1;i++)
	{
		while(l<=r&&i-line[l]-1>k)l++;
		if(l<=r)
			f[i] = max(f[i],f[line[l]]-sum[line[l]]+sum[i-1]);
		while(l<=r&&f[i]-sum[i]>f[line[r]]-sum[line[r]])
			r--;
		line[++r] = i;
	}
	printf("%lld\n",f[n+1]);
	return 0;
}
Problem2453

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int C = 1e6+5;
const int INF = 0x3f3f3f3f;
int n,m;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2],*col[C];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_less(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}else if(y<x->val)get_less(x->ls,y);
	else
	{
		if(x->ls)tmp+=x->ls->size;
		tmp+=x->cnt;
		get_less(x->rs,y);
	}
}
void get_less(int p,int l,int r,int a,int b,int y)
{
	if(l>=a&&r<=b){get_less(root[p],y);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_less(p<<1,l,mid,a,b,y);
	if(b >mid)get_less(p<<1|1,mid+1,r,a,b,y);
}
int tt;
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)get_pre(x->ls,y);
	else
	{
		tt = max(tt,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)get_sub(x->rs,y);
	else
	{
		tt = min(tt,x->val);
		get_sub(x->ls,y);
	}
}
int pre[N],last[C],color[N];
void build(int p,int l,int r,int pos,int val)
{
	Insert(root[p],val);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,val);
	else build(p<<1|1,mid+1,r,pos,val);
}
void change(int p,int l,int r,int pos,int a,int b)
{
	Delete(root[p],a);
	Insert(root[p],b);
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,a,b);
	else change(p<<1|1,mid+1,r,pos,a,b);
}
int main()
{
	scanf("%d%d",&n,&m);
	int cc = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&color[i]);
		pre[i] = last[color[i]];
		last[color[i]] = i;
		Insert(col[color[i]],i);
		cc = max(cc,color[i]);
	}
	for(int i = 1;i<= n;i++)
		build(1,1,n,i,pre[i]);
	for(int i=1;i<=1000000;i++)
		Insert(col[i],0),Insert(col[i],n+1);
	char opt[2];
	int x,y;
	while(m--)
	{
		scanf("%s%d%d",opt,&x,&y);
		if(opt[0]=='Q'){tmp = 0;get_less(1,1,n,x,y,x);printf("%d\n",tmp);}
		else
		{
			tt = INF;get_sub(col[color[x]],x);
			int nextA = tt;
			tt = 0;get_pre(col[y],x);
			int lastB = tt;
			tt = INF;get_sub(col[y],x);
			int nextB = tt;
			if(nextA!=n+1)change(1,1,n,nextA,x,pre[x]);
			change(1,1,n,x,pre[x],lastB);
			if(nextB!=n+1)change(1,1,n,nextB,lastB,x);
			Delete(col[color[x]],x);Insert(col[y],x);
			color[x] = y;
			if(nextA!=n+1)pre[nextA] = pre[x];
			pre[x] =lastB;
			if(nextB!=n+1)pre[nextB] = x;
		}
	}
	return 0;
}
Problem2460

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
typedef long long ll;
struct B
{
	ll no,val;
	bool operator <(const B &s)const
	{
		return val>s.val;
	}
}stone[N];
ll a[N],p[70];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		ll x,y;
		scanf("%lld%lld",&x,&y);
		stone[i].no = x,stone[i].val = y;
	}
	sort(stone+1,stone+1+n);
	for(int i = 1;i<= n;i++)a[i]=stone[i].no;
	ll ans = 0;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 63;j>=0;j--)
			if((a[i]>>j)&1)
			{
				if(!p[j]){p[j] = a[i];break;}
				else a[i]^=p[j];
			}
		if(a[i])ans+=stone[i].val;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2467

#include <stdio.h>
int ans[]={0,4,40,300,2000,458,741,1981,1285,1458,518,842,1491,1888,1675,1662,836,929,432,1165,850,1452,1298,764,1281,1738,1411,765,473,1661,771,304,1828,645,890,803,1836,292,1174,426,1001,1367,687,793,790,117,1490,1940,213,1798,613,1320,1889,1946,333,841,85,1902,839,980,867,226,655,900,653,86,591,1753,748,1788,1187,1289,1278,625,391,327,1523,1034,363,1864,1537,882,500,1013,1644,1150,505,384,1250,893,1764,1336,1372,390,1712,1349,795,316,1348,1566,23};
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		printf("%d\n",ans[n]);
	}
	return 0;
}
Problem2500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
LL f[N],t[N],hap[N];
int Q1[N],Q2[N],f_no[N],l1,l2,r1,r2;
struct E
{
	int next,to,val;
}e[N];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		if(f[e[i].to]+e[i].val>f[x])
		{
			t[x] = f[x];
			f[x] = f[e[i].to]+e[i].val;
			f_no[x] = e[i].to;
		}else if(f[e[i].to]+e[i].val>t[x])
			t[x] = f[e[i].to]+e[i].val;
	}
}
void redfs(int x,LL v)
{
	hap[x] = max(f[x],v);
	for(int i = head[x];i;i = e[i].next)
	{
		LL tmp = f_no[x]==e[i].to?t[x]:f[x];
		redfs(e[i].to,max(v,tmp)+e[i].val);
	}
}
int main()
{
	int n,m,x,y,ans = 0;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		//if(x==i)root = i;
		add(x,i,y);
	}
	dfs(1);
	redfs(1,0);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&hap[i]>hap[Q1[r1]])r1--;
		Q1[++r1] = i;
		while(l2<=r2&&hap[i]<hap[Q2[r2]])r2--;
		Q2[++r2] = i;
		while(hap[Q1[l1]]-hap[Q2[l2]]>m)
		{
			j++;
			while(l1<=r1&&Q1[l1]<j)l1++;
			while(l2<=r2&&Q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2500

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
LL f[N],t[N],hap[N];
int Q1[N],Q2[N],f_no[N],l1,l2,r1,r2;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
struct E
{
	int next,to,val;
}e[N];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		dfs(e[i].to);
		if(f[e[i].to]+e[i].val>f[x])
		{
			t[x] = f[x];
			f[x] = f[e[i].to]+e[i].val;
			f_no[x] = e[i].to;
		}else if(f[e[i].to]+e[i].val>t[x])
			t[x] = f[e[i].to]+e[i].val;
	}
}
void redfs(int x,LL v)
{
	hap[x] = max(f[x],v);
	for(int i = head[x];i;i = e[i].next)
	{
		LL tmp = f_no[x]==e[i].to?t[x]:f[x];
		redfs(e[i].to,max(v,tmp)+e[i].val);
	}
}
int main()
{
	int n,m,x,y,ans = 0;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		x = read();y = read();
		//if(x==i)root = i;
		add(x,i,y);
	}
	dfs(1);
	redfs(1,0);
	int j = 1;
	r1 = r2 = -1;
	for(int i = 1;i<= n;i++)
	{
		while(l1<=r1&&hap[i]>hap[Q1[r1]])r1--;
		Q1[++r1] = i;
		while(l2<=r2&&hap[i]<hap[Q2[r2]])r2--;
		Q2[++r2] = i;
		while(hap[Q1[l1]]-hap[Q2[l2]]>m)
		{
			j++;
			while(l1<=r1&&Q1[l1]<j)l1++;
			while(l2<=r2&&Q2[l2]<j)l2++;
		}
		ans = max(ans,i-j+1);
	}
	printf("%d\n",ans);
	return 0;
}
Problem2525

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int f[N],sta[N],cnt,ans,d[N],n,m;
void dfs(int x,int fa)
{
	int nf = -1,fw= d[x]-1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			if(sta[e[i].to]==0)
				nf = max(nf,f[e[i].to]-1);
			else if(sta[e[i].to]==1)
				fw = max(fw,f[e[i].to]+1);
		}
	if(nf<fw)
	{
		if(fw==ans)
		{
			cnt++;
			f[x] = ans;
			sta[x] = 0;
		}else
		{
			f[x] = fw;
			sta[x] = 1;
		}
	}else if(nf!=-1)
	{
		f[x] = nf;
		sta[x] = 0;
	}else
	{
		f[x] = 0;
		sta[x] = 2;
	}
}
int check()
{
	int l = 0,r = n+1;
	while(l<r)
	{
		ans = (l+r)>>1;
		memset(f,0,sizeof(f));
		memset(sta,-1,sizeof(sta));
		cnt = 0;
		dfs(1,0);
		if(sta[1]==1)cnt++;
		if(cnt>m)l = ans+1;
		else r = ans;
	}
	return l;
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&d[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	printf("%d\n",check());
	return 0;
}
Problem2527

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
typedef long long LL;
struct E
{int next,to;}e[N],k[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int pos[N],Cnt,n,m,K;
void Add(int x,int y)
{
	k[++Cnt].to = y;
	k[Cnt].next = pos[x];
	pos[x] = Cnt;
}
struct A
{int l,r,mid;}ask[N];
LL c[N];
struct R
{int s,t,a;}rain[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
LL getans(int x)
{
	LL ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void UP(int i)
{
	if(rain[i].s>rain[i].t)
	{
		update(1,rain[i].a);update(rain[i].t+1,-rain[i].a);
		update(rain[i].s,rain[i].a);update(m+1,-rain[i].a);
	}else
		update(rain[i].s,rain[i].a),update(rain[i].t+1,-rain[i].a);
}
LL p[N];
void check()
{
	memset(c,0,sizeof(c));
	memset(head,0,sizeof(head));
	tot = 0;
	for(int i = 1;i<= n;i++)
	{
		ask[i].mid = (ask[i].l+ask[i].r)>>1;
		add(ask[i].mid,i);
	}
	for(int i = 1;i<= K;i++)
	{
		UP(i);
		for(int j = head[i];j;j = e[j].next)
		{
			LL ans = 0;
			for(int t = pos[e[j].to];t;t = k[t].next)
			{
				ans+=getans(k[t].to);
				if(ans>p[e[j].to])break;
			}
			if(ans<p[e[j].to])
				ask[e[j].to].l = ask[e[j].to].mid+1;
			else
				ask[e[j].to].r = ask[e[j].to].mid;
		}
	}
}
int main()
{
	//freopen("met.in","r",stdin);
	//freopen("met.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int x;
		scanf("%d",&x);
		Add(x,i);
	}
	for(int i = 1;i<= n;i++)
		scanf("%lld",&p[i]);
	scanf("%d",&K);
	for(int i = 1;i<= K;i++)
		scanf("%d%d%d",&rain[i].s,&rain[i].t,&rain[i].a);
	for(int i = 1;i<= n;i++)
		ask[i].l = 1,ask[i].r = K+1;
	for(int i = 1;i<= 20;i++)
		check();
	for(int i = 1;i<= n;i++)
	{
		if(ask[i].mid<=K)
			printf("%d\n",ask[i].mid);
		else printf("NIE\n");
	}
	return 0;
}
Problem2529

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
struct S
{int lth,col;}stick[N],a[4];
bool cmp(S a,S b)
{
	return a.lth<b.lth;
}
int main()
{
	int k,x,tot = 0;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&x);
		for(int j = 1;j<= x;j++)
		{
			tot++;
			scanf("%d",&stick[tot].lth);
			stick[tot].col = i;
		}
	}
	sort(stick+1,stick+tot+1,cmp);
	for(int i = 1;i<= tot;i++)
	{
		int j;
		for(j = 1;j<= 3;j++)
			if(stick[i].col==a[j].col)
				{a[j] = stick[i];break;}
		if(j==4)a[1] = stick[i];
		sort(a+1,a+4,cmp);
		if(a[1].col!=0)
			if(a[1].lth+a[2].lth>a[3].lth)
			{
				printf("%d %d %d %d %d %d\n",a[1].col,a[1].lth,a[2].col,a[2].lth,a[3].col,a[3].lth);
				return 0;
			}
	}
	printf("NIE\n");
	return 0;
}
Problem2530

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
bool map[N][N];
bool v[N];
int main()
{	
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y] = map[y][x] = true;
	}
	int cnt = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i])
			for(int j = i+1;j<= n;j++)
				if(!v[j]&&!map[i][j])
				{
					v[i] = v[j] = true;
					break;
				}
	for(int i = 1;i<= n;i++)
	{
		if(!v[i])
			printf("%d%c",i,++cnt==n/3?' ':'\n');
		if(cnt==n/3)break;
	}
	return 0;
}
Problem2539

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
typedef long long ll;
const int maxm=100000,inf=1061109567;
const ll mod=1000000007;
map<ll,int>id;  char str[30];   ll hash[100];
int h[100],p[maxm],c[maxm],cost[maxm],n1[maxm],q[maxm],sp[100],inq[100];
int D,n,S,T,TT,An=0,path[maxm],w[100][100],pre[100],tot=0,px[100],py[100];
inline void ae(int a,int b,int cc,int co)
{
	p[tot]=b; c[tot]=cc; cost[tot]=co;  n1[tot]=h[a]; h[a]=tot++;
	p[tot]=a; c[tot]=0;  cost[tot]=-co; n1[tot]=h[b]; h[b]=tot++;
}
inline int spfa()
{
	memset(sp,63,sizeof(sp));   
	memset(inq,0,sizeof(inq));
	int head=0,tail=1; 
	sp[S]=0; q[0]=S; 
	inq[S]=1; pre[S]=-1;
	while(head!=tail)
	{
		int u=q[head++]; 
		if(head>=maxm) 
			head-=maxm; 
		inq[u]=0;
		for(int i=h[u];~i;i=n1[i])
			if(c[i]>0&&sp[p[i]]>sp[u]+cost[i])
			{
				path[p[i]]=i, pre[p[i]]=u, sp[p[i]]=sp[u]+cost[i];
				if(!inq[p[i]])
				{ 
					inq[p[i]]=1, q[tail++]=p[i]; 
					if(tail>=maxm) 
						tail-=maxm;
				}
			}
	}
	return sp[T]!=inf;
}
inline int aug()
{
	int delta=inf,  flow=0;
	for(int i=T;pre[i]!=-1;i=pre[i]) delta=min(delta,c[path[i]]);
	for(int i=T;pre[i]!=-1;i=pre[i])
	{
		c[path[i]]-=delta, c[path[i]^1]+=delta;
		flow+=cost[path[i]]*delta;
	}
	return flow;
}
inline int cf()
{
	int ret=0; 
	while(spfa()) 
		ret+=aug(); 
	return ret;
}
inline ll gethash(char *str)
{
	ll tmp=0; int len=strlen(str);
	for(int j=0;j<len;j++) 
		if(str[j]>='A' && str[j]<='Z') 
			str[j]=str[j]+32; 
	for(int j=0;j<len;j++)
	{
		tmp=tmp*29+str[j];
		if(tmp>=mod) tmp%=mod;
	}
	return tmp;
}
inline int ok(int u,int v)
{
	if((px[u]-px[v])*(px[u]-px[v])+(py[u]-py[v])*(py[u]-py[v])>D*D) return 0;
	for(int i=1;i<=n<<1;i++)
	{
		if(i==u||i==v) continue;
		if((px[i]-px[u])*(px[i]-px[v])>0) continue;
		if((py[i]-py[u])*(py[i]-py[v])>0) continue;
		if((px[i]-px[u])*(py[v]-py[i])==(py[i]-py[u])*(px[v]-px[i])) return 0;
	}
	return 1;
}
int main()
{
	scanf("%d%d",&D,&n);
	S=0;TT=n<<1|1;T=TT+1;
	memset(h,0xff,sizeof(h));
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%s",&px[i],&py[i],str);
		px[i]+=50;py[i]+=50;
		id[hash[i]=gethash(str)]=i;
		ae(S,i,1,0);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%s",&px[n+i],&py[n+i],str);
		px[n+i]+=50;py[n+i]+=50;
		id[hash[n+i]=gethash(str)]=n+i;
		ae(n+i,T,1,0);
	}
	int u,v;
	for(int i=1;i<=n<<1;i++) 
		for(int j=1;j<=n<<1;j++) 
			w[i][j]=1;
	while(1)
	{
		scanf("%s",str);    
		if(!strcmp("End",str)) break;   
		u=id[gethash(str)];
		scanf("%s",str);    v=id[gethash(str)];
		scanf("%d",&w[u][v]);   w[v][u]=w[u][v];
	}
	for(int i=1;i<=n;i++) 
		for(int j=n+1;j<=n<<1;j++) 
			if(ok(i,j)) 
				ae(i,j,1,-w[i][j]);
	printf("%d\n",-cf()); 
	return 0;
}
Problem2547

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define vx v.x
#define ux u.x
#define vy v.y
#define uy u.y
const int N = 115;
const int INF = 0x3f3f3f3f;
int h[N][N],dis[N][N],n,m,par[N],tot,mp[N][N],cnt,pt;
struct P
{
	int x,y;
	P(int x=0,int y=0):x(x),y(y){}
}a[N],b[N];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
bool vis[N][N],bo[N];
queue<P>Q;
void spfa(int sx,int sy,int p)
{
	memset(dis,0x3f,sizeof(dis));
	dis[sx][sy]=0;
	vis[sx][sy]=true;
	Q.push(P(sx,sy));
	P u,v;
	int t;
	while(!Q.empty())
	{
		u = Q.front();
		Q.pop();
		vis[ux][uy]=false;
		for(int i = 0;i<4;i++)
		{
			vx = ux+dx[i],vy=uy+dy[i];
			if(vx<=0||vy<=0||vx>n||vy>m)continue;
			if(p^(dis[ux][uy]&1))
				{if(h[vx][vy]<=h[ux][uy])t=0;else t=1;}
			else
				{if(h[vx][vy]>=h[ux][uy])t=0;else t=1;}
			if(dis[ux][uy]+t<dis[vx][vy])
			{
				dis[vx][vy]=dis[ux][uy]+t;
				if(!vis[vx][vy])
				{
					Q.push(P(vx,vy));
					vis[vx][vy]=true;
				}
			}
		}
	}
}
bool get_partner(int x,int lim)
{
	for(int i = 1;i<= tot;i++)
		if(bo[i]&&mp[x][i]<=lim)
		{
			bo[i]=false;
			if(!par[i]||get_partner(par[i],lim))
			{
				par[i]=x;
				return true;
			}
		}
	return false;
}
bool check(int x)
{
	int tmp = 0;
	memset(par,0,sizeof(par));
	for(int i= 1;i<= cnt<<1;i++)
	{
		memset(bo,1,sizeof(bo));
		if(get_partner(i,x))tmp++;
	}
	return tmp+x>=(cnt<<1);
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&cnt,&pt);
	int x,y,t;
	for(int i = 1;i<=(cnt<<1|1);i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	for(int i = 1;i<=pt;i++)
	{
		scanf("%d%d%d",&x,&y,&t);
		while(t--)
			b[++tot].x=x,b[tot].y=y;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&h[i][j]);
	for(int i = 1;i<= cnt<<1;i++)
	{
		if(i<=cnt)spfa(a[i].x,a[i].y,0);
		else spfa(a[i].x,a[i].y,1);
		for(int j = 1;j<= tot;j++)mp[i][j]=dis[b[j].x][b[j].y];
	}
	int l = 0,r = cnt*2;
	while(l<r)
	{
		int mid =(l+r)>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem2553

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
#define s(no,i) s[no][i]-'a'
typedef long double ld;
const int P = 81;
int n,L,k;
struct Matrix
{
	int w,h;
	ld d[P][P];
	Matrix(){}
	Matrix(int _w,int _h):w(_w),h(_h){}

	void operator*=(const Matrix &S)
	{
		Matrix res(w,S.h);
		for(int i = 0;i<res.w;i++)
			for(int j = 0;j<res.h;j++)
			{
				res.d[i][j] = 0;
				for(int k = 0;k<h;k++)
					res.d[i][j]+=d[i][k]*S.d[k][j];
			}
		*this = res;
	}
};
int len[6];
char s[6][20];
bool cover(int a,int b)
{
	if(len[a]<len[b])return false;
	for(int i = 1;i+len[b]-1<=len[a];i++)
	{
		bool flag = true;
		for(int j = 1;j<= len[b];j++)
			if(s[a][i+j-1]!=s[b][j])
				{flag=false;break;}
		if(flag)return true;
	}
	return false;
}
struct AC_Machine
{
	int ch[P][26],fail[P];
	int cnt,q[P],h,t;
	bool end[P];
	void insert(int no)
	{
		int now = 0,i = 1;
		while(s[no][i])
		{
			if(!ch[now][s(no,i)])ch[now][s(no,i)] = ++cnt;
			now = ch[now][s(no,i)];
			i++;
		}
		end[now]=true;
	}
	void build()
	{
		h = 0,t = -1;
		for(int i = 0;i<k;i++)
			if(ch[0][i])
				q[++t] = ch[0][i];
		while(h<=t)
		{
			int x=q[h++];
			for(int i = 0;i<k;i++)
			{
				int j = ch[x][i];
				if(j)
				{
					q[++t] = j;
					int r = fail[x];
					while(r&&!ch[r][i])r = fail[r];
					fail[j] = ch[r][i];
					end[j]|=end[fail[j]];
				}
				else ch[x][i] = ch[fail[x]][i];
			}
		}
	}
}AC;
bool covered[6];
int main()
{
	scanf("%d%d%d",&n,&L,&k);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	for(int i = 1;i<= n;i++)
		len[i] = strlen(s[i]+1);
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			if(cover(i,j))
				covered[i] = true;
	bool a_c = true;
	for(int i = 1;i<= n;i++)
		if(!covered[i])a_c = false;
	if(a_c)covered[1] = false;
	AC.cnt = 0;
	for(int i = 1;i<= n;i++)
		if(!covered[i])
			AC.insert(i);
	AC.build();
	int cnt = AC.cnt;
	Matrix res(1,cnt+2);
	res.d[0][0] = 1;
	Matrix add(cnt+2,cnt+2);add.d[cnt+1][cnt+1] = 1;
	for(int i = 0;i<=cnt;i++)
		for(int j = 0;j<k;j++)
			if(AC.end[AC.ch[i][j]])add.d[i][cnt+1]+=(ld)1/(ld)k,add.d[i][0]+=(ld)1/(ld)k;
			else add.d[i][AC.ch[i][j]]+=(ld)1/(ld)k;
	for(;L;L>>=1,add*=add)if(L&1)res*=add;
	double ans = res.d[0][cnt+1];
	printf("%.6lf\n",ans);
	return 0;
}
Problem2555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1200005;
char s[N];
int mask;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,add_mark;
	Splay();
	void push_down();
	void Add(int x);
}*null = new Splay;
Splay :: Splay ()
{
	ls = rs = fa = null;
	val = add_mark = 0;
}
void Splay :: push_down()
{
	if(fa->ls==this||fa->rs==this)
		fa->push_down();
	if(add_mark)
	{
		ls->Add(add_mark);
		rs->Add(add_mark);
		add_mark = 0;
	}
}
void Splay :: Add(int x)
{
	val+=x;
	add_mark+=x;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa= x;
}
void splay(Splay *x)
{
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
}
void Access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		y = x,x = x->fa;
	}
}
void Cut(Splay *x)
{
	Access(x);
	splay(x);
	x->ls->fa = null;
	x->ls = null;
}
void Link(Splay *x,Splay *y)
{
	Cut(x);
	x->fa = y;
}
struct SAM
{
	int trs[N][26],fa[N],len[N];
	int cnt,last;
	Splay *tree[N];
	void init(){cnt=last=1;tree[1] = new Splay;}
	void insert(int x)
	{
		int p,newp,q,newq;
		p = last,newp = ++cnt,last = cnt;
		tree[cnt] = new Splay;
		len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)
		{
			fa[newp] = 1;
			Link(tree[newp],tree[1]);
		}
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)
			{
				fa[newp] = q;
				Link(tree[newp],tree[q]);
			}
			else
			{
				newq = ++cnt;
				tree[newq] = new Splay;
				fa[newq] = fa[q];
				Link(tree[newq],tree[fa[q]]);
				memcpy(trs[newq],trs[q],sizeof(trs[q]));
				len[newq] = len[p]+1;
				fa[newp] = fa[q] = newq;
				Link(tree[q],tree[newq]);
                Link(tree[newp],tree[newq]);
                tree[q]->push_down();
                tree[newq]->val = tree[q]->val;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = newq;
			}
		}
		Access(tree[newp]);
        splay(tree[newp]);
        tree[newp]->Add(1);
	}
	void Insert()
	{
		for(int i = 1;s[i];i++)
			insert(s[i]-'A');
	}
	int Query(char *s)
    {
        int p = 1;
        for(;p;p=trs[p][(*s++)-'A'])
            if(!*s) return tree[p]->push_down(),tree[p]->val;
        return 0;
    }
}sam;
void Decode(char s[],int mask)
{
    int i,n=strlen(s);
    for(i=0;i<n;i++)
    {
        mask=(mask*131+i)%n;
        swap(s[i],s[mask]);
    }
}
int main()
{
	int q;
	char opt[10];
	sam.init();
	scanf("%d",&q);
	scanf("%s",s+1);
	sam.Insert();
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%s",opt,s+1);
		Decode(s+1,mask);
		if(opt[0]=='A')sam.Insert();
		else
		{
			int tmp = sam.Query(s+1);
			mask^=tmp;
			printf("%d\n",tmp);
		}
	}
	return 0;
}
Problem2557

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1e6+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool used[N],pass[N];
int fa[N];
bool dfs(int x)
{
	for(int i=head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			used[e[i].to] = true;
			if(!fa[e[i].to]||dfs(fa[e[i].to]))
			{
				fa[e[i].to] = x;
				return true;
			}
		}
	return false;
}
int main()
{
	int n,m,r,t,k,x,y;
	scanf("%d%d%d%d%d",&n,&m,&r,&t,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	int ans1 = 0,ans2 = 0;
	for(int j = r;j<=t;j = j+r)
	{
		for(int i = 1;i<= n;i++)
			if(!pass[i])
			{
				memset(used,0,sizeof(used));
				if(dfs(i))ans1++,ans2+=j;
				else pass[i] = true;
			}
	}
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem2560

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<16;
const int mod = 1e9+7;
int c[20][20];
int f[S],g[S],n;
int main()
{
	int now;
	scanf("%d",&n);
	for(int i = 0;i<n;i++)
		for(int j = 0;j<n;j++)
			scanf("%d",&c[i][j]);
	int end = 1<<n;
	for(int i = 1;i<end;i++)
	{
		g[i] = 1;
		for(int j = 0;j<n;j++)if(i&(1<<j))
			for(int k = j+1;k<n;k++)if(i&(1<<k))
				g[i] = (ll)g[i]*(c[j][k]+1)%mod;
		for(int j = n-1;j>= 0;j--)
			if(i&(1<<j)){now = j;break;}
		f[i] = g[i];
		now = i^(1<<now);
		for(int j = now;j;j=(j-1)&now)
			(f[i]+=mod-(ll)g[j]*f[i^j]%mod)%=mod;
	}
	printf("%d\n",f[end-1]);
	return 0;
}
Problem2563

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 1e5+5;
struct E
{int next,to,val;}e[M<<1];
int head[N],tot,w[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
struct data
{
	int id,val;
	bool operator <(const data &s)const
	{
		return val>s.val;
	}
}p[N];
int main()
{
	long long ans = 0;
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]),ans-=w[i];
	int a,b,c;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c),ans-=c;
	}
	for(int i = 1;i<= n;i++)
	{
		p[i].id = i;
		p[i].val = 2*w[i];
		for(int j = head[i];j;j=e[j].next)
			p[i].val+=e[j].val;
	}
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i+=2)
		ans+=p[i].val;
	printf("%lld\n",ans);
	return 0;
}
Problem2588

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 8000005;
typedef long long ll;
struct E
{int next,to;}e[N<<1];
inline int read() 
{
	int f = 1; ll x = 0; char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) f = ch == '-' ? -1 : 1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';
	return f * x;
}
int head[N],tot,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N][20],dep[N],line[N],tail;
int cnt,root[N],ls[M],rs[M];
int sum[M],val[N],pos[N],top,ans;
int getpos(int x)
{
	int l = 1,r = top+1;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void init()
{
	for(int j = 1;j<= 18;j++)
		for(int i = 1;i<=n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 18;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 18;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void update(int &p,int l,int r,int pos,int val,int pre)
{
	p = ++cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)
		update(ls[p],l,mid,pos,val,ls[pre]);
	else
		update(rs[p],mid+1,r,pos,val,rs[pre]);
	//sum[p] = sum[ls[p]]+sum[rs[p]];
}
int a[N],b[N];
void build(int &p,int l,int r)
{
	p = ++cnt;
	if(l==r)return ;
	int mid = (l+r)>>1;
	build(ls[p],l,mid);
	build(rs[p],mid+1,r);
}
void dfs(int x)
{
	update(root[x],1,n,a[x],1,root[fa[x][0]]);
	dep[x] = dep[fa[x][0]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			fa[e[i].to][0] = x;
			dfs(e[i].to);
		}
}
void solve(int x,int y,int k)
{
	int u = getlca(x,y);
	int v = fa[u][0];
	int l = 1,r = n,ret;
	x = root[x],y = root[y],u = root[u],v = root[v];
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(sum[ls[x]]+sum[ls[y]]-sum[ls[u]]-sum[ls[v]]>=k)
		{
			x = ls[x],y = ls[y];
			u = ls[u],v = ls[v];
			r = mid;
		}else
		{
			k-=sum[ls[x]]+sum[ls[y]]-sum[ls[u]]-sum[ls[v]];
			x = rs[x],y = rs[y];
			u = rs[u],v = rs[v];
			l = mid+1;
		}
	}
	ans = b[l];
	printf("%d",ans);
}
int main()
{
	n = read();m = read();
	for(int i = 1;i<= n;i++){a[i] = read();b[i] = a[i];}
	sort(b+1,b+n+1);
	for(int i = 1;i<= n;i++)
		a[i] = lower_bound(b+1,b+n+1,a[i])-b;
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		x = read();y = read();
		add(x,y),add(y,x);
	}
	build(root[0],1,n);
	dfs(1);
	init();
	for(int i = 1;i<= m;i++)
	{
		x = read();y = read();z = read();
		x = x^ans;
		//if(x==y){ans = val[x];printf("%d",ans);}
		solve(x,y,z);
		if(i!=m)printf("\n");
	}
	return 0;
}
Problem2595

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 11;
const int S = 1<<10;
const int INF = 0x3f3f3f3f;
#define f(i,j,s1,s2) f[i][j][s1]+f[i][j][s2]
int f[N][N][S],a[N][N],n,m,K;;
struct Pair{int x,y;};
struct Tele{int x,y,s;};
int dx[4] = {0,0,1,-1};
int dy[4] = {1,-1,0,0};
Tele pre[N][N][S];
queue <Pair>Q;
bool v[N][N];
void spfa(int sta)
{
	while(!Q.empty())
	{
		Pair t = Q.front();
		Q.pop();
		v[t.x][t.y] = false;
		for(int i = 0;i<4;i++)
		{
			int xx = t.x+dx[i],yy = t.y+dy[i];
			if(xx<0||yy<0||xx>n||yy>m)continue;
			if(f[xx][yy][sta]>f[t.x][t.y][sta]+a[xx][yy])
			{
				f[xx][yy][sta] = f[t.x][t.y][sta]+a[xx][yy];
				pre[xx][yy][sta] = (Tele){t.x,t.y,sta};
				if(!v[xx][yy])
				{
					Q.push((Pair){xx,yy});
					v[xx][yy] = true;
				}	
			}
		}
	}
}
bool used[N][N];
void dfs(int x,int y,int sta)
{
	if(x>=INF||pre[x][y][sta].s==0)return ;
	used[x][y] = true;
	Tele t = pre[x][y][sta];
	dfs(t.x,t.y,t.s);
	if(t.x==x&&t.y==y)dfs(x,y,sta-t.s);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&a[i][j]);
			if(!a[i][j])K++;
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			for(int s = 0;s<1<<K;s++)
				f[i][j][s] = pre[i][j][s].x = INF;
	K = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(!a[i][j])
				{f[i][j][1<<K] = 0;K++;}
	for(int sta = 0;sta<1<<K;sta++)
	{
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= m;j++)
			{
				for(int s = sta&(sta-1);s;s = sta&(s-1))
					if(f(i,j,s,sta-s)-a[i][j]<f[i][j][sta])
					{
						f[i][j][sta] = f(i,j,s,sta-s)-a[i][j];
						pre[i][j][sta] = (Tele){i,j,s};
					}
				if(f[i][j][sta]<INF)
					{Q.push((Pair){i,j});v[i][j] = true;}
			}
		spfa(sta);
	}
	int x,y;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(!a[i][j])
				{x = i,y = j;break;}
	dfs(x,y,(1<<K)-1);
	printf("%d\n",f[x][y][(1<<K)-1]);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= m;j++)
		{
			if(!a[i][j])printf("x");
			else if(used[i][j])printf("o");
			else printf("_");
		}
		printf("\n");
	}
	return 0;
}
Problem2599

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int K = 1e6+5;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,t[K];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
bool used[N];
int sum,root,size[N],f[N],n,k;
void get_root(int x,int fa)
{
	size[x] = 1;f[x] = 0;
	for(int i = head[x];i;i =e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int dis[N],dep[N];
int ans = INF;
void get_ans(int x,int fa)
{
	if(dis[x]<=k)ans = min(ans,dep[x]+t[k-dis[x]]);
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		dep[e[i].to] = dep[x]+1;
		dis[e[i].to] = dis[x]+e[i].val;
		get_ans(e[i].to,x);
	}
}
void init(int x,int fa,int opt)
{
	if(dis[x]<=k)
	{
		if(opt)t[dis[x]] = min(t[dis[x]],dep[x]);
		else t[dis[x]] = INF;
	}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			init(e[i].to,x,opt);
}
void work(int x)
{
	used[x] = true,t[0] = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			dep[e[i].to] = 1,dis[e[i].to] = e[i].val;
			get_ans(e[i].to,0);
			init(e[i].to,0,1);
		}
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
			init(e[i].to,0,0);
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			root = 0,sum = size[e[i].to];
			get_root(e[i].to,0);
			work(root);
		}
}
int main()
{
	int x,y,z;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= k;i++)t[i]=n;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		x++,y++;
		add(x,y,z);
	}
	ans = sum = f[0] = n;
	get_root(1,0);
	work(root);
	if(ans<n)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem2600

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
int n,x;
LL p;
LL pos[N];
bool check(int len)
{
	int i,l,r,mid;
	LL now=0;
	l=1,r=len,mid=(l+r)>>1;
	for(i=l;i<mid;i++)now+=(pos[mid]-pos[i]);
	for(i=mid+1;i<=r;i++)now+=(pos[i]-pos[mid]);
	if(now<=p)return true;
	for(;r<n;)
	{
		now-=(pos[mid]-pos[l++]);
		now+=(pos[++r]-pos[mid]);
		mid=(l+r)>>1;
		now+=(pos[mid]-pos[mid-1])*(mid-l);
		now-=(pos[mid]-pos[mid-1])*(r-mid+1);
		if(now<=p)return true;
	}
	return false;
}
int main()
{
	scanf("%d%d%lld",&n,&x,&p);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&pos[i]);
	int L = 0,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(check(mid))L = mid+1;
		else R = mid;
	}
	L--;
	printf("%d\n",L);
	return 0;
}
Problem2618

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 510;
const double eps = 1e-7;
struct Point
{
	double x,y;
	Point(){}
	Point(double x,double y):x(x),y(y){}
	Point operator+(const Point &a)const
	{
		return Point(x+a.x,y+a.y);
	}
	Point operator-(const Point &a)const
	{
		return Point(x-a.x,y-a.y);
	}
	double operator*(const Point &a)const
	{
		return x*a.y-y*a.x;
	}
	Point operator*(const double &s)const
	{
		return Point(x*s,y*s);
	}
	void getp()
	{
		scanf("%lf%lf",&x,&y);
	}
}poi[N];
struct Line
{
	Point p,v;
	double alpha;
	Line(){}
	Line(const Point &a,const Point &b):p(a),v(b-a)
	{
		alpha = atan2(v.y,v.x);
	}
	bool operator<(const Line &a)const
	{
		return alpha<a.alpha;
	}
}line[N];
int n,m,tot,r,h;
Line *q[N];
double ans;
bool on_left(const Point &p,const Line &l)
{
	return (l.p-p)*l.v>=0;
}
Point get_its(const Line &l1,const Line &l2)
{
	Point u = l1.p-l2.p;
	double tmp = (l2.v*u)/(l1.v*l2.v);
	return l1.p+l1.v*tmp;
}
void Get_hpits()
{
	for(int i = 1;i<= tot;i++)
	{
		while(r-h>=2&& !on_left(get_its(*q[r],*q[r-1]),line[i]))
			q[r--]=NULL;
		if(r-h>=1&&fabs(line[i].v*q[r]->v)<=0)
			q[r] = on_left(line[i].p,*q[r])?&line[i]:q[r];
		else q[++r]=&line[i];
	}
	while(true)
	{
		if(r-h>=2&& !on_left(get_its(*q[h+1],*q[h+2]),*q[r]))
			q[++h]=NULL;
		else if(r-h>=2&& !on_left(get_its(*q[r],*q[r-1]),*q[h+1]))
			q[r--]=NULL;
		else break;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		Point fir,p1,p2;
		scanf("%d",&m);
		fir.getp();p2 = fir;
		for(int j = 2;j<= m;j++)
		{
			p1 = p2;p2.getp();
			line[++tot]=Line(p1,p2);
		}
		line[++tot] = Line(p2,fir);
	}
	sort(line+1,line+tot+1);
	Get_hpits();
	if(r-h<=2)
		return printf("0.000\n"),0;
	tot = 0;
	for(int i = h+2;i<= r;i++)
		poi[++tot] = get_its(*q[i],*q[i-1]);
	poi[++tot]=get_its(*q[r],*q[h+1]);
	for(int i = 2;i<= tot;i++)
		ans+=poi[i-1]*poi[i];
	ans+=poi[tot]*poi[1];
	printf("%.3lf\n",ans/2.0);
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
const int mod = 51061;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,sum,add,size,times;
	bool rev;
	Splay(int x);
	void push_up();
	void push_down();
	void reverse();
	void Add(int x);
	void Times(int x);
}*null = new Splay(0),*tree[N];
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	val = sum = x;
	if(x)size = 1;else size = 0;
	add = 0;rev = false;times = 1;
}
void Splay :: reverse()
{
	if(this==null)return ;
	swap(ls,rs);
	rev ^= 1;
}
void Splay :: Add(int x)
{
	if(this==null)return ;
	(val+=x)%=mod;
	(sum+=(LL)x*size%mod)%=mod;
	(add+=x)%=mod;
}
void Splay :: Times(int x)
{
	if(this==null)return ;
	times=(LL)times*x%mod;
    val=(LL)val*x%mod;
    add=(LL)add*x%mod;
    sum=(LL)sum*x%mod;
}
void Splay :: push_up()
{
	if(this==null)return ;
	size = ls->size+rs->size+1;
	sum = (ls->sum+rs->sum+val)%mod;
}
void Splay :: push_down()
{
	if(this==null)return ;
	if(this==fa->ls||fa->rs==this)
		fa->push_down();
	if(times^1)
	{
		ls->Times(times);
		rs->Times(times);
		times = 1;
	}
	if(add)
	{
		ls->Add(add);
		rs->Add(add);
		add = 0;
	}if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = false;
	}
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	//y->push_down();
	//x->push_down();
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	//y->push_down();
	//x->push_down();
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	if(x==null)return ;
	x->push_down();
	Splay *y,*z;
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
void link(Splay *x,Splay *y)
{
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	x->fa = null;
	y->ls = null;
	y->push_up();
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
queue<int>Q;
int fa[N];
void bfs(int x)
{
	Q.push(x);
	while(!Q.empty())
	{
		int t = Q.front();
		Q.pop();
		tree[t] = new Splay(1);
		if(fa[t])
			tree[t]->fa=tree[fa[t]];
		for(int i = head[t];i;i = e[i].next)
		{
			if(e[i].to==fa[t])continue;
			Q.push(e[i].to);
			fa[e[i].to] = t;
		}
	}
}
int main()
{
	int n,q,x,y,a,b,c;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	bfs(1);
	char opt[3];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='+')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			tree[y]->Add(c);
		}else if(opt[0]=='-')
		{
			scanf("%d%d%d%d",&x,&y,&a,&b);
			cut(tree[x],tree[y]);
			link(tree[a],tree[b]);
		}else if(opt[0]=='*')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			tree[y]->Times(c);
		}else
		{
			scanf("%d%d",&x,&y);
			move_to_root(tree[x]);
			access(tree[y]);
			splay(tree[y]);
			printf("%d\n",tree[y]->sum);
		}
	}
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 51061;
int son[N][2],fa[N],val[N],add[N],mul[N],size[N],sum[N];
bool rev[N];
bool is_root(int p)
{
	return son[fa[p]][0]!=p&&son[fa[p]][1]!=p;
}
void init(int p,int v = 0)
{
	son[p][0]=son[p][1]=fa[p]=0;
	val[p] = sum[p] = v;
	add[p] = 0,mul[p] = 1;
}
void Add(int p,int a)
{
	if(!p)return ;
	sum[p] = (sum[p]+(ll)size[p]*a%mod)%mod;
	add[p] = (add[p]+a)%mod;
	val[p] = (val[p]+a)%mod;
}
void reverse(int p)
{
	rev[p]^=1;
	swap(son[p][0],son[p][1]);	
}
void Multi(int p,int m)
{
	if(!p)return ;
	sum[p] = (ll)sum[p]*m%mod;
	val[p] = (ll)val[p]*m%mod;
	add[p] = (ll)add[p]*m%mod;
	mul[p] = (ll)mul[p]*m%mod;
}
void Push_up(int p)
{
	if(!p)return ;
	size[p] = size[son[p][0]]+size[son[p][1]]+1;
	sum[p] = (sum[son[p][0]]+sum[son[p][1]]+val[p])%mod;
}
void Push_down(int p)
{
	if(!is_root(p))
		Push_down(fa[p]);
	if(mul[p]^1)
	{
		Multi(son[p][0],mul[p]);
		Multi(son[p][1],mul[p]);
		mul[p] = 1;
	}
	if(add[p])
	{
		Add(son[p][0],add[p]);
		Add(son[p][1],add[p]);
		add[p] = 0;
	}
	if(rev[p])
	{
		reverse(son[p][0]),reverse(son[p][1]);
		rev[p] = false;
	}
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(son[z][0]==y)son[z][0] = x;
		else son[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[son[x][d^1]] = y;
	son[y][d] = son[x][d^1],son[x][d^1] = y;
	Push_up(y);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)^(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		son[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;
	son[y][0] = 0;
	Push_up(y);
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void adde(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
queue<int>Q;
int father[N];
void bfs(int rt)
{
	Q.push(rt);
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		fa[x] = father[x];
		for(int i = head[x];i;i=e[i].next)
			if(father[x]!=e[i].to)
			{
				Q.push(e[i].to);
				father[e[i].to] = x;
			}
	}
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	int u,v;
	for(int i = 1;i<= n;i++)init(i,1);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		adde(u,v);
	}
	bfs(1);
	char opt[3];
	int x,y,a,b,c;
	while(q--)
	{
		scanf("%s",opt);
		if(opt[0]=='+')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(x);
			access(y);splay(y);
			Add(y,c);
		}else if(opt[0]=='-')
		{
			scanf("%d%d%d%d",&x,&y,&a,&b);
			cut(x,y);
			link(a,b);
		}else if(opt[0]=='*')
		{
			scanf("%d%d%d",&x,&y,&c);
			move_to_root(x);
			access(y),splay(y);
			Multi(y,c);
		}else
		{
			scanf("%d%d",&x,&y);
			move_to_root(x);
			access(y),splay(y);
			printf("%d\n",sum[y]);
		}
	}
	return 0;
}
Problem2631

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 51061;
int ch[N][2],add[N],mul[N],size[N],fa[N],val[N],sum[N];
bool rev[N];
bool is_root(int p)
{
	return ch[fa[p]][0]!=p&&ch[fa[p]][1]!=p;
}
void init(int p,int v)
{
	ch[p][0]=ch[p][1]=fa[p]=0;
	size[p]=1;
	mul[p] = 1,add[p]=0,rev[p]=false;
	sum[p]=val[p]=v;
}
void Multiply(int p,int c)
{
	if(!p)return ;
	mul[p] = (ll)mul[p]*c%mod;
	sum[p] = (ll)sum[p]*c%mod;
	val[p] = (ll)val[p]*c%mod;
	add[p] = (ll)add[p]*c%mod;
}
void Add(int p,int c)
{
	if(!p)return ;
	(add[p]+=c)%=mod;
	(val[p]+=c)%=mod;
	(sum[p]+=(ll)size[p]*c%mod)%=mod;
}
void Reverse(int p)
{
	rev[p]^=1;
	swap(ch[p][0],ch[p][1]);
}
void Push_down(int p)
{
	if(!is_root(p))Push_down(fa[p]);
	if(mul[p]!=1)
	{
		Multiply(ch[p][0],mul[p]);
		Multiply(ch[p][1],mul[p]);
		mul[p] = 1;
	}
	if(add[p])
	{
		Add(ch[p][0],add[p]);
		Add(ch[p][1],add[p]);
		add[p] = 0;
	}
	if(rev[p])
	{
		Reverse(ch[p][0]);
		Reverse(ch[p][1]);
		rev[p] = false;
	}
}
void Push_up(int p)
{
	if(!p)return ;
	size[p] = size[ch[p][0]]+1+size[ch[p][1]];
	sum[p] = (sum[ch[p][0]]+val[p]+sum[ch[p][1]])%mod;
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		if(ch[z][1]==y)ch[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y),Push_up(x);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[y][0]==x)^(ch[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	Reverse(x);
}
void Link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void Cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;ch[y][0] = 0;
	Push_up(y);
}
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void adde(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
queue<int>Q;
void bfs()
{
	Q.push(1);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				Q.push(e[i].to);
			}
	}
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)init(i,1);
	int u,v;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&u,&v);
		adde(u,v);
	}
	bfs();
	char opt[3];
    int x,y,a,b,c;
    while(q--)
    {
        scanf("%s",opt);
        if(opt[0]=='+')
        {
            scanf("%d%d%d",&x,&y,&c);
            move_to_root(x);
            access(y);splay(y);
            Add(y,c);
        }else if(opt[0]=='-')
        {
            scanf("%d%d%d%d",&x,&y,&a,&b);
            Cut(x,y);
            Link(a,b);
        }else if(opt[0]=='*')
        {
            scanf("%d%d%d",&x,&y,&c);
            move_to_root(x);
            access(y),splay(y);
            Multiply(y,c);
        }else
        {
            scanf("%d%d",&x,&y);
            move_to_root(x);
            access(y),splay(y);
            printf("%d\n",sum[y]);
        }
    }
	return 0;
}
Problem2654

#include<iostream>
#include<set>
#include<map>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<vector>
#include<queue>
#include<algorithm>
#include<cmath>
#define inf 1000000000
#define pa pair<int,int>
#define ll long long 
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,cnt,tot,ned;
int sumv;
int u[100005],v[100005],w[100005],c[100005];
int fa[100005];
struct edge{
	int u,v,w,c;
}e[100005];
bool operator<(edge a,edge b)
{
	return a.w==b.w?a.c<b.c:a.w<b.w;
}
int find(int x)
{
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
bool check(int x)
{
	tot=cnt=0;
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		e[i].u=u[i],e[i].v=v[i],e[i].w=w[i];e[i].c=c[i];
		if(!c[i])e[i].w+=x;
	}
	sort(e+1,e+m+1);
	for(int i=1;i<=m;i++)
	{
		int p=find(e[i].u),q=find(e[i].v);
		if(p!=q)
		{
			fa[p]=q;
			tot+=e[i].w;
			if(!e[i].c)cnt++;
		}
	}
	return cnt>=ned;
}
int main()
{
	n=read();m=read();ned=read();
	for(int i=1;i<=m;i++)
	{
		u[i]=read(),v[i]=read(),w[i]=read(),c[i]=read();
		u[i]++;v[i]++;
	}
	int l=-105,r=105;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))l=mid+1,sumv=tot-ned*mid;
		else r=mid-1;
	}
	printf("%d",sumv);
	return 0;
}
Problem2657

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
int cnt;
struct E
{int x,y,id;}edge[N<<2];
void insert(int a,int b,int i)
{
	edge[++cnt].x = a;
	edge[cnt].y = b;
	edge[cnt].id = i; 
}
bool cmp(E a,E b)
{
	if(a.x!=b.x)
		return a.x<b.x;
	return a.y<b.y;
}
struct Edge
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int max_dep,end;
void dfs(int x,int fa,int dep)
{
	if(dep>max_dep)
	{
		max_dep = dep;
		end = x;
	}
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,dep+1);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n-2;i++)
	{
		int a[4];
		scanf("%d%d%d",&a[1],&a[2],&a[3]);
		sort(a+1,a+4);
		insert(a[1],a[2],i);insert(a[1],a[3],i);insert(a[2],a[3],i);
	}
	sort(edge+1,edge+cnt+1,cmp);
	for(int i = 2;i<= cnt;i++)
		if(edge[i].x==edge[i-1].x&&edge[i].y==edge[i-1].y)add(edge[i].id,edge[i-1].id);
	dfs(1,0,1);
	dfs(end,0,1);
	printf("%d\n",max_dep);
	return 0;
}
Problem2671

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int mu[N],prime[N],cnt;
bool v[N];
ll n,stack[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
		{
			mu[i] = -1;
			prime[++cnt] = i;
		}
		for(int j=1;j<= cnt&&i*prime[j]<N;j++)
		{
			v[prime[j]*i]=true;
			if(i%prime[j])mu[i*prime[j]]=-mu[i];
			else 
			{
				mu[i*prime[j]]=0;
				break;
			}
		}
	}
}
void get_fac(ll x)
{
	stack[0]=0;
	for(ll i = 1;i*i<=x;i++)
		if(x%i==0)
		{
			stack[++stack[0]] = i;
			if(i*i!=x)stack[++stack[0]]=x/i;
		}
	sort(stack+1,stack+stack[0]+1);
}
ll calc()
{
	ll a,b,k,last,ans=0;
	for(b=1;b*(b+1)<=n;b++)
	{
		get_fac(b);
		for(a=1;a<b&&b*(a+b)<=n;a=last+1)
		{
			last=min(n/(n/b/(a+b))/b-b,b-1);
			ll cnt = 0;
			for(k=1;stack[k]<=last;k++)
				cnt+=(ll)mu[stack[k]]*(last/stack[k]-(a-1)/stack[k]);
			ans+=n/b/(a+b)*cnt;
		}
	}
	return ans;
}
int main()
{
	scanf("%lld",&n);
	quick_mu();
	printf("%lld\n",calc());
	return 0;
}
Problem2683

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 500005;
struct P
{int x,y,num,opt,no;}p[N<<2],np[N<<2];
int ans[N];
bool cmp(const P &a,const P &b)
{
	if(a.x==b.x)
	{
		if(a.y==b.y)return a.no<b.no;
		return a.y<b.y;
	}
	return a.x<b.x;
}
int c[M];
void update(int x,int y)
{
	for(int i = x;i<M;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void clear(int x)
{
	for(int i = x;i<M;i+=i&(-i))
		c[i] = 0;
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)return ;
	for(int i = l;i<= r;i++)
	{
		if(p[i].no<=mid&&p[i].opt==0)
			update(p[i].y,p[i].num);
		else if(p[i].no>mid&&p[i].opt!=0)
		{
			ans[p[i].num]+=p[i].opt*getans(p[i].y);
		}
	}
	for(int i = l;i<=r;i++)
		if(p[i].no<=mid&&p[i].opt==0)
			update(p[i].y,-p[i].num);
	int t1 = l,t2 = mid+1;
	for(int i = l;i<= r;i++)
		if(p[i].no<=mid)np[t1++] = p[i];
		else np[t2++] = p[i];
	for(int i = l;i<= r;i++)
		p[i]=np[i];
	CDQ(l,mid);CDQ(mid+1,r);
}
int main()
{
	int n,opt,x,y,a,b,cnt = 0,ask = 0;
	scanf("%d",&n);
	while(scanf("%d",&opt))
	{
		if(opt==3)break;
		else if(opt==1)
		{
			scanf("%d%d%d",&x,&y,&a);
			++cnt;p[cnt] = (P){x,y,a,0,cnt};
		}else
		{
			ask++;
			scanf("%d%d%d%d",&x,&y,&a,&b);
			++cnt;p[cnt] = (P){a,b,ask,1,cnt};
			if(y!=1){++cnt;p[cnt] = (P){a,y-1,ask,-1,cnt};}
			if(x!=1){++cnt;p[cnt] = (P){x-1,b,ask,-1,cnt};}
			if(x!=1&&y!=1){++cnt;p[cnt] = (P){x-1,y-1,ask,1,cnt};}
		}
	}
	sort(p+1,p+cnt+1,cmp);
	CDQ(1,cnt);
	for(int i=1;i<= ask;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem2687

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
const int N = 1e6+5;
typedef long long ll;
using namespace std;
struct aa{int l, r;}a[N], b[N];
int n, now, mxp, l, flag[N];
ll ans;
bool cmp(aa a, aa b)
{
    if(a.l!=b.l)return a.l<b.l;
    return a.r>b.r;
}
ll get(int i, int j)
{
    if(b[i].r<b[j].l)return 0;
    return (ll)(b[i].r-b[j].l+1)*(b[j].r-b[i].l+1);
}
int main()
{
    scanf("%d",&n);
    for(int i=1; i<=n; i++)
    {
    	scanf("%d%d",&a[i].l,&a[i].r);
    	a[i].r--;
    }
    sort(a+1, a+1+n, cmp);
    now=mxp=ans=0;
    for(int i=1; i<=n; i++)
    {
        if(a[i].r<=now)
        {
            flag[i]=mxp;
            ans=max(ans, (ll)(a[i].r-a[i].l+1)*(a[mxp].r-a[mxp].l+1));
        }
        else flag[i]=0;
        if(now<a[i].r){now=a[i].r; mxp=i;}
    }
    l=0;
    for(int i=1; i<=n; i++)if(!flag[i])b[++l]=a[i];
    now=2;
    for(int i=1; i<=l-1; i++)
    {
        if(now==i)now++;
        while(now<=l-1&&get(i, now)<get(i, now+1))now++;
        ans=max(ans, get(i, now));
    }
    printf("%lld", ans);
    return 0;
}
Problem2705

#include<stdio.h>
#include<math.h>
typedef long long LL;
int main()
{
	 LL n;
	 while(scanf("%lld",&n)!=EOF)
	 {
	 	LL ans = n,tmp,q,cnt;
	 	tmp = (int)sqrt(n);
	 	for(int i = 2;i<= tmp;i++)
	 	{
	 		if(n%i==0)
	 		{
	 			cnt = 0;
	 			q = i;
	 			while(n%q==0)
	 			{
	 				cnt++;
	 				n = n/q;
	 			}
	 			ans = ans+ans*cnt*(q-1)/q;
	 		}
	 	}
	 	if(n!=1) ans = ans+ans*(n-1)/n;
	 	printf("%lld\n",ans);
	 }
	 return 0;
}
Problem2708

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
int a[55],f[55];
int calc(int x,int y)
{
	for(int k = 1;k<= y-x+1;k++)
	{
		for(int j = x;j<= y-k;j++)
			if(abs(a[j]-a[j+k])>1)return k-1;
		if(abs(a[x+k-1]-a[y-k+1])<=1)return k-1;
	}
	return y-x+1;
}
int main()
{
	int n;
	while(scanf("%d",&n)!=EOF)
	{
		for(int i = 1;i<= n;i++)
			scanf("%d",&a[i]);
		sort(a+1,a+n+1);
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
			for(int j = 0;j<i;j++)
				f[i] = max(f[i],f[j]+calc(j+1,i));
		printf("%d\n",f[n]);
	}
	return 0;
}
Problem2716

#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll long long
#define inf 1000000000 
using namespace std;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int n,m,root,D;
struct P{
	int d[2],mn[2],mx[2],l,r;
	int& operator[](int x){return d[x];}
	P(int x=0,int y=0)
		{l=0,r=0;d[0]=x,d[1]=y;}  
}p[500005];
bool operator<(P a,P b)
{
	return a[D]<b[D];
}
inline int dis(P a,P b)
{
	return abs(a[0]-b[0])+abs(a[1]-b[1]);
}
struct kdtree{
	int ans;
	P t[1000005],T;
	void update(int k){
		P l=t[t[k].l],r=t[t[k].r];
		for(int i=0;i<2;i++)
		{
			if(t[k].l)t[k].mn[i]=min(t[k].mn[i],l.mn[i]),t[k].mx[i]=max(t[k].mx[i],l.mx[i]);
			if(t[k].r)t[k].mn[i]=min(t[k].mn[i],r.mn[i]),t[k].mx[i]=max(t[k].mx[i],r.mx[i]);
		}
	}
	int build(int l,int r,int now){
		D=now;
		int mid=(l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid]=p[mid];
		for(int i=0;i<2;i++)
			t[mid].mn[i]=t[mid].mx[i]=t[mid][i];
		if(l<mid)t[mid].l=build(l,mid-1,now^1);
		if(r>mid)t[mid].r=build(mid+1,r,now^1);
		update(mid);
		return mid;
	}
	int get(int k,P p){
		int tmp=0;
		for(int i=0;i<2;i++)
			tmp+=max(0,t[k].mn[i]-p[i]);
		for(int i=0;i<2;i++)
			tmp+=max(0,p[i]-t[k].mx[i]);
		return tmp;
	}
	void insert(int k,int now){
		if(T[now]>=t[k][now])
		{
			if(t[k].r)insert(t[k].r,now^1);
			else 
			{
				t[k].r=++n;t[n]=T;
				for(int i=0;i<2;i++)
					t[n].mn[i]=t[n].mx[i]=t[n][i];
			}
		}
		else 
		{
			if(t[k].l)insert(t[k].l,now^1);
			else 
			{
				t[k].l=++n;t[n]=T;
				for(int i=0;i<2;i++)
					t[n].mn[i]=t[n].mx[i]=t[n][i];
			}
		}
		update(k);
	}
	void query(int k,int now){
		int d,dl=inf,dr=inf;
		d=dis(t[k],T);
		ans=min(ans,d);
		if(t[k].l)dl=get(t[k].l,T);
		if(t[k].r)dr=get(t[k].r,T);
		if(dl<dr)
		{
			if(dl<ans)query(t[k].l,now^1);
			if(dr<ans)query(t[k].r,now^1);
		}
		else
		{
			if(dr<ans)query(t[k].r,now^1);
			if(dl<ans)query(t[k].l,now^1);
		}
	}
	int query(P p){
		ans=inf;T=p;query(root,0);
		return ans;
	}
	void insert(P p){
		T=p;insert(root,0);
	}
}kd;
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)p[i][0]=read(),p[i][1]=read();
	root=kd.build(1,n,0);
	while(m--)
	{
		int opt=read(),x=read(),y=read();
		if(opt==1)kd.insert(P(x,y));
		else printf("%d\n",kd.query(P(x,y)));
	}
	return 0;
}
Problem2721

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int mod = 1e9+7;
int prime[N],cnt;
bool v[N];
void quick_prime(int n)
{
	for(int i = 2;i<= n;i++)
	{
		if(!v[i])
			prime[++cnt]=i;
		for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	int n;
	long long ans = 1;
	scanf("%d",&n);
	quick_prime(n);
	for(int i = 1;i<= cnt;i++)
	{
		int tmp = n;
		long long cnt = 0;
		while(tmp)
		{
			cnt+=tmp/prime[i];
			tmp/=prime[i];
		}
		cnt = (cnt<<1|1)%mod;
		ans = ans*cnt%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem2730

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1005;
struct E
{int next,to;}e[M];
int head[N],tot = 1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int stack[N],low[N],dfn[N],dcc,cnt,top,m,n;
bool ins[N],v[N];
int bel[N];
int ans1;
long long ans2;
void init()
{
	memset(v,0,sizeof(v));
	memset(head,0,sizeof(head));
	tot = 1,cnt = 0,dcc = 0,top = 0,n = 0;
	ans1 = 0;ans2 = 1;
	memset(bel,0,sizeof(bel));
}
void tarjan(int x,int l)
{
	dfn[x] = low[x] = ++cnt;
	//stack[++top] = x;
	v[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(v[e[i].to])low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			if(low[e[i].to]>=dfn[x])
				bel[x]++;
		}
	}
}
void tarjan1(int x,int l)
{
	dfn[x] = low[x] = ++cnt;
	stack[++top] = x;
	ins[x] = v[x] = true;
	int temp,size;
	for(int i = head[x];i;i = e[i].next)
	{
		if(i==(l^1))continue;
		if(v[e[i].to])low[x] = min(low[x],dfn[e[i].to]);
		else
		{
			tarjan1(e[i].to,i);
			low[x] = min(low[x],low[e[i].to]);
			if(low[e[i].to]>=dfn[x])
			{
				temp = size = 0;
				int tmp;
				do
				{
					tmp = stack[top--];
					ins[tmp] = false;
					if(bel[tmp]>=2)
						temp++;
					size++;
				}while(tmp!=e[i].to);
				tmp = x;
				if(bel[tmp]>=2)
					temp++;
				size++;
				if(!temp)
					ans1+=2,ans2*=size*(size-1)/2;
				else if(temp==1) 
					ans1++,ans2*=size-1;
			}
		}
	}
}
int main()
{
	int x,y,T = 0;
	while(scanf("%d",&m)&&m!=0)
	{
		T++;
		init();
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
			n = max(n,max(x,y));
		}
		for(int i = 1;i<= n;i++)
			if(!v[i])
				tarjan(i,-1);
			else bel[i]++;
		memset(v,0,sizeof(v));
		cnt = 0;
		for(int i = 1;i<= n;i++)
			if(!v[i])
				tarjan1(i,-1);
		printf("Case %d: %d %lld\n",T,ans1,ans2);
	}
	return 0;
}
Problem2733

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Q = 300005;
const int N = 100005;
int root[N],ls[N*20],rs[N*20],sum[N*20],num[N],seg;
void update(int &p,int l,int r,int x)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		sum[p] = 1;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(ls[p],l,mid,x);
	else update(rs[p],mid+1,r,x);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int p,int l,int r,int x,int s)
{
	if(!p)return -1;
	if(l==r)
		return l;
	int mid = (l+r)>>1;
	if(sum[ls[p]]+s<x)
		return getans(rs[p],mid+1,r,x,sum[ls[p]]+s);
	else return getans(ls[p],l,mid,x,s);
}
int merge(int x,int y)
{
	if(!x)return y;
	if(!y)return x;
	ls[x] = merge(ls[x],ls[y]);
	rs[x] = merge(rs[x],rs[y]);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
int fa[N],rnk[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else
	{ 
		int tmp = getfa(fa[x]);
		//root[x] = merge(root[tmp],root[x]);
		return fa[x] = tmp;
	}
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx==fy)return ;
	if(rnk[fx]>rnk[fy])
	{
		fa[fy] = fx;
		root[fx] = merge(root[fx],root[fy]);
	}
	else
	{
		fa[fx] = fy,rnk[fy]+=rnk[fx]==rnk[fy];
		root[fy] = merge(root[fy],root[fx]);
	}
}
int imc[N],bri[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&imc[i]);
		bri[imc[i]] = i;
		update(root[i],1,n,imc[i]);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		uni(x,y);
	}
	int q;
	scanf("%d",&q);
	char ju[3];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",ju);
		scanf("%d%d",&x,&y);
		if(ju[0]=='B')uni(x,y);
		else
		{
			int fx = getfa(x);
			int tmp = getans(root[fx],1,n,y,0);
			if(tmp==-1)printf("-1\n");
			else printf("%d\n",bri[tmp]);
		}
	}
	return 0;
}
Problem2734

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int M = 1<<12;
const int INF = 1e8;
const LL mod = 1000000001;
bool v[N];
int a[20][13],b[20],p2[20],n;
int f[20][M];
LL calc(int x)
{
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	a[1][1] = x;
	for(int i = 2;i<= 18;i++)
	{
		if((a[i-1][1]<<1)<=n)
			a[i][1] = a[i-1][1]<<1;
		else a[i][1] = INF;
	}
	for(int i = 1;i<= 18;i++)
		for(int j = 2;j<= 12;j++)
		{
			if(a[i][j-1]*3<=n)
				a[i][j] = a[i][j-1]*3;
			else a[i][j] = INF;
		}
	for(int i = 1;i<= 18;i++)
		for(int j = 1;j<= 12;j++)
			if(a[i][j]<=n)
			{
				v[a[i][j]] = true;
				b[i]+=p2[j-1];
			}
	memset(f,0,sizeof(f));
	f[0][0] = 1;
	for(int i = 1;i<= 18;i++)
		for(int j = 0;j<=b[i-1];j++)
		{
			if(((j<<1)&j)||((j>>1)&j))continue;
			for(int k = 0;k<= b[i];k++)
			{
				if(((k<<1)&k)||((k>>1)&k)||(j&k))continue;
				f[i][k]=(f[i][k]+f[i-1][j])%mod;
			}
		}
	long long ans = 0;
	for(int i = 0;i<=b[18];i++)
		ans = (ans+f[18][i])%mod;
	return ans;
}
int main()
{
	for(int i = 0;i<=18;i++)
		p2[i] = 1<<i;
	scanf("%d",&n);
	LL ans = 1;
	for(int i = 1;i<= n;i++)
		if(!v[i])ans = ans*calc(i)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem2744

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
struct E
{int next,to;}e[N*N>>2];
int head[N],tot=1;
void add(int x,int y)
{
	e[++tot].to =y;
	e[tot].next =head[x];
	head[x]=tot;
}
int res[N],sta[N],ban[N],dfn[N];
int a[N],b[N],A,B,m,n,ans,T1,T2;
bool map[N][N];
int cnt(int x)
{
	int ans = 0;
	while(x)
		x-=x&(-x),ans++;
	return ans;
}
bool get_partner(int x)
{
	if(ban[x]==T1)return false;
	for(int i = head[x];i;i=e[i].next)
		if(ban[e[i].to]!=T1&&sta[e[i].to]!=T2)
		{
			sta[e[i].to]=T2;
			if(!res[e[i].to]||dfn[e[i].to]!=T1||get_partner(res[e[i].to]))
			{
				dfn[e[i].to]=T1;
				res[e[i].to]=x;
				return true;
			}
		}
	return false;
}
int getans(int x=0,int y=0)
{
	T1++;
	int ans = 0;
	for(int i = 1;i<= B;i++)
		if(map[x][i]||map[y][i])
			ban[i]=T1,ans++;
	for(int i = 1;i<= B;i++)
		if(b[i]&1)
		{
			++T2;
			if(get_partner(i))
				ans++;
		}
	return B-ans;
}
int main()
{
	scanf("%d%d%d",&A,&B,&m);
	for(int i = 1;i<= A;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= B;i++)scanf("%d",&b[i]);
	memset(map,true,sizeof(map));
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		map[x][y]=false;
	}
	for(int i = 1;i<= B;i++)
		if(b[i]&1)
			for(int j = 1;j<= B;j++)
				if(~b[j]&1)
					if(~cnt(b[i]|b[j])&1)
						add(i,j);
	int ans;
	for(int i = 1;i<=B;i++)map[0][i]=0;
	ans=getans();
	for(int i = 1;i<=A;i++)
		ans=max(ans,getans(i)+1);
	for(int i = 1;i<= A;i++)
		if(a[i]&1)
			for(int j = 1;j<= A;j++)
				if(~a[j]&1)
					ans = max(ans,getans(i,j)+2);
	printf("%d\n",ans);
	return 0;
}
Problem2754

#include <stdio.h>
#include <map>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int s[N];
vector<int>a[20005],st[N],V,M;
bool vis[N],mark[N];
int ans1[N],ans2[N];
struct AC_Machine
{
	map<int,int>ch[N];
	int fail[N];bool end[N];
	int cnt,q[N],h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i=-1;i<=10000;i++)
            ch[0][i]=1;
        fail[1]=0;
	}
	void insert(int len,int id)
	{
		int now = 1;
		for(int i = 1;i<=len;i++)
		{
			if(!ch[now][s[i]])ch[now][s[i]]=++cnt;
			now = ch[now][s[i]];
		}
		st[now].push_back(id);
	}
	void build()
	{
		h = 0,t = -1;
		q[++t]=1,fail[0] =1;
		while(h<=t)
		{
			int x = q[h++];
			map<int,int>::iterator it;
			for(it=ch[x].begin();it!=ch[x].end();it++)
			{
				int i = it->first;
				int to = it->second;
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[to] = ch[k][i];
				q[++t]=to;
			}
		}
	}
	void get(int id,int x)
	{
		for(int i = x;i;i=fail[i])
			if(!vis[i])
			{
				vis[i] = true;V.push_back(i);
				for(int j= 0;j<st[i].size();j++)
					if(!mark[st[i][j]])
					{
						mark[st[i][j]]=true;
						M.push_back(st[i][j]);
						ans1[st[i][j]]++;
						ans2[id]++;
					}
			}
			else break;
	}
	void solve(int x)
	{
		int now = 1;
		int sz = a[x].size();
		for(int i = 0;i<sz;i++)
		{
			int t = a[x][i];
			while(!ch[now][t])now = fail[now];
			now = ch[now][t],get(x,now);
		}
		for(int i= 0;i<V.size();i++)vis[V[i]] = false;
		for(int i= 0;i<M.size();i++)mark[M[i]] = false;
		V.clear();M.clear();
	}
}AC;
int main()
{
	int n,m,l;
	scanf("%d%d",&n,&m);
	for(int i= 1;i<= n;i++)
	{
		int x;
		scanf("%d",&l);
		for(int j = 1;j<= l;j++)
		{
			scanf("%d",&x);
			a[i].push_back(x);
		}
		a[i].push_back(-1);
		scanf("%d",&l);
		for(int j = 1;j<= l;j++)
		{
			scanf("%d",&x);
			a[i].push_back(x);
		}
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&l);
		for(int k =1;k<= l;k++)
			scanf("%d",&s[k]);
		AC.insert(l,i);
	}
	AC.build();
	for(int i= 1;i<= n;i++)
		AC.solve(i);
	for(int i = 1;i<= m;i++)printf("%d\n",ans1[i]);
	for(int i = 1;i<= n;i++)
	{
		printf("%d",ans2[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem2759

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
struct data
{
	int k,b;
	data(int _k=1,int _b=0):k(_k%mod),b(_b%mod){}
	data operator +(const data &s)const
	{
		data res;
		res.k = k*s.k%mod;
		res.b = (b*s.k+s.b)%mod;
		return res;
	}
	int cal(int x){x%=mod;return (k*x+b)%mod;}
};
void ex_gcd(int a,int b,int &x,int &y)
{
	if(!b)y=0,x=1;
	else
	{
		ex_gcd(b,a%b,y,x);
		y-=a/b*x;
	}
}
const int N = 6e4+5;
int ch[N][2],fa[N],sp_fa[N],size[N];
data sum[N],val[N];
bool vis[N],ins[N];
void dfs(int x)
{
	ins[x] = vis[x] = true;
	int v = fa[x];
	if(ins[v])
	{
		sp_fa[x] = v;
		fa[x] = 0;
	}
	if(!vis[v])dfs(v);
	ins[x] = false;
}
bool is_root(int x)
{
	return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;
}
void Push_up(int x)
{
	sum[x] = sum[ch[x][0]]+val[x]+sum[ch[x][1]];
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		else ch[z][1] = x;
	}
	fa[y] = x;fa[x] = z;fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y);
}
void splay(int x)
{
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[y][0]==ch[x][0])^(ch[z][0]==ch[y][0]))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
int Find_root(int x)
{
	access(x);
	splay(x);
	int rot = x;
	while(ch[rot][0])rot = ch[rot][0];
	splay(rot);return rot;
}
int Getans(int x)
{
	access(x);
	splay(x);
	data v1 = sum[x];
	int rot = Find_root(x),f = sp_fa[rot];
	access(f);splay(f);
	data v2 = sum[f];
	if(v2.k==1)return v2.b?-1:-2;
	if(v2.k==0)return v1.cal(v2.b);
	int X,Y;
	ex_gcd(v2.k-1,mod,X,Y);
	int tmp = (mod-X)%mod*v2.b%mod;
	return v1.cal(tmp);
}
void Cut(int x)
{
	access(x);
	splay(x);
	fa[ch[x][0]] = 0;
	ch[x][0] = 0;
	Push_up(x);
}
void Link(int x,int y)
{
	access(x);splay(x);
	fa[x] = y;
}
bool in_circle(int x,int rot)
{
	int f = sp_fa[rot];
	if(x==f)return true;
	access(f);
	splay(f);splay(x);
	return !is_root(f);
}
void update(int u,int f,int k,int b)
{
    access(u);
    splay(u);
    val[u]=data(k,b);
    Push_up(u);
    int ro=Find_root(u);
    if(u==ro)
    {
        int rf=Find_root(f);
        if(rf==ro)sp_fa[u]=f;
        else
        {
            sp_fa[u]=0;
            Link(u,f);
        }
    }else
    {
        if(in_circle(u,ro))
        {
            Cut(u);
            Link(ro,sp_fa[ro]);
            sp_fa[ro]=0;
            int rf=Find_root(f);
            if(rf==u)sp_fa[u]=f;
            else Link(u,f);
        }else
        {
            Cut(u);
            int rf=Find_root(f);
            if(rf==u)sp_fa[u]=f;
            else Link(u,f);
        }   
    }
}
int main()
{
	int n,k,b;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&k,&fa[i],&b);
		val[i] = sum[i] = data(k,b);
	}
	for(int i = 1;i<= n;i++)if(!vis[i])dfs(i);
	int q,x,f;
	char opt[3];
	scanf("%d",&q);
	while(q--)
	{
		scanf("%s%d",opt,&x);
		if(opt[0]=='A')printf("%d\n",Getans(x));
		else
		{
			scanf("%d%d%d",&k,&f,&b);
			update(x,f,k,b);
		}
	}
	return 0;
}
Problem2780

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int id[N],Dfn,in[N],out[N];
int c[N];
struct E
{int next,to;};
struct Gragh
{
	E e[N];
	int head[N],tot;
	void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
	void dfs(int x)
	{
		id[++Dfn] = x;
		in[x] = Dfn;
		for(int i = head[x];i;i=e[i].next)
			dfs(e[i].to);
		out[x] = Dfn;
	}
}g1,g2;
int trs[N][26],len[N],fa[N],lastins[N],ans[N];
int cnt,last;
int insert(int x)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	return last;
}
void init(){last=cnt=1;}
void build()
{
	for(int i = 1;i<= cnt;i++)
		g1.add(fa[i],i);
	g1.dfs(1);
}
struct Ask
{
	int l,r,no;
	bool operator<(const Ask &S)const
	{
		return r<S.r;
	}
}ask[N];
void update(int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
char s[360005];
int main()
{
	int n,q;
	init();
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1);
		last = 1;
		for(int j = 1;j<= l;j++)
		{
			int tmp = insert(s[j]-'a');
			g2.add(tmp,i);
		}
	}
	build();
	for(int i = 1;i<= q;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1),p=1;
		bool find = true;
		for(int j=1;j<=l;j++)
			if(!trs[p][s[j]-'a']){find = false;break;}
			else p = trs[p][s[j]-'a'];
		if(find)
			ask[i] = (Ask){in[p],out[p],i};
		else ask[i] = (Ask){-1,-1,i};
	}
	sort(ask+1,ask+q+1);
	int noww;
	int k=1;
	while(k<=q&&ask[k].l==-1)
		k++;
	for(int i=1;i<=cnt;i++)
	{
		for(int j=g2.head[id[i]];j;j=g2.e[j].next)
		{
			noww=g2.e[j].to;
			update(i,1);
			if(lastins[noww])
				update(lastins[noww],-1);
			lastins[noww]=i;
		}
		for(;ask[k].r==i;k++)
			ans[ask[k].no]=getans(ask[k].r)-getans(ask[k].l-1);
	}
	for(int i = 1;i<= q;i++)printf("%d\n",ans[i]);
	return 0;
}
Problem2783

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,a[N],sum[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int line[N],h,t,cnt,n,s;
multiset<int>Q;
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		sum[e[i].to] = sum[x]+a[e[i].to];
		if(Q.find(sum[e[i].to]-s)!=Q.end())cnt++;
		Q.insert(sum[e[i].to]);
		dfs(e[i].to);
		Q.erase(Q.find(sum[e[i].to]));
	}
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	Q.insert(0);
	sum[1] = a[1];
	Q.insert(sum[1]);
	dfs(1);
	printf("%d\n",cnt);
	return 0;
}
Problem2788

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 605;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool ins[N],v[N];
int dep[N],low[N],stack[N],dfn,top,bel[N],scc;
int map[N][N];
void tarjan(int x)
{
	v[x] = ins[x] = true;
	stack[++top] = x;
	dep[x] = low[x] = ++dfn;
	for(int i = head[x];i;i = e[i].next)
	{
		if(!v[e[i].to])
			{tarjan(e[i].to);low[x] = min(low[e[i].to],low[x]);}
		else if(ins[e[i].to])
			{low[x] = min(low[x],dep[e[i].to]);}
	}
	if(dep[x]==low[x])
	{
		scc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] =false;
			bel[tmp] = scc;
		}while(tmp!=x);
	}
}
int main()
{
	int n,m1,m2;
	scanf("%d%d%d",&n,&m1,&m2);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			map[i][j] = -INF;
	for(int i = 1;i<= n;i++)map[i][i] = 0;
	int x,y;
	for(int i = 1;i<= m1;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,1),add(y,x,-1);
		map[x][y] = max(map[x][y],1);
		map[y][x] = max(map[y][x],-1);
	}
	for(int i = 1;i<= m2;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,0);
		map[x][y] = max(map[x][y],0);
	}
	for(int i = 1;i<= n;i++)
		if(!v[i])
			tarjan(i);
	int t_ans = 0;
	for(int t = 1;t<= scc;t++)
	{
		for(int k = 1;k<= n;k++)
		{
			if(bel[k]!=t)continue;
			for(int i = 1;i<= n;i++)
			{
				if(bel[i]!=t||map[i][k]==-INF)continue;
				for(int j = 1;j<= n;j++)
				{
					if(bel[j]!=t||map[k][j]==-INF)continue;
					map[i][j] = max(map[i][j],map[i][k]+map[k][j]);
				}
			}
		}
		int ans = 0;
		for(int i = 1;i<= n;i++)
			if(bel[i]==t)
				for(int j = 1;j<= n;j++)
					if(bel[j]==t)
						ans = max(ans,abs(map[i][j]));
		t_ans += ans+1;
	}
	for(int i = 1;i<= n;i++)
		if(map[i][i])
		{
			printf("NIE\n");
			return 0;
		}
	printf("%d\n",t_ans);
	return 0;
}
Problem2789

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int last[30],next[N],val[N],c[N];
char s1[N],s2[N];
queue <int>Q[30];
void update(int x,int t)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=t;
}
int getans(int x)
{
	int sum = 0;
	for(int i = x;i>0;i-=i&(-i))
		sum+=c[i];
	return sum;
}
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s1+1);
	scanf("%s",s2+1);
	for(int i = 1;i<= n;i++)
		Q[s1[i]-'A'].push(i);
	for(int i = 1;i<= n;i++)
	{
		val[i] = Q[s2[i]-'A'].front();
		Q[s2[i]-'A'].pop();
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans+=getans(n)-getans(val[i]);
		update(val[i],1);
	}
	printf("%lld",ans);
	return 0;
}
Problem2790

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
int f[M],a[N],pre[M],sec[M];
int prime[N],cnt,v[M];
void init(int x)
{
	for(int i = 2;i<= x;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			f[i] = 1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<= x;j++)
		{
			v[prime[j]*i]= true;
			f[i*prime[j]] = f[i]+1;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	//freopen("odl.in","r",stdin);
	//freopen("odl.out","w",stdout);
	f[0] = INF;
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	init(1000000);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j*j<= a[i];j++)
		{
			if(a[i]%j==0)
			{
				if(f[a[i]]<f[a[pre[j]]])sec[j] = pre[j],pre[j] = i;
				else if(f[a[i]]<f[a[sec[j]]])sec[j] = i;
				if(f[a[i]]<f[a[pre[a[i]/j]]])sec[a[i]/j] = pre[a[i]/j],pre[a[i]/j] = i;
				else if(f[a[i]]<f[a[sec[a[i]/j]]]&&pre[a[i]/j]!=i)sec[a[i]/j] = i;
			}
		}
	}
	
	for(int i = 1;i<= n;i++)
	{
		int ans1 = 0x3f3f3f3f,ans2 = 0;
		for(int j = 1;j*j<= a[i];j++)
		{
			if(a[i]%j==0)
			{
				if(pre[j]&&sec[j]&&f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]]<ans1)
				{
					ans1 = f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]];
					ans2 = pre[j]==i?sec[j]:pre[j];
				}else if(f[a[i]]-2*f[j]+f[a[pre[j]==i?sec[j]:pre[j]]]==ans1)
					ans2 = min(ans2,pre[j]==i?sec[j]:pre[j]);
				if(pre[a[i]/j]&&sec[a[i]/j]&&f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]]<ans1)
				{
					ans1 = f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]];
					ans2 = pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j];
				}else if(f[a[i]]-2*f[a[i]/j]+f[a[pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]]]==ans1)
					ans2 = min(ans2,pre[a[i]/j]==i?sec[a[i]/j]:pre[a[i]/j]);
			}
		}
		printf("%d\n",ans2);
	}
	return 0;
}
Problem2791

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
int fa[N][20];
int a[N],on_ring[N],v[N],pos[N],size[N],root[N],dep[N],n;
void dfs(int x,int id)
{
	v[x] = id;
	if(v[a[x]]==v[x])
	{
		int tmp = 1;
		for(int i = x;i!=x||tmp==1;i = a[i],tmp++)
			on_ring[i] = id,pos[i] = tmp,root[i] = i;
		size[id] = --tmp;
		return ;
	}
	if(!v[a[x]])
		dfs(a[x],id);
	if(!on_ring[x])
	{
		fa[x][0] = a[x];
		dep[x] = dep[a[x]]+1;
		root[x] = root[a[x]];
	}
}
void init()
{
	for(int j = 1;j<= 19;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 19;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 19;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int dist(int x,int y,int p)
{
	return (y-x+p)%p;
}
void solve(int x,int y)
{
	if(on_ring[root[x]]!=on_ring[root[y]])
	{
		printf("-1 -1\n");
		return ;
	}
	if(root[x]==root[y])
	{
		int lca = getlca(x,y);
		printf("%d %d\n",dep[x]-dep[lca],dep[y]-dep[lca]);
		return ;
	}
	int fx = root[x],fy = root[y];
	int x1=dep[x]+dist(pos[fx],pos[fy],size[on_ring[fx]]),y1=dep[y];
	int x2=dep[x],y2=dep[y]+dist(pos[fy],pos[fx],size[on_ring[fy]]);
	if(max(x1,y1)!=max(x2,y2))
	{
		if(max(x1,y1)<max(x2,y2))printf("%d %d\n",x1,y1);
		else printf("%d %d\n",x2,y2);
		return ;
	}
	if(min(x1,y1)!=min(x2,y2))
	{
		if(min(x1,y1)<min(x2,y2))printf("%d %d\n",x1,y1);
		else printf("%d %d\n",x2,y2);
		return ;
	}
	printf("%d %d\n",max(x1,y1),min(x1,y1));
}
int main()
{
	int q,x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int rings = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i])
		{
			rings++;
			dfs(i,rings);
		}
	init();
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&x,&y);
		solve(x,y);
	}
	return 0;
}
Problem2792

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 1e6+5;
int x[M];
int c[M];
long long l[M],r[M];
int n;
LL m;
int check(int p)
{
	memcpy(c,x,sizeof(x));
	memset(l,0,sizeof(l));
	memset(r,0,sizeof(r));
	LL tot = 0;
	for(int i = 1;i<= n-1;i++)
		if(c[i+1]-c[i]>=p)
		{
			tot+=c[i+1]-c[i]-p;
			c[i+1] = c[i]+p;
		}
	//if(c[1]>c[2]+p){tot+=c[1]-c[2]-p;c[1] = c[2]+p;}
	if(tot>m)return -1;
	for(int i = n;i>= 2;i--)
		if(c[i-1]-c[i]>=p)
		{
			tot+=c[i-1]-c[i]-p;
			c[i-1] = c[i]+p;
		}
	//if(c[n]>c[n-1]+p){tot+=c[n]-c[n-1]-p;c[n] = c[n-1]+p;}
	if(tot>m)return -1;
	LL sum =0;
	int j = 1;
	for(int i = 1;i<= n;i++)
	{
		while((i-j)*p>c[j]&&j<i)
			{sum-=c[j];j++;}
		l[i]=sum-(LL)(i-j)*(i-j+1)/2*p;
		sum+=c[i];
	}
	sum =0,j = n;
	for(int i = n;i>= 1;i--)
	{
		while((j-i)*p>c[j]&&j>i)
			{sum-=c[j];j--;}
		r[i]=sum-(LL)(j-i)*(j-i+1)/2*p;
		sum+=c[i];
	}
	for(int i = 1;i<= n;i++)
		if(tot+l[i]+r[i]+c[i]<=m)
			return i;
	return -1;
}
int main()
{
	//freopen("stu.in","r",stdin);
	//freopen("stu.out","w",stdout);
	int maxn = 0;
	scanf("%d%lld",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x[i]);
		maxn = max(maxn,x[i]);
	}
	int L = 0,R = maxn+1;
	int ans = 1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		int tmp = check(mid);
		if(tmp==-1)L = mid+1;
		else {ans = tmp;R = mid;}
	}
	printf("%d %d\n",ans,L);
	return 0;
}
Problem2793

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 1e6;
bool is_luck[N],v[N];
int mn[N],cnt;
long long ans[N];
int main()
{
	int m,x;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&x);
		is_luck[x] = true;
	}
	int n;
	long long tot = 0;
	scanf("%d",&n);
	v[0] = true;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		for(int j = 1;j<= x;j++)
		{
			while(mn[x]*x<=INF&&v[mn[x]*x])mn[x]++;
			if(mn[x]*x>INF)break;
			v[mn[x]*x] = true;
			if(is_luck[mn[x]*x])ans[++cnt] = tot+j;
		}
		tot+=x;
	}
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem2794

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int Q = 1e6+5;
const int M = 1e5+5;
struct A
{int l,r,v,id;}w[N],ask[Q];
bool cmp(A a,A b)
{
	return a.l<b.l;
}
int f[M],ans[Q];
int main()
{
	int n,q;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&w[i].v,&w[i].l,&w[i].r);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].l,&ask[i].v,&ask[i].r);
		ask[i].r+=ask[i].l;
		ask[i].id = i;
	}
	sort(w+1,w+n+1,cmp);
	sort(ask+1,ask+1+q,cmp);
	f[0] = 1e9;
	int j = 1;
	for(int i = 1;i<= q;i++)
	{
		while(w[j].l<=ask[i].l&&j<=n)
		{
			for(int k = M-5;k>= w[j].v;k--)
				f[k] = max(f[k],min(f[k-w[j].v],w[j].r));
			j++;
		}
		if(f[ask[i].v]>ask[i].r)
			ans[ask[i].id] = 1;
	}
	for(int i = 1;i<= q;i++)
	{
		if(ans[i])printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem2795

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int MOD = 23333333;
const int SED = 37;
const int N = 500005;
int nxt[N],pow[N],n;
int sum[N][26];
void init()
{
	pow[0] = 1;
	for(int i = 1;i<= n;i++)
		pow[i] = (LL)pow[i-1]*SED%MOD;
}
char s[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
int gethash(int a,int b)
{
	int lth = b-a+1;
	return (LL)(nxt[a]-(LL)nxt[b+1]*pow[lth]%MOD+MOD)%MOD;
}
int main()
{
	int a,b;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<26;j++)
			sum[i][j] = sum[i-1][j]+(s[i]==j+'a');
	for(int i = n;i>=1;i--)
		nxt[i] = ((LL)nxt[i+1]*SED+s[i]-'a')%MOD;
	init();
	int q;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&a,&b);
		int tmp = b-a+1;
		int lth = tmp;
		for(int j = 0;j<26;j++)
			tmp = gcd(tmp,sum[b][j]-sum[a-1][j]);
		int ans = lth;
		for(int j = 1;j*j<= tmp;j++)
		{
			if(tmp%j==0)
			{
				if(gethash(a,b-lth/j)==gethash(a+lth/j,b))
					ans = min(ans,lth/j);
				if(gethash(a,b-lth/(tmp/j))==gethash(a+lth/(tmp/j),b))
					ans = min(ans,lth/(tmp/j));
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem2796

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL f[100];
int solve(LL x)
{
	if(!x)return 0;
	int i = 1;
	while(f[i]<x)i++;
	if(f[i]==x)return 1;
	return solve(min(f[i]-x,x-f[i-1]))+1;
}
int main()
{
	f[1] = f[2] = 1;
	for(int i = 3;i<= 95;i++)f[i] = f[i-1]+f[i-2];
	int T;
	scanf("%d",&T);
	while(T--)
	{
		LL n;
		scanf("%lld",&n);
		printf("%d\n",solve(n));
	}
	return 0;
}
Problem2797

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
multiset<int>m;
int ans[305][305];
int t_ans[305];
int sum[90005],n,tot,cnt;
void getans(int sum3)
{
	m.clear();
	for(int i = 3;i<= tot;i++)
		m.insert(sum[i]);
	if((sum[1]+sum[2]+sum3)&1)return ;
	t_ans[1] = (sum[1]+sum[2]-sum3)>>1;
	t_ans[2] = (sum[1]+sum3-sum[2])>>1;
	t_ans[3] = (sum[2]+sum3-sum[1])>>1;
	if(t_ans[1]<=0||t_ans[2]<=0||t_ans[3]<=0)return ;
	m.erase(m.find(sum3));
	for(int i = 4;i<= n;i++)
	{
		t_ans[i] = *m.begin()-t_ans[1];
		if(t_ans[i]<=0)return ;
		for(int j = 1;j<i;j++)
		{
			int tmp = t_ans[j]+t_ans[i];
			if(m.find(tmp)==m.end())return ;
			m.erase(m.find(tmp));
		}
	}
	for(int i = 2;i<= n;i++)
		if(t_ans[i-1]>=t_ans[i])return ;
	cnt++;
	for(int i = 1;i<= n;i++)
		ans[cnt][i] = t_ans[i];
}
int main()
{
	scanf("%d",&n);
	tot = n*(n-1)/2;
	for(int i = 1;i<=tot;i++)
		scanf("%d",&sum[i]);
	sort(sum+1,sum+tot+1);
	for(int i = 3;i<= n;i++)
		if(i==3||sum[i]!=sum[i-1])
			getans(sum[i]);
	printf("%d\n",cnt);
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = 1;j<=n;j++)
			printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
Problem2799

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int p[N],z[N],mn[N],fa[N],num[N],id[N],sum[N],cnt;
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void dfs(int x)
{
	if(mn[x])return ;
	dfs(p[x]);
	mn[x] = getfa(mn[p[x]]-1);
	if(++num[mn[x]]==1)
		id[mn[x]] = x;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)fa[i] = i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&p[i],&z[i]);
		if(p[i]==i)z[i] = n;
		if(z[i])
		{
			fa[z[i]] = z[i]-1;
			mn[i] = z[i];
		}
	}
	for(int i = 1;i<= n;i++)
		if(!mn[i])dfs(i);
	for(int i = 1;i<= n;i++)
		sum[i] = sum[i-1]+(fa[i]==i);
	for(int i = 1;i<= n;i++)
		if(num[i])
		{
			if(num[i]==1&&sum[i]==cnt+1)
				z[id[i]] = i,cnt++;
			else if(num[i]+cnt==sum[i])
				cnt = sum[i]; 
			else num[i+1]+=num[i];
		}
	for(int i = 1;i<= n;i++)
		printf("%d\n",z[i]);
	return 0;
}
Problem2801

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 500005;
const int M = 3000005;
char BB[1<<15],*K=BB,*T=BB;
#define getc() (K==T&&(T=(K=BB)+fread(BB,1,1<<15,stdin),K==T)?0:*K++)
inline long long read()
{
    long long x=0;char ch=getc();
    while(ch<'0'||ch>'9')ch=getc();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getc();
    return x;
}
struct F
{
	LL k,c;
	F()
	{k = c = 0;}
	void operator -=(const F &S)
	{k-=S.k;c-=S.c;}
}f[N];
struct E
{int next,to,val;}e[M<<1];
int head[N],tot;
LL p[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
bool v[N];
LL l,r;
LL O,V,X;
int line[N],h,t;
int dfs(int s)
{
	O = V= 0;
	h = 0,t = -1;
	l = 0,r = p[s];
	line[++t] = s;
	v[s] = true;
	f[s].k = 1,f[s].c = 0;
	while(h<=t)
	{
		int x = line[h++];
		O-=f[x].k,V+=p[x]-f[x].c;
		for(int i = head[x];i;i = e[i].next)
		{
			int j = e[i].to;
			if(!v[j])
			{
				line[++t] = j;
				v[j] = true;
				f[j].k = -f[x].k;
				f[j].c = e[i].val-f[x].c;
				if(f[e[i].to].k==1)
				{
					r=min(r,p[j]-f[j].c);
					l=max(l,-f[j].c);
				}
				else
				{
					r=min(r,f[j].c);
					l=max(l,f[j].c-p[j]);
				}
				if(r<l)return -1;
			}else
			{
				if(f[j].k==f[x].k)
				{
					X = f[j].c+f[x].c-e[i].val;
					if(X%2!=0)return -1;
					r = min(r,(e[i].val-f[x].c-f[e[i].to].c)/2/f[x].k);
					l = max(l,(e[i].val-f[x].c-f[e[i].to].c)/2/f[x].k);
					if(r<l)return -1;
				}else
				{
					if(e[i].val!=f[x].c+f[j].c)
						return -1;
				}
			}
		}
	}
	return 0;
}
int main()
{
	//freopen("bez.in","r",stdin);
	//freopen("bez.out","w",stdout);
	long long n,m,x,y,z;
	n = read(),m = read();
	for(int i = 1;i<= n;i++)
		p[i] = read();
	for(int i = 1;i<= m;i++)
	{
		x = read(),y = read(),z = read();
		add(x,y,z),add(y,x,z);
	}
	LL minn = 0,maxn = 0;
	for(int i = 1;i<= n;i++)
	{
		if(!v[i])
		{
			int tmp = dfs(i);
			if(tmp==-1){printf("NIE\n");return 0;}
			else if(O>0)
				minn+=l*O+V,maxn+=r*O+V;
			else minn+=r*O+V,maxn+=l*O+V;
		}
	}
	printf("%lld %lld\n",minn,maxn);
	return 0;
}
Problem2802

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250005;
typedef long long LL;
struct H
{int no,val;}heap[N];
LL a[N];
int ans[N],cnt;
bool cmp(H a,H b)
{
	return a.val<b.val;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		int b;
		scanf("%d",&b);
		a[i]+=a[i-1];
		if(b<=a[i])
		{
			a[i]-=b;
			heap[++cnt].val = b;
			heap[cnt].no = ++ans[0];
			ans[ans[0]] = i;
			push_heap(heap+1,heap+cnt+1,cmp);
		}else if(cnt)
		{
			int tmp = heap[1].val,pos = heap[1].no;
			if(a[i]+tmp-b>=0&&tmp>b)
			{
				pop_heap(heap+1,heap+cnt+1,cmp);
				cnt--;
				a[i] = a[i]+tmp-b;
				ans[pos] = i;
				heap[++cnt].val = b;
				heap[cnt].no = pos;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
	}
	printf("%d\n",ans[0]);
	for(int i = 1;i< ans[0];i++)
		printf("%d ",ans[i]);
	if(ans[0])printf("%d\n",ans[ans[0]]);
	return 0;
}
Problem2803

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
const int SED = 37;
int MOD[2] = {23333333,99824435};
int pre[2][N],pow[2][N],n;
char s[N];
void init()
{
	for(int i = 1;i<= n;i++)
	{
		pre[0][i] = ((LL)pre[0][i-1]*SED+s[i]-'a')%MOD[0];
		pre[1][i] = ((LL)pre[1][i-1]*SED+s[i]-'a')%MOD[1];
	}
	pow[0][0] = pow[1][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		pow[0][i] = ((LL)pow[0][i-1]*SED)%MOD[0];
		pow[1][i] = ((LL)pow[1][i-1]*SED)%MOD[1];	
	}
}
int gethash(int l,int r,int no)
{
	int lth = r-l+1;
	return (pre[no][r]-(LL)pre[no][l-1]*pow[no][lth]%MOD[no]+MOD[no])%MOD[no];
}
bool check(int l1,int r1,int l2,int r2)
{
	return gethash(l1,r1,0)==gethash(l2,r2,0)&&gethash(l1,r1,1)==gethash(l2,r2,1);
}
int main()
{
	scanf("%d",&n);
	scanf("%s",s+1);
	init();
	int ans = 0;
	for(int i = n>>1,j = 0;i>0;i--,j = min(j+2,n/2-i))
		if(check(1,i,n-i+1,n))
			for(;~j;j--)
				if(check(i+1,i+j,n-i-j+1,n-i))
				{
					ans = max(ans,i+j);
					break;
				}
	printf("%d\n",ans);
	return 0;
}
Problem2806

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2300000+5;
char s[N];
int trs[N][2],len[N],fa[N];
int cnt,last,maxlen;
void insert(int x)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
}
int mtc[N];
void match(int n)
{
	int tmp = 0,p = 1;
	for(int i = 1;i<= n;i++)
	{
		int x = s[i]-'0';
		if(trs[p][x])p=trs[p][x],tmp++;
		else
		{
			while(p&&!trs[p][x])p=fa[p];
			if(!p)tmp = 0,p=1;
			else tmp = len[p]+1,p = trs[p][x];
		}
		mtc[i] = tmp;
	}
}
int Q[N],H,T,f[N],tmp[N];
bool check(int x,int n)
{
	f[0] = 0;
	H = 0,T = -1;
	//for(int i=1;i<=n;i++)tmp[i]=i-mtc[i];
	for(int i = 1;i<= n;i++)
	{
		f[i] = f[i-1];
		int p = i-x;  
        while(p>=0&&H<=T&&f[p]-p>f[Q[H]]-Q[H])
        	H++;
		if(p>=0)Q[++T] = p;
        while(H<=T&&i-mtc[i]>Q[H])H++;  
        if(H<=T)f[i] = max(f[i], f[Q[H]]+i-Q[H]);
	}
	return f[n]*10>=n*9;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	cnt = 1;
	for(int i = 1;i<= m;i++)
	{
		last = 1;
		scanf("%s",s+1);int lth = strlen(s+1);
		maxlen = max(maxlen,lth);
		for(int j = 1;j<= lth;j++)
			insert(s[j]-'0');
	}
	while(n--)
	{
		scanf("%s",s+1);
		int lth = strlen(s+1);
		match(lth);
		int l = 0,r = lth,ans=0;
		while(l<=r)
		{
			int mid = (l+r)>>1;
			if(check(mid,lth))l=mid+1,ans = mid;
			else r=mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem2809

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
int n,tot_root,b;
long long m;
struct Heap{
	Heap *ls,*rs;
	int key;
	Heap(int f)
	{
		ls = rs = NULL;
		key = f;
	}
};
Heap* Merge(Heap *x,Heap *y)
{
	if(!x)return y;
	if(!y)return x;
	if(y->key>x->key)
		swap(x,y);
	if(rand()%2==1)
		x->ls = Merge(x->ls,y);
	else 
		x->rs = Merge(x->rs,y);
	return x;
}
struct e
{int next,to;}edge[100005];
int head[100005],tot;
long long c[100005],l[100005],tc[100005],tp[100005];
Heap *h[100005];
void add(int x,int y)
{
	edge[++tot].to = y;
	edge[tot].next = head[x];
	head[x] = tot;
}
long long ans = 0;
void dfs(int x)
{
	Heap *root = new Heap(c[x]);
	tc[x]+=c[x];tp[x]++;
	for(int i = head[x];i;i = edge[i].next)
	{
		dfs(edge[i].to);
		root = Merge(root,h[edge[i].to]);
		tc[x]+=tc[edge[i].to];
		tp[x]+=tp[edge[i].to];
	}
	while(tc[x]>m)
	{
		tc[x]-=root->key;
		root = Merge(root->ls,root->rs);
		tp[x]--;
	}
	ans = max(ans,(long long)tp[x]*l[x]);
	h[x] = root;
}
int main()
{
	scanf("%d%lld",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%lld%lld",&b,&c[i],&l[i]);
		if(b==0)tot_root = i;
		else add(b,i);
	}
	dfs(tot_root);
	printf("%lld",ans);
	return 0;
}
Problem2813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e7+5;
const int mod = 1e9+7;
bool v[N];
int f[N],g[N],prime[N],e[N],d[N],cnt;
int main()
{
	int q1,a,b,c;
	int q;
	scanf("%d%d%d%d%d",&q,&q1,&a,&b,&c);
	f[1] = g[1] = 1;
	for(int i = 2;i<= c;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			e[i] = d[i] = 1;
			g[i] = 2;
			f[i]=((LL)i*i+1)%mod;
		}
		int k;
		for(int j = 1;j<= cnt&&(k=i*prime[j])<=c;j++)
		{
			v[k] = true;
			if(i%prime[j]==0)
			{
				e[k] = e[i]+1;
				g[k] = (g[i]/e[k])*(e[k]+1);
				d[k] = d[i];
				f[k] = ((LL)f[i]*prime[j]%mod*prime[j]%mod+f[d[i]])%mod;
			}else
			{
				e[k] = 1;
				d[k] = i;
				g[k] = g[i]*2;
				f[k] = (LL)f[i]*((LL)prime[j]*prime[j]%mod+1)%mod;
			}
		}
	}
	int ans1 = 0,ans2 = 0;
	for(int i = 1;i<= q;i++)
	{
		(ans1+=g[q1]+(q1&1))%=mod;
		(ans2+=f[q1]+4*(q1&1))%=mod;
		q1 = ((LL)q1*a+b)%c+1;
	}
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e7+5;
const int mod = 1e9+7;
bool v[N];
int f[N],g[N],prime[N],e[N],d[N],cnt;
int main()
{
	int q1,a,b,c;
	int q;
	scanf("%d%d%d%d%d",&q,&q1,&a,&b,&c);
	f[1] = g[1] = 1;
	for(int i = 2;i<= c;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			e[i] = d[i] = 1;
			g[i] = 2;
			f[i]=((LL)i*i+1)%mod;
		}
		int k;
		for(int j = 1;j<= cnt&&(k=i*prime[j])<=c;j++)
		{
			v[k] = true;
			if(i%prime[j]==0)
			{
				e[k] = e[i]+1;
				g[k] = (g[i]/e[k])*(e[k]+1);
				d[k] = d[i];
				f[k] = ((LL)f[i]*prime[j]%mod*prime[j]%mod+f[d[i]])%mod;
				break;
			}else
			{
				e[k] = 1;
				d[k] = i;
				g[k] = g[i]*2;
				f[k] = (LL)f[i]*((LL)prime[j]*prime[j]%mod+1)%mod;
			}
		}
	}
	int ans1 = 0,ans2 = 0;
	for(int i = 1;i<= q;i++)
	{
		(ans1+=g[q1]+(q1&1))%=mod;
		(ans2+=f[q1]+4*(q1&1))%=mod;
		q1 = ((LL)q1*a+b)%c+1;
	}
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}
Problem2815

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 65534+5;
struct E
{int next,to;}e1[N<<4],e2[N<<1],ef[N<<4];
int he[N],ht[N],hf[N],tote,tott,fa[N][17],ind[N],dep[N];
void adde(int x,int y)
{
	ind[y]++;
	e1[++tote].to = y;
	e1[tote].next = he[x];
	he[x] = tote;
	ef[tote].to = x;
	ef[tote].next = hf[y];
	hf[y] = tote;
}
void addt(int x,int y)
{
	e2[++tott].to = y;
	e2[tott].next = ht[x];
	ht[x] = tott;
	e2[++tott].to = x;
	e2[tott].next = ht[y];
	ht[y] = tott;
}
queue <int>Q;
int line[N],cnt,n;
void addleaf(int x,int y)
{
	dep[x] = dep[y]+1;fa[x][0] = y;
	for(int i = 1;i<17;i++)
		fa[x][i] = fa[fa[x][i-1]][i-1];
}
int getlca(int x,int y)
{
	if(x<0)return y;
	if(dep[x]<dep[y])swap(x,y);
	for(int j = 16;j>=0;j--)
		if(dep[fa[x][j]]>=dep[y])
			x = fa[x][j];
	if(x==y)return x;
	int re;
	for(int j = 16;j>=0;j--)
	{
		if(fa[x][j]!=fa[y][j])
		{
			x = fa[x][j];
			y = fa[y][j];
		}else re = fa[x][j];
	}
	return re;
}
void topo()
{
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i),addt(0,i),dep[i] = 1;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = he[x];i;i = e1[i].next)
		{
			--ind[e1[i].to];
			if(!ind[e1[i].to])
			{
				Q.push(e1[i].to);
				line[++cnt] = e1[i].to;
			}
		}
	}
}
void build(int x)
{
	int tmp = -1;
	for(int i = hf[x];i;i = ef[i].next)
		tmp = getlca(tmp,ef[i].to);
	addt(tmp,x);
	addleaf(x,tmp);
}
int size[N];
void dfs(int x,int fa)
{
	size[x]++;
	for(int i = ht[x];i;i = e2[i].next)
		if(e2[i].to!=fa)
		{
			dfs(e2[i].to,x);
			size[x]+=size[e2[i].to];
		}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		int x;
		while(scanf("%d",&x))
		{
			if(x==0)break;
			adde(x,i);
		}
	}
	topo();
	for(int i = 1;i<= cnt;i++)
		build(line[i]);
	dfs(0,-1);
	for(int i = 1;i<= n;i++)
		printf("%d\n",size[i]-1);
	return 0;
}
Problem2818

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
long long sum_oula[10000005];
long long oula[10000005];
int prime[1000005],t_p,n;
bool v[10000005];
void quick_oula()
{
	oula[1] = 1;
	for(int i = 2;i<= n;i++)
	{
		if(!v[i])
		{
			t_p++;
			prime[t_p] = i;
			oula[i] = i - 1;
		}
		for(int j = 1;j<= t_p&&i*prime[j]<=n;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j]==0)
			{
				oula[i*prime[j]] = oula[i]*prime[j];
				break;
			}
			else 
				oula[i*prime[j]] = oula[i]*(prime[j]-1);
		}
	}
	for(int i = 1;i<= n;i++)
		sum_oula[i] = sum_oula[i-1]+oula[i];
}
int main()
{
	memset(prime,0x3f,sizeof(prime));
	scanf("%d",&n);
	quick_oula();
	int j = 1;long long ans = 0;
	while(prime[j]<=n)
	{
		ans +=sum_oula[n/prime[j]];
		j++;
	}
	ans = ans*2-j+1;
	printf("%lld",ans);
	return 0;
}
Problem2820

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int prime[N/10],mu[N],sum[N],g[N],cnt;
bool vis[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<=cnt;i++)
		for(int j = 1;j*prime[i]<N;j++)
			g[j*prime[i]]+=mu[j];
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+g[i];
}
void solve(int n,int m)
{
	ll ans = 0;
	int last;
	for(int i = 1;i<=n&&i<=m;i = last+1)
	{
		last = min(m/(m/i),n/(n/i));
		ans+=(ll)(n/i)*(m/i)*(sum[last]-sum[i-1]);
	}
	printf("%lld\n",ans);
}
int main()
{
	int t;
	scanf("%d",&t);
	quick_mu();
	while(t--)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		solve(x,y);
	}
	return 0;
}
Problem2879

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 3e6+5;
const int INF = 0x3f3f3f3f;
int p[45],P,m,n,from[N];
int t[45][105];
struct E
{int next,to,c,f,from;}e[M];
int head[N],tot=1,st,end;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f;e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0;e[tot].c=-c;
	e[tot-1].from=x;e[tot].from=y;
}
int dis[N];bool v[N];
queue<int>Q;
bool spfa()
{
	memset(dis,0x3f,sizeof(dis));
	Q.push(st);
	dis[st]=0,v[st]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].c&&e[i].f)
			{
				dis[e[i].to]=dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[end]!=INF;
}
int ans;
void mcf()
{
	int x = INF,a,b,y;
	for(int i = from[end];i;i=from[e[i].from])
	{
		x = min(x,e[i].f);
		if(e[i].from==0)
		{
			y = e[i].to;
			a = (y-1)/P+1;b = y%P+1;
		}
	}
	for(int i = from[end];i;i=from[e[i].from])
	{
		e[i].f-=x;e[i^1].f+=x;ans+=e[i].c*x;
	}
	for(int i = 1;i<= m;i++)
		add((a-1)*P+b,n*P+i,1,b*t[i][a]);
}
int main()
{
	scanf("%d%d",&m,&n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&p[i]);
		P+=p[i];
	}
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			scanf("%d",&t[i][j]);
	st = 0,end = n*P+m+1;
	for(int i = 1;i<= n*P;i++)
		add(st,i,1,0);
	for(int i = 1;i<= m;i++)
		add(n*P+i,end,p[i],0);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			add((i-1)*P+1,n*P+j,1,t[j][i]);
	while(spfa())mcf();
	printf("%d\n",ans);
	return 0;
}
Problem2888

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 40005;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,ans,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int son[N][2],sum[N],fa[N],size[N],lazy[N],val[N],s[N],d[N];
bool rev[N];
inline bool is_root(int x)
{
	return son[fa[x]][0]!=x&&son[fa[x]][1]!=x;
}
inline void reverse(int x)
{
	rev[x]^=1;
	swap(son[x][0],son[x][1]);
}
inline void init(int x,int f)
{
	fa[x] = f;
	son[x][0] = son[x][1] = val[x] = lazy[x] = 0;
	sum[x] = s[x] = d[x] = 0;size[x] = 1;
}
inline void Push_up(int x)
{
	if(!x)return ;
	size[x] =size[son[x][0]]+1+size[son[x][1]];
}
inline void Add(int x,int y)
{
	if(!x)return ;
	val[x]+=y;
	lazy[x]+=y;
}
inline void update(int x,int S,int D)
{
	if(!x)return ;
	sum[x]+=S+size[son[x][1]]*D;
	s[x]+=S,d[x]+=D;
}
inline void Push_down(int x)
{
	int ls = son[x][0],rs = son[x][1];
	if(rev[x])
	{
		reverse(ls);
		reverse(rs);
		rev[x] = 0;
	}
	if(lazy[x])
	{
		Add(ls,lazy[x]),Add(rs,lazy[x]);
		lazy[x] = 0;
	}
	if(d[x])
	{
		update(ls,s[x]+(size[rs]+1)*d[x],d[x]);
		update(rs,s[x],d[x]);
		s[x] = d[x] = 0;
	}
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(y==son[z][0])son[z][0] = x;
		else son[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[son[x][d^1]] = y;
	son[y][d] = son[x][d^1],son[x][d^1] = y;
	Push_up(x),Push_up(y);
}
int stack[N],top;
void splay(int x)
{
	top = 0;
	stack[++top] = x;
	for(int i = x;!is_root(i);i = fa[i])stack[++top] = fa[i];
	while(top)Push_down(stack[top--]);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)!=(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		son[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
int find(int x)
{
	access(x);
	splay(x);
	while(son[x][0])
		x = son[x][0];
	return x;
}
void insert(int f,int x)
{
	init(x,f);
	f = find(f);access(x);splay(f);
	Add(f,1);
	update(f,0,1);
	x = son[f][1];
	while(son[x][0])
		x = son[x][0];
	splay(x);
	int v1 = val[f],v2= val[x];
	if(v2*2>v1)
	{
		val[x] = v1,val[f]-=v2;
		sum[f]-=sum[x]+v2;sum[x]+=sum[f]+v1-v2;
		access(x);splay(f);
		son[f][0] = x;son[f][1] = 0;
	}
}
void dfs(int x,int f)
{
	insert(f,x);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=f)dfs(e[i].to,x);
}
void Link(int x,int y)
{
	add(x,y),add(y,x);
	int p = find(x),q = find(y);
	ans-=sum[p]+sum[q];
	if(val[p]<val[q])swap(x,y);
	dfs(y,x);
	ans+=sum[find(x)];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)val[i]=size[i]=1;
	char opt[3];
	int a,b;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='A'){scanf("%d%d",&a,&b);Link(a,b);}
		else printf("%d\n",ans);
	}
	return 0;
}
Problem2929

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 205;
const int M = 8e4+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].flow = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].flow = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow&&d[e[i].to]==d[s]-1)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF))!=0)
			ans+=nowflow;
	return ans;
}
int main()
{
	int n,m,x;
	scanf("%d",&n);
	int st = 1,end = n;
	for(int i = 1;i< n;i++)
	{
		scanf("%d",&m);
		if(i==1)
			while(m--)
			{
				scanf("%d",&x);
				add(1,x,1);
			}
		else
			while(m--)
			{
				scanf("%d",&x);
				if(x!=n)add(i,x,INF);
				else add(i,n,1);
			}
	}
	printf("%d\n",dinic(st,end));
	return 0;
}
Problem2938

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int s[N];char str[N];
bool ins[N],vis[N];
struct AC_Machine
{
	int ch[N][2],fail[N];bool end[N];
	int cnt,q[N],h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<2;i++)
			ch[0][i] = 1;
	}
	void insert(int len)
	{
		int now = 1;
		for(int i = 1;i<=len;i++)
		{
			if(!ch[now][s[i]])ch[now][s[i]]=++cnt;
			now = ch[now][s[i]];
		}
		end[now] = true;
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1,fail[0] = 1;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<2;i++)
			{
				int j = ch[x][i];
				if(!j)
				{
					ch[x][i]=ch[fail[x]][i];
					continue;
				}
				int k = fail[x];
				while(!ch[k][i])k = fail[k];
				fail[j] = ch[k][i];
				end[j]|=end[fail[j]];
				q[++t]=j;
			}
		}
	}
	bool dfs(int x)
	{
		ins[x] = true;
		for(int i = 0;i<2;i++)
		{
			int v = ch[x][i];
			if(ins[v])return true;
			if(vis[v]||end[v])continue;
			vis[v] = true;
			if(dfs(v))return true;
		}
		ins[x] = false;
		return false;
	}
}AC;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",str+1);
		int len = strlen(str+1);
		for(int j = 1;j<= len;j++)
			s[j] = str[j]-'0';
		AC.insert(len);
	}
	AC.build();
	if(AC.dfs(1))printf("TAK\n");
	else printf("NIE\n");
	return 0;
}
Problem2960

#include <stdio.h>
#include <set>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e4+5;
struct Point 
{
	int x,y;
	Point(int _x=0,int _y=0):x(_x),y(_y){}
	void read(){scanf("%d%d",&x,&y);}
	int operator *(const Point &s)const
	{
		return x*s.y-y*s.x;
	}
}p[N];
struct E
{
	int x,y;
	double alp;
	E(int _x=0,int _y=0):x(_x),y(_y)
	{
		alp = atan2(p[_y].x-p[_x].x,p[_y].y-p[_x].y);
	}
}e[N];
struct Edge
{
	int x,y,v;
	Edge(int _x=0,int _y=0,int _v=0):x(_x),y(_y),v(_v){}
}ed[N];
int bel[N],cnt,tp=1;
int w[N];
struct Pic_to_Gra
{
	struct cmp
	{
		bool operator()(const int &a,const int &b)
			{return e[a].alp<e[b].alp;}
	};
	set<int,cmp>g[N];
	set<int>::iterator it;
	bool del[N];
	int q[N];
	void Insert(int x,int y){g[x].insert(y);}
	void work()
	{
		int t,j;
		for(int i = 2;i<=tp;i++)
			if(!del[i])
			{
				t = 1;
				q[t] = j = i;
				while(true)
				{
					it = g[e[j].y].find(j^1);
					it++;
					if(it==g[e[j].y].end())it = g[e[j].y].begin();
					if(*it==i)break;
					q[++t] = j = *it;
				}
				int s= 0;
				for(j=1;j<=t;j++)s+=p[e[q[j]].x]*p[e[q[j]].y];
				++cnt;
				for(j=1;j<=t;j++)del[q[j]]=true,bel[q[j]]=cnt;
			}
	}
}p2g;
struct Minimum_Tree_Gragh
{
	int pre[N],id[N],in[N],vis[N];
	int work(int root,int n,int m)
	{
		int tn,tm,ans = 0;
		while(true)
		{
			for(int i = 1;i<= n;i++)in[i]=INF,pre[i]=0;
			for(int i = 1;i<= m;i++)
				if(ed[i].v<in[ed[i].y])
				{
					in[ed[i].y] = ed[i].v;
					pre[ed[i].y] = ed[i].x;
				}
			tn = tm = in[root] = 0;
			for(int i = 1;i<= n;i++)id[i]=vis[i] = 0;
			for(int v,i = 1;i<= n;i++)
			{
				ans+=in[v=i];
				while(vis[v]!=i&&!id[v]&&v!=root)vis[v]=i,v=pre[v];
				if(v!=root&&!id[v])
				{
					id[v] = ++tn;
					for(int u = pre[v];u!=v;u=pre[u])id[u]=tn;
				}
			}
			if(!tn)break;
			for(int i = 1;i<= n;i++)if(!id[i])id[i]=++tn;
			for(int i = 1;i<= m;i++)
				if(id[ed[i].x]!=id[ed[i].y])
					ed[++tm] = Edge(id[ed[i].x],id[ed[i].y],ed[i].v-in[ed[i].y]);
			n = tn,m = tm,root = id[root];
		}
		return ans;
	}
	void solve()
	{
		int n = cnt+1,root = cnt+1,m=0,sum = 0;
		for(int i = 2;i<= tp;i++)
			if(bel[i]&&bel[i^1]&&w[i])
			{
				ed[++m] = Edge(bel[i],bel[i^1],w[i]);
				sum+=w[i];
			}
		for(int i = 1;i<= cnt;i++)ed[++m] = Edge(root,i,sum);
		printf("%d\n",work(root,n,m)-sum);
	}
}mtg;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)p[i].read();
	for(int i = 1;i<= m;i++)
	{
		int u,v;
		scanf("%d%d%d%d",&u,&v,&w[i*2],&w[i*2+1]);
		e[++tp] = E(u,v),p2g.Insert(u,tp);
		e[++tp] = E(v,u),p2g.Insert(v,tp);
	}
	p2g.work();
	mtg.solve();
	return 0;
}
Problem2961

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const double INF = 1e11;
const int N = 5e5+500;
struct Point
{
	double x,y;
	Point(){}
	Point(double _x,double _y):x(_x),y(_y){}
};
struct Qurey
{
	int type,id;
	Point a;
	double k;
	Qurey(){}
	Qurey(int _type,double _x,double _y,int _id):type(_type),id(_id)
	{
		a.x = _x,a.y = _y;
		if(fabs(a.y)<eps)
			k = INF;
		else 
			k = -a.x/a.y;
	}
	bool operator <(const Qurey &s)const
	{
		return k<s.k;
	}
}q[N],nq[N];
double Distance(const Point &a,const Point &b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
double Slope(const Point &a,const Point &b)
{
	if(fabs(a.x-b.x)<eps)
		return INF;
	return (b.y-a.y)/(b.x-a.x);
}
int n,cnt,stk1[N],stk2[N];
bool ap[N];
void solve(int l,int r)
{
	if(l==r)return ;
	int mid = (l+r)>>1;
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
	{
		if(q[i].id<=mid)
			nq[l1++]=q[i];
		else 
			nq[l2++]=q[i];
	}
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	solve(l,mid);
	int top1 = 0,top2 = 0;
	for(int i = l;i<= mid;i++)
	{
		if(q[i].type==1)continue;
		while(top1>1 && Slope(q[stk1[top1-1]].a,q[i].a)+eps>Slope(q[stk1[top1-1]].a,q[stk1[top1]].a))
			top1--;
		stk1[++top1] = i;
		while(top2>1 && Slope(q[stk2[top2-1]].a,q[i].a)<Slope(q[stk2[top2-1]].a,q[stk2[top2]].a)+eps)
			top2--;
		stk2[++top2] = i;
	}
	int j = 1;
	for(int i = mid+1;i<= r;i++)
	{
		if(q[i].type==0)continue;
		if(q[i].a.y<eps)
		{
			while(top1>1&&Slope(q[stk1[top1-1]].a,q[stk1[top1]].a)<q[i].k)
				top1--;
			if(top1>0&&Distance(q[stk1[top1]].a,q[0].a)<Distance(q[stk1[top1]].a,q[i].a))
				ap[q[i].id]=false;
		}else
		{
			while (j<top2 && Slope(q[stk2[j]].a,q[stk2[j+1]].a)<q[i].k)
				j++;
            if (j<=top2 && Distance(q[stk2[j]].a,q[0].a)<Distance(q[stk2[j]].a,q[i].a)) 
            	ap[q[i].id]=false;
		}
	}
	solve(mid+1,r);
	l1 = l,l2 = mid+1;
	for (int i = l;i<= r;i++)
        if (l1<=mid && q[l1].a.x<q[l2].a.x || l2>r)
        	nq[i]=q[l1++]; 
        else nq[i]=q[l2++];
    for (int i=l; i<=r; i++) q[i]=nq[i];
}
bool cmp(const Qurey &a,const Qurey &b)
{
	return a.id<b.id;
}
int main()
{
	int type;
	double x,y;
	scanf("%d",&n);
	bool flag = false;
	q[0].a = Point(0,0);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%lf%lf",&type,&x,&y);
		q[i] = Qurey(type,x,y,i);
		if(!q[i].type)flag = true;
		ap[i]=flag;
	}
	sort(q+1,q+n+1);
	solve(1,n);
	sort(q+1,q+n+1,cmp);
	for(int i = 1;i<= n;i++)
		if(q[i].type)
			puts(ap[i]?"Yes":"No");
	return 0;
}
Problem2962

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int mod = 19940417;
const int nmd = 17091780;
const int N = 50050;
const int INF = 1e9+5;
int fac[N],env[N];
int calc[N][25];
void init()
{
	calc[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		calc[i][0] = 1;
		for(int j = 1;j<= 20;j++)
			calc[i][j] = (calc[i-1][j-1]+calc[i-1][j])%mod;
	}
	return ;
}
int f[N<<2][21],la[N<<2],lf[N<<2];
void push_up(int p,int l,int r)
{
	int len = (r-l+1);
	int end = min(len,20);
	for(int i = 1;i<= end;i++)
	{
		f[p][i] = 0;
		for(int j = 0;j<=i;j++)
			(f[p][i]+=((LL)f[p<<1][j]*f[p<<1|1][i-j])%mod+mod)%=mod;
	}
}
int powx[21];
void push_down(int p,int l,int r)
{
	if(l==r||(lf[p]==0&&la[p]==0))return ;
	int mid = (l+r)>>1;
	if(lf[p])
	{
		for(int i = 1;i<=19;i+=2)
		{
			f[p<<1][i] = (mod-f[p<<1][i])%mod;
			f[p<<1|1][i] = (mod-f[p<<1|1][i])%mod;
		}
		lf[p<<1] = lf[p<<1]^lf[p],lf[p<<1|1] = lf[p<<1|1]^lf[p];
		la[p<<1] = (mod-la[p<<1])%mod,la[p<<1|1] = (mod-la[p<<1|1])%mod;
	}
	if(la[p])
	{
		powx[0] = 1;
		for(int i = 1;i<= 20;i++)
			powx[i] = (LL)powx[i-1]*la[p]%mod;
		for(int i = 20;i>= 1;i--)
			for(int j = 1;j<= i;j++)
			{
				(f[p<<1][i] += (LL)f[p<<1][i-j]*powx[j]%mod*calc[mid-l+1-i+j][j]%mod+mod)%=mod;
				(f[p<<1|1][i] += (LL)f[p<<1|1][i-j]*powx[j]%mod*calc[r-mid-i+j][j]%mod+mod)%=mod;
			}
		la[p<<1] += la[p],la[p<<1|1]+=la[p];
	}
	
	lf[p] = la[p] = 0;
	return ;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		if(c==INF)
		{
			for(int i = 1;i<=19;i+=2)
				f[p][i] = mod-f[p][i];
			lf[p] = lf[p]^1;
		}else
		{
			int end = min(20,(r-l+1));
			powx[0] = 1;
			for(int i = 1;i<= end;i++)
				powx[i] = (LL)powx[i-1]*c%mod;
			for(int i = end;i>= 1;i--)
				for(int j = 1;j<= i;j++)
					(f[p][i] += (LL)f[p][i-j]*powx[j]%mod*calc[r-l+1-i+j][j]%mod+mod)%=mod;
			la[p]+=c;
		}
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,c);
	push_up(p,l,r);
}
struct E
{int t[21];};
E getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		E a;
		a.t[0] =1;
		for(int i = 1;i<= 20;i++)
			a.t[i] = f[p][i];
		return a;
	}
	int mid=(l+r)>>1;
	if(b<=mid)
		return getans(p<<1,l,mid,a,b);
	else if(a>mid)
		return getans(p<<1|1,mid+1,r,a,b);
	else
	{
		E A = getans(p<<1,l,mid,a,mid);
		E B = getans(p<<1|1,mid+1,r,mid+1,b);
		E C;
		int len = (b-a+1);
		int end = min(len,20);
		C.t[0] = 1;
		for(int i = 1;i<= end;i++)
		{
			C.t[i] = 0;
			for(int j = 0;j<=i;j++)
				if(j<=mid-a+1&&i-j<=b-mid)(C.t[i]+=((LL)A.t[j]*B.t[i-j])%mod+mod)%=mod;
		}
		return C;
	}
}
void build(int p,int l,int r)
{
	la[p] = lf[p] = 0;
	f[p][0] =1;
	if(l==r)
	{
		scanf("%d",&f[p][1]);
		f[p][1] = (f[p][1]%mod+mod)%mod;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p,l,r);
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	init();
	build(1,1,n);
	char opt[3];
	int a,b,c;
	for(int i =1;i<= q;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d%d%d",&a,&b,&c);
			update(1,1,n,a,b,c);
		}else if(opt[0]=='R')
		{
			scanf("%d%d",&a,&b);
			update(1,1,n,a,b,INF);
		}else
		{
			scanf("%d%d%d",&a,&b,&c);
			E t = getans(1,1,n,a,b);
			printf("%d\n",t.t[c]%mod);
		}
	}
	return 0;
}
Problem3004

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1200005;
int fa[N],size[N],f[N],ind[N];
int Div[2200],cnt;
void getdiv(int x)
{
	for(int i = 1;i*i<= x;i++)
	{
		if(i*i==x)
			Div[++cnt] = i;
		else if(x%i==0)
			Div[++cnt] = i,Div[++cnt] = x/i;
	}
	return ;
}
queue<int>Q;
int main()
{
	int n;
	scanf("%d",&n);
	getdiv(n);
	sort(Div+1,Div+cnt+1);
	for(int id = 1;id<= 10;id++)
	{
		memset(ind,0,sizeof(ind));
		if(id==1)
			for(int i = 2;i<= n;i++)
			{
				if(i==n)scanf("%d",&fa[i]);
				else scanf("%d,",&fa[i]);
				ind[fa[i]]++;
			}
		else
			for(int i = 2;i<= n;i++)
				{fa[i] = (fa[i]+19940105)%(i-1)+1;ind[fa[i]]++;}
		memset(size,0,sizeof(size));
		memset(f,0,sizeof(f));
		for(int i = 1;i<= n;i++)
			if(!ind[i])
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			size[x]++;
			ind[fa[x]]--;
			size[fa[x]]+=size[x];
			if(!ind[fa[x]])
				Q.push(fa[x]);
		}
		for(int i = 1;i<= n;i++)
			f[size[i]]++;
		printf("Case #%d:\n",id);
		for(int i = 1;i<= cnt;i++)
		{
			int num = 0;
			for(int j = Div[i];j<=n;j+=Div[i])
				num+=f[j];
			if(num==n/Div[i])
				printf("%d\n",Div[i]);
		}
	}
	return 0;
}
Problem3028

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 10007;
char s[1005];
int quick_pow(int x,int y)
{
	if(y==0)return 1;
	int tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{	
	int d,n=0;
	scanf("%s",s+1);
	for(int i = 1;s[i];i++)
		n = (n*10+s[i]-'0')%mod;
	int ans = n*(n+1)%mod*(n+2)%mod;
	ans = ans*quick_pow(6,mod-2)%mod;
	printf("%d\n",ans);
	return 0;
}
Problem3029

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 201;
double f[2][N][N<<1];
int w[N];
double p[N];
int main()
{
	int n,l,K;
	scanf("%d%d%d",&n,&l,&K);
	if(K>n)K = n;
	f[0][0][K+200] = 1;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf",&p[i]);
		p[i]/=100.0;
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&w[i]);
	for(int i = 0;i< n;i++)
	{
		int next = (i+1)&1,now = i&1;
		for(int j = 0;j<=i;j++)
			for(int k = -i;k<= n;k++)
			{
				f[next][j][k+200] += (1.0-p[i+1])*f[now][j][k+200];
				int tmp = k+w[i+1];
				if(tmp>n)tmp = n;
				f[next][j+1][tmp+200] += p[i+1]*f[now][j][k+200];
			}
		memset(f[now],0,sizeof(f[now]));
	}
	double ans = 0;
	for (int i=0;i<=n;i++) 
	  for (int j=l;j<=n;j++) 
	    ans+=f[n&1][j][i+200];
	printf("%.6f\n",ans);
	return 0;
}
Problem3037

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,a[N],edge;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool v[N];
int p;
void dfs(int x)
{
	v[x] = true;
	if(v[a[x]]){p = x;return ;}
	dfs(a[x]);
}
int g[N],f[N];
void dp(int x,int fa)
{
	f[x] = 1,g[x] = INF,v[x] = true;
	if(x==edge)g[x]= 0;
	for(int i = head[x];i;i= e[i].next)
	{
		if(e[i].to!=fa&&e[i].to!=p)
		{
			dp(e[i].to,x);
			g[x] += min(g[e[i].to],f[e[i].to]);
			g[x] = min(g[x],f[x]+f[e[i].to]-1);
			f[x] += min(g[e[i].to],f[e[i].to]); 
		}
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		add(a[i],i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
	{
		if(v[i])continue;
		dfs(i);
		edge = a[p];
		dp(p,0);int tmp = f[p];
		edge = 0;
		dp(p,0);
		ans+=min(tmp,g[p]);
	}
	printf("%d\n",n-ans);
	return 0;
}
Problem3038

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long LL;
LL sum[N<<2];
LL a[N];
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void update(int p,int l,int r,int x,LL c)
{
	if(l==r)
		{sum[p] = c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,c);
	else update(p<<1|1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
LL getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans = ans+getans(p<<1,l,mid,a,b);
	if(b>mid)ans = ans+getans(p<<1|1,mid+1,r,a,b);
	return ans;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = a[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int main()
{
	int n,m;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	build(1,1,n);
	for(int i = 1;i<= n;i++)
	{
		if(a[i]>1)fa[i] = i;
		else fa[i] = i+1;
	}
	fa[n+1] = n+1;
	int x,y,opt;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt,&x,&y);
		if(x>y)swap(x,y);
		if(opt==0)
		{
			for(int t = getfa(x);t<= y;t= getfa(t))
			{
				a[t] = sqrt(a[t]);
				update(1,1,n,t,a[t]);
				if(a[t]<=1)
					fa[t] = t+1;
				t = t+1;
			}
		}else
			printf("%lld\n",getans(1,1,n,x,y));
	}
	return 0;
}
Problem3039

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
bool map[N][N];
int l[N][N],r[N][N],h[N][N];
char s[3];
int ans = 0,n,m;
void work()
{
	for(int i = 1;i<= n;i++)
	{
		int t = 1;
		for(int j = 1;j<= m;j++)
			if(map[i][j])l[i][j] = t;
			else l[i][j] = 1,t = j+1;
		t = m;
		for(int j = m;j>=1;j--)
			if(map[i][j])r[i][j] = t;
			else r[i][j] = m,t = j-1;
	}
	for(int j = 1;j<= m;j++)l[0][j] = 1,r[0][j] = m;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(map[i][j])
			{
				h[i][j] = h[i-1][j]+1;
				l[i][j] = max(l[i-1][j],l[i][j]);
				r[i][j] = min(r[i-1][j],r[i][j]);
				ans = max(ans,(r[i][j]-l[i][j]+1)*h[i][j]);
			}
	printf("%d\n",ans*3);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<=m;j++)
		{
			scanf("%s",s);
			map[i][j] = s[0]=='F';
		}
	}
	work();
	return 0;
}
Problem3053

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int INF = 1e9+1;
typedef double db;
int n,k,t,m,root;
struct P
{
	int mx[6],mn[6],d[6],l,r;
	int& operator[](int x){return d[x];}
	void clear()
	{
		for(int i = 0;i<6;i++)
			mx[i] = mn[i] = d[i] = 0;
	}
}p[N];
struct data
{int no,dis;}ans[15];
int top;
bool cmp(const data &a,const data &b)
{
	return a.dis<b.dis;
}
int D;
bool operator<(P a,P b)
{
	return a[D]<b[D];
}
inline int getdis(P a,P b)
{
	int ans = 0;
	for(int i = 0;i< k;i++)
		ans+=(a[i]-b[i])*(a[i]-b[i]);
	return ans;
}
struct KD_tree
{
	P t[N],T;
	int cnt;
	void clear()
	{
		for(int i = 0;i<N;i++)
			t[i].clear();
		T.clear();
		cnt = 0;
	}
	void update(int o)
	{
		P l = t[t[o].l],r = t[t[o].r];
		for(int i = 0;i< k;i++)
		{
			if(t[o].l)t[o].mn[i] = min(t[o].mn[i],l.mn[i]),t[o].mx[i] = max(t[o].mx[i],l.mx[i]);
			if(t[o].r)t[o].mn[i] = min(t[o].mn[i],r.mn[i]),t[o].mx[i] = max(t[o].mx[i],r.mx[i]);
		}
		return ;
	}
	int build(int l,int r,int now)
	{
		D = now;
		int mid = (l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid] = p[mid];
		for(int i = 0;i<k;i++)
			t[mid].mn[i]=t[mid].mx[i] = t[mid][i];
		if(l<mid)t[mid].l = build(l,mid-1,(now+1)%k);
		if(r>mid)t[mid].r = build(mid+1,r,(now+1)%k);
		update(mid);
		return mid;
	}
	int getmindis(int o,P p)
	{
		int ans = 0;
		for(int i = 0;i<k;i++)
		{
			if(p[i]<t[o].mn[i])
				ans+=(t[o].mn[i]-p[i])*(t[o].mn[i]-p[i]);
			if(p[i]>t[o].mx[i])
				ans+=(p[i]-t[o].mx[i])*(p[i]-t[o].mx[i]);
		}
		return ans;
	}
	void query(int o,int now)
	{
		int d,dl = INF,dr = INF;
		d = getdis(t[o],T);
		if(d<ans[1].dis)
		{
			pop_heap(ans+1,ans+top+1,cmp);
			ans[top] = (data){o,d};
			push_heap(ans+1,ans+top+1,cmp);
		}
		if(t[o].l)dl = getmindis(t[o].l,T);
		if(t[o].r)dr = getmindis(t[o].r,T);
		if(dl<dr)
		{
			if(dl<ans[1].dis)query(t[o].l,(now+1)%k);
			if(dr<ans[1].dis)query(t[o].r,(now+1)%k);
		}else
		{
			if(dr<ans[1].dis)query(t[o].r,(now+1)%k);
			if(dl<ans[1].dis)query(t[o].l,(now+1)%k);
		}
	}
	void getans(P p,int num)
	{
		for(int i = 1;i<= num;i++)
			ans[i] = (data){0,INF};
		top = num;
		T = p;
		query(root,0);
	}
}KD;
void init()
{
	KD.clear();
	top = t = 0;
	memset(ans,0,sizeof(ans));
}
void work()
{
	int x;
	init();
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<k;j++)
		{
			scanf("%d",&x);
			p[i][j] = x;
		}
	root = KD.build(1,n,0);
	P tmp;
	scanf("%d",&t);
	for(int i =1;i<= t;i++)
	{
		for(int j = 0;j<k;j++)
		{
			scanf("%d",&x);
			tmp[j] = x;
		}
		scanf("%d",&m);
		KD.getans(tmp,m);
		printf("the closest %d points are:\n",m);
		sort(ans+1,ans+m+1,cmp);
		for(int j = 1;j<=m;j++)
		{
			for(int tt = 0;tt<k-1;tt++)
				printf("%d ",p[ans[j].no][tt]);
			printf("%d\n",p[ans[j].no][k-1]);
			//printf("%d ",ans[1].no);
			//pop_heap(ans+1,ans+top+1,cmp);
			//top--;
		}
	}
}
int main()
{
	while(scanf("%d%d",&n,&k)!=EOF)
		work();
	return 0;
}
Problem3053

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e9+1;
int n,k,D,root;
struct Point
{
	int mx[6],mn[6],d[6],l,r;
	int& operator[](int x){return d[x];}
	void clear()
	{
		for(int i = 0;i<6;i++)
			mx[i]=mn[i]=d[i]=0;
	}
}p[N];
bool operator <(Point a,Point b)
{
	return a[D]<b[D];
}
int getdis(Point a,Point b)
{
	int ans = 0;
	for(int i = 0;i<k;i++)
		ans = ans+(a[i]-b[i])*(a[i]-b[i]);
	return ans;
}
int top;
struct Heap
{
	int o,dis;
	Heap(int _o=0,int _dis=INF):o(_o),dis(_dis){}
	bool operator <(const Heap &s)const
	{
		return dis<s.dis;
	}
}ans[15];
struct KD_tree
{
	Point t[N],target;
	int cnt;
	void clear()
	{
		for(int i = 0;i<N;i++)
			t[i].clear();
		target.clear();
		cnt = 0;
	}
	void Push_up(int p)
	{
		Point l = t[t[p].l],r = t[t[p].r];
		for(int i = 0;i<k;i++)
		{
			if(t[p].l)t[p].mx[i]=max(t[p].mx[i],l.mx[i]),t[p].mn[i]=min(t[p].mn[i],l.mn[i]);
			if(t[p].r)t[p].mx[i]=max(t[p].mx[i],r.mx[i]),t[p].mn[i]=min(t[p].mn[i],r.mn[i]);
		}
	}
	int getmindis(int x,Point p)
	{
		int ans = 0;
		for(int i = 0;i<k;i++)
		{
			if(p[i]>t[x].mx[i])
				ans = ans+(p[i]-t[x].mx[i])*(p[i]-t[x].mx[i]);
			if(p[i]<t[x].mn[i])
				ans = ans+(t[x].mn[i]-p[i])*(t[x].mn[i]-p[i]);
		}
		return ans;
	}
	int build(int l,int r,int now)
	{
		D = now;
		int mid = (l+r)>>1;
		nth_element(p+l,p+mid,p+r+1);
		t[mid] = p[mid];
		for(int i = 0;i<k;i++)
			t[mid].mx[i]=t[mid].mn[i]=t[mid][i];
		if(l<mid)t[mid].l = build(l,mid-1,(now+1)%k);
		if(r>mid)t[mid].r = build(mid+1,r,(now+1)%k);
		Push_up(mid);
		return mid;
	}
	void getans(int o)
	{
		int d,dl = INF,dr = INF;
		d = getdis(target,t[o]);
		if(d<ans[1].dis)
		{
			pop_heap(ans+1,ans+top+1);
			ans[top] = Heap(o,d);
			push_heap(ans+1,ans+top+1);
		}
		if(t[o].l)dl = getmindis(t[o].l,target);
		if(t[o].r)dr = getmindis(t[o].r,target);
		if(dl<dr)
		{
			if(dl<ans[1].dis)getans(t[o].l);
			if(dr<ans[1].dis)getans(t[o].r);
		}else
		{
			if(dr<ans[1].dis)getans(t[o].r);
			if(dl<ans[1].dis)getans(t[o].l);
		}
	}
	void Getans(const Point &o,int num)
	{
		for(int i = 1;i<=num;i++)
			ans[i] = Heap(0,INF);
		top = num;
		target = o;
		getans(root);
	}
}kd;
void init()
{
	kd.clear();
	top = 0;
	for(int i = 0;i<15;i++)
		ans[i]=Heap(0,INF);
}
void work()
{
	init();
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<k;j++)
			scanf("%d",&p[i].d[j]);
	root = kd.build(1,n,0);
	int m,num;Point t;
	scanf("%d",&m);
	while(m--)
	{
		for(int i = 0;i<k;i++)
			scanf("%d",&t.d[i]);
		scanf("%d",&num);
		kd.Getans(t,num);
		printf("the closest %d points are:\n",num);
		sort(ans+1,ans+num+1);
		for(int j = 1;j<=num;j++)
		{
			for(int tt = 0;tt<k-1;tt++)
				printf("%d ",p[ans[j].o][tt]);
			printf("%d\n",p[ans[j].o][k-1]);
		}
	}
}
int main()
{
	while(scanf("%d%d",&n,&k)!=EOF)
		work();
	return 0;
}
Problem3060

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 2e6+5;
const int N = 1e6+5;
int fa[N],rnk[N];
int a[M],b[M];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(rnk[x]>rnk[y])
		fa[y] = x;
	else
	{
		fa[x] = y;
		rnk[y]+=rnk[x]==rnk[y];
	}
}
int main()
{
	int n,m,k,x,y,cnt = 0;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		if(x<=k||y<=k)
		{
			a[++cnt] = x;
			b[cnt] = y;
		}else uni(x,y);
	}
	int ans = 0;
	for(int i = 1;i<= cnt;i++)
	{
		int fx = getfa(a[i]),fy = getfa(b[i]);
		if(fx==fy)ans++;
		else uni(a[i],b[i]);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3065

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double beta = 0.75;
const int N = 7e4;
const int M = 1e7+5;
struct seg
{int l,r,sum;}a[M];
vector<int>rec,T,P;
int root[140005],ls[140005],rs[140005],v[140005],dfn[140005];
int n,m,size,lastans,tmp,Root;
int newnode()
{
	if(!rec.size())return ++size;
	else
	{
		int k = rec.back();rec.pop_back();
		return k;
	}
}
void Free(int &x)
{
	if(!x)return ;
	rec.push_back(x);
	Free(a[x].l),Free(a[x].r);
	a[x].sum =0;x = 0;
}
void Insert(int &p,int l,int r,int pos,int num)
{
	if(!p)p = newnode();
	if(l==r){a[p].sum+=num;return ;}
	int mid=(l+r)>>1;
	if(pos<=mid)Insert(a[p].l,l,mid,pos,num);
	else Insert(a[p].r,mid+1,r,pos,num);
	a[p].sum = a[a[p].l].sum+a[a[p].r].sum;
	if(!a[p].sum)Free(p);
}
void build(int &p,int l,int r)
{
	if(l>r)return ;
	if(l==r)
	{
		p = dfn[l];
		Insert(root[p],0,N,v[p],1);
		return ;
	}
	int mid=(l+r)>>1;
	p = dfn[mid];
	build(ls[p],l,mid-1);build(rs[p],mid+1,r);
	for(int i = l;i<=r;i++)
		Insert(root[p],0,N,v[dfn[i]],1);
}
void del(int &x)
{
	if(!x)return ;
	Free(root[x]);
	del(ls[x]);P.push_back(x);del(rs[x]);
	x = 0;
}
void rebuild(int &x)
{
	del(x);
	int s1 = P.size();
	for(int i = 1;i<= s1;i++)dfn[i] = P[i-1];
	build(x,1,s1);
	P.clear();
}
int update(int p,int x,int val)
{
	Insert(root[p],0,N,val,1);
	int t,lsize = a[root[ls[p]]].sum;
	if(x==lsize+1){t=v[p];v[p] = val;}
	else if(lsize>=x)t=update(ls[p],x,val);
	else t=update(rs[p],x-lsize-1,val);
	Insert(root[p],0,N,t,-1);
	return t;
}
void getans(int p,int l,int r)
{
	int L = a[root[ls[p]]].sum,R = a[root[p]].sum;
	if(l==1&&R==r){T.push_back(root[p]);return ;}
	if(l<=L+1&&r>=L+1)P.push_back(v[p]);
	if(r<=L)getans(ls[p],l,r);
	else if(l>L+1)getans(rs[p],l-L-1,r-L-1);
	else
	{
		if(l<=L)getans(ls[p],l,L);
        if(R>L+1)getans(rs[p],1,r-L-1);
	}
}
int Getans(int L,int R,int K)
{
	getans(Root,L,R);
	K--;
	int l = 0,r = N;
	int s1=T.size(),s2 = P.size();
	while(l<r)
	{
		int mid = (l+r)>>1,sum=0;
		for(int i = 0;i<s1;i++)sum+=a[a[T[i]].l].sum;
		for(int i = 0;i<s2;i++)
			if(P[i]>=l&&P[i]<=mid)
				sum++;
		if(K<sum)
		{
			for(int i = 0;i<s1;i++)T[i]=a[T[i]].l;
			r=mid;
		}else
		{
			for(int i = 0;i<s1;i++)T[i]=a[T[i]].r;
			l = mid+1;K-=sum;
		}
	}
	T.clear();P.clear();
	return l;
}
void Insert(int &p,int x,int val)
{
	if(!p)
	{
		p=++n;
		Insert(root[p],0,N,val,1);
		v[p] =val;
		return ;
	}
	Insert(root[p],0,N,val,1);
	int lsize = a[root[ls[p]]].sum;
	if(x<=lsize)Insert(ls[p],x,val);
	else Insert(rs[p],x-lsize-1,val);
	if(a[root[p]].sum*beta>max(a[root[ls[p]]].sum,a[root[rs[p]]].sum))
	{
		if(tmp)
		{
			if(ls[p]==tmp)rebuild(ls[p]);
			else rebuild(rs[p]);
			tmp = 0;
		}
	}else tmp = p;  
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&v[i]);
	for(int i = 1;i<= n;i++)dfn[i] = i;
	build(Root,1,n);
	scanf("%d",&m);
	int x,y,K;char opt[3];
	while(m--)
	{
		scanf("%s%d%d",opt,&x,&y);
		x = x^lastans,y = y^lastans;
		switch(opt[0])
		{
			case 'Q':scanf("%d",&K);K = K^lastans;lastans = Getans(x,y,K);printf("%d\n",lastans);break;
			case 'M':update(Root,x,y);break;
			case 'I':tmp = 0;Insert(Root,x-1,y);if(tmp){tmp = 0;rebuild(Root);}break;
		}
		//printf("%d %d ",x,y);
		//if(opt[0]=='Q')printf("%d\n",K);
		//else printf("\n");
	}
	return 0;
}
Problem3083

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E{int next,to;}e[N<<1];
int head[N],tot,n,m,logx[N],root;
long long f[N<<2];
long long minn[N<<2];
long long INF;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int deep[N],top[N],fa[N],son[N],w[N],size[N],end[N],cnt;
int anc[18][N];
bool v[N];
void init()
{
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<=n;i++)
			anc[j][i] = anc[j-1][anc[j-1][i]];
}
void dfs1(int x,int dep)
{
	deep[x] = dep;
	v[x] = true;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	end[x] = cnt;
}
void push_down(int p)
{
	f[p<<1] = f[p];
	f[(p<<1)+1] = f[p];
	minn[p<<1] = f[p];
	minn[(p<<1)+1] = f[p];
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b,long long c)
{
	if(l>=a&&r<=b)
		{f[p] = c;minn[p] = c;return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update((p<<1)+1,mid+1,r,a,b,c);
	minn[p] = min(minn[p<<1],minn[(p<<1)+1]);
	return ;
}
long long getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return minn[p];
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	long long ans = INF;
	if(a<=mid)
		ans = min(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)
		ans = min(ans,getans((p<<1)+1,mid+1,r,a,b));
	return ans;
}
void get_update(int x,int y,long long c)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		update(1,1,n,w[top[x]],w[x],c);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	update(1,1,n,w[y],w[x],c);
}
long long Ask(int x)
{
	if(w[root]<w[x]||w[root]>end[x])
		return getans(1,1,n,w[x],end[x]);
	else if(root==x)
		return minn[1];
	else
	{
		int tmp = root;
		for(int j = 17;j>=0;j--)
			if(deep[fa[anc[j][tmp]]]>=deep[x])
				tmp = anc[j][tmp];
		long long ans = INF;
		ans = min(ans,getans(1,1,n,1,w[tmp]-1));
		ans = min(ans,getans(1,1,n,end[tmp]+1,n));
		return ans;
	}
}
int main()
{
	memset(minn,0x3f,sizeof(minn));
	INF = minn[0];
	int x,y;long long z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	long long tmp;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&tmp);
		update(1,1,n,w[i],w[i],tmp);
		anc[0][i]= fa[i];
	}
	init();
	scanf("%d",&root);
	int opt;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1){scanf("%d",&x);root = x;}
		else if(opt==2){scanf("%d%d%lld",&x,&y,&z);get_update(x,y,z);}
		else {scanf("%d",&x);printf("%lld\n",Ask(x));}
	}
	return 0;
}
Problem3100

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+2;
ll a[N];
int last[N];
int i,n,ans,mx,wz;
void calc()
{
	int j,l;
	ans = max(ans,1);
	mx = 1;
	l = last[a[i]-a[i-1]];
	last[a[i]-a[i-1]] = i;
	wz = l+1;
	for(j = i+1;j<= n+1;j++)
	{
		if(j>n||a[j]-a[j-1]==1)break;
		l = last[a[j]-a[j-1]];
		last[a[j]-a[j-1]] = j;
		wz = max(wz,l);
		mx = max(mx,int(a[j]-a[j-1]));
		if(wz<=j-mx+1)
			if(a[j]-a[j-mx]==(ll)mx*(mx+1)/2)
				ans = max(ans,mx);
	}
	i = j;
}
int main()
{
	scanf("%d",&n);
	for(i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	for(i = 1;i<= n;i++)a[i]+=a[i-1];
	for(i = 1;i<= n;i++)
	{
		if(a[i]-a[i-1]==1)break;
		last[a[i]-a[i-1]]=i;
	}
	while(i<=n)calc();
	for(i = n;i>= 1;i--)a[i]-=a[i-1];
	for(i = 1;i<= n/2;i++)swap(a[i],a[n-i+1]);
	for(i = 1;i<= n;i++)a[i]+=a[i-1];
	for(i = 1;i<= n;i++)last[i]=0;
	for(i = 1;i<= n;i++)
	{
		if(a[i]-a[i-1]==1)break;
		last[a[i]-a[i-1]]=i;
	}
	while(i<=n)calc();
	printf("%d\n",ans);	
	return 0;
}
Problem3110

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
typedef long long ll;
using namespace std;
const int N = 5e4+5;
const int M = 2e7+5;
int root[N<<2];
int ls[M],rs[M],lazy[M];
ll sum[M];
int tot,n,m;
void push_down(int p,int l,int r)
{
	if(!lazy[p]||l==r)return ;
	if(!ls[p])ls[p] = ++tot;
	if(!rs[p])rs[p] = ++tot;
	lazy[ls[p]]+=lazy[p];
	lazy[rs[p]]+=lazy[p];
	int mid = (l+r)>>1;
	sum[ls[p]]+=(mid-l+1)*lazy[p];
	sum[rs[p]]+=(r-mid)*lazy[p];
	lazy[p] = 0;
}
void update(int &p,int l,int r,int a,int b)
{
	if(!p)p = ++tot;
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sum[p]+=r-l+1;
		lazy[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(ls[p],l,mid,a,b);
	if(b >mid)update(rs[p],mid+1,r,a,b);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
ll getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	push_down(p,l,r);
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1;ll ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
void insert(int a,int b,int c)
{
	int l = 1,r = n,p = 1;
	while(l!=r)
	{
		int mid=(l+r)>>1;
		update(root[p],1,n,a,b);
		if(c<=mid)r = mid,p = p<<1;
		else l = mid+1,p = p<<1|1;
	}
	update(root[p],1,n,a,b);
}
int solve(int a,int b,ll c)
{
	int l = 1,r = n,p = 1;
	while(l!=r)
	{
		int mid = (l+r)>>1;
		ll tmp = getans(root[p<<1],1,n,a,b);
		if(tmp>=c)r = mid,p = p<<1;
		else l = mid+1,p = p<<1|1,c-=tmp;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	int opt,a,b,c;
	for(int i= 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&opt,&a,&b,&c);
		if(opt==1)
			insert(a,b,n-c+1);
		else
			printf("%d\n",n-solve(a,b,c)+1);
	}
	return 0;
}
Problem3122

#include <stdio.h>
#include <map>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll x,y;
ll ex_gcd(ll a,ll b)
{
	if(b==0)
	{
		x = 1,y = 0;
		return a;
	}
	ll ans = ex_gcd(b,a%b);
	ll c = x;
	x = y;
	y = c-a/b*y;
	return ans;
}
ll getenv(ll X,ll c)
{
	ex_gcd(X,c);
	ll tmp = x;
	tmp = (tmp%c+c)%c;
	return tmp;
}
map<int,int>Pow;
int powA[100005];
ll A,B,C;
ll work()
{
	Pow.clear();
	//scanf("%lld%lld%lld",&A,&C,&B);
	if(A%C==0&&B!=0)return -1;
	ll D = 1;
	ll tmp = 1;
	for(int i = 0;i<=50;i++)
	{
		if((tmp%=C)==B)return i;
		tmp = tmp*A%C;
	}
	ll k = 0,gcd = ex_gcd(A,C);
	while(gcd!=1)
	{
		k++;
		if(B%gcd!=0)return -1;
		B/=gcd,C/=gcd,D*=A/gcd;
		D%=C;
		gcd = ex_gcd(A,C);
	}
	B*=getenv(D,C),B%=C;
	int m = ceil(sqrt(C)+1e-5);
	powA[0] = 1;Pow[1] = 0;
	for(int i = 1;i<= m;i++)
	{
		powA[i] = powA[i-1]*A%C;
		if(powA[i]==B)return i+k;
		Pow[powA[i]] = i;
	}
	D = 1;
	for(int i = 0;i<= m;i++)
	{
		ex_gcd(D,C);
		x = (x*B%C+C)%C;
		if(Pow.find(x)!=Pow.end())
			return (ll)i*m+k+Pow[x];
		D=D*powA[m]%C;
	}
	return -1;
}
ll solve()
{
	ll p,a,b,x1,t,tmp;
	scanf("%lld%lld%lld%lld%lld",&p,&a,&b,&x1,&t);
	if(x1==t)return 1;
	if(!a)return b==t?2:-1;
	if(a==1)
	{
		t+=p-x1,t%=p;
		tmp = ex_gcd(b,p);
		if(t%tmp)return -1;
		b/=tmp,p/=tmp,t/=tmp;
		ex_gcd(b,p);
		tmp = (x*t%p+p)%p;
		return tmp+1;
	}
	ll Y = (a*x1-x1+b)%p;
	ll Z = (a*t-t+b)%p;
	tmp = ex_gcd(Y,p);
	if(Z%tmp)return -1;
	Z/=tmp,Y/=tmp,p/=tmp;
	C = p;
	B = Z*getenv(Y,C)%p;
	A = a;
	tmp = work();
	if(tmp==-1)return -1;
	else return tmp+1;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
		printf("%lld\n",solve());
	return 0;
}
Problem3123

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
const int M = 32*17*N;
struct E
{int next,to;}e[N<<2];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int fa[N][18];
int sz[M],ls[M],rs[M],root[N];
int q[N],a[N],T[N],F[N],dep[N],size[N];
int cnt;
void update(int &p,int pre,int l,int r,int x)
{
	p = ++cnt;
	ls[p] = ls[pre],rs[p] = rs[pre];
	sz[p] = sz[pre]+1;
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(x<=mid)
		update(ls[p],ls[pre],l,mid,x);
	else update(rs[p],rs[pre],mid+1,r,x);
}
int getans(int l,int r,int k,int x,int y,int u,int v)
{
	if(l==r)return T[l];
	int mid = (l+r)>>1;
	if(sz[ls[x]]+sz[ls[y]]-sz[ls[u]]-sz[ls[v]]>=k)
		return getans(l,mid,k,ls[x],ls[y],ls[u],ls[v]);
	else return getans(mid+1,r,k-(sz[ls[x]]+sz[ls[y]]-sz[ls[u]]-sz[ls[v]]),rs[x],rs[y],rs[u],rs[v]);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void init(int x)
{
	for(int j = 1;j<= 17;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
}
int top;
void DFS(int x)
{
    int l = 1, r = 0;
    q[++r] = x;
    while(l<=r)
    {
        int tt = q[l++]; 
        init(tt);
        update(root[tt],root[fa[tt][0]],1,top,a[tt]);
        for(int i=head[tt];i;i=e[i].next)
            if(e[i].to!=fa[tt][0])
            {
                fa[e[i].to][0] = tt;
                dep[e[i].to] = dep[tt]  + 1;
                q[++r] = e[i].to;
            }
    }
}
int find(int x)
{
	if(F[x]==x||!F[x])return F[x] = x;
	else return F[x] = find(F[x]);
}
int main()
{
	int p;
	scanf("%d",&p);
	int n,m,t;
	scanf("%d%d%d",&n,&m,&t);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		T[i] = a[i];
	}
	sort(T+1,T+n+1);
	for(int i = 1;i<= n;i++)
		if(T[i]!=T[i-1])
			T[++top] = T[i];
	for(int i = 1;i<= n;i++)
		a[i] = lower_bound(T+1,T+top+1,a[i])-T;
	for(int i = 1;i<= n;i++)size[i] = 1;
	int x,y,z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		int fx = find(x),fy = find(y);
		if(fx==fy)continue;
		if(size[fx]<size[fy])swap(fx,fy);
		size[fx]+=size[fy];
		F[fy] = fx;
	}
	for(int i = 1;i<= n;i++)
		if(!root[i])
		{
			dep[i] = 1;
			DFS(i);
		}
	char opt[3];
	int ans=0;
	for(int i = 1;i<= t;i++)
	{
		scanf("%s%d%d",opt,&x,&y);
		x = x^ans,y = y^ans;
		if(opt[0]=='L')
		{
			add(x,y);
			int fx = find(x),fy = find(y);
			if(size[fx]<size[fy])
				swap(fx,fy),swap(x,y);
			F[fy] = fx;size[fx]+=size[fy];
			fa[y][0] = x;dep[y] = dep[x]+1;
			DFS(y);
		}else
		{
			scanf("%d",&z);z = z^ans;
			int u = getlca(x,y);int v = fa[u][0];
			printf("%d\n",ans = getans(1,top,z,root[x],root[y],root[u],root[v]));
		}
	}
	return 0;
}
Problem3132

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2049;
struct T
{
	int a[N][N];
	T()
	{memset(a,0,sizeof(a));}
	void update(int x,int y,int c)
	{
		for(int i = x;i<N;i+=i&(-i))
			for(int j = y;j<N;j+=j&(-j))
				a[i][j]+=c;
	}
	int getans(int x,int y)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			for(int j = y;j>0;j-=j&(-j))
				ans+=a[i][j];
		return ans;
	}
}A,B,C,D;
void update(int x1,int x2,int y1,int y2,int d)
{
	A.update(x1,y1,d),A.update(x2+1,y1,-d);
	A.update(x1,y2+1,-d),A.update(x2+1,y2+1,d);

	B.update(x1,y1,d*x1),B.update(x2+1,y1,-d*(x2+1));
	B.update(x1,y2+1,-d*x1),B.update(x2+1,y2+1,d*(x2+1));

	C.update(x1,y1,d*y1),C.update(x2+1,y1,-d*y1);
	C.update(x1,y2+1,-d*(y2+1)),C.update(x2+1,y2+1,d*(y2+1));

	D.update(x1,y1,d*x1*y1),D.update(x2+1,y1,-d*(x2+1)*y1);
	D.update(x1,y2+1,-d*x1*(y2+1)),D.update(x2+1,y2+1,d*(x2+1)*(y2+1));
}
int getb(int x,int y)
{
	return (x+1)*(y+1)*A.getans(x,y)-(x+1)*C.getans(x,y)-(y+1)*B.getans(x,y)+D.getans(x,y);
}
int main()
{
	int n,m,a,b,c,d,z;
	char ju[3];
	scanf("%s",ju);
	scanf("%d%d",&n,&m);
	while(scanf("%s",ju)!=EOF)
	{
		if(ju[0]=='k')
		{
			scanf("%d%d%d%d",&a,&b,&c,&d);
			int ans = 0;
			ans += getb(c,d)-getb(a-1,d)-getb(c,b-1)+getb(a-1,b-1);
			printf("%d\n",ans);
		}
		else
		{
			scanf("%d%d%d%d%d",&a,&b,&c,&d,&z);
			update(a,c,b,d,z);
		}
	}
	return 0;
}
Problem3143

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 505;
const double eps = 1e-8;
struct E
{int next,to;}e[N*N];
int head[N],tot,n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double f[N][N],cnt[N];
double Ans[N*N],ans[N];
void work()
{
	for(int i = 1;i< n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(xn,i);
		for(int line = i+1;line<= n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = 1;j<= n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n-1;i>= 1;i--)
	{
		for(int j = i+1;j<= n;j++)
			f[i][n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n+1]/f[i][i];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
		cnt[u]+=1.0;cnt[v]+=1.0;
	}
	for(int i = 1;i< n;i++)
	{
		for(int j = head[i];j;j = e[j].next)
			f[i][e[j].to] += 1.0/cnt[e[j].to];
		f[i][i]-=1.0;
	}
	f[1][n+1]-=1.0;
	work();
	int tmp = 0;
	for(int i = 1;i< n;i++)
	{
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to>i)
				Ans[++tmp] = ans[i]/cnt[i]+ans[e[j].to]/cnt[e[j].to];
	}
	sort(Ans+1,Ans+tmp+1);
	double t_ans = 0;
	for(int i = 1;i<= tmp;i++)
		t_ans+=Ans[i]*(m-i+1);
	printf("%.3f\n",t_ans);
	return 0;
}
Problem3155

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long LL;
LL sum[N<<2],lazy[N<<2];
LL pre[N],a[N];
void build(int p,int l,int r)
{
	if(l==r){sum[p] = pre[l];return ;}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
void push_down(int p,int l,int r)
{
	if(l==r){lazy[p] = 0;return ;}
	int mid = (l+r)>>1;
	lazy[p<<1] += lazy[p];
	lazy[p<<1|1] +=lazy[p];
	sum[p<<1] += lazy[p]*(mid+1-l);
	sum[p<<1|1]+=lazy[p]*(r-mid);
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,LL dec)
{
	if(lazy[p])push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=dec;
		sum[p] = sum[p]+dec*(r-l+1);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,dec);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,dec);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
LL get_ans(int p,int l,int r,int a,int b)
{
	if(lazy[p])push_down(p,l,r);
	if(l>=a&&r<=b)
		return sum[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans+=get_ans(p<<1,l,mid,a,b);
	if(b>mid)ans+=get_ans(p<<1|1,mid+1,r,a,b);
	//sum[p] = sum[p<<1]+sum[p<<1|1];
	return ans;
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&a[i]);
		pre[i] = pre[i-1]+a[i];
	}
	build(1,1,n);
	char ju[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",ju);
		if(ju[0]=='M')
		{
			scanf("%d%d",&x,&y);
			LL dec = y-a[x];
			update(1,1,n,x,n,dec);
			a[x] = y;
		}else
		{
			scanf("%d",&x);
			printf("%lld\n",get_ans(1,1,n,1,x));
		}
	}
	return 0;
}
Problem3156

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
int a[N],line[N],l,r;
LL f[N];
double calc(int j,int k)
{
	return ((double)(f[j]-f[k])*2+(double)j*(j+1)-(double)k*(k+1))/(double)(j-k);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
	{
		while(l<r&&calc(line[l+1],line[l])<2*i)l++;
		if(l<=r)f[i] = f[line[l]]+(LL)(i-line[l]-1)*(i-line[l])/2+a[i];
		while(l<r&&calc(line[r],line[r-1])>calc(i,line[r]))r--;
		line[++r] = i;
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem3160

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 8e5+5;
typedef double db;
typedef long long ll;
const int mod = 1e9+7;
const db PI = 3.14159265358979323;
char s[N];
struct cp
{
	db x,y;
	friend cp operator+(const cp &a,const cp &b)
	{
		return (cp){a.x+b.x,a.y+b.y};
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return (cp){a.x-b.x,a.y-b.y};
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return (cp){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};
	}
}a[M],b[M],c[M];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i= 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<=len;i<<=1)
	{
		cp wn = (cp){cos(2*PI*type/i),sin(2*PI*type/i)};
		for(int j = 0;j<len;j+=i)
		{
			cp w = (cp){1,0},tmp;
			for(int k = 0;k<(i>>1);k++,w = w*wn)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[M];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1);FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i] = a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)
		ans[i] += (int)(c[i].x+0.1);
}
int pow2[N<<1];
void init()
{
	pow2[0] = 1;
	for(int i = 1;i<N*2;i++)
		pow2[i] = pow2[i-1]*2%mod;
}
char tt[N<<1];int p[N<<1],no[N<<1];
ll tot,Ans;
void manacher(int n)
{
	int lth = 0;
	int maxp = 1,id = 1;
	for(int i = 0;i<n;i++)
	{
		tt[++lth] = s[i];
		no[lth] = i+1;
		if(i!=n-1)tt[++lth]='^';
	}
	for(int i = 1;i<= lth;i++)
	{
		if(maxp>i)p[i] = min(p[id*2-i],maxp-i);
		else p[i] = 0;
		while(i+p[i]<=lth&&i-p[i]>=1&&tt[i+p[i]]==tt[i-p[i]])p[i]++;
		p[i]--;
		if(i+p[i]>maxp)maxp = i+p[i],id = i;
		tot+=(no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1])-(no[i]?no[i]:no[i+1])+1;
	}
}
int main()
{
	init();
	scanf("%s",s);
	int n = strlen(s);
	for(int i = 0;i<n;i++)
	{
		a[i].x = (s[i]=='b')?0:1;
		b[i].x = a[i].x;
		a[i].y = b[i].y = 0;
	}
	int len = 1,m= 2*n;
	while(len<=m)len = len<<1;
	len = len<<1;
	conv(a,b,c,len);
	//for(int i = 0;i<len;i++)
	//	printf("%d ",ans[i]);
	//printf("\n");
	for(int i = 0;i<len;i++)
	{
		if(i<n)a[i].x = (s[i]=='a')?0:1;
		else a[i].x = 0;
		b[i].x = a[i].x;
		a[i].y = b[i].y = c[i].x = c[i].y = 0;
	}
	conv(a,b,c,len);
	//for(int i = 0;i<m-1;i++)
	//	printf("%d ",ans[i]);
	for(int i = 0;i<m;i++)
	{
		int tmp = (ans[i]+1)>>1;
		(Ans+=pow2[tmp]-1)%=mod;
	}
	manacher(n);
	Ans = ((Ans-tot)%mod+mod)%mod;
	printf("%lld\n",Ans);
	return 0;
}
Problem3162

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int mod = 1e9+7;
const int sed = 377;
const int N = 5e5+5;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot=1,n,rot,cgs[2];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	//e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],stack[N];
ull hash[N];
ll f[N][2],inv[N];
void Init()
{
	inv[1] = 1;
	for(int i = 2;i<= n;i++)
		inv[i] = (ll)(mod-mod/i)*inv[mod%i]%mod;
}
ll C(ll n,ll m)
{
	ll res = 1;
	n%=mod;
	for(int i = 1;i<= m;i++)
		(res*=(ll)(n-i+1)*inv[i]%mod)%=mod;
	return res;
}
bool cmp(int x,int y)
{
	return hash[x]<hash[y];
}
void dfs(int x,int fa)
{
	bool flag = true;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa)
	{
		dfs(e[i].to,x);
		size[x]+=size[e[i].to];
		if(size[e[i].to]<<1>n)
			flag = false;
	}
	if((n-size[x])<<1>n)
		flag = false;
	if(flag)
		(cgs[0]?cgs[1]:cgs[0])=x;
}
void DP(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			DP(e[i].to,x);
	int top = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			stack[++top] = e[i].to;
	sort(stack+1,stack+top+1,cmp);
	hash[x] = sed;
	f[x][0]=f[x][1]=1;
	int j;
	for(int i = 1;i<= top;i=j)
	{
		for(j = i+1;j<=top&&hash[stack[i]]==hash[stack[j]];j++);
		(f[x][0]*=C(j-i+f[stack[i]][0]+f[stack[i]][1]-1,j-i))%=mod,
		(f[x][1]*=C(j-i+f[stack[i]][0]-1,j-i))%=mod;
	}
	for(int i = 1;i<= top;i++)
	{
		hash[x] = hash[x]*sed+hash[stack[i]];
		hash[x] = (hash[x]^hash[stack[i]])+hash[stack[i]];
	}
}
int main()
{
	scanf("%d",&n);
	Init();
	int x,y;
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs(1,0);
	if(cgs[1])
	{
		for(int i = head[cgs[0]];i;i=e[i].next)
			if(e[i].to==cgs[1])
			{
				e[i].to = e[i^1].to = rot = n+1;
				break;
			}
		add(n+1,cgs[0]);
		add(n+1,cgs[1]);
	}else rot = cgs[0];
	DP(rot,0);
	ll ans = 0;
	if(!cgs[1])
		ans = (f[rot][0]+f[rot][1])%mod;
	else
	{
		x=cgs[0];y=cgs[1];
        if(hash[x]!=hash[y])
            ans=(f[x][0]*f[y][0]%mod+f[x][1]*f[y][0]%mod+f[x][0]*f[y][1]%mod)%mod;
        else
            ans=(f[x][0]*f[y][1]+C(f[x][0]+1,2) )%mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3166

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int M = 35*N;
const int INF = 1e9+1;
int root[N];
set<int>q;
struct Data{int pos,val;}a[N];
bool operator<(Data a,Data b)
{
	return a.val>b.val;
}
struct Trie
{
	int ch[M][2],cnt,sum[M];
	int insert(int x,int num)
	{
		int tmp,y;
		tmp=y=++cnt;
		for(int i=30;i>=0;i--)
		{
			int t = num&(1<<i);t=t>>i;
			ch[y][0] = ch[x][0];
			ch[y][1] = ch[x][1];
			x = ch[x][t];
			y = ch[y][t] = ++cnt;
			sum[y]=sum[x]+1;
		}
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 30;i>= 0;i--)
		{
			int t = val&(1<<i);t=t>>i;
			if(sum[ch[r][t^1]]-sum[ch[l][t^1]]>0)
				l=ch[l][t^1],r = ch[r][t^1],ans+=(1<<i);
			else l = ch[l][t],r = ch[r][t];
		}
		return ans;
	}
}trie;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%d",&a[i].val);
		a[i].pos = i;
	}
	for(int i = 1;i<= n;i++)
		root[i] = trie.insert(root[i-1],a[i].val);
	q.insert(-2),q.insert(-1),q.insert(INF),q.insert(INF+1);
	sort(a+1,a+n+1);
	q.insert(a[1].pos);
	int ans = 0;
	for(int i = 2;i<= n;i++)
	{
		int l = a[i].pos,r = a[i].pos,x = a[i].pos;
		set<int>::iterator t,p;
		p=q.lower_bound(x);
		t = p;
		r = *t;t++;r = *t-1;
		l = *--p;p--;l=*p+1;
		l = max(1,l),r = min(r,n);
		if(l!=r)ans = max(ans,trie.getans(root[l-1],root[r],a[i].val));
		q.insert(x);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3170

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct P
{
	ll x,y;
	P(){}
	P(ll x,ll y):x(x+y),y(x-y){}

}p[N];
int n;
ll X[N],Y[N],ans = 1e18;
ll sumx[N],sumy[N];
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		p[i]=P(x,y);
		X[i] = p[i].x,Y[i] = p[i].y;
	}
	sort(X+1,X+n+1);
	sort(Y+1,Y+n+1);
	for(int i = 1;i<= n;i++)
	{
		sumx[i] = sumx[i-1]+X[i];
		sumy[i] = sumy[i-1]+Y[i];
	}
	ll tmp=0;
	int pos;
	for(int i = 1;i<= n;i++)
	{
		tmp = 0;
		pos = lower_bound(X+1,X+n+1,p[i].x)-X;
		tmp+=(p[i].x*pos-sumx[pos])+((sumx[n]-sumx[pos])-p[i].x*(n-pos));
		pos = lower_bound(Y+1,Y+n+1,p[i].y)-Y;
		tmp+=(p[i].y*pos-sumy[pos])+((sumy[n]-sumy[pos])-p[i].y*(n-pos));
		ans = min(ans,tmp);
	}
	printf("%lld\n",ans>>1);
	return 0;
}
Problem3171

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int nxt,to,fr,f,c;}e[M];
int head[N],tot=1;
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].nxt=head[x];head[x]=tot;
	e[tot].f=f,e[tot].c=c;e[tot].fr=x;
	e[++tot].to=x;e[tot].nxt=head[y];head[y]=tot;
	e[tot].f=0,e[tot].c=-c;e[tot].fr=y;
}
int from[N],dis[N],S,T;
bool v[N];
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	dis[S] = 0,v[S] = true;
	Q.push(S);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].nxt)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans,mxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	mxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
int id[20][20][2];
int map[20][20];
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
int main()
{
	int cnt = 0;
	int l,r;
	char s[20];
	scanf("%d%d",&l,&r);
	for(int i = 1;i<= l;i++)
	{
		scanf("%s",s+1);
		for(int j=1;j<= r;j++)
		{
			if(s[j]=='U')map[i][j]=0;
			else if(s[j]=='D')map[i][j]=1;
			else if(s[j]=='L')map[i][j]=2;
			else map[i][j]=3;
		}
	}
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			for(int k = 0;k<2;k++)
				id[i][j][k]=++cnt;
	S = 0,T =cnt+1;
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			for(int d = 0;d<4;d++)
			{
				int nx = i+dx[d],ny = j+dy[d];
				if(nx<1)nx=l;if(ny<1)ny=r;
				if(nx>l)nx=1;if(ny>r)ny=1;
				if(map[i][j]==d)add(id[i][j][0],id[nx][ny][1],1,0);
				else add(id[i][j][0],id[nx][ny][1],1,1);
			}
	for(int i = 1;i<= l;i++)
		for(int j = 1;j<= r;j++)
			add(S,id[i][j][0],1,0),add(id[i][j][1],T,1,0);
	while(spfa())mcf();
	printf("%d\n",ans);
	return 0;
}
Problem3172

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int LEN = 1e6+5;
const int N = 205;
int pos[N];
char s[LEN];
#define s(i) (s[i]-'a')
struct AC_Machine
{
	int ch[LEN][26],sum[LEN],fail[LEN],q[LEN];
	int cnt,h,t;
	AC_Machine()
	{
		cnt = 1;
		for(int i = 0;i<26;i++)
			ch[0][i]=1;
	}
	void insert(int &pos)
	{
		int i = 0,now = 1;
		while(s[i])
		{
			if(!ch[now][s(i)])
				ch[now][s(i)] = ++cnt;
			now = ch[now][s(i)];
			sum[now]++;
			i++;
		}
		pos = now;
	}
	void build()
	{
		h = 0,t = -1;
		q[++t] = 1;fail[1] = 0;
		while(h<=t)
		{
			int x = q[h++];
			for(int i = 0;i<26;i++)
			{
				int to = ch[x][i];
				if(!to)continue;
				int k = fail[x];
				while(!ch[k][i])k=fail[k];
				fail[to]=ch[k][i];
				q[++t] = to;
			}
		}
		for(int i = t;i>=0;i--)
			sum[fail[q[i]]]+=sum[q[i]];
	}
}AC;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		AC.insert(pos[i]);
	}
	AC.build();
	for(int i = 1;i<= n;i++)
		printf("%d\n",AC.sum[pos[i]]);
	return 0; 
}
Problem3172

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+500;
char s[N];
int size[N<<1],pos[205];
queue<int>q;
struct SAM
{
	int trs[N<<1][27],fa[N<<1],len[N<<1],ind[N<<1],size[N<<1];
	int cnt,last;
	int end[N<<1];
	void init(){cnt=last=1;}
	int insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np]=len[p]+1;
		size[np]++;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
		return np;
	}
	void build()
	{
		for(int i=1;i<=cnt;i++)ind[fa[i]]++;
		for(int i=1;i<=cnt;i++)
			if(!ind[i])q.push(i);
		while(!q.empty())
		{
			int t=q.front();q.pop();
			if((--ind[fa[t]])==0)q.push(fa[t]);
			size[fa[t]]+=size[t];
		}
	}
}sam;
int beg[205],lth[205];
int main()
{
	int n,ll=0;
	sam.init();
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+ll+1);
		beg[i] = ll+1;
		ll+=(lth[i]=strlen(s+ll+1));
		s[++ll]='a'-1;
	}
	for(int i=1;i<=ll;i++)
        sam.insert(s[i]-'a'+1);
    sam.build();
	for(int i=1;i<=n;i++)
    {
        int now=1;
        for(int j=beg[i];j<=beg[i]+lth[i]-1;j++)
            now=sam.trs[now][s[j]-'a'+1];
        printf("%d\n",sam.size[now]);
    }
	return 0;
}
Problem3191

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int n,m;
double f[55][55];
int a[55];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i= 1;i<= m;i++)scanf("%d",&a[i]);
	f[1][1] = 1;
	for(int i = 2;i<= n;i++)
	{
		for(int j = 1;j<= i;j++)
		{
			for(int k = 1;k<= m;k++)
			{
				int tmp = a[k]%i;
				if(tmp==0)tmp = i;
				if(tmp==j)continue;
				if(tmp>j)tmp = i-tmp+j;
				else tmp = j-tmp;
				f[i][j] += f[i-1][tmp]/(double)m;
			}
		}
	}
	for(int i = 1;i< n;i++)
		printf("%.2lf%c ",f[n][i]*100.0,'%');
	printf("%.2lf%c",f[n][n]*100.0,'%');
	return 0;
}
Problem3192

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct P
{
    int tt,no,ss;
}num[100005];
int pos[100005],c[100005],lim;
bool cmp1(P a,P b){return a.tt<b.tt;}
bool cmp2(P a,P b){return a.no<b.no;}
void update(int x)
{
    for(int i = x;i<=lim;i+=(i&(-i)))
        c[i]--;
}
int check(int x)
{
    int ans = 0;
    for(int i = x;i>0;i-=(i&(-i)))
        ans+=c[i];
    return ans;
}
int main()
{
    //freopen("all.in", "r", stdin);
    //freopen("all.out", "w", stdout);
    int n,m,x;
    scanf("%d%d",&n,&m);
    lim = n+m;
    int cnt = 0;
    for(int i = 1;i<=n;i++)
    {
        scanf("%d",&x);
        cnt++;num[cnt].tt = x;num[cnt].no = n-i;
    }
    for(int i = 1;i<= m;i++)
    {
        scanf("%d",&x);
        cnt++;num[cnt].tt = x;num[cnt].no = n+i;
    }
    sort(num+1,num+cnt+1,cmp1);
    for(int i = 1;i<= cnt;i++)
        num[i].ss = i;
    sort(num+1,num+cnt+1,cmp2);
    for(int i = 1;i<= cnt;i++)
        pos[num[i].ss] = i;
    //p_n为n与n+1之间的
    for(int i = 1;i<= lim;i++)
        c[i] = i&(-i);
    int p = n;int now = n+m;long long ans = 0;
    while(now>0)
    {
        int tmp = check(p);
        if(pos[now]>p)
        {
            ans += check(pos[now]-1)-tmp;
            p = pos[now]-1;
            update(pos[now]);
        }else
        {
            ans += tmp-check(pos[now]);
            p = pos[now];
            update(pos[now]);
        }
        now--;
    }
    printf("%lld",ans);
    return 0;
}
Problem3195

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<9;
const int M = 31;
const int mod = 1000000007;
int f[M+1][M][N][10];
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int end = (1<<(k+1))-1;
	f[2][0][0][0] = 1;
	for(int i = 2;i<= n;i++)
	{
		for(int j = 0;j<= m;j++)
		{
			for(int sta = 0;sta<=end;sta++)
			{
				for(int l = 0;l<k;l++)
				{
					(f[i][j][sta][l+1]+=f[i][j][sta][l])%=mod;
					if(j<m&&i-k+l>0)
						(f[i][j+1][sta^(1<<k)^(1<<l)][l]+=f[i][j][sta][l])%=mod;
				}
				if(!(sta&1))(f[i+1][j][sta>>1][0]+=f[i][j][sta][k])%=mod;
			}
		}
	}
	printf("%d\n",f[n+1][m][0][0]);
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(200037);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:scanf("%d%d%d",&l,&r,&k);tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:scanf("%d%d%d",&l,&r,&k);get_number(l,r,k);break;
			case 3:scanf("%d%d",&l,&k);change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:scanf("%d%d%d",&l,&r,&k);tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:scanf("%d%d%d",&l,&r,&k);tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<3)+(x<<1) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(200037);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i] = read();
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:l=read();r=read();k=read();tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:l=read();r=read();k=read();get_number(l,r,k);break;
			case 3:l=read();k=read();change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:l=read();r=read();k=read();tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:l=read();r=read();k=read();tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
const int INF = 1e8+1;
int a[N],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x<<3)+(x<<1) + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Treap
{
	Treap *ls,*rs;
	int val,cnt,size,key;
	Treap(int x);
	void push_up();
}*root[N<<2];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	key = rand();
	cnt = size = 1;
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)
		size+=ls->size;
	if(rs)
		size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int tmp;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)tmp+=x->ls->size;
		return ;
	}
	else if(x->val>y)get_rank(x->ls,y);
	else
	{
		tmp+=x->cnt;
		if(x->ls)
			tmp+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){get_rank(root[p],c);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,c);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,c);
}
void get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		tmp = 1;
		get_rank(1,1,n,x,y,mid);
		if(tmp<=c){l = mid+1;ans=  mid;}
		else r = mid-1;
	}
	printf("%d\n",ans);
}
void build(int p,int l,int r,int pos,int num)
{
	insert(root[p],num);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)build(p<<1,l,mid,pos,num);
	else build(p<<1|1,mid+1,r,pos,num);
}
void change(int p,int l,int r,int pos,int c,int d)
{
	Delete(root[p],c);
	insert(root[p],d);
	if(l==r)return ;
	int mid =(l+r)>>1;
	if(pos<=mid)change(p<<1,l,mid,pos,c,d);
	else change(p<<1|1,mid+1,r,pos,c,d);
}
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)
		get_pre(x->ls,y);
	else
	{
		tmp = max(tmp,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)
		get_sub(x->rs,y);
	else 
	{
		tmp = min(tmp,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_pre(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,num);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,num);
}
void get_sub(int p,int l,int r,int a,int b,int num)
{
	if(l>=a&&r<=b){get_sub(root[p],num);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,num);
	if(b>mid)get_sub(p<<1|1,mid+1,r,a,b,num);
}
void display_tree(Treap *x)
{
	if(!x)return ;
	display_tree(x->ls);
	for(int i = 1;i<= x->cnt;i++)
		printf("%d ",x->val);
	display_tree(x->rs);
}
void display_tree(int p,int l,int r)
{
	printf("%d %d:",l,r);
	display_tree(root[p]);
	printf("\n");
	if(l==r)return ;
	int mid = (l+r)>>1;
	display_tree(p<<1,l,mid);
	display_tree(p<<1|1,mid+1,r);
}
int main()
{
	srand(237);
	int opt,l,r,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i] = read();
	for(int i = 1;i<= n;i++)build(1,1,n,i,a[i]);
	//display_tree(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		switch(opt)
		{
			case 1:l=read();r=read();k=read();tmp = 1;get_rank(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 2:l=read();r=read();k=read();get_number(l,r,k);break;
			case 3:l=read();k=read();change(1,1,n,l,a[l],k);a[l] = k;break;
			case 4:l=read();r=read();k=read();tmp = 0;get_pre(1,1,n,l,r,k);printf("%d\n",tmp);break;
			case 5:l=read();r=read();k=read();tmp = INF;get_sub(1,1,n,l,r,k);printf("%d\n",tmp);break;
		}
	}
	return 0;
}
Problem3196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int INF = 1e8+1;
int a[N],n,m;
struct Treap
{
	Treap *ls,*rs;
	int val,key,cnt,size;
	Treap();
	Treap(int v);
	void Push_up();
}*root[N<<2];
Treap :: Treap()
{
	ls = rs = NULL;
	val = 0;
	key = rand();
	cnt = size = 0;
}
Treap :: Treap(int v)
{
	ls = rs = NULL;
	val = v;
	key = rand();
	cnt = size = 1;
}
void Treap :: Push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->Push_up();
	x->Push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->Push_up();
	x->Push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x=new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->Push_up();
}
void Delete(Treap *&x,int y)
{
	if(!x)return ;
	if(y<x->val)Delete(x->ls,y);
	else if(y>x->val)Delete(x->rs,y);
	else
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x = x->rs;
		else if(!x->rs)x = x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}
	if(x)x->Push_up();
}
int rnk;
void get_rank(Treap *x,int y)
{
	if(!x)return ;
	if(x->val==y)
	{
		if(x->ls)rnk+=x->ls->size;
		return ;
	}else if(y<x->val)get_rank(x->ls,y);
	else
	{
		rnk+=x->cnt;
		if(x->ls)rnk+=x->ls->size;
		get_rank(x->rs,y);
	}
}
void get_rank(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_rank(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_rank(p<<1,l,mid,a,b,v);
	if(b >mid)get_rank(p<<1|1,mid+1,r,a,b,v);
}
void Insert(int p,int l,int r,int pos,int v)
{
	Insert(root[p],v);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Insert(p<<1,l,mid,pos,v);
	else Insert(p<<1|1,mid+1,r,pos,v);
}
void Delete(int p,int l,int r,int pos,int v)
{
	Delete(root[p],v);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Delete(p<<1,l,mid,pos,v);
	else Delete(p<<1|1,mid+1,r,pos,v);
}
int pre,sub;
void get_pre(Treap *x,int y)
{
	if(!x)return ;
	if(x->val>=y)get_pre(x->ls,y);
	else
	{
		pre = max(pre,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(!x)return ;
	if(x->val<=y)get_sub(x->rs,y);
	else
	{
		sub = min(sub,x->val);
		get_sub(x->ls,y);
	}
}
void get_pre(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_pre(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_pre(p<<1,l,mid,a,b,v);
	if(b >mid)get_pre(p<<1|1,mid+1,r,a,b,v);
}
void get_sub(int p,int l,int r,int a,int b,int v)
{
	if(l>=a&&r<=b){get_sub(root[p],v);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)get_sub(p<<1,l,mid,a,b,v);
	if(b >mid)get_sub(p<<1|1,mid+1,r,a,b,v);
}
void Get_rank(int l,int r,int k)
{
	rnk = 1;
	get_rank(1,1,n,l,r,k);
	printf("%d\n",rnk);
}
void Get_sub(int l,int r,int k)
{
	sub = INF;
	get_sub(1,1,n,l,r,k);
	printf("%d\n",sub);
}
void Get_pre(int l,int r,int k)
{
	pre = -INF;
	get_pre(1,1,n,l,r,k);
	printf("%d\n",pre);
}
void Get_number(int x,int y,int c)
{
	int l = 0,r = INF,ans;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		rnk = 1;
		get_rank(1,1,n,x,y,mid);
		if(rnk<=c){l=mid+1,ans=mid;}
		else {r = mid-1;}
	}
	printf("%d\n",ans);
}
void update(int pos,int c)
{
	Delete(1,1,n,pos,a[pos]);
	Insert(1,1,n,pos,c);
	a[pos] = c;
}
int main()
{
	srand(200037);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)Insert(1,1,n,i,a[i]);
	while(m--)
	{
		int opt,l,r,x,pos;
		scanf("%d",&opt);
		if(opt==3){scanf("%d%d",&pos,&x);}
		else {scanf("%d%d%d",&l,&r,&x);}
		if(opt==1)Get_rank(l,r,x);
		else if(opt==2)Get_number(l,r,x);
		else if(opt==3)update(pos,x);
		else if(opt==4)Get_pre(l,r,x);
		else Get_sub(l,r,x);
	}
	return 0;
}
Problem3197

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int sed = 237;
const int mul = 213;
const int N = 705;
const int INF = 0x3f3f3f3f;
int f[N][N],f1[N],f2[N],root,cg[2],n;
ull hash[N];
bool cmp(int x,int y)
{
	return hash[x]<hash[y];
}
namespace Tree
{
	struct E
	{int next,to;}e[N<<1];
	int head[N],tot,size[N],fa[N];
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void Get_G(int x,int father)
	{
		size[x] = 1;int F=0;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=father)
			{
				Get_G(e[i].to,x);
				size[x]+=size[e[i].to];
				F = max(F,size[e[i].to]);
			}
		F = max(F,n-size[x]);
		if(!(F<<1>n))
		{
			if(cg[0])cg[1] = x;
			else cg[0] = x;
		}
	}
	int dep[N];
	void Get_Hash(int x)
	{
		dep[x] = dep[fa[x]]+1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				Get_Hash(e[i].to);
			}
		static int stack[N],top;
		top = 0;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
				stack[++top] = e[i].to;
		sort(stack+1,stack+top+1,cmp);
		hash[x] = sed;
		for(int i = 1;i<= top;i++)
		{
			hash[x] = hash[x]*mul+hash[stack[i]];
			hash[x] = hash[x]^hash[stack[i]];
			hash[x] = hash[x]+hash[stack[i]];
		}
	}
}
namespace Flow
{
	struct E
	{int next,to,f,c,from;}e[N*N<<1];
	int head[N<<1],tot,ans,from[N<<1];
	void add(int x,int y,int f,int c)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].from = x;
		e[tot].f = f;e[tot].c = c;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].from = y;
		e[tot].f = 0;e[tot].c = -c;
	}
	void init()
	{
		memset(head,0,sizeof(head));
		tot = 1;ans = 0;
	}
	int dis[N<<1];bool vis[N<<1];
	queue<int>Q;
	bool spfa(int S,int T)
	{
		for(int i = S;i<= T;i++)dis[i] = INF;
		dis[S] = 0;vis[S] = true;
		Q.push(S);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			vis[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
				{
					dis[e[i].to] = dis[x]+e[i].c;
					from[e[i].to] = i;
					if(!vis[e[i].to])
					{
						Q.push(e[i].to);
						vis[e[i].to] = true;
					}
				}
		}
		return dis[T]!=INF;
	}
	void mcf(int S,int T)
	{
		int x = INF;
		for(int i = from[T];i;i=from[e[i].from])
			x = min(x,e[i].f);
		for(int i = from[T];i;i=from[e[i].from])
			ans+=x*e[i].c,e[i].f-=x,e[i^1].f+=x;
	}
	int getmcf(int S,int T)
	{
		while(spfa(S,T))mcf(S,T);
		return ans;
	}
}
int solve(int x,int y)
{
	static int stack1[N],stack2[N];
	int top1 = 0,top2 = 0;
	for(int i = Tree::head[x];i;i=Tree::e[i].next)
		if(Tree::e[i].to!=Tree::fa[x])
			stack1[++top1]=Tree::e[i].to;
	for(int i = Tree::head[y];i;i=Tree::e[i].next)
		if(Tree::e[i].to!=Tree::fa[y])
			stack2[++top2]=Tree::e[i].to;
	sort(stack1+1,stack1+1+top1,cmp);
	sort(stack2+1,stack2+1+top2,cmp);
	Flow::init();
	int j;
	for(int i = 1;i<= top1;i=j)
	{
		for(j=i+1;j<=top1&&hash[stack1[i]]==hash[stack1[j]];j++);
		for(int k=i;k<j;k++)
			for(int l=i;l<j;l++)
				Flow::add(k,top1+l,1,f[stack1[k]][stack2[l]]);
	}
	int S = 0,T = 2*n+1;
	for(int i = 1;i<= top1;i++)
	{
		Flow::add(S,i,1,0);
		Flow::add(i+top1,T,1,0);
	}
	return Flow::getmcf(S,T)+(f1[x]^f2[y]);
}
pair<pair<int,ull>,int> sorter[N]; 
int main()
{
	int x,y;
	scanf("%d",&n);
	Tree::tot = 1;
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		Tree::add(x,y);
	}
	for(int i = 1;i<= n;i++)scanf("%d",&f1[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&f2[i]);
	Tree::Get_G(1,0);
	if(cg[1])
	{
		root = ++n;
		for(int i = Tree::head[cg[1]];i;i=Tree::e[i].next)
			if(Tree::e[i].to==cg[0])
			{
				Tree::e[i].to = Tree::e[i^1].to = n;
				break;
			}
		Tree::add(root,cg[0]);
		Tree::add(root,cg[1]);
	}else root = cg[0];
	Tree::Get_Hash(root);
	for(int i = 1;i<= n;i++)
		sorter[i] = make_pair(make_pair(-Tree::dep[i],hash[i]),i);
	sort(sorter+1,sorter+n+1);
	int j;
	for(int i = 1;i<= n;i=j)
	{
		for(j=i+1;j<=n&&sorter[i].first==sorter[j].first;j++);  
        for(int x=i;x<j;x++)  
            for(int y=i;y<j;y++)  
                f[sorter[x].second][sorter[y].second]=solve(sorter[x].second,sorter[y].second);  
	}
	printf("%d\n",f[root][root]);
	return 0;
}
Problem3198

#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>

#define md 1234567
#define ll long long
#define inf (int) 1e9
#define eps 1e-8
#define N 1234590
#define cg 23333LL
#define M 500010
using namespace std;
int n;
int a[N][6],c[10][10];
ll ans[7];
bool same(int x,int y,int opt)
{
	for (int i=0;i<=5;i++) if ((opt&(1<<i))&&a[x][i]!=a[y][i]) return 0;
	return 1;
}
	
struct ha
{
	ll a[N];
	int q[N],is[N];
	int sz;
	ll clear()
	{
		ll ans=0;
		for (int i=1;i<=sz;i++)
		{
			int x=q[i];
			ans+=a[x]*(a[x]-1)/2;
			a[x]=is[x]=0;
		}
		sz=0;
		return ans;
	}
	void insert(int k,int x,int opt)
	{
		int pos=k;
		while (a[pos]&&(!same(x,is[pos],opt))) pos=(pos+1)%md; 
		if (!a[pos]) q[++sz]=pos,is[pos]=x;
		a[pos]++;
	}
} hash;

ll solve(int opt)
{
	for (int i=1;i<=n;i++)
	{
		ll ha=0;
		for (int j=0;j<=5;j++)
		{
			ha=ha*cg%md;
			if (opt&(1<<j)) { ha=(ha+a[i][j]+1)%md;}
		}
		hash.insert(ha,i,opt);
	}
	return hash.clear();
}
int cal(int i)
{
	int sum=0;
	for (int j=0;j<=5;j++) sum+=(i>>j)&1;
	return sum;
}
int main()
{
	int k;
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++)
		for(int j=0;j<=5;j++)
			scanf("%d",&a[i][j]);
	for (int i=0;i<=63;i++) ans[cal(i)]+=solve(i);
	c[0][0]=1;
	for (int i=1;i<=6;i++)
		for (int j=0;j<=i;j++)
			c[i][j]=c[i-1][j-1]+c[i-1][j];
	for (int i=6;i>=k;i--)
		for (int j=0;j<i;j++)
			ans[j]-=ans[i]*c[i][j];
	printf("%lld\n",ans[k]);
	return 0;
}
Problem3207

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
const int N = 100005;
const int M = 8e6+5;
int num[N],n,m,k,Num,cnt;
ull a[N],T[N];
int find(ull x)
{
	int l = 1,r = Num+1;
	while(l<r)
	{
		int mid=(l+r)>>1;
		if(T[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int root[N],ls[M],rs[M],sum[M];
void init()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&num[i]);
	for(int i=1;i+k-1<=n;i++)
	{
		for(int j = i;j<=i+k-1;j++)
			a[i] = (a[i]<<31)+num[j];
		T[++Num] = a[i];
	}
	sort(T+1,T+Num+1);
}
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)
		update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
void Find(int x,int y,int k)
{
	if(x>y){printf("Yes\n");return ;}
	int l = 1,r = Num;
	x = root[x],y = root[y];
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(k<=mid)
		{
			x = ls[x],y = ls[y];
			r = mid;
		}else
		{
			x = rs[x],y = rs[y];
			l = mid+1;
		}
	}
	if(sum[y]-sum[x]>0)printf("No\n");
	else printf("Yes\n");
}
ull hash()
{
	int tmp[25];
	ull t = 0;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&tmp[i]);
		t = (t<<31)+tmp[i];
	}
	return t;
}
int main()
{
	init();
	for(int i =1;i<= Num;i++)
		update(root[i],root[i-1],1,Num,find(a[i]));
	int x,y;
	while(m--)
	{
		scanf("%d%d",&x,&y);
		ull t = hash();
		int tmp = find(t);
		if(T[tmp]!=t)printf("Yes\n");
		else
			Find(x-1,y-k+1,tmp);
	}
	return 0;
}
Problem3209

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL mod = 10000007;
LL c[55][55];
LL x,y;
LL quick_pow(LL x,LL y)
{
    if(y==0)return 1;
    LL tmp = quick_pow(x,y/2);
    if(y&1)return tmp*tmp%mod*x%mod;
    else return tmp*tmp%mod;
}
int main()
{
    c[1][0] = c[1][1] = 1;
    for(int i = 2;i<= 53;i++)
    {
        c[i][0] = 1;
        for(int j = 1;j<= 53;j++)
            c[i][j] = c[i-1][j-1]+c[i-1][j];
    }
    LL n,ans = 1,cnt = 0;
    scanf("%lld",&n);
    for(int i = 53;i>=1;i--)
    {
        if((n&((LL)1<<(i-1)))!=0)
        {
            ans = ans*(cnt+1)%mod;
            for(int j = i-1;j>=1;j--)
                ans = ans*quick_pow(j+cnt,c[i-1][j])%mod;
            cnt++;
        }
    }
    printf("%lld",ans);
    return 0;
}
Problem3217

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1100005;
const int M = 35000005;
const int mod = 1048576;
double alpha = 0.81;
int stack[305],top,a[N],n,m,n0;
struct Trie
{
	int ch[M][2],num[M],cnt;
	queue<int>Q;
	int Addpoint()
	{
		if(!Q.empty())
		{
			int tmp = Q.front();Q.pop();
			ch[tmp][0] = ch[tmp][1] = 0;
			num[tmp] = 0;
			return tmp;
		}
		return ++cnt;
	}
	void Delete(int x)
	{
		if(!x)return ;
		Q.push(x);
		Delete(ch[x][0]);Delete(ch[x][1]);
	}
	void Insert(int &now,int v,int dep,int top)
	{
		if(!now)now = Addpoint();
		num[now]+=top;
		if(dep<0)return ;
		if(v>>dep&1)Insert(ch[now][1],v,dep-1,top);
		else Insert(ch[now][0],v,dep-1,top);
	}
	int merge(int x,int y)
	{
		if(!x&&!y)return 0;
		int ret = Addpoint();
		ch[ret][0] = merge(ch[x][0],ch[y][0]);
		ch[ret][1] = merge(ch[x][1],ch[y][1]);
		num[ret] = num[x]+num[y];
		return ret;
	}
	int getans(int x,int dep)
	{
		if(dep<0)return 0;
		int tmp = x>>dep&1,sum = 0;
		for(int i = 1;i<= top;i++)
			sum+=num[ch[stack[i]][tmp^1]];
		for(int i = 1;i<= top;i++)
			stack[i] = ch[stack[i]][sum ? tmp^1 : tmp];
		return getans(x,dep-1)+(sum?1<<dep:0);
	}
}trie;
struct Node
{
	int mx,sx;
	Node(){}
	Node(int mx,int sx):mx(mx),sx(sx){}
	void ins(int x)
	{
		if(x>mx)sx = mx,mx = x;
		else if(x>sx)sx = x;
	}
};
Node merge(Node r1,Node r2)
{
	Node ret = r1;
	ret.ins(r2.mx),ret.ins(r2.sx);
	return ret;
}
struct Balanced_Tree
{
	queue<int>Q;
	int ch[N][2],root[N],fa[N],size[N],val[N],sz[N],b[N];
	int cnt,Root,fre,pre,tar;
	Node n1,v[N];
	int Addpoint()
	{
		if(!Q.empty())
		{
			int t = Q.front();Q.pop();
			ch[t][0]=ch[t][1]=root[t]=fa[t]=size[t]=val[t]=b[t]=0;
			v[t] = Node(0,0);
			return t;
		}
		return ++cnt;
	}
	int NewNode(int x)
	{
		int ret = Addpoint();
		b[ret] = 1;
		val[ret] = x;
		size[ret] = sz[ret] = 1;
		v[ret] = Node(x,0);
		trie.Insert(root[ret],x,20,1);
		return ret;
	}
	void Push_up(int x)
	{
		size[x] = size[ch[x][0]]+size[ch[x][1]];
		sz[x] = size[x]+1;
		root[x] = trie.merge(root[ch[x][0]],root[ch[x][1]]);
		v[x] = merge(v[ch[x][0]],v[ch[x][1]]);
		fa[ch[x][0]] = fa[ch[x][1]] = x;
	}
	int Build(int l,int r)
	{
		if(l>r)return 0;
		if(l==r)return NewNode(a[l]);
		int mid = (l+r)>>1,ret = Addpoint();
		ch[ret][0] = Build(l,mid);
		ch[ret][1] = Build(mid+1,r);
		Push_up(ret);
		return ret;
	}
	void dfs(int x)
	{
		if(!x)return ;
		Q.push(x);
		trie.Delete(root[x]);
		if(b[x]){a[++n] = val[x];return ;}
		dfs(ch[x][0]),dfs(ch[x][1]);
	}
	void Rebuild(int x)
	{
		trie.Delete(root[x]);
		n = 0;
		dfs(ch[x][0]),dfs(ch[x][1]);
		int tmp = Build(1,n);
		if(x==Root)Root = tmp;
		fa[tmp] = fa[x];
		ch[fa[x]][ch[fa[x]][1]==x]=tmp;
	}
	void Insert(int &now,int x,int y)
	{
		if(size[now]==1||!now)
		{
			int t = NewNode(y),ret = Addpoint();
			fa[ret] = pre;
			ch[ret][0] = t,ch[ret][1] = now;
			Push_up(ret);
			now = ret;
			return ;
		}
		pre=now;
		if(size[ch[now][0]]>=x)Insert(ch[now][0],x,y);
		else Insert(ch[now][1],x-size[ch[now][0]],y);
		trie.Insert(root[now],y,20,1);
		v[now].ins(y);
		size[now]++;sz[now]+=2;
		fa[ch[now][0]] = fa[ch[now][1]] = now;
		if(max(sz[ch[now][0]],sz[ch[now][1]])>sz[now]*alpha)
			fre = now;
	}
	void Delete(int &now,int x)
	{
		if(b[now])
		{
			Q.push(now);
			tar = val[now];
			now = 0;
			return ;
		}
		if(size[ch[now][0]]>=x)Delete(ch[now][0],x);
		else Delete(ch[now][1],x-size[ch[now][0]]);
		trie.Insert(root[now],tar,20,-1);
		v[now] = merge(v[ch[now][0]],v[ch[now][1]]);
		size[now]--;sz[now]--;
		fa[ch[now][0]] = fa[ch[now][1]] = now;
		if(max(sz[ch[now][0]],sz[ch[now][1]])>sz[now]*alpha)
			fre = now;
	}
	void Insert(int x,int y)
	{
		fre = 0;
		Insert(Root,x,y);
		if(fre)
			Rebuild(fre);
	}
	void Delete(int x)
	{
		fre = 0;
		Delete(Root,x);
		if(fre)
			Rebuild(fre);
	}
	void Find(int now,int pre,int x,int y)
	{
		if(pre+1>=x&&pre+size[now]<=y)
		{
			stack[++top] = root[now];
			n1 = merge(n1,v[now]);
			return ;
		}
		if(pre+size[ch[now][0]]>=x)
			Find(ch[now][0],pre,x,y);
		if(pre+size[ch[now][0]]<y)
			Find(ch[now][1],pre+size[ch[now][0]],x,y);
	}
	Node Find(int x,int y)
	{
		top = 0;
		n1 = Node(0,0);
		Find(Root,0,x,y);
		return n1;
	}
}sheep;
int main()
{
	int lastans = 0;
	scanf("%d%d",&n,&m);n0=n;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	sheep.Root=sheep.Build(1,n);
	int x,y;
	char opt[3];
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='I')
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%mod;
			n0++;
			sheep.Insert(x,y);
		}else if(opt[0]=='D')
		{
			scanf("%d",&x);
			x = (x+lastans)%n0+1;n0--;
			sheep.Delete(x);
		}else if(opt[0]=='C')
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%mod;
			sheep.Delete(x);
			sheep.Insert(x,y);
		}else
		{
			scanf("%d%d",&x,&y);
			x = (x+lastans)%n0+1,y = (y+lastans)%n0+1;
			Node tmp = sheep.Find(x,y);
			lastans = trie.getans(tmp.sx,20);
			printf("%d\n",lastans);
		}
		//printf("Ask:%c %d %d\nAns = %d\n",opt[0],x,y,lastans);
	}
	return 0;
}
Problem3219

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N=100005;
int to[N<<1],ne[N<<1],val[N<<1],v[N<<1];
int fi[N],V[N],num[N],mx[N],fa[N],dep[N],f[N],g[N];
int q[N],d[N],n,L,R,tot=0,cur,rt;
bool u[N];
inline int read() 
{
    int x=0,f=1;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f=-1;ch = getchar();}
    while(ch >='0' && ch <='9'){x=(x<<1)+(x<<3)+ch-'0';ch = getchar();}
    return x*f;
}
void add(int x,int y,int z)
{
	to[++tot]=y;val[tot]=z;ne[tot]=fi[x];fi[x]=tot;
}
void findrt(int x)
{
	num[x]=1;mx[x]=0;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]] && to[i]!=fa[x])
	{
		fa[to[i]]=x;
		findrt(to[i]);
		num[x]+=num[to[i]];
		mx[x]=std::max(mx[x],num[to[i]]);
	}
	mx[x]=std::max(mx[x],cur-num[x]);
	if (mx[x]<mx[rt]) rt=x;
}
bool work(int x,int sum)
{
	if (sum<=L) return 0;
	cur=sum;rt=0;
	findrt(x);u[x=rt]=1;
	int maxdep=0;f[0]=0;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]])
	{
		int s=1,t=1,head=1,tail=0;
		for (int j=maxdep;j>=L;j--)
		{
			for (;head<=tail && f[d[tail]]<=f[j];tail--);
			d[++tail]=j;
		}
		fa[q[1]=to[i]]=x;dep[to[i]]=1;g[to[i]]=v[i];
		for (;s<=t;s++)
		{
			for (;head<=tail && d[head]+dep[q[s]]>R;head++);
			if (dep[q[s]]<=L)
			{
				for (;head<=tail && f[d[tail]]<=f[L-dep[q[s]]];tail--);
				d[++tail]=L-dep[q[s]];
			}
			if (head<=tail && f[d[head]]+g[q[s]]>=0) return 1;
			if (dep[q[s]]>=R) continue;
			for (int j=fi[q[s]];j;j=ne[j])
			if (!u[to[j]] && to[j]!=fa[q[s]])
			{
				fa[q[++t]=to[j]]=q[s];
				dep[to[j]]=dep[q[s]]+1;
				g[to[j]]=g[q[s]]+v[j];
			}
		}
		maxdep=std::max(maxdep,dep[q[t]]);
		for (int j=1;j<=t;j++) f[dep[q[j]]]=std::max(f[dep[q[j]]],g[q[j]]);
	}
	for (int i=0;i<=maxdep;i++) f[i]=-n;
	for (int i=fi[x];i;i=ne[i])
	if (!u[to[i]])
	{
		if (num[to[i]]>num[x]) num[to[i]]=sum-num[x];
		if (work(to[i],num[to[i]])) return 1;
	}
	return 0;
}
bool check(int mid)
{
	for (int i=1;i<=tot;i++)
		if (val[i]<mid) v[i]=-1;else v[i]=1;
	for (int i=0;i<=n;i++) u[i]=false,fa[i]=0,f[i]=-n;
	mx[0]=n;
	return work(1,n);
}
int main()
{
	n = read();
	L = read();
	R = read();
	for (int i=1;i<n;i++)
	{
		int x,y,z;
		x = read();y = read();z = read();
		add(x,y,z);add(y,x,z);V[i]=z;
	}
	std::sort(V+1,V+n);
	int m=std::unique(V+1,V+n)-V-1;
	V[0]=-1;
	int l=1,r=m,ans=0,mid;
	for (;l<=r;)
	{
		mid=(l+r)>>1;
		if (check(V[mid])) ans=mid,l=mid+1;
			else r=mid-1;
	}
	printf("%d\n",V[ans]);
}
Problem3223

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct S{
	S *son[2],*fa;
	int val,size,flag;
	S(){}
	void reverse()
	{
		flag ^=1;
		swap(son[0],son[1]);
	}
	void push_down()
	{
		if(flag==1)
		{
			son[0]->reverse();
			son[1]->reverse();
			flag = 0;
		}
	}
	void push_up()
	{
		size = son[0]->size+son[1]->size+1;
	}
	void Combine(S *a,bool dir) 
	{
        son[dir] = a;
        a->fa = this;
    }
    bool Check() {
        return fa->son[1] == this;
    }
}none,*nil = &none,*root = nil;
int n,m;
S* Newnode(S *now,int x)
{
	S *re = new S();
	re->val = x;
	re->son[0] = re->son[1]  = nil;
	re->size = 1; re->flag = 0;
	re->fa = now;
	return re;
}
S* build(int l,int r)
{
	if(l>r)return nil;
	int mid = (l+r)>>1;
	S *re = nil;
	re = Newnode(re,mid);
	re->Combine(build(l,mid - 1),false);
    re->Combine(build(mid + 1,r),true);
	re->push_up();
	return re;
}
void Rotate(S *a,bool dir)
{
    S *f = a->fa;
    f->push_down(),a->push_down();
    f->son[!dir] = a->son[dir];
    f->son[!dir]->fa = f;
    a->son[dir] = f;
    a->fa = f->fa;
    f->fa->son[f->Check()] = a;
    f->fa = a;
    f->push_up();
    if(root == f)   root = a;
}
 
void Splay(S *a,S *aim)
{
    while(a->fa != aim) {
        if(a->fa->fa == aim) 
            Rotate(a,!a->Check());
        else if(!a->fa->Check()) {
            if(!a->Check()) {
                Rotate(a->fa,true);
                Rotate(a,true);
            }
            else {
                Rotate(a,false);
                Rotate(a,true);
            }
        }
        else {
            if(a->Check()) {
                Rotate(a->fa,false);
                Rotate(a,false);
            }
            else {
                Rotate(a,true);
                Rotate(a,false);
            }
        }
    }
    a->push_up();
}
S* find_rank(S *now,int x)
{
	now->push_down();
	if(x<=now->son[0]->size)return find_rank(now->son[0],x);
	x = x-now->son[0]->size;
	if(x==1)return now;
	return find_rank(now->son[1],x-1);
}
void work(int x,int y)
{
	x++;y++;
	Splay(find_rank(root,x-1),nil);
	Splay(find_rank(root,y+1),root);
	root->son[1]->son[0]->reverse();
}
void print(S *now)
{
	if(now==nil)return ;
	now->push_down();
	print(now->son[0]);
	if(now->val&&now->val!=n+1)
		printf("%d ",now->val);
	print(now->son[1]);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	root = build(0,n+1);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		work(x,y);
	}
	print(root);
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <time.h>
using namespace std;
struct Treap
{
	Treap *ls,*rs;
	int val,key,cnt,size;
	Treap(int f)
	{
		ls = rs = NULL;
		val = f;
		key = rand();
		cnt = size = 1;
	}
	void push_up()
	{
		size = cnt;
		if(ls) 
			size+=ls->size;
		if(rs)
			size+=rs->size;
	}
};
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y<x->val)
	{
		insert(x->ls,y);
		if(x->ls->key > x->key)
			go_right(x);
	}else
	{
		insert(x->rs,y);
		if(x->rs->key > x->key)
			go_left(x);
	}
	x->push_up();
}
void dele(Treap *&x,int y)
{
	if(y<x->val)
		dele(x->ls,y);
	else if(y>x->val)
		dele(x->rs,y);
	else
	{
		if(x->cnt>1)
			x->cnt--;
		else if(!x->ls)
			x = x->rs;
		else if(!x->rs)
			x = x->ls;
		else
		{
			go_left(x);
			dele(x->ls,y);
			if(x->ls && x->ls->key > x->key)
				go_right(x);
		}
	}
	if(x)x->push_up();
}
int query_rank(Treap *x,int y)
{
    if(!x)return 0;
    int tmp;
    if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(x->val==y)return tmp+1;
	else if(y>x->val)
		return tmp+x->cnt+query_rank(x->rs,y);
	else return query_rank(x->ls,y);
}
int query_num(Treap *x,int y)
{
    if(!x)return 0;
    int tmp;
    if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(y<=tmp)
		return query_num(x->ls,y);
    else if(y>tmp+x->cnt)
		return query_num(x->rs,y-tmp-x->cnt);
    else return x->val;
}
/*int getrank(Treap *x,int y,int tr)
{
	if((y<x->val&&x->ls!=NULL)||(y>x->val&&!x->ls))
		return getrank(x->ls,y,tr);
	else if(y>x->val&&x->rs!=NULL)
		return getrank(x->rs,y,tr+x->ls->size);
	else
	{
		if(!x->ls)return tr+1;
		else return tr+x->ls->size+1;
	}
}
int getnum(Treap *x,int y,int ts)
{
	if(y>=ts&&y<=ts+x->cnt)
		return x->val;
	else if(y < x->size+ts&&x->ls!=NULL)
		return getnum(x->ls,y);
	else
		return getnum(x->rs,y);
}*/
int b,q;
/*void getb(Treap *x,int y)
{
	if(x->val<y)b = max(b,x->val);
	if(y<=x->val&&x->ls!=NULL)
		getb(x->ls,y);
	else if(y>x->val&&x->rs!=NULL)
		getb(x->rs,y);
	else return ;
}
void getq(Treap *x,int y)
{
	if(x->val>y)q = min(q,x->val);
	if(y<x->val&&x->ls!=NULL)
		getb(x->ls,y);
	else if(y>=x->val&&x->rs!=NULL)
		getb(x->rs,y);
	else return ;
}*/
int ans;
void query_pro(Treap *x,int y)
{
    if(!x)return;
    if(x->val<y)
	{
		ans=max(ans,x->val);query_pro(x->rs,y);
	}
    else query_pro(x->ls,y);
}
void query_sub(Treap *x,int y)
{
	if(!x)return;
	if(x->val>y)
	{
		ans=min(ans,x->val);query_sub(x->ls,y);
	}
	else query_sub(x->rs,y);
}
int main()
{
	//srand(time(NULL));
	int n,opt,x;
	scanf("%d",&n);
	Treap *root = NULL;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)insert(root,x);
		else if(opt==2)dele(root,x);
		else if(opt==3)printf("%d\n",query_rank(root,x));
		else if(opt==4)printf("%d\n",query_num(root,x));
		else if(opt==5)
			{ans = 0;query_pro(root,x);printf("%d\n",ans);}
		else {ans = 0x3f3f3f3f;query_sub(root,x);printf("%d\n",ans);}
	}
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct S{
	S *son[2],*fa;
	int val,size,cnt;
	S(){}
	int compare(int x)
	{
		if(x==val)return -1;
		else return x>val;
	}
	void push_up()
	{
		size = cnt;
		size+=son[0]->size;
		size+=son[1]->size;
	}
}none,*nil = &none,*root = nil;
S* newnode(S *now,int x)
{
	S *re = new S();
    re->cnt = re->size = 1;
    re->val = x;
    re->son[0] = re->son[1] = nil;
    re->fa = now;
    return re;
}
void go_right(S *x)
{
	S *y = x->fa;
	y->son[0] = x->son[1];
	x->son[1]->fa = y;
	x->son[1] = y;
	x->fa = y->fa;
	if(y==y->fa->son[0])
		y->fa->son[0] = x;
	else if(y==y->fa->son[1])
		y->fa->son[1] = x;
	y->fa = x;
	y->push_up();
	x->push_up();
	if(root == y)
		root = x;
}
void go_left(S *x)
{
	S *y = x->fa;
	y->son[1] = x->son[0];
	x->son[0]->fa = y;
	x->son[0] = y;
	x->fa = y->fa;
	
	if(y==y->fa->son[0])
		y->fa->son[0] = x;
	else if(y==y->fa->son[1])
		y->fa->son[1] = x;
	y->fa = x;
	y->push_up();
	x->push_up();
	if(root == y)
		root = x;
}
void Update(S* now)
{
    now->push_up();
    if(now != root)
        Update(now->fa);
}
void Splay(S *x,S *target)
{
	while(true)
	{
		S *y = x->fa;
		S *z = y->fa;
		if(y==target)
			break;
		if(z==target)
		{
			if(x==y->son[0])go_right(x);
			else go_left(x);
			break;
		}
		else if(x==y->son[0])
		{
			if(y==z->son[0]){go_right(y);go_right(x);}
			else {go_right(x);go_left(x);}
		}else
		{
			if(y==z->son[1]){go_left(y);go_left(x);}
			else {go_left(x);go_right(x);}
		}
	}
	x->push_up();
}
void Insert(int x)
{
	if(root==nil)
	{
		root = newnode(nil,x);return ;
	}
	S *now = root;
	while(1)
	{
		int dir = now->compare(x);
		if(dir==-1)
		{
			now->cnt++;
			Update(now);
			break ;
		}else if(now->son[dir]!=nil)
			now = now->son[dir];
		else
		{
			now->son[dir] = newnode(now,x);
			Update(now);
			Splay(now->son[dir],nil);break ;
		}
	}
}
void Delete(S *&now,int x)
{
	int dir = now->compare(x);
	if(dir!=-1)
		Delete(now->son[dir],x);
	else 
	{
		if(now->cnt>1)now->cnt--;
		else
		{
			if(now->son[0]==nil){now->son[1]->fa = now->fa;now = now->son[1];}
			else if(now->son[1]==nil){now->son[0]->fa = now->fa;now = now->son[0];}
			else 
			{
				go_right(now->son[0]);
				Delete(now->son[1],x);
			}
		}
	}
	if(now!=nil)now->push_up();
}
int get_rank(S *now,int x)
{
	int re = now->son[0]->size;
	int dir = now->compare(x);
	if(dir==-1)return re+1;
	else if(dir==0)return get_rank(now->son[0],x);
	return re+now->cnt+get_rank(now->son[1],x);
}
int get_num(S *now,int x)
{
	if(x<=now->son[0]->size)return get_num(now->son[0],x);
	x = x-now->son[0]->size;
	if(x<=now->cnt)return now->val;
	x = x-now->cnt;
	return get_num(now->son[1],x);
}
int get_pre(S* now,int x)
{
	if(now==nil)return -0x3f3f3f3f;
	else if(x<=now->val)return get_pre(now->son[0],x);
	else return max(now->val,get_pre(now->son[1],x));
}
int get_suc(S* now,int x)
{
	if(now==nil)return 0x3f3f3f3f;
	else if(x>=now->val)return get_suc(now->son[1],x);
	else return min(now->val,get_suc(now->son[0],x));
}
int main()
{
	int n,x,opt;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&opt,&x);
		switch(opt)
		{
			case 1:Insert(x);break;
			case 2:Delete(root,x);break;
			case 3:printf("%d\n",get_rank(root,x));break;
			case 4:printf("%d\n",get_num(root,x));break;
			case 5:printf("%d\n",get_pre(root,x));break;
			case 6:printf("%d\n",get_suc(root,x));break;
		}
	}
	return 0;
}
Problem3224

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 1e8+1;
struct Treap
{
	Treap *ls,*rs;
	int cnt,val,size,key;
	Treap(int x);
	void push_up();
};
Treap :: Treap(int x)
{
	ls = rs = NULL;
	cnt = size = 1;
	val = x;
	key = rand();
}
void Treap :: push_up()
{
	size =cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(x==NULL)
		x = new Treap(y);
	else if(x->val==y)
		x->cnt++;
	else if(y<x->val)
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	else
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}
	x->push_up();
}
void Delete(Treap *&x,int y)
{
	if(x==NULL)return ;
	else if(x->val==y)
	{
		if(x->cnt>1)x->cnt--;
		else if(!x->ls)x= x->rs;
		else if(!x->rs)x= x->ls;
		else
		{
			go_left(x);
			Delete(x->ls,y);
			if(x->ls&&x->ls->key>x->key)
				go_right(x);
		}
	}else if(y<x->val)
		Delete(x->ls,y);
	else Delete(x->rs,y);
	if(x)x->push_up();
}
int get_rank(Treap *x,int y)
{
	if(x==NULL)return 0;
	if(x->val==y)
	{
		if(x->ls)return x->ls->size;
		else return 0;
	}else if(y<x->val)
		return get_rank(x->ls,y);
	else
	{
		int tmp = x->cnt;
		if(x->ls)tmp+=x->ls->size;
		return tmp+get_rank(x->rs,y);
	}
}
int get_num(Treap *x,int y)
{
    if(!x)return 0;
    int tmp = 0;
    if(x->ls)tmp+=x->ls->size;
	if(y<=tmp)
		return get_num(x->ls,y);
    else if(y>tmp+x->cnt)
		return get_num(x->rs,y-tmp-x->cnt);
    else return x->val;
}
int pre,sub;
void get_pre(Treap *x,int y)
{
	if(x==NULL)return ;
	else if(y<=x->val)get_pre(x->ls,y);
	else
	{
		pre = max(pre,x->val);
		get_pre(x->rs,y);
	}
}
void get_sub(Treap *x,int y)
{
	if(x==NULL)return ;
	else if(y<x->val)
	{
		sub = min(sub,x->val);
		get_sub(x->ls,y);
	}else get_sub(x->rs,y);
}
int main()
{
	int n,opt,x;
	scanf("%d",&n);
	Treap *root = NULL;
	while(n--)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)Insert(root,x);
		else if(opt==2)Delete(root,x);
		else if(opt==3)printf("%d\n",get_rank(root,x)+1);
		else if(opt==4)printf("%d\n",get_num(root,x));
		else if(opt==5)pre = -INF,get_pre(root,x),printf("%d\n",pre);
		else sub = INF,get_sub(root,x),printf("%d\n",sub);
	}
	return 0;
}
Problem3230

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long ll;
char s[N];
int cnt[N],sa[N],v[N],nv[N],q[N],rnk[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[v[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[v[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;i>=0;i--)sa[--cnt[v[q[i]]]]=q[i];

		lim=0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i= 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j=max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]]=j;
		}
}
int st[18][N];
int log_2[N];
void build_st(int len)
{
	for(int i = 1;i<len;i++)
		st[0][i]=h[i];
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i+(1<<(j-1))<len;i++)
			st[j][i]=min(st[j-1][i],st[j-1][i+(1<<(j-1))]);
	for(int i = 2;i<N;i++)
		log_2[i]=log_2[i>>1]+1;
}
int getans(int l,int r,int n)
{
	l=rnk[l],r=rnk[r];
	if(l>r)swap(l,r);
	l++;
	if(l>r)return n-sa[r];
	int lth = log_2[r-l+1];
	return min(st[lth][l],st[lth][r-(1<<lth)+1]); 
}
ll sum[N];
struct Ask
{int l,r,p,q,a,b;ll ans;}ask[N];
int find(ll x,int n)
{
	int l = 0,r = n,ans=-1;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(sum[mid]<x)l=mid+1;
		else r = mid-1,ans=mid;
	}
	return ans;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	scanf("%s",s);
	build_sa(n,256);
	build_rank(n);
	build_height(n);
	build_st(n);
	for(int i = 0;i<n;i++)
		sum[i]=n-sa[i]-h[i];
	for(int i = 1;i< n;i++)
		sum[i]+=sum[i-1];
	ll x,y;
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld%lld",&x,&y);
		int l = find(x,n),p=find(y,n);
		if(l==-1||p==-1){ask[i].ans=-1;continue;}
		ask[i].l=sa[l],ask[i].p=sa[p];
		if(l>=1)ask[i].r=x-sum[l-1]+ask[i].l+h[l]-1;
		else ask[i].r=ask[i].l+x-1;
		if(p>=1)ask[i].q=y-sum[p-1]+ask[i].p+h[p]-1;
		else ask[i].q=ask[i].p+y-1;
		ask[i].a=min(min(ask[i].r-ask[i].l+1,ask[i].q-ask[i].p+1),getans(ask[i].l,ask[i].p,n));
	}
	for(int i = 0;i<n/2;i++)swap(s[i],s[n-i-1]);
	build_sa(n,256);
	build_rank(n);
	build_height(n);
	build_st(n);
	for(int i = 1;i<= q;i++)
	if(ask[i].ans!=-1)
	{
		ask[i].b=min(min(ask[i].r-ask[i].l+1,ask[i].q-ask[i].p+1),getans(n-ask[i].r-1,n-ask[i].q-1,n));
		ask[i].ans=(ll)ask[i].a*ask[i].a+(ll)ask[i].b*ask[i].b;
	}
	for(int i = 1;i<= q;i++)
		printf("%lld\n",ask[i].ans);
	return 0;
}
Problem3232

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const int N = 105;
const int S = 8e4+5;
int sl[N][N],sr[N][N];
struct E
{int next,to;double dis,a,b;}e[S];
int head[S],tot;
void add(int x,int y,double a,double b)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[tot].a = a,e[tot].b = b;
}
bool inq[S];
double dis[S];
bool dfs(int x)
{
	inq[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(dis[e[i].to]>dis[x]+e[i].dis)
		{
			dis[e[i].to]=dis[x]+e[i].dis;
			if(inq[e[i].to])return true;
			if(dfs(e[i].to))return true;
		}
	inq[x] = false;
	return false;
}
int cnt,id[N][N];
bool check(double mid)
{
	memset(dis,0,sizeof(dis));
	memset(inq,0,sizeof(inq));
	for(int i = 1;i<= tot;i++)
		e[i].dis = -(e[i].a-mid*e[i].b);
	for(int i = 1;i<= cnt;i++)
		if(dfs(i))return true;
	return false;
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			sl[i][j] = sl[i][j-1]+x;
			sr[i][j] = sr[i-1][j]+x;
		}
	for(int i = 0;i<= n;i++)
		for(int j = 0;j<= m;j++)
			id[i][j] = ++cnt;
	for(int i = 0;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			add(id[i][j-1],id[i][j],sr[i][j],x);
			add(id[i][j],id[i][j-1],-sr[i][j],x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<= m;j++)
		{
			scanf("%d",&x);
			add(id[i-1][j],id[i][j],-sl[i][j],x);
			add(id[i][j],id[i-1][j],sl[i][j],x);
		}
	double l = 0,r = 1e9;
	while(fabs(l-r)>eps)
	{
		double mid = (l+r)/2;
		if(check(mid))l=mid;
		else r = mid;
	}
	printf("%.3lf\n",l/2);
	return 0;
}
Problem3233

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5;
int n,a[55];
int f[N+5],prime[N],cnt;
bool vis[N+5];
void quick_prime()
{
	for(int i = 2;i<= N;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<=N;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	quick_prime();
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	memset(f,0x3f,sizeof(f));
	f[1] = 0;
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= N;i++)
	{
		for(int j = 1;j<= cnt&&i*prime[j]<=N;j++)
		{
			int val = i*prime[j];
			ll tmp = 0;
			for(int k = 1;k<= n;k++)
				tmp+=a[k]%val/i;
			if(tmp<=0x3f3f3f3f)
				f[val] = min(f[val],f[i]+(int)tmp);
		}
		ll tmp = f[i];
		for(int k = 1;k<= n;k++)
			tmp+=a[k]/i;
		if(tmp<=0x3f3f3f3f)
			ans = min(ans,(int)tmp);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3238

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
typedef long long ll;
char s[N];
int val[N],newval[N],sa[N],cnt[N],q[N],rank[N],h[N];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rank[sa[i]] = i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
	if(rank[i])
	{
		int j = 0;
		if(i)j=max(0,h[rank[i-1]]-1);
		while(i+j<len&&sa[rank[i]-1]+j<len&&s[i+j]==s[sa[rank[i]-1]+j])j++;
		h[rank[i]] = j;
	}
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]-'a']++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[val[i]]] = i;
	for(int d=1;;d++)
	{
		int id = 0,hl = 1<<(d-1);
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++]=sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]]=q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)newval[sa[k]] = lim;
		}
		for(i = 0;i<len;i++)val[i]=newval[i];
		if(lim==len)break;
	}
}
struct Data
{
	int val,num;
}stack[N];
int main()
{
	scanf("%s",s);
	int n = strlen(s);
	build_sa(n,26);
	build_rank(n);
	build_height(n);
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=(ll)(i+1+n)*(n-i)/2+(ll)i*(n-i);
	int top = 0;
	ll nowans = 0;int nowcnt = 0;
	for(int i = 1;i<n;i++)
	{
		nowcnt = 1;
		while(top>=1&&h[i]<=stack[top].val)
		{
			nowcnt+=stack[top].num;
			nowans-=(ll)stack[top].num*stack[top].val;
			top--;
		}
		stack[++top]=(Data){h[i],nowcnt};
		nowans+=(ll)h[i]*nowcnt;
		ans-=nowans*2;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3238

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 500005;
struct E{int next,to;};
char s[N];
ll ans;
struct SAM
{
	int trs[N<<1][26],fa[N<<1],len[N<<1],size[N<<1],f[N<<1],ct[N<<1],rnk[N<<1];
	int cnt,last;
	bool end[N<<1];
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p = last,np = ++cnt,q,nq;
		last = np,len[np] = len[p]+1;
		end[np] = true;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np]=1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np]=q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq]=len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[q] = fa[np] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
			}
		}
	}
	void getans(int n)
	{
		ans=0;
		for(int i = 1;i<= cnt;i++)f[i]=size[i]=end[i];
		for(int i=1;i<=cnt;i++) ct[len[i]]++;
		for(int i=1;i<=n;i++) ct[i]+=ct[i-1];
		for(int i=1;i<=cnt;i++) rnk[ct[len[i]]--]=i;
		for(int i=cnt;i;i--) f[fa[rnk[i]]]+=f[rnk[i]];
		for(int i=1;i<=cnt;i++)
		{
			ans+=(ll)size[fa[i]]*f[i]*len[fa[i]];
			size[fa[i]]+=f[i];
		}
	}
}sam;
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	sam.init();
	for(int i = n;i>0;i--)
		sam.insert(s[i]-'a');
	sam.getans(n);
	ans = -2*ans;
	for(int i = 1;i<= n;i++)ans+=(ll)(n-1)*i;
	printf("%lld\n",ans);
	return 0;
}
Problem3251

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N=100005;
long long a[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,q,fa[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int dep[N];
void dfs(int x,int f)
{
	fa[x] = f;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
}
long long stack[100];
int top;
bool getans(int x,int y)
{
	top = 0;
	if(dep[y]>dep[x])swap(x,y);
	while(dep[x]>dep[y])
	{
		stack[++top] = a[x];
		if(top>=55)return true;
		x = fa[x];
	}
	while(x!=y)
	{
		stack[++top] = a[x];
		stack[++top] = a[y];
		if(top>=55)return true;
		x = fa[x],y = fa[y];
	}
	stack[++top] = a[x];
	sort(stack+1,stack+top+1);
	for(int i = 1;i<= top-2;i++)
		if(stack[i]+stack[i+1]>stack[i+2])
			return true;
	return false;
}
int main()
{
	//freopen("tree.in","r",stdin);
	//freopen("tree.out","w",stdout);
	int x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%I64d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	int ju;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ju,&x,&y);
		if(ju==0)
		{
			if(getans(x,y))printf("Y\n");
			else printf("N\n");
		}else
			a[x] = y;
	}
	return 0;
}
Problem3254

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int n,m;
const int N = 10;
const int M = 1e4+5;
const ll INF = 1e18;
int E1[M][N],E2[M][N];
int A[M][N],B[M][N],a[M][N];
ll f[M][1<<5],trs[M][1<<5][1<<5];
ll calc(int line,int sta)
{
	ll res = 0;
	int d[10]={0};
	for(int i = 1;i<= n;i++)
		d[i] = (sta>>(i-1))&1;
	for(int i = 1;i<= n;i++)
		res+=(d[i]^a[line][i])*B[line][i];
	for(int i = 1;i<= n;i++)
		res+=(d[i]^d[i%n+1])*E1[line][i];
	return res;
}
int main()
{
	int maxx=0;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&A[j][i]),maxx = max(maxx,A[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&B[j][i]),maxx = max(maxx,B[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 2;j<=m;j++)
			scanf("%d",&E2[j][i]),maxx = max(maxx,E2[j][i]);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&E1[j][i]),maxx = max(maxx,E1[j][i]);
	int l = 1,cnt=0;
	while(l<=maxx)l<<=1,cnt++;
	//cnt--;
	ll Ans = 0;
	for(int j = 2;j<= m;j++)
		for(int sta = 0;sta<1<<n;sta++)
		{
			for(int pre = 0;pre<1<<n;pre++)
			{
				ll sum = 0;
				for(int i = 0;i< n;i++)
					if(((sta>>i)&1)^((pre>>i)&1))
						sum+=E2[j][i+1];
				trs[j][sta][pre] = sum;
			}
		}
	for(int s = 0;s<cnt;s++)
	{
		for(int j = 1;j<= m;j++)
			for(int i = 1;i<= n;i++)
				a[j][i]=(A[j][i]>>s)&1;
		for(int sta = 0;sta<1<<n;sta++)
			f[1][sta] = calc(1,sta);
		for(int j = 2;j<= m;j++)
			for(int sta = 0;sta<1<<n;sta++)
			{
				f[j][sta] = INF;
				ll tmp = calc(j,sta);
				for(int pre = 0;pre<1<<n;pre++)
					f[j][sta] = min(f[j][sta],f[j-1][pre]+trs[j][sta][pre]+tmp);
			}
		ll tmp = INF;
		for(int i = 0;i<1<<n;i++)
			tmp = min(tmp,f[m][i]);
		Ans += tmp*(1<<s);
	}
	printf("%lld\n",Ans);
	return 0;
}
Problem3261

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 600005;
const int INF = 0x3f3f3f3f;
struct Trie
{
	int cnt;
	int s[N*24][2],sum[N*24];
	int insert(int x,int val)
	{
		int tmp,y;tmp=y=++cnt;
		for(int i = 23;i>=0;i--)
		{
			s[y][0] = s[x][0];
			s[y][1] = s[x][1];
			sum[y]= sum[x]+1;
			int t = val&(1<<i);t = t>>i;
			x=s[x][t];
			s[y][t] = ++cnt;
			y = s[y][t];
		}
		sum[y]=sum[x]+1;
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 23;i>= 0;i--)
		{
			int t = val&(1<<i);t = t>>i;
			if(sum[s[r][t^1]]-sum[s[l][t^1]])
				ans+=(1<<i),r = s[r][t^1],l = s[l][t^1];
			else r = s[r][t],l = s[l][t];
		}
		return ans;
	}
}trie;
int a[N],b[N],root[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);n++;
	for(int i = 2;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)b[i] = b[i-1]^a[i];
	for(int i = 1;i<= n;i++)
		root[i]=trie.insert(root[i-1],b[i]);
	char opt[3];
	int l,r,x;
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='A')
		{
			n++;
			scanf("%d",&a[n]);
			b[n] = b[n-1]^a[n];
			root[n] = trie.insert(root[n-1],b[n]);
		}else
		{
			scanf("%d%d%d",&l,&r,&x);
			printf("%d\n",trie.getans(root[l-1],root[r],b[n]^x));
		}
	}
	return 0;
}
Problem3262

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct Treap
{
	Treap *ls,*rs;
	int cnt,size,val,key;
	Treap(int x);
	void push_up();
}*root[N];
Treap :: Treap(int x)
{
	ls = rs = NULL;
	val = x;
	cnt = size = 1;
	key = rand();
}
void Treap :: push_up()
{
	size = cnt;
	if(ls)size+=ls->size;
	if(rs)size+=rs->size;
}
void go_left(Treap *&x)
{
	Treap *y = x->rs;
	x->rs = y->ls;
	y->ls = x;
	x = y;
	x->ls->push_up();
	x->push_up();
}
void go_right(Treap *&x)
{
	Treap *y = x->ls;
	x->ls = y->rs;
	y->rs = x;
	x = y;
	x->rs->push_up();
	x->push_up();
}
void Insert(Treap *&x,int y)
{
	if(!x){x = new Treap(y);return ;}
	if(x->val==y)x->cnt++;
	else if(y>x->val)
	{
		Insert(x->rs,y);
		if(x->rs->key>x->key)
			go_left(x);
	}else
	{
		Insert(x->ls,y);
		if(x->ls->key>x->key)
			go_right(x);
	}
	x->push_up();
}
int get_rank(Treap *x,int y)
{
	if(!x)return 0;
	int tmp;
	if(!x->ls)tmp = 0;else tmp = x->ls->size;
	if(x->val==y)return tmp+x->cnt;
	else if(y>x->val)return tmp+x->cnt+get_rank(x->rs,y);
	else return get_rank(x->ls,y);
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		Insert(root[i],y);
}
int getans(int x,int y)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=get_rank(root[i],y);
	return ans;
}
struct F
{int s,c,m,no;}flower[N];
bool cmp1(const F &a,const F &b)
{
	return a.s<b.s;
}
int id[N],cnt;
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int ans[N],no[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&flower[i].s,&flower[i].c,&flower[i].m);
		id[i] = flower[i].c;
		flower[i].no = i;
	}
	sort(flower+1,flower+n+1,cmp1);
	cnt = 0;
	sort(id+1,id+n+1);
	for(int i = 1;i<= n;i++)
		if(id[i]!=id[cnt])
			id[++cnt] = id[i];
	int st,end;
	for(int i = 1;i<= n;i=end+1)
	{
		st = i,end = i;
		while(flower[end].s==flower[st].s&&end<=n)end++;
		end--;
		for(int j = st;j<=end;j++)
		{
			int pos = find(flower[j].c);
			update(pos,flower[j].m);
		}
		for(int j = st;j<= end;j++)
		{
			int pos = find(flower[j].c);
			int rank = getans(pos,flower[j].m)-1;
			ans[rank]++;
			no[flower[j].no] = rank;
		}
		/*int pos = find(flower[i].c);
		int rank = getans(pos,flower[i].m);
		ans[rank]++;
		update(pos,flower[i].m);*/
	}
	//for(int i= 1;i<= n;i++)
	//	printf("%d : %d\n",i,no[i]);
	for(int i = 0;i< n;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3270

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 25;
const int M = N*N;
const double eps = 1e-8;
struct E{int next,to;}e[2*M];
int id[N][N],Cnt,tot,head[N],n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double f[M][M],cnt[N],p[N],ans[M];
void work()
{
	for(int i = 1;i<= n*n;i++)
	{
		int xn = i;
		while(fabs(f[xn][i])<eps)xn++;
		if(xn!=i)swap(f[xn],f[i]);
		for(int line = i+1;line<= n*n;line++)
		{
			double tmp = f[line][i]/f[i][i];
			for(int j = i;j<=n*n+1;j++)
				f[line][j]-=f[i][j]*tmp;
		}
	}
	for(int i = n*n;i>= 1;i--)
	{
		for(int j = i+1;j<= n*n;j++)
			f[i][n*n+1]-=f[i][j]*ans[j];
		ans[i] = f[i][n*n+1]/f[i][i];
	}
}
int main()
{
	int x,y,a,b;
	scanf("%d%d%d%d",&n,&m,&a,&b);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
		cnt[x]+=1.0,cnt[y]+=1.0;
	}
	for(int i = 1;i<= n;i++)
		scanf("%lf",&p[i]);
	for(int i = 1;i<=n;i++)
		for(int j = 1;j<= n;j++)
			id[i][j] = ++Cnt;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= n;j++)
		{
			if(i!=j)
			{
				f[id[i][j]][id[i][j]] -= p[i]*p[j];
				for(int t = head[i];t;t = e[t].next)
					f[id[i][j]][id[e[t].to][j]] -= p[j]*(1-p[i])/cnt[i];
				for(int t = head[j];t;t = e[t].next)
					f[id[i][j]][id[i][e[t].to]] -= p[i]*(1-p[j])/cnt[j];
				for(int t1 = head[i];t1;t1 = e[t1].next)
					for(int t2 = head[j];t2;t2 = e[t2].next)
						f[id[i][j]][id[e[t1].to][e[t2].to]] -= (1-p[i])*(1-p[j])/cnt[i]/cnt[j];
			}
		}
	}
	for(int i = 1;i<= n*n;i++)
		for(int j=1;j<i;j++)
			swap(f[i][j],f[j][i]);
	for(int i = 1;i<= n*n;i++)
		f[i][i]+=1;
	f[id[a][b]][n*n+1] = 1;
	work();
	for(int i = 1;i<= n;i++)
		printf("%.6f ",ans[id[i][i]]);
	return 0;
}
Problem3275

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].flow=f;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].flow=0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans=0,nowflow;
	while(bfs(s,t))
		while((nowflow=get_maxflow(s,t,INF))!=0)
			ans+=nowflow;
	return ans;
}
int a[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
bool check(int x,int y)
{
	if(gcd(x,y)!=1)return false;
	int tmp = x*x+y*y;
	if(((int)sqrt(tmp))*((int)sqrt(tmp))==tmp)return true;
	return false;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int st = 0,end = n+1;
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		if(a[i]&1)add(st,i,a[i]);
		else add(i,end,a[i]);
		sum+=a[i];
	}
	for(int i = 1;i<= n;i++)
		if(a[i]&1)
			for(int j = 1;j<= n;j++)
				if(!(a[j]&1))
					if(check(a[i],a[j]))
						add(i,j,INF);
	int ans = dinic(st,end);
	printf("%d\n",sum-ans);
	return 0;
}
Problem3280

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 1e7+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,fr,f,c;}e[M];
int head[N],tot = 1,from[N];
void add(int x,int y,int f,int c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f,e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0,e[tot].c=-c;
	e[tot-1].fr=x,e[tot].fr=y;
}
bool v[N];
int dis[N],S,T;
queue<int>Q;
bool spfa()
{
	for(int i = S;i<= T;i++)
		dis[i] = INF;
	Q.push(S);
	v[S] = true;dis[S] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[x]+e[i].c<dis[e[i].to]&&e[i].f)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
	return dis[T]!=INF;
}
int ans =0,maxf;
void mcf()
{
	int x = INF;
	for(int i = from[T];i;i=from[e[i].fr])
		x = min(x,e[i].f);
	maxf+=x;
	for(int i = from[T];i;i=from[e[i].fr])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(from,0,sizeof(from));
	tot = 1;
	ans=0,maxf=0;
}
int a[N],l[N],p[N],d[N],q[N];
void work()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int sum = 0;
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),sum+=a[i];
	for(int i = 1;i<= m;i++)
		scanf("%d%d",&l[i],&p[i]);
	for(int i = 1;i<= k;i++)
		scanf("%d%d",&d[i],&q[i]);
	S = 0,T = 2*n+m+1;
	for(int i = 1;i<= m;i++)
		add(S,i,l[i],0);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			add(j,m+n+i,INF,p[j]);
	for(int i = 1;i<= n;i++)
	{
		add(m+n+i,T,a[i],0);
		if(i<n)add(m+n+i,m+n+i+1,INF,0);
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= k;j++)
		{
			int to = i+d[j]+1;
			if(to<=n)add(m+i,m+n+to,INF,q[j]);
		}
	for(int i = 1;i<= n;i++)
		add(S,m+i,a[i],0);
	while(spfa())mcf();
	if(maxf==sum)printf("%d\n",ans);
	else printf("impossible\n");
}
int main()
{
	int cas;
	scanf("%d",&cas);
	for(int i = 1;i<= cas;i++)
	{
		printf("Case %d: ",i);
		init();
		work();
	}
	return 0;
}
Problem3282

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
struct Splay
{
	Splay *ls,*rs,*fa;
	int val,sum;
	bool rev;
	Splay(int x);
	void reverse();
	void push_up();
	void push_down();
}*null = new Splay(0),*tree[N];
Splay :: Splay(int x)
{
	ls = rs = fa = null;
	val = x;sum = x;
	rev = false;
}
void Splay :: reverse()
{
	swap(ls,rs);
	rev ^=1;
}
void Splay :: push_down()
{
	if(this==fa->ls||this==fa->rs)
		fa->push_down();
	if(rev)
	{
		ls->reverse();
		rs->reverse();
		rev = 0;
	}
}
void Splay :: push_up()
{
	sum = ls->sum ^ rs->sum ^ val;
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y==y->fa->ls)
		y->fa->ls = x;
	else if(y==y->fa->rs)
		y->fa->rs = x;
	y->fa = x;
	y->push_up();
}
void splay(Splay *x)
{
	Splay *y,*z;
	x->push_down();
	while(x==x->fa->ls||x==x->fa->rs)
	{
		y = x->fa,z = y->fa;
		if(x==y->ls)
		{
			if(y==z->ls)go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
void access(Splay *x)
{
	Splay *y = null;
	while(x!=null)
	{
		splay(x);
		x->rs = y;
		x->push_up();
		y = x;
		x = x->fa;
	}
}
void move_to_root(Splay *x)
{
	access(x);
	splay(x);
	x->reverse();
}
Splay* find_root(Splay *x)
{
	while(x->fa!=null)x = x->fa;
	return x;
}
void link(Splay *x,Splay *y)
{
	if(find_root(x)==find_root(y))return ;
	move_to_root(x);
	x->fa = y;
}
void cut(Splay *x,Splay *y)
{
	if(x==y||find_root(x)!=find_root(y))return ;
	move_to_root(x);
	access(y);
	splay(y);
	if(y->ls!=x)return ;
	x->fa = null;
	y->ls = null;
	y->push_up();
}
void change(Splay *x,int y)
{
	splay(x);
	x->val = y;
	x->push_up();
}
void qurey(Splay *x,Splay *y)
{
	move_to_root(x);
	access(y);
	splay(y);
	printf("%d\n",y->sum);
}
int main()
{
	int n,m,x,y,c;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		tree[i] = new Splay(x);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&c,&x,&y);
		switch(c)
		{
			case 0:qurey(tree[x],tree[y]);break;
			case 1:link(tree[x],tree[y]);break;
			case 2:cut(tree[x],tree[y]);break;
			case 3:change(tree[x],y);break;
		}
	}
	return 0;
}
Problem3295

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 50005;
int n,m,cnt[N],a[N],b[N],c[N],tim[N],f[M],tot;
long long ans;
void update(int x,int flag)
{
	for(int i = x;i&&i<N;i+=flag*(i&-i))
	{
		if(tim[i]!=tot)
			c[i] = 0,tim[i] = tot;
		c[i]++;
	}
}
int getans(int x,int flag)
{
	int ans = 0;
	for(int i = x;i&&i<N;i+=flag*(i&-i))
		if(tim[i]==tot)
			ans+=c[i];
	return ans;
}
struct A
{
	int x,y,pos;
	bool operator <(const A &b)const
	{return y<b.y;}
}q[N],nq[N];
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)
	{
		printf("%lld\n",ans);
		ans-=cnt[q[mid].y];
		ans+=f[mid];
		return ;
	}
	int l1 = l,l2 = mid+1;
	for(int i = l;i<= r;i++)
		if(q[i].pos<=mid)
			nq[l1++]=q[i];
		else 
			nq[l2++]=q[i];
	memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
	CDQ(l,mid);
	tot++;int j = l;
	for(int i = mid+1;i<= r;i++)
	{
		for(;j<=mid&&q[j].y<q[i].y;j++)
			update(q[j].x,-1);
		f[q[i].pos]+=getans(q[i].x,1);
	}
	tot++,j = mid;
	for(int i = r;i>=mid+1;i--)
	{
		for(;j>=l&&q[j].y>q[i].y;j--)
			update(q[j].x,1);
		f[q[i].pos]+=getans(q[i].x,-1);
	}
	CDQ(mid+1,r);
	l1=l;l2=mid+1;
    for(int i=l;i<=r;i++)
        if((q[l1]<q[l2]||l2>r)&&l1<=mid)
            nq[i]=q[l1++];
        else
            nq[i]=q[l2++];
    memcpy(q+l,nq+l,sizeof(q[0])*(r-l+1));
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		b[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
	{
		cnt[i] = getans(a[i],1);
		update(a[i],-1);
		ans+=cnt[i];
	}
	tot++;
	for(int i = n;i;i--)
	{
		cnt[i] += getans(a[i],-1);
		update(a[i],1);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&q[i].x);
		q[i].y = b[q[i].x];
		q[i].pos = i;
	}
	sort(q+1,q+m+1);
	CDQ(1,m);
	return 0;
}
Problem3307

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
const int M = 6000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N][25],dep[N],cnt;
void dfs(int x,int f)
{
	fa[x][0] = f;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i =e[i].next)
		if(e[i].to!=fa[x][0])
			dfs(e[i].to,x);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 22;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 22;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int maxn[M],ls[M],rs[M],seg,maxno[M],root[N],n,m;
void update(int &p,int l,int r,int x,int c)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		maxn[p] += c;
		maxno[p] = l;
		if(!maxn[p])maxno[p] =0;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(ls[p],l,mid,x,c);
	else update(rs[p],mid+1,r,x,c);
	if(maxn[ls[p]]>=maxn[rs[p]])
		maxn[p] = maxn[ls[p]],maxno[p] = maxno[ls[p]];
	else 
		maxn[p] = maxn[rs[p]],maxno[p] = maxno[rs[p]];
	if(!maxn[p])maxno[p] =0;
}
int merge(int x,int y,int l,int r)
{
	if(!x||!y)return x+y;
	if(l==r)
	{
		maxn[x] = maxn[x]+maxn[y];
		maxno[x] = l;
		if(!maxn[x])maxno[x] =0;
		return x;
	}
	int mid = (l+r)>>1;
	ls[x] = merge(ls[x],ls[y],l,mid);
	rs[x] = merge(rs[x],rs[y],mid+1,r);
	if(maxn[ls[x]]>=maxn[rs[x]])
		maxn[x] = maxn[ls[x]],maxno[x] = maxno[ls[x]];
	else 
		maxn[x] = maxn[rs[x]],maxno[x] = maxno[rs[x]];
	if(!maxn[x])maxno[x] =0;
	return x;
}
int kind[N],Cnt,ans[N];
int find(int x)
{
	int l = 1,r = Cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(kind[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
struct O
{int x,y,d;}opt[N];
void solve(int x)
{
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa[x][0])
		{
			solve(e[i].to);
			root[x] = merge(root[x],root[e[i].to],1,Cnt);
		}
	}
	ans[x] = kind[maxno[root[x]]];
}
void init()
{
	for(int j= 1;j<= 19;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	init();
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt[i].x,&opt[i].y,&opt[i].d);
		kind[++Cnt] = opt[i].d;
	}
	sort(kind+1,kind+Cnt+1);
	int tmp = Cnt;Cnt = 0;
	for(int i = 1;i<= tmp;i++)
		if(kind[i]!=kind[Cnt])
			kind[++Cnt] = kind[i];
	for(int i = 1;i<= m;i++)
	{
		int pos = find(opt[i].d);
		int lca = getlca(opt[i].x,opt[i].y);
		update(root[opt[i].x],1,Cnt,pos,1);
		update(root[opt[i].y],1,Cnt,pos,1);
		update(root[lca],1,Cnt,pos,-1);
		update(root[fa[lca][0]],1,Cnt,pos,-1);
	}
	solve(1);
	for(int i = 1;i<= n;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3309

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int g[N],last[N],t[N],prime[N/10],cnt;
bool vis[N];
int sum[N];
void quick_mu()
{
	for(int i =2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			g[i] = last[i] = t[i] = 1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			int x = i*prime[j];
			vis[x] = true;
			if(i%prime[j]==0)
			{
				last[x] = last[i];
				t[x] = t[i]+1;
				if(last[x]==1)g[x] = 1;
				else g[x] = (t[last[x]]==t[x]?-g[last[x]]:0);
				break;
			}
			last[x] = i;t[x] = 1;
			g[x] = (t[i]==1?-g[i]:0);
		}
	}
	for(int i = 1;i<N;i++)
		sum[i] = sum[i-1]+g[i];
}
ll getans(int x,int y)
{
	int last;
	ll ans = 0;
	for(int i = 1;i<=x&&i<= y;i = last+1)
	{
		last = min(x/(x/i),y/(y/i));
		ans+=(ll)(x/i)*(y/i)*(sum[last]-sum[i-1]);
	}
	return ans;
}
int main()
{
	int t,n,m;
	scanf("%d",&t);
	quick_mu();
	while(t--)
	{
		scanf("%d%d",&n,&m);
		printf("%lld\n",getans(n,m));
	}
	return 0;
}
Problem3329

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const LL mod = 1e9+7;
LL f[65][2],ans;
struct Martix
{
	int h,w;
	LL map[4][4];
	Martix(int x,int y)
	{
		h = x;
		w = y;
		memset(map,0,sizeof(map));
	}
	Martix()
	{
		h = w = 0;
		memset(map,0,sizeof(map));
	}
	Martix operator*(const Martix &S)const
	{
		Martix ans(S.w,h);
        for(int i = 1;i<= ans.h;i++)
            for(int j = 1;j<= ans.w;j++)
                for(int k = 1;k<= S.h;k++)
                    (ans.map[i][j]+=map[i][k]*S.map[k][j])%=mod;
		return ans;
	}
};
Martix quick_pow(LL y,const Martix &S) 
{
	if(y==0)
	{
		Martix one(3,3);
		for(int i = 0;i<= 3;i++)
			one.map[i][i] = 1;
		return one;
	}
	Martix tmp = quick_pow(y/2,S);
	if(y&1)return tmp*tmp*S;
	else return tmp*tmp;	
}
void init()
{
	f[1][1] = 1,f[1][0] = 1;
	for(int j = 2;j<= 63;j++)
	{
		f[j][0] = f[j-1][0]+f[j-1][1];
		f[j][1] = f[j-1][0];
	}
}
void work(LL n)
{
	//LL tmp = n;
	int cnt = 63;
    while(n < ((LL)1<<(cnt-1))) cnt--;
	for(int i = 1;i < cnt;i++)
        ans += f[i][1];
	int cur = n / ((LL)1<<(cnt-1));
    int pre = cur;
    n %= ((LL)1<<(cnt-1));
	for(int j = cnt-1;j>=1;j--)
	{
		cur = n/((LL)1<<(j-1));
		if(cur)
			ans+=f[j][0];
		if(cur&&pre)break;
		pre = cur;
		n%=((LL)1<<(j-1));
	}
}
int main()
{
	init();
	int T;
	scanf("%d",&T);
	LL n;
	while(T--)
	{
		scanf("%lld",&n);
		ans = 0;
		work(n+1);
		Martix sta(1,2);
		sta.map[1][1] = 1;sta.map[1][2] = 1;
		Martix go(2,2);
		go.map[1][1] = go.map[1][2] = go.map[2][1] = 1;
		sta = sta*quick_pow(n,go);
		printf("%lld\n%lld\n",ans,sta.map[1][1]);
	}
	return 0;
}
Problem3339

#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 0x3f3f3f3f;
int sg[N<<2],lazy[N<<2],fa[N],a[N],fs[N],next[N],last[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
struct A
{int l,r,no,ans;}ask[N];
bool cmp(A a,A b){return a.l<b.l;}
bool fir(A a,A b){return a.no<b.no;}
void build(int p,int l,int r)
{
	lazy[p] = INF;
	if(l==r)
	{
		sg[p] = fs[l];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sg[p] = max(sg[p<<1],sg[p<<1|1]);
}
void push_down(int p,int l,int r)
{
	if(lazy[p]==INF||l==r)return ;
	sg[p<<1] = min(sg[p<<1],lazy[p]);
	sg[p<<1|1] = min(sg[p<<1|1],lazy[p]);
	lazy[p<<1] = min(lazy[p<<1],lazy[p]);
	lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
	lazy[p] = INF;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		sg[p] = min(sg[p],c);
		lazy[p] = min(lazy[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	sg[p] = max(sg[p<<1],sg[p<<1|1]);
}
int getans(int p,int l,int r,int x)
{
	push_down(p,l,r);
	if(l==r)return sg[p];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int main()
{
	int n,q,maxn = 0;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		maxn = max(maxn,a[i]);
		next[last[a[i]]] = i;
		last[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
		if(!next[i])next[i] = n+1;
	for(int i = 1;i<= maxn;i++)
		fa[i] = i;
	fa[maxn+1] = maxn+1;
	for(int i = 1;i<= n;i++)
	{
		fa[a[i]] = a[i]+1;
		fs[i] = getfa(0);
	}
	build(1,1,n);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].no = i;
	}
	sort(ask+1,ask+q+1,cmp);
	ask[0].l = 1;
	for(int i = 1;i<= q;i++)
	{
		for(int j = ask[i-1].l;j<ask[i].l;j++)
			update(1,1,n,j,next[j]-1,a[j]);
		ask[i].ans = getans(1,1,n,ask[i].r);
	}
	sort(ask+1,ask+q+1,fir);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ask[i].ans);
	return 0;
}
Problem3413

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
char s[N],b[N];
int ch[N][10],len[N],fa[N],n,m,fl,cnt=1,last=1,rt[N],pp;
struct E{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int in[N],out[N],dfn,id[N],to[N];
void dfs(int x)
{
	in[x] = ++dfn;
	if(to[x])id[dfn] = n-len[x];
	else id[dfn] = -1;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	out[x] = dfn;
}
int L[N*20],R[N*20],sz[N*20],ID;
void update(int &x,int y,int l,int r,int k)
{
	sz[x = ++ID] = sz[y]+1;
	L[x]=L[y],R[x]=R[y];
	if(l==r)return ;
	int mid=(l+r)>>1;
	if(k<=mid)update(L[x],L[y],l,mid,k);
	else update(R[x],R[y],mid+1,r,k);
}
int getans(int k,int l,int r,int x)
{
	if(!k)return 0;
	if(r<=x)return sz[k];
	int mid = (l+r)>>1;
	int ans = getans(L[k],l,mid,x);
	if(x>mid)ans+=getans(R[k],mid+1,r,x);
	return ans;
}
int getm(int x,int y)
{
	int l = 0,r = n,mid;
	while(l<r)
	{
		mid = (l+r)>>1;
		if(sz[L[y]]-sz[L[x]])
			x = L[x],y = L[y],r = mid;
		else x = R[x],y=R[y],l=mid+1;
	}
	return l;
}
void insert(int x,int y)
{
	int p = last,np = ++cnt,q,nq;
	last = np;len[np] = len[p]+1;
	for(;p&&!ch[p][x];p=fa[p])ch[p][x] = np;
	if(!p)fa[np] = 1;
	else
	{
		q = ch[p][x];
		if(len[q]==len[p]+1)fa[np] = q;
		else
		{
			fa[nq=++cnt]=fa[q];
			len[nq] = len[p]+1;
			memcpy(ch[nq],ch[q],sizeof(ch[q]));
			fa[np] = fa[q] = nq;
			for(;p&&ch[p][x]==q;p=fa[p])ch[p][x] = nq;
		}
	}
	to[last] = y;
}
bool match(int lenb)
{
	int w = 1,ff = 1,i,j;pp = 1;
	for(fl = 0;w<=lenb&&ff;)
		for(ff = 0,i = head[pp];i;i=e[i].next)
			if(s[e[i].val]==b[w])
			{
				int tt = e[i].to;
				for(fl=j=0;j<min(len[tt]-len[pp],lenb-w+1);fl++,j++)
					if(s[e[i].val+j]!=b[w+j])
						return pp=tt,0;
				w+=len[tt]-len[pp];pp=tt;ff=1;break;
			}
	return ff;
}
int v[N];
int main()
{
	scanf("%d%s",&n,s+1);
	for(int i = n;i>=1;i--)
		insert(s[i]-'0',i);
	int p,i,j;
	for(v[1] = 1,i = 1;i<=cnt;i++)
		if(to[i])
			for(p = n,j = i;!v[j];j=fa[j])
				p-=len[j]-len[fa[j]],v[j]=true,add(fa[j],j,p+1);
	dfs(1);
	for(i = 1;i<= dfn;i++)
		if(id[i]>=0)
			update(rt[i],rt[i-1],0,n,id[i]);
		else rt[i] = rt[i-1];
	scanf("%d",&m);
	int ans,w;
	while(m--)
	{
		scanf("%s",b+1);
		int lenb = strlen(b+1);
		ans = w = match(lenb)?getm(rt[in[pp]-1],rt[out[pp]]):n;
		for(ans+=fl*(getans(rt[out[pp]],0,n,w)-getans(rt[in[pp]-1],0,n,w)),pp=fa[pp];pp;pp=fa[pp])
            ans+=(len[pp]-len[fa[pp]])*(getans(rt[out[pp]],0,n,w)-getans(rt[in[pp]-1],0,n,w));
        printf("%d\n",ans);
	}
	return 0;
}
Problem3414

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
int er[N],la[N],beg[N],lef[N],now[N];
int who[N],when[N],how[N],n,m;
bool check(int e)
{
	memset(er,0x3f,sizeof(er));
	memset(la,0,sizeof(la));
	memset(beg,0,sizeof(beg));
	memset(lef,0,sizeof(lef));
	memset(now,0,sizeof(now));
	int maxn = 0;
	for(int i=1;i<= e;i++)
	{
		er[who[i]] = min(er[who[i]],when[i]);
		la[who[i]] = max(la[who[i]],when[i]);
		maxn = max(maxn,when[i]);
		if(!now[when[i]]||now[when[i]]==how[i]+1)now[when[i]] = how[i]+1;
		else return false;
	}
	for(int i = 1;i<= n;i++)
		if(er[i]!=INF)
			beg[er[i]]++,lef[la[i]]++;
	int tot=0,peop = 0,ended = 0,notbegin = 0;
	for(int i=1;i<=maxn;i++)
	if(now[i])
	{
		peop+=beg[i];
		if(peop>now[i])return false;
		if(beg[i]<=notbegin)notbegin-=beg[i];
		else tot+=beg[i]-notbegin,notbegin = 0;
		if(peop+notbegin+ended<now[i])tot += now[i]-peop-notbegin-ended,notbegin = now[i]-peop-ended;
		else
		{
			if(peop+notbegin>now[i])notbegin=now[i]-peop,ended=0;
			else ended=now[i]-peop-notbegin;
		}
		peop-=lef[i];ended+=lef[i];
	}
	if(tot>n)return false;
	return true;
}
void work()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&when[i],&who[i],&how[i]);
	int l = 1,r = m+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(mid))l = mid+1;
		else r = mid;
	}
	printf("%d\n",l-1);
}	
int main()
{
	int c;
	scanf("%d",&c);
	while(c--)
		work();
	return 0;
}
Problem3416

#include <stdio.h>
#include <vector>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
bool last[N<<1];
char in[N];
int a[N],q[N],t;
vector<int>ans[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	scanf("%s",in+1);
	for(int i = 1;i<= n;i++)
	{
		if(in[i]=='c')a[i] = a[i-1]-k;
		else a[i] = a[i-1]+1;
	}
	int cnt = 0;
	last[n] = true;
	for(int i = 1;i<= n;i++)
	{
		a[i]+=n;
		if(last[a[i]])
		{
			cnt++;
			for(int j = t-k+1;j<= t;j++)
				ans[cnt].push_back(q[j]),last[a[q[j]]] = false;
			ans[cnt].push_back(i);
			t-=k;
		}else
		{
			t++;
			q[t] = i;
			last[a[i]] =true;
		}
	}
	for(int i = cnt;i>=1;i--)
	{
		for(unsigned int j = 0;j<ans[i].size();j++)
			printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
Problem3417

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
const int K = 1e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct A
{int s,t,k,no,ans;}ask[K];
bool cmp1(A a,A b){return a.s<b.s;}
bool cmp2(A a,A b){return a.no<b.no;}
queue<int>Q;
int f[N],g[N];
bool v[N];
void spfa(int s)
{
	memset(f,0x3f,sizeof(f));
	memset(g,0x3f,sizeof(g));
	Q.push(s);
	f[s] = 0;
	v[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i = e[i].next)
		{
			if(f[x]+1<g[e[i].to]||g[x]+1<f[e[i].to])
			{
				f[e[i].to] = min(f[e[i].to],g[x]+1);
				g[e[i].to] = min(g[e[i].to],f[x]+1);
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
			else if(e[i].to==s)
			{
				if(f[s]==0)f[s] = g[x]+1,g[s] = f[x]+1;
				else f[s] = min(g[x]+1,f[s]),g[s] = min(f[x]+1,g[s]);
			}
		}
	}
	if(f[s]==0)f[s] = 0x3f3f3f3f;
}
int main()
{
	int n,m,k,x,y;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%d",&ask[i].s,&ask[i].t,&ask[i].k);
		ask[i].no = i;
	}
	sort(ask+1,ask+k+1,cmp1);
	int j = 0;
	for(int i = 1;i<= k;i++)
	{
		if(ask[i].s!=j)
		{
			spfa(ask[i].s);
			j = ask[i].s;
		}
		if(ask[i].k%2==1)
			{if(g[ask[i].t]<=ask[i].k)ask[i].ans = 1;}
		else {if(f[ask[i].t]<=ask[i].k)ask[i].ans = 1;}
	}
	sort(ask+1,ask+k+1,cmp2);
	for(int i = 1;i<= k;i++)
	{
		if(ask[i].ans)printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem3419

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 500005;
LL a[N];
bool cmp(LL a,LL b)
{
	return a>b;
}
int main()
{
	//freopen("tak.in","r",stdin);
	//freopen("tak.out","w",stdout);
	int n;
	LL m,d;
	scanf("%lld%lld%d",&m,&d,&n);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	sort(a+1,a+n+1,cmp);
	if(a[1]>=m+d){printf("1\n");return 0;}
	int sec = 0;
	for(int i = 1;i<= n;i++)
		if(a[i]>=m-d)sec = i;
	if(sec==0){printf("0\n");return 0;}
	int ans = 1;
	LL back = 0;
	for(int i=1;i<=n;i++)
	{
		if(i==sec) continue;
		if(back>=d||m-back+d-back<=a[sec]) break;
		if(a[i]<=d-back) {puts("0");return 0;}
		ans++;
		back+=a[i]-(d-back);
		if(back>=m) {ans--;break;}
	}
	if(m-back+d-back>a[sec]) puts("0");
	else printf("%d\n",ans);
	return 0;
}
Problem3420

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N =300005;
typedef long long LL;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
LL f[N];
bool is_leaf[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int ans;
void dfs(int x,int fa)
{
	is_leaf[x] = true;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			is_leaf[x] = false;
			dfs(e[i].to,x);
			f[x]+=f[e[i].to]+1;
		}
	f[x]-=ans;
	f[x] = max(f[x],(LL)0);
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	int l = 0,r = n-1;
	while(l<r)
	{
		ans = (l+r)>>1;
		memset(f,0,sizeof(f));
		dfs(1,0);
		if(f[1]!=0)l = ans+1;
		else r = ans;
	}
	printf("%d\n",l);
	return 0;
}
Problem3425

#include <stdio.h>
#include <bitset>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 250005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
bitset<N>F;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	head[y] = tot;
}
int size[N],tb[N];
int root,dirr,n;
LL ans;
void dfs(int x,int fa)
{
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(fa!=e[i].to)
		{
			dfs(e[i].to,x);
			size[x]+=size[e[i].to];
			tb[x] = max(tb[x],size[e[i].to]);
		}
	}
	tb[x] = max(tb[x],n-size[x]);
	if(tb[x]<tb[root])
	{
		root = x;
		dirr = fa;
	}
}
int ts[N];
void getpre(int x,int fa,int dep)
{
	ans+=dep;
	ts[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			getpre(e[i].to,x,dep+1);
			ts[x]+=ts[e[i].to];
		}
	}
}
void solve1(int x)
{
	F[0] = 1;
	for(int i = head[x];i;i = e[i].next)
		F |= F<<ts[e[i].to];
	LL tmp = 0;
	for(int i = 1;i<= n;i++)
		if(F[i])
			tmp = max(tmp,(LL)i*(n-i-1));
	ans+=tmp;
}
int heap[N],cnt;
void solve2(int x)
{
	for(int i = head[x];i;i =e[i].next)
	{
		heap[++cnt] = ts[e[i].to];
		push_heap(heap+1,heap+cnt+1);
	}
	while(cnt>=2)
	{
		int t1 = heap[1];
		pop_heap(heap+1,heap+cnt+1);cnt--;
		int t2 = heap[1];
		pop_heap(heap+1,heap+cnt+1);cnt--;
		heap[++cnt] = abs(t1-t2);
		push_heap(heap+1,heap+cnt+1);
	}
	ans+=(LL)((n-1+heap[1])/2)*((n-1-heap[1])/2);
}
int d[N];
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		d[x]++;d[y]++;
	}
	tb[0] = INF;
	dfs(1,0);
	getpre(root,0,0);
	if(d[root]<=800)
		solve1(root);
	else solve2(root);
	printf("%d %lld\n",n-1,ans);
	return 0;
}
Problem3426

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const int M = 1000005;
struct E
{int next,to;}e[M<<1];
int head[N],tot;
bool u1[N],u2[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void cover2(int x)
{
	u1[x] = true;
	for(int i = head[x];i;i = e[i].next)
		u1[e[i].to] = true;
	return ;
}
void cover1(int x)
{
	u1[x] = u2[x] = true;
	for(int i = head[x];i;i =e[i].next)
	{
		if(u2[e[i].to])continue;
		u2[e[i].to] = true;
		cover2(e[i].to);
	}
	return ;
}
int ans[N],cnt;
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		if(!u1[i])
		{
			ans[++cnt] = i;
			cover1(i);
		}
	printf("%d\n",cnt);
	for(int i = 1;i<cnt;i++)
		printf("%d ",ans[i]);
	printf("%d",ans[cnt]);
	return 0;
}
Problem3427

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int INF = 707185547;
int f[N][3];
int a[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	f[1][0] = f[1][1] = f[1][2] = INF;
	if(a[1]==-1)f[1][0] = 0;
	else if(a[1]==0)f[1][1] = 0;
	else f[1][2] = 0;
	for(int i = 2;i<= n;i++)
	{
		f[i][0] = f[i-1][0]+a[i]+1;
		if(a[i]==-1)
		{
			if(a[i-1]==1)f[i][1] = min(f[i-1][1],f[i-1][0])+1;
			else f[i][1] = INF;
		}else if(a[i]==0)f[i][1] = min(f[i-1][1],f[i-1][0]);
		else
		{
			if(a[i-1]==-1)f[i][1] = min(f[i-1][1],f[i-1][0])+1;
			else f[i][1] = f[i-1][0]+1;
		}
		if(a[i]==-1)
		{
			if(a[i-1]==1)f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+2;
			else f[i][2] = f[i-1][2]+2;
		}else if(a[i]==0)
		{
			if(a[i-1]==1)f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+1;
			else f[i][2] = f[i-1][2]+1;
		}else f[i][2] = min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
	}
	int ans = min(f[n][0],min(f[n][1],f[n][2]));
	if(ans>=INF)printf("BRAK\n");
	else printf("%d\n",ans);
	return 0;
}
Problem3438

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e3+5;
const int M = 5e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot = 1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].flow = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].flow = 0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].flow)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int a[N],b[N],c1[N],c2[N];
int main()
{
	int n;
	scanf("%d",&n);
	int st = 0,end = n+1;
	int id = n+1;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	int m,k,x,ans = 0;
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&k,&c1[i],&c2[i]);
		ans+=c1[i]+c2[i];
		add(st,id+1,c1[i]),add(id+2,end,c2[i]);
		for(int j = 1;j<=k;j++)
		{
			scanf("%d",&x);
			add(id+1,x,INF);add(x,id+2,INF);
		}
		id+=2;
	}
	for(int i = 1;i<= n;i++)add(st,i,a[i]),ans+=a[i];
	for(int i = 1;i<= n;i++)add(i,end,b[i]),ans+=b[i];
	ans-=dinic(st,end);
	printf("%d\n",ans);
	return 0;
}
Problem3439

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int ch[N][26],tot=1;
char s[N];
vector<int>end[N];
void insert(int no)
{
	int i = strlen(s+1),p = 1;
	while(i)
	{
		if(!ch[p][s[i]-'a'])ch[p][s[i]-'a'] = ++tot;
		p = ch[p][s[i]-'a'];
		i--;
	}
	end[p].push_back(no);
}
int ls[N*20],rs[N*20],root[N],sum[N*20],cnt;
int a[N],in[N],out[N],Dfn;
void dfs(int x)
{
	int num = Dfn;
	for(int i= 0;i<end[x].size();i++)a[++Dfn] = end[x][i];
	for(int i = 0;i<26;i++)
		if(ch[x][i])
			dfs(ch[x][i]);
	for(int i = 0;i<end[x].size();i++)
		in[end[x][i]] = num,out[end[x][i]] = Dfn;
}
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p] = sum[pre]+1;
		return ;
	}
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int x,int y,int l,int r,int k)
{
	int mid = (l+r)>>1;
	if(l==r)return l;
	if(sum[y]-sum[x]<k)return -1;
	if(sum[ls[y]]-sum[ls[x]]>=k)return getans(ls[x],ls[y],l,mid,k);
	else return getans(rs[x],rs[y],mid+1,r,k-sum[ls[y]]+sum[ls[x]]);
}
int main()
{
	int n,k;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		insert(i);
	}
	dfs(1);
	root[0]=ls[0]=rs[0]=sum[0]=0;
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],1,n,a[i]);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		printf("%d\n",getans(root[in[i]],root[out[i]],1,n,k));
	}
	return 0;
}
Problem3450

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
char m[N];
double l[N],f[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",m+1);
	for(int i = 1;i<= n;i++)
	{
		if(m[i]=='o')
		{
			l[i] = l[i-1]+1;
			f[i] = f[i-1]+2*l[i-1]+1;
		}else if(m[i]=='x')
		{
			l[i] = 0;
			f[i] = f[i-1];
		}else
		{
			l[i] = 0.5*(l[i-1]+1);
			f[i] = 0.5*(f[i-1])+0.5*(f[i-1]+2*l[i-1]+1);
		}
	}
	printf("%.4f\n",f[n]);
	return 0;
}
Problem3456

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<18;
typedef long long ll;
const int mod = 1004535809;
int fac[N],env[N],cnt;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y = y>>1;
	}
	return res;
}
int a[N],b[N],c[N];
void NTT(int *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = (len>>1);(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		int wn = quick_pow(3,(mod-1)/i);
		for(int j = 0;j<len;j+=i)
		{
			int w = 1,tmp;
			for(int k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
			{
				tmp = (ll)a[j+k+(i>>1)]*w%mod;
				a[j+k+(i>>1)]=(a[j+k]-tmp+mod)%mod;
				a[j+k] = (a[j+k]+tmp)%mod;
			}
		}
	}
	if(type==-1)
	{
		for(int i = 1;i<(len>>1);i++)
			swap(a[i],a[len-i]);
		int Inv = quick_pow(len,mod-2);
		for(int i = 0;i<len;i++)
			a[i] = (ll)a[i]*Inv%mod;
	}
	/*printf("#case %d:",++cnt);
	for(int i = 0;i<len;i++)
		printf("%d ",a[i]);
	printf("\n");*/
}
void Get_Inv(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = quick_pow(a[0],mod-2);
		return ;
	}
	Get_Inv(a,b,len>>1);
	static int tmp[N];
	memcpy(tmp,a,sizeof(int)*len);
	memset(tmp+len,0,sizeof(int)*len);
	NTT(tmp,len<<1,1);
	NTT(b,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i]=(ll)b[i]*(2-(ll)b[i]*tmp[i]%mod+mod)%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(int)*len);
}
int C(int n)
{
	return ((ll)n*(n-1)>>1)%(mod-1);
}
int main()
{
	int n,m=1;
	scanf("%d",&n);
	for(m=1;m<=n;m<<=1);
	fac[0]=1,env[0]=1;
	for(int i =1;i<=m;i++)
		fac[i] = (ll)fac[i-1]*i%mod;
	env[m] = quick_pow(fac[m],mod-2);
	for(int i = m-1;i>=1;i--)
		env[i] = (ll)env[i+1]*(i+1)%mod;
	for(int i = 0;i< m;i++)
		b[i] = (ll)quick_pow(2,C(i))*env[i]%mod;
	for(int i = 1;i< m;i++)
		c[i] = (ll)quick_pow(2,C(i))*env[i-1]%mod;
	static int tmp[N];
	memset(tmp,0,sizeof(tmp));
	Get_Inv(b,tmp,m);
	NTT(c,m<<1,1);
	NTT(tmp,m<<1,1);
	for(int i = 0;i<m<<1;i++)a[i]=(ll)c[i]*tmp[i]%mod;
	NTT(a,m<<1,-1);
	printf("%lld\n",(ll)a[n]*fac[n-1]%mod);
	return 0;
}
Problem3460

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,m,key;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int top[N],size[N],son[N],fa[N],dep[N],q[N],rk[N],a[N];
void dfs(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		size[x]+=size[e[i].to];
		if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
	}
}
int seq[N],Dfn,in[N],out[N];
void dfs2(int x,int tp)
{
	top[x] = tp;
	in[x] = ++Dfn;seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	out[x] = ++Dfn;seq[Dfn] = x;
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	else return y;
}
struct data
{
	int x,y,k;
	data(int _x=0,int _y=0,int _k=0):x(_x),y(_y),k(_k){}
}b[N];
int cnt;
ll c[N],ans[N],res;
bool vis[N];
void Add(int x,ll y)
{
	for(int i = x;i<=n;i+=i&(-i))
		c[i]+=y;
}
ll Getans(int x)
{
	ll ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void Insert(int x,int y)
{
	int lca = getlca(x,y);
	if(in[x]>in[y])swap(x,y);
	cnt++;
	b[cnt] = data(lca==x?in[x]:out[x],in[y],cnt+1);
}
int per;
void update(int y)
{
	int x = rk[y];
	vis[y]^=1;
	if(vis[y])
	{
		per++;
		Add(x,(ll)a[y]*n+1);
		ll z = Getans(x)-1;
		res+=(ll)a[y]*(per-z%n-1)+z/n;
	}else
	{
		ll z = Getans(x)-1;
		res-=(ll)a[y]*(per-z%n-1)+z/n;
		per--;
		Add(x,-((ll)a[y]*n+1));
	}
}
int bl;
bool cmp1(int x,int y)
{
	return a[x]<a[y];
}
bool cmp2(const data &a,const data &b)
{
	if(a.x/bl==b.x/bl)return a.y<b.y;
	return a.x/bl<b.x/bl;
}
int main()
{
	int root =0;
	scanf("%d%d%d",&n,&m,&key);
	bl = sqrt(2*n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),q[i]=i;
	sort(q+1,q+n+1,cmp1);
	for(int i=1;i<= n;i++)rk[q[i]]=i;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&fa[i]);
		if(fa[i])add(fa[i],i);
		else root = i;
	}
	dfs(root);dfs2(root,root);
	int x=1,y;char opt[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s%d",opt,&y);
		if(opt[0]=='C')x=y;
		else
		{
			Insert(x,y%n+1);
			Insert(x,(y+key)%n+1);
		}
	}
	sort(b+1,b+cnt+1,cmp2);
	int l = 1,r = 0;res = 0;
	for(int i = 1;i<= cnt;i++)
	{
		while(l<b[i].x)update(seq[l]),l++;
		while(b[i].x<l)l--,update(seq[l]);
		while(r<b[i].y)r++,update(seq[r]);
		while(b[i].y<r)update(seq[r]),r--;
		x=seq[l]; y=seq[r]; int z=getlca(x,y);
		if (x!=z) update(z); 
		ans[b[i].k]=res; 
		if (x!=z) update(z);
	}
	ll tmp = 0;
	for(int i = 1;i<= cnt>>1;i++)
	{
		tmp = ans[i<<1|(tmp&1)];
		printf("%lld\n",tmp);
	}
	return 0;
}
Problem3473

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
char s[N];
struct E{int next,to;};
int id[N],in[N],out[N],Dfn,num[N],n,k,to[N];
ll ans[N];
int last,cnt;
int trs[N][26],fa[N],len[N];
vector<int>ed[N];
bool v[N];
struct Gragh
{
	E e[N];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}
	void dfs(int x)
	{
		id[++Dfn] = x;
		in[x] = Dfn;
		for(int i = head[x];i;i=e[i].next)
			dfs(e[i].to);
		out[x] = Dfn;
	}
	void getans(int x,ll Ans)
	{
		if(num[x]>=k)Ans+=len[x]-len[fa[x]];
		for(int i = 0;i<ed[x].size();i++)
			ans[ed[x][i]]+=Ans;
		for(int i = head[x];i;i=e[i].next)
			getans(e[i].to,Ans);
	}
}g1,g2;
void init(){last=cnt=1;}
int insert(int x,int y)
{
	int p = last;
	if(trs[p][x])
	{
		int q = trs[p][x];
		if(len[q]==len[p]+1)last = q;
		else
		{
			int nq = ++cnt;
			last = nq;
			fa[nq] = fa[q];len[nq]=len[p]+1;
			memcpy(trs[nq],trs[q],sizeof(trs[q]));
			fa[q] = nq;
			for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=nq;
		}
	}else
	{
		int np = ++cnt,q,nq;
		last = np;len[np] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x]=np;
		if(!p)fa[np] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[np] = q;
			else
			{
				fa[nq=++cnt]=fa[q];
				len[nq] = len[p]+1;
				memcpy(trs[nq],trs[q],sizeof(trs[q]));
				fa[np] = fa[q] = nq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = nq;
			}
		}
	}
	ed[last].push_back(y);
	return last;
}
void build()
{
	for(int i = 1;i<= cnt;i++)
		g1.add(fa[i],i);
	g1.dfs(1);
}
int c[N];
void update(int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int lst[N];
struct Ask
{
	int l,r,no;
	bool operator<(const Ask &s)const
	{
		return r<s.r;
	}
}ask[N];
int pos[N];
int main()
{
	scanf("%d%d",&n,&k);
	init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s+1);
		int l = strlen(s+1);
		last = 1;
		for(int j = 1;j<= l;j++)
		{
			int tmp=insert(s[j]-'a',i);
			g2.add(tmp,i);
		}
	}
	build();
	for(int i = 1;i<=cnt;i++)
		ask[i] = (Ask){in[i],out[i],i};
	sort(ask+1,ask+cnt+1);
	int tt = 1;
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = g2.head[id[i]];j;j=g2.e[j].next)
		{
			int p = g2.e[j].to;
			if(lst[p])update(lst[p],-1);
			update(i,1);
			lst[p] = i;
		}
		for(;ask[tt].r==i;tt++)
			num[ask[tt].no]=getans(ask[tt].r)-getans(ask[tt].l-1);
	}
	g1.getans(1,0);
	for(int i = 1;i<= n;i++)
		printf("%lld ",ans[i]);
	printf("\n");
	return 0;
}
Problem3489

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stack>
#include <algorithm>
#define Maxn 200010
#define l(x) ch[x][0]
#define r(x) ch[x][1]
#define lc(x) c[x][0]
#define rc(x) c[x][1]
using namespace std;
int n,m,tot=0,_tot=0,tree[Maxn]={0};
int a[Maxn],last[Maxn],pos[Maxn],next[Maxn],N,rank[Maxn];
int maxt[40000005],ch[40000010][2];
int c[2000010][2],root[2000010];
stack<int> _mL,mL;
int get()
{
	if(mL.empty()) return ++tot;
	int tp=mL.top();
	mL.pop();
	return tp;
}
int _get()
{
	if(_mL.empty()) return ++_tot;
	int tp=_mL.top();
	_mL.pop();
	return tp;
}
int _change(int o,int l,int r,int qx,int qv)
{
    int x=++_tot; maxt[x]=max(maxt[o],qv);
    l(x)=l(o); r(x)=r(o);
    if(l==r) return x;
    int mid=(l+r)>>1;
    if(qx<=mid) l(x)=_change(l(x),l,mid,qx,qv);
    else r(x)=_change(r(x),mid+1,r,qx,qv);
    return x;
}
int _query(int o,int l,int r,int ql,int qr)
{
	if(!o) return 0;
    if(ql<=l&&r<=qr) return maxt[o];
    int mid=(l+r)>>1,res=0;
    if(ql<=mid) res=max(res,_query(l(o),l,mid,ql,qr));
    if(mid<qr) res=max(res,_query(r(o),mid+1,r,ql,qr));
    return res;
}
int query(int o,int l,int r,int ql,int qr,int qa,int qb)
{
    if(ql<=l&&r<=qr) return _query(root[o],1,n,qa,qb);
    int mid=(l+r)>>1,res=0;
    if(ql<=mid) res=max(res,query(lc(o),l,mid,ql,qr,qa,qb));
    if(mid<qr) res=max(res,query(rc(o),mid+1,r,ql,qr,qa,qb));
    return res;
}
int change(int o,int l,int r,int qx,int qy,int qv)
{
    int x=++tot;
    lc(x)=lc(o); rc(x)=rc(o);
    root[x]=_change(root[o],1,n,qy,qv);
    if(l==r) return x;
    int mid=(l+r)>>1;
    if(qx<=mid) lc(x)=change(lc(o),l,mid,qx,qy,qv);
    else rc(x)=change(rc(o),mid+1,r,qx,qy,qv);
    return x;
}
bool cmp(const int &a,const int &b){return last[a]<last[b];}
int main()
{
    scanf("%d%d",&n,&m);
    memset(last,0,sizeof(last));
    for(int i=1;i<=n;i++) pos[i]=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        last[i]=pos[a[i]],pos[a[i]]=i;
    }
    memset(next,0,sizeof(next));
    for(int i=1;i<=n;i++) pos[i]=n+1;
    for(int i=n;i>=1;i--)
    {
        rank[i]=i;
        next[i]=pos[a[i]],pos[a[i]]=i;
    }
    sort(rank+1,rank+n+1,cmp);
    int j=1,ans=0,l,r;
    for(int i=0;i<n;i++)
    {
        if(i) tree[i]=tree[i-1];
        while(j<=n&&last[rank[j]]==i)
        {
            tree[i]=change(tree[i],0,n+1,next[rank[j]],rank[j],a[rank[j]]);
            j++;
        }
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&l,&r);
        l=(l+ans)%n+1;
        r=(r+ans)%n+1;
        if(l>r) swap(l,r);
        ans=query(tree[l-1],0,n+1,r+1,n+1,l,r);
        printf("%d\n",ans);
    }
    return 0;
}
Problem3505

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
int gcd(int x,int y)
{
	if(x==0)return y;
	return gcd(y%x,x);
}
int main()
{
	LL n,m;
	scanf("%lld%lld",&n,&m);
	n++;m++;
	LL ans = n*m*(n*m-1)*(n*m-2);
	ans = ans/(LL)6;
	for(int i = 0;i< n;i++)
	{
		for(int j = 0;j< m;j++)
		{
			LL len = min(i,j);
			if(!i)len = j-1;
			if(!j)len = i-1;
			if(i&&j)len = gcd(i,j)-1;
			len = max(0ll,len);
			if(len==0)continue;
			if(i&&j)ans-=len*(n-i)*(m-j)*2;
			else ans-=len*(n-i)*(m-j);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3509

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mxs = 30005;
const int N = 1e5+5;
const int size = 1800;
const double PI = 3.14159265358979323;
int n;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}a[524299],b[524299];

int num[N],pos[N],L[N],R[N];
int st[N],end[N],tot,lim;
int cnt[400][60005];
int cnt_nxt[60005],cnt_pre[60005];
ll ans[N];

void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*2*type/i),sin(PI*2*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = a[j+k+(i>>1)]*w;
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}	
	if(type==-1)
		for(int i = 0;i<len;i++)a[i].x/=len*4,a[i].y/=len;
}

void conv(int len)
{
	memset(a,0,sizeof(cp)*(len+1));
	memset(b,0,sizeof(cp)*(len+1));
	for(int i = 0;i<=lim;i++)a[i] = cp(L[i]+R[i],L[i]-R[i]);
	FFT(a,len,1);
	for(int i = 0;i<len;i++)b[i]=a[i]*a[i];
	FFT(b,len,-1);
	for(int i = 0;i<len;i++)ans[i] = (ll)(b[i].x+0.5);
}

void div_block()
{
	for(int i = 1;i<= n;i++)pos[i] = (i-1)/size+1;
	tot = pos[n];
	for(int i = 1;i<= tot;i++)st[i] = (i-1)*size+1,end[i] = i*size;
	end[tot] =n;
	for(int i = 1;i<= tot;i++)
		for(int j = st[i];j<=end[i];j++)
			cnt[i][num[j]]++;
}
int len;
void init()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&num[i]);
	for(int i = 1;i<= n;i++)lim=max(lim,num[i]);
	len = 1;
	for(;len<=2*lim;len<<=1);
}

ll res;
void calc(int p)
{
	int t = num[p]<<1;
	int cur = pos[p];
	for(int i = st[cur];i<p;i++)if(t>=num[i])res+=R[t-num[i]];
	for(int i = p+1;i<= end[cur];i++)
		if(t>=num[i])
		{
			res+=cnt_pre[t-num[i]];
			res+=L[t-num[i]];
			if (cur == 1) continue;
		}
	if (p <= end[1] || p >= st[tot]) return;
    res += ans[t];
}

void solve()
{
	for(int i = 1;i<= n;i++)R[num[i]]++;
	for(int i = 1;i<= tot;i++)
	{
		memset(cnt_pre,0,sizeof(int)*(lim+1));
		for(int j = st[i];j<=end[i];j++)cnt_nxt[num[j]]++;
		for(int j = 0;j<= lim;j++)R[j]-=cnt[i][j];
		if(i!=1&&i!=tot)conv(len);
		for(int j = st[i];j<= end[i];j++)
		{
			cnt_nxt[num[j]]--;
			calc(j);
			cnt_pre[num[j]]++;
		}
		for(int j = 0;j<= lim;j++)L[j]+=cnt[i][j];
		//printf("%lld\n",res);
	}
	printf("%lld\n",res);
}
int main()
{
	//freopen("3509.in","r",stdin);
	//freopen("3509.out","w",stdout);
	init();
	div_block();
	solve();
	return 0;
}
Problem3521

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const int INF = 0x3f3f3f3f;
int v[N],stack[N],top,nxt[N],fv[N],b[N],pre[N];
char s[N];
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	scanf("%s",s+1);
	for(int i = 1;i<= n;i++)
	{
		if(s[i]=='p')pre[i] = pre[i-1]+1;
		else pre[i] = pre[i-1]-1;
	}
	for(int i = 1;i<= n;i++)
	{
		while(top>0&&pre[i]-pre[stack[top]-1]<0)
		{
			nxt[stack[top]] = i-1;
			top--;
		}
		if(top)fv[i] = stack[1];
		else if(pre[i]-pre[i-1]==1)fv[i] = i;
		else fv[i] = INF;
		if(pre[i]-pre[i-1]==1)stack[++top] = i;
	}
	while(top>0)
	{
		nxt[stack[top]] = n;
		top--;
	}
	int L,R,mid,head = 0;
	for(int i = n;i>= 1;i--)
	{
		while(top>0&&pre[stack[top]]-pre[i-1]<0)
		{
			L = 2,R = head+1;
			while(L<R)
			{
				mid = (L+R)>>1;
				if(nxt[b[mid]]>=stack[top])L = mid+1;
				else R = mid;
			}
			ans = max(ans,stack[top]-max(fv[stack[top]]-1,b[L-1]-1));
			top--;
		}
		if(pre[i]-pre[i-1]==1)
		{
			stack[++top] = i;
			while(head&&nxt[b[head]]<=nxt[i])head--;
			b[++head] = i;
		}
	}
	while(top>0)
	{
		L = 2,R = head+1;
		while(L<R)
		{
			mid = (L+R)>>1;
			if(nxt[b[mid]]>=stack[top])L = mid+1;
			else R = mid;
		}
		ans = max(ans,stack[top]-max(fv[stack[top]]-1,b[L-1]-1));
		top--;
	}
	printf("%d\n",ans);
	return 0;
}
Problem3522

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5005;
typedef long long LL;
struct E
{int next,to;}e[N<<1];
int head[N],tot,tmp[N],g[N],f[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa,int dep)
{
	tmp[dep]++;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x,dep+1);
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	LL ans = 0;
	for(int rt = 1;rt<= n;rt++)
	{
		memset(f,0,sizeof(f));
		memset(g,0,sizeof(g));
		for(int i = head[rt];i;i = e[i].next)
		{
			memset(tmp,0,sizeof(tmp));
			dfs(e[i].to,rt,1);	
			for(int j = 1;j<= n;j++)
			{
				ans+=(LL)g[j]*tmp[j];
				g[j]+=f[j]*tmp[j];
				f[j]+=tmp[j];
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3523

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
struct H
{
	int col,num,se;
}heap[N];
bool cmp(H a,H b)
{
	if(a.num!=b.num)
		return a.num<b.num;
	return a.se<b.se;
}
int a[N],ans[N],cnt;
int main()
{
	int n,s,t;
	scanf("%d%d%d",&n,&s,&t);
	int sum = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum = sum+a[i];
	}
	if(sum==1&&s==t)
		{printf("%d\n",1);return 0;}
	else if(sum==1){printf("0\n");return 0;}
	for(int i = 1;i<= n;i++)
	{
		if(a[i]-(i==s)-(i==t)>0)
		{
		heap[++cnt].col = i;
		heap[cnt].num = a[i]-(i==s)-(i==t);
		heap[cnt].se = i==t;
		push_heap(heap+1,heap+cnt+1,cmp);
		}else if(a[i]-(i==s)-(i==t)<0)
		{printf("0\n");return 0;}
	}
	int i;
	ans[1] = s,ans[sum] = t; 
	for(i = 2;i< sum;i++)
	{
		H x = heap[1];
		pop_heap(heap+1,heap+1+cnt,cmp);
		cnt--;
		if(x.col==ans[i-1]&&cnt!=0)
		{
			H tmp = x;
			x = heap[1];
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			ans[i] = x.col;
			x.num--;
			if(x.num)
			{
				heap[++cnt] = x;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
			heap[++cnt] = tmp;
			push_heap(heap+1,heap+cnt+1,cmp);
			continue;
		}
		else if(x.col!=ans[i-1])
		{
			ans[i] = x.col;
			x.num--;
			if(x.num)
			{
				heap[++cnt] = x;
				push_heap(heap+1,heap+cnt+1,cmp);
			}
		}
		if(!cnt&&ans[i]==0)
			{printf("0\n");return 0;}
	}
	if(ans[sum]!=ans[sum-1]||sum==1)
	{
		for(i = 1;i< sum;i++)
			printf("%d ",ans[i]);
		printf("%d\n",ans[sum]);
	}
	else printf("0\n");
	return 0;
}
Problem3524

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 1e7+5;
int root[N];
int ls[M],rs[M],sum[M];
int cnt,n,m;
void update(int l,int r,int rt1,int &rt2,int v)
{
	rt2 = ++cnt;
	sum[rt2] = sum[rt1]+1;
	if(l==r)return ;
	int mid = (l+r)>>1;
	ls[rt2] = ls[rt1],rs[rt2] = rs[rt1];
	if(v<=mid)update(l,mid,ls[rt1],ls[rt2],v);
	else update(mid+1,r,rs[rt1],rs[rt2],v);
}
int ask(int L,int R)
{
	int l,r,tmp = (R-L+1)>>1;
	int rt1 = root[L-1],rt2 = root[R];
	l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[rt2]-sum[rt1]<=tmp)return 0;
		if(sum[ls[rt2]]-sum[ls[rt1]]>tmp)
		{
			r = mid;
			rt1 = ls[rt1],rt2 = ls[rt2];
		}else if(sum[rs[rt2]]-sum[rs[rt1]]>tmp)
		{
			l = mid+1;
			rt1 = rs[rt1],rt2 = rs[rt2];
		}
		else return 0;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		int x;
		scanf("%d",&x);
		update(1,n,root[i-1],root[i],x);
	}
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		printf("%d\n",ask(x,y));
	}
	return 0;
}
Problem3527

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double x=0,double y=0):x(x),y(y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}x[N],y[N],z[N];
void FFT(cp *a,int len,int type)
{
	int t=0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*type*2/i),sin(PI*type*2/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w = cp(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
double ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<=len;i++)
		c[i]=a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<=len;i++)
		ans[i]=c[i].x;
}
int main()
{
	int n;
	scanf("%d",&n);
	n--;
	for(int i = 0;i<= n;i++)scanf("%lf",&x[i].x);
	for(int i = 0;i<n;i++)
		y[i].x = (-1.0)/((double)(n-i)*(n-i));
	for(int i = n+1;i<=2*n;i++)
		y[i].x = -y[2*n-i].x;
	int m = 4*n,L = 1,nn = n;
	for(n=1;n<=m;n=n<<1)L++;
	conv(x,y,z,n);
	//for(int i = 0;i<= m;i++)ans[i] = c[i].x;
	for(int i = nn;i<= 2*nn;i++)printf("%.5lf\n",ans[i]);
	return 0;
}
Problem3529

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
const ll mod = (1ll<<31)-1;
bool vis[N];
int mu[N],prime[N],cnt;
ll G[N],g[N];
struct To
{int no;ll val;}g_no[N];
bool cmp(const To &a,const To &b){return a.val<b.val;}
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] =i;
			mu[i] = -1;
		}
		for(int j = 1;j<=cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]] = -mu[i];
			else
			{
				mu[i*prime[j]] = 0;
				break;
			}
		}
	}
	for(int i = 1;i<N;i++)
		for(int j = 1;j*i<N;j++)
			g[i*j]=(g[i*j]+i)&mod;
	for(int i = 1;i<N;i++)
		g_no[i].val = g[i],g_no[i].no = i;
	sort(g_no+1,g_no+N,cmp);
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		G[i]=(G[i]+y)&mod;
}
ll getans(int x)
{
	ll ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans=(ans+G[i])&mod;
	return ans;
}
struct A
{int a,no,n,m;}ask[N];
bool cmpask(const A &a,const A &b){return a.a<b.a;}
ll ans_no[N];
void solve(int n,int m,int no)
{
	ll ans = 0;
	int last;
	for(int i = 1;i<=n&&i<=m;i =last+1)
	{
		last = min(n/(n/i),m/(m/i));
		ans = (ans+(ll)(n/i)*(m/i)*((getans(last)-getans(i-1))%(mod+1)+mod+1))&mod;
	}
	ans_no[no] = ans;
}
int main()
{
	int q;
	scanf("%d",&q);
	quick_mu();
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].n,&ask[i].m,&ask[i].a);
		ask[i].no = i;
	}
	sort(ask+1,ask+q+1,cmpask);
	int r = 1;
	for(int i = 1;i<= q;i++)
	{
		while(g_no[r].val<=ask[i].a&&r<N)
		{
			for(int j = 1;j*g_no[r].no<N;j++)
				update(j*g_no[r].no,g_no[r].val*mu[j]);
			r++;
		}
		solve(ask[i].n,ask[i].m,ask[i].no);
	}
	for(int i=1;i<= q;i++)
		printf("%lld\n",ans_no[i]);
	return 0;
}
Problem3530

#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define mod 1000000007
#define LL long long
#include <queue>
using namespace std;
struct trie
{
    int ch[12],mark,fail,last;
}t[2005];
char N[1500],s[1500];
int m,tot=0,n[2000],l;
LL f[1205][2005][3];
void Insert(char s[])
{
    int x=0;
    for (int i=0;i<strlen(s);i++)
    {
        int c=s[i]-'0';
        if (!t[x].ch[c])
            t[x].ch[c]=++tot;
        x=t[x].ch[c];
    }
    t[x].mark=1;
}
void Make_fail()
{
    queue<int> q;
    for (int i=0;i<=9;i++)
        if (t[0].ch[i]) 
            q.push(t[0].ch[i]);
    while (!q.empty())
    {
        int x=q.front();
        q.pop();
        for (int i=0;i<=9;i++)
            if (t[x].ch[i])
            {
                int y=t[x].ch[i];
                q.push(y);
                int v=t[x].fail;
                while (v&&!t[v].ch[i])
                    v=t[v].fail;
                t[y].fail=v=t[v].ch[i];
                t[y].last=t[v].mark?v:t[v].last;
            }
    }
}
void Add(LL &a,LL b)
{
    a=(a+b)%mod;
}
int C(int a,int b)
{
    if (a==b) return 1;
    if (a<b) return 0;
    return 2;
}
void DP()
{
    LL ans=0;
    for (int k=1;k<=9;k++)
    {
        int v=t[0].ch[k];
        if (!t[v].mark&&!t[v].last)
            f[1][t[0].ch[k]][C(k,n[1])]+=1;
    }
    for (int j=0;j<=tot;j++)
        ans=(ans+f[1][j][0]+f[1][j][1]+f[1][j][2])%mod;
    for (int i=1;i<l;i++)
    {
        for (int j=0;j<=tot;j++)
            if (f[i][j][0]||f[i][j][1]||f[i][j][2])
                for (int k=0;k<=9;k++)
                {
                    int v=j;
                    while (v&&!t[v].ch[k])
                        v=t[v].fail;
                    v=t[v].ch[k];
                    if (!t[v].mark&&!t[v].last)
                    {
                        int x=C(k,n[i+1]);
                        if (x==0)
                            Add(f[i+1][v][0],f[i][j][0]+f[i][j][1]),
                            Add(f[i+1][v][2],f[i][j][2]);
                        if (x==1)
                            Add(f[i+1][v][0],f[i][j][0]),
                            Add(f[i+1][v][1],f[i][j][1]),
                            Add(f[i+1][v][2],f[i][j][2]);
                        if (x==2)
                            Add(f[i+1][v][0],f[i][j][0]),
                            Add(f[i+1][v][2],f[i][j][1]+f[i][j][2]);
                    }
                }
        for (int j=0;j<=tot;j++)
        {
            Add(ans,f[i+1][j][0]+f[i+1][j][1]);
            if (i+1!=l)
                Add(ans,f[i+1][j][2]);
        }
    }
    printf("%d\n",(int)ans%mod);
}
int main()
{
    scanf("%s",N);
    l=strlen(N);
    for (int i=1;i<=l;i++)
        n[i]=N[i-1]-'0';
    scanf("%d",&m);
    for (int i=1;i<=m;i++)
        scanf("%s",s),Insert(s);
    Make_fail();
    DP();
    return 0;
}
Problem3531

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define N 100005
#define M 10000005
struct seg{int ls,rs,sum,mw;}t[M];
int tpn,n;
struct E{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x]= tot;
}
int top[N],deep[N],fa[N],size[N],son[N],w[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x]= ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int score[N],color[N];
int root[N];
void update(int p,int l,int r,int x,int b)
{
	if(l==r){t[p].sum = b,t[p].mw= b;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)
	{
		if(t[p].ls==0)t[p].ls= ++tpn;
		update(t[p].ls,l,mid,x,b);
	}else
	{
		if(t[p].rs==0)t[p].rs= ++tpn;
		update(t[p].rs,mid+1,r,x,b);
	}
	t[p].sum = t[t[p].ls].sum+t[t[p].rs].sum;
	t[p].mw = max(t[t[p].ls].mw,t[t[p].rs].mw);	
}
int getmax(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return t[p].mw;
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)
		ans = max(ans,getmax(t[p].ls,l,mid,a,b));
	if(b>mid)
		ans = max(ans,getmax(t[p].rs,mid+1,r,a,b));
	return ans;
}
int getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return t[p].sum;
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<= mid)
		ans+=getsum(t[p].ls,l,mid,a,b);
	if(b>mid)
		ans+=getsum(t[p].rs,mid+1,r,a,b);
	return ans;
}
int get_ans(int x,int y,int opt,int c)
{
	int ans = 0;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		if(opt==1)ans += getsum(root[c],1,n,w[top[x]],w[x]);
		else ans = max(ans,getmax(root[c],1,n,w[top[x]],w[x]));
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)ans += getsum(root[c],1,n,w[y],w[x]);
	else ans = max(ans,getmax(root[c],1,n,w[y],w[x]));
	return ans;
}
int main()
{
	for(int i = 1;i<= N-5;i++)
		root[i] = ++tpn;
	int x,y,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&score[i],&color[i]);
	for(int i = 1;i<n;i++)
		{scanf("%d%d",&x,&y);add(x,y);add(y,x);}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(root[color[i]],1,n,w[i],score[i]);
	char j[5];
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",j,&x,&y);
		if(j[1]=='S')printf("%d\n",get_ans(x,y,1,color[x]));
		else if(j[1]=='M')printf("%d\n",get_ans(x,y,0,color[x]));
		else if(j[1]=='W')
		{
			score[x] = y;
			update(root[color[x]],1,n,w[x],y);
		}else
		{
			update(root[color[x]],1,n,w[x],0);
			color[x] = y;
			update(root[color[x]],1,n,w[x],score[x]);
		}
	}
	return 0;
}
Problem3538

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 10005;
const int M = 50005;
bool v[N];
struct E
{int next,to,val;};
queue<int>Q;
struct G
{
	E e[M<<1];
	int head[N],tot,minn;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val = f;
		head[x] = tot;
	}
	int dis[N];
	void spfa(int s,int t)
	{
		memset(dis,0x3f,sizeof(dis));
		dis[s] = 0;
		v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i = e[i].next)
			{
				if(dis[x]+e[i].val<dis[e[i].to])
				{
					dis[e[i].to] = dis[x]+e[i].val;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
			}
		}
		minn = dis[t];
	}
}g1,g2,g;
int main()
{
	int n,m,x,y,u,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		g1.add(y,x,u);
		g2.add(y,x,w);
	}
	g1.spfa(n,1);
	g2.spfa(n,1);
	for(int i = 1;i<= n;i++)
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			int t = g1.e[j].to;
			int cnt = 0;
			if(g1.dis[i]+g1.e[j].val!=g1.dis[t])cnt++;
			if(g2.dis[i]+g2.e[j].val!=g2.dis[t])cnt++;
			g.add(t,i,cnt);
		}
	g.spfa(1,n);
	printf("%d\n",g.minn);
	return 0;
}
Problem3540

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
const int LIM = (N<<1)+5;
struct C
{int k,s;}cow[N];
bool cmp(C a,C b)
{return a.s<b.s;}
int pos[(N<<1)+5];
int main()
{	
	int n,x;
	char tmp[3];
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%s",&x,tmp);
		if(tmp[0]=='W')cow[i].k = -1;
		else cow[i].k = 1;
		cow[i].s =x;
	}
	sort(cow+1,cow+n+1,cmp);
	memset(pos,0x3f,sizeof(pos));
	int sum = n,ans = 0;
	pos[sum] = cow[1].s;
	for(int i = 1;i< n;i++)
	{
		sum+=cow[i].k;
		pos[sum] = min(pos[sum],cow[i+1].s);
	}
	for(int i = 2*n;i>=0;i--)
		pos[i] = min(pos[i],pos[i+2]);
	sum = n;
	for(int i = 1;i<= n;i++)
	{
		sum+=cow[i].k;
		ans = max(cow[i].s-pos[sum],ans);
	}
	printf("%d\n",ans);
	return 0;
}
Problem3545

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 5e6+5;
int sum[M],ls[M],rs[M],tot,root[N],maxn;
int fa[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void Insert(int &p,int l,int r,int pos)
{
	if(!p)p=++tot;
	if(l==r)
	{
		sum[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)Insert(ls[p],l,mid,pos);
	else Insert(rs[p],mid+1,r,pos);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
int merge(int x,int y,int l,int r)
{
	if(!x||!y)return x+y;
	if(l==r)
	{
		sum[x] = sum[x]+sum[y];
		return x;
	}
	int mid = (l+r)>>1;
	ls[x] = merge(ls[x],ls[y],l,mid);
	rs[x] = merge(rs[x],rs[y],mid+1,r);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
struct edge
{
	int x,y,w;
	bool operator <(const edge &s)const
	{
		return w<s.w;
	}
}e[5*N];
struct Ask
{
	int p,v,k,no;
	bool operator <(const Ask &s)const
	{
		return v<s.v;
	}
}ask[5*N];
int hill[N],ans[5*N];
int getans(int p,int k)
{
	if(k<=0)return -1;
	int l = 1,r = maxn,ans=-1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[ls[p]]>=k)
			p = ls[p],r=mid;
		else 
		{
			k-=sum[ls[p]];
			p = rs[p],l= mid+1;
		}
	}
	return l;
}
int main()
{
	int n,m,q;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<=n;i++)
		scanf("%d",&hill[i]),maxn = max(maxn,hill[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].p,&ask[i].v,&ask[i].k);
		ask[i].no = i;
	}
	sort(e+1,e+m+1);sort(ask+1,ask+q+1);
	for(int i = 1;i<= n;i++)
		Insert(root[i],1,maxn,hill[i]);
	int j = 1;
	for(int i = 1;i<= q;i++)
	{
		while(j<=m&&e[j].w<=ask[i].v)
		{
			int fx = getfa(e[j].x),fy = getfa(e[j].y);
			if(fx==fy){j++;continue;}
			fa[fy] = fx;
			root[fx] = merge(root[fx],root[fy],1,maxn);
			j++;
		}
		int tmp = getfa(ask[i].p);
		ans[ask[i].no] = getans(root[tmp],sum[root[tmp]]-ask[i].k+1);
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem3555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int sed = 299;
typedef unsigned long long ll;
const int N = 6e6+5;
ll pow[205];
ll hash[N];
char s[205];
int cnt;
int main()
{
	int n,l,q;
	pow[0]=1;
	for(int i = 1;i<205;i++)pow[i]=pow[i-1]*sed;
	scanf("%d%d%d",&n,&l,&q);
	for(int i = 1;i<= n;i++)
	{
		ll tmp = 0;
		scanf("%s",s+1);
		int lth = strlen(s+1);
		for(int i = 1;i<=lth;i++)
			tmp = tmp*sed+s[i];
		for(int i = 1;i<=lth;i++)
		{
			ll tt = tmp-s[i]*pow[lth-i];
			hash[++cnt] = tt;
		}
	}
	sort(hash+1,hash+cnt+1);
	ll ans = 0;
	int cc = 0;
	for(int i = 1;i<= cnt;i++)
	{
		if(i==1||hash[i]!=hash[i-1])
			cc=-1;
		cc++;
		ans+=cc;
	}
	printf("%llu\n",ans);
	return 0;
}
Problem3566

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
const double eps = 1e-6;
struct E{int next,to;double p;}e[N<<2];
int head[N],tot;
void add(int x,int y,double val)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].p = val;
	head[x] = tot;
}
double g[N],f[N],q[N];
void dfs(int x,int fa)
{
	double tmp = 1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			tmp*=(1.0-e[i].p*f[e[i].to]);
		}	
	}
	f[x] = 1.0-tmp*(1.0-q[x]);	
}
void dfs2(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		double tmp = 1-f[e[i].to]*e[i].p;
		if(fabs(tmp)<eps)g[e[i].to] = 1;
		else
		{
			double y = (g[x]-f[e[i].to]*e[i].p)/(1-f[e[i].to]*e[i].p);
			g[e[i].to] = f[e[i].to]+y*e[i].p-f[e[i].to]*y*e[i].p;
		}
		dfs2(e[i].to,x);
	}
}
int main()
{
	int n,x,y;
	double p;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%lf",&x,&y,&p);
		add(x,y,p/100.0);
		add(y,x,p/100.0);
	}
	for(int i = 1;i<= n;i++)
		{scanf("%lf",&q[i]);q[i]/=100.0;}
	dfs(1,0);
	g[1] = f[1];
	dfs2(1,0);
	double ans = 0;
	for(int i = 1;i<= n;i++)
		ans+=g[i];
	printf("%.6f",ans);
	return 0;
}
Problem3572

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+100;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;};
int size[N],fa[N][20],dep[N],dfn[N],Dfn;
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;
	}
	void dfs(int x,int f)
	{
		fa[x][0] = f;
		dep[x] = dep[f]+1;
		size[x] = 1;
		dfn[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=f)
			{
				dfs(e[i].to,x);
				size[x]+=size[e[i].to];
			}
	}
	void init(int n)
	{
		for(int j = 1;j<= 19;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 19;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 19;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	int jump(int x,int h)
	{
		for(int i = 19;i>=0;i--)
			if(dep[fa[x][i]]>=h)
				x=fa[x][i];
		return x;
	}
}tree;
int h[N],stk[N],top;
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int father[N],rec[N],val[N],dis[N],ans[N],tr[N],len[N],near[N];
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i= 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		tree.add(x,y);
	}
	tree.dfs(1,0);
	tree.init(n);
	int q,m;
	scanf("%d",&q);
	while(q--)
	{
		scanf("%d",&m);
		int cnt = 0;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&h[i]);
			tr[++cnt] = h[i];
			rec[i] = near[h[i]]=h[i];
			dis[h[i]]=ans[h[i]]=0;
		}
		top = 0;
		sort(h+1,h+m+1,cmp);
		for(int i=1;i<=m;i++)
		{
			if(!top)father[stk[++top]=h[i]]=0;
			else
			{
				int lca = tree.getlca(stk[top],h[i]);
				while(dep[lca]<dep[stk[top]])
				{
					if(dep[lca]>=dep[stk[top-1]])
						father[stk[top]]=lca;
					top--;
				}
				if(stk[top]!=lca)
				{
					father[lca]=stk[top];
					stk[++top]=tr[++cnt]=lca;
					near[lca]=0,dis[lca]=INF;
				}
				father[stk[++top]=h[i]]=lca;
			}
		}
		sort(tr+1,tr+cnt+1,cmp);
		for(int i = 1;i<= cnt;i++)
		{
			val[tr[i]]=size[tr[i]];
			len[tr[i]]=dep[tr[i]]-dep[father[tr[i]]];
		}
		for(int i = cnt;i>=2;i--)
		{
			if(dis[father[tr[i]]]>dis[tr[i]]+len[tr[i]])
			{
				dis[father[tr[i]]]=dis[tr[i]]+len[tr[i]];
				near[father[tr[i]]]=near[tr[i]];
			}else if(dis[father[tr[i]]]==dis[tr[i]]+len[tr[i]])
				near[father[tr[i]]]=min(near[father[tr[i]]],near[tr[i]]);
		}
		for(int i = 2;i<= cnt;i++)
		{
			if(dis[tr[i]]>dis[father[tr[i]]]+len[tr[i]])
			{
				dis[tr[i]] = dis[father[tr[i]]]+len[tr[i]];
				near[tr[i]] = near[father[tr[i]]];
			}else if(dis[tr[i]]==dis[father[tr[i]]]+len[tr[i]])
				near[tr[i]]=min(near[father[tr[i]]],near[tr[i]]);
		}
		for(int i = 1;i<= cnt;i++)
		{
			if(i==1)ans[near[tr[i]]]=n-size[tr[i]];
			else
			{
				int x = tree.jump(tr[i],dep[father[tr[i]]]+1);
				int s = size[x]-size[tr[i]];
				val[father[tr[i]]]-=size[x];
				if(near[father[tr[i]]]==near[tr[i]])
					ans[near[tr[i]]]+=s;
				else
				{
					int num = dis[father[tr[i]]]+dis[tr[i]]+len[tr[i]]+1;
					int mid = dep[tr[i]]+dis[tr[i]]-(num+1)/2+1;
					if((num&1)&&near[tr[i]]>near[father[tr[i]]])mid++;
					x=size[x]-size[tree.jump(tr[i],mid)];
					ans[near[father[tr[i]]]]+=x;
					ans[near[tr[i]]]+=s-x;
				}
			}
		}
		for(int i = 1;i<= cnt;i++)
			ans[near[tr[i]]]+=val[tr[i]];
		for(int i = 1;i<= m;i++)
			printf("%d ",ans[rec[i]]);
		printf("\n");
	}
	return 0;
}
Problem3586

#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
typedef long double ld;
int tt,n,l,t;
char s[10];
int trie[60][26],pos[60],tot,fail[60];
ld f[60][356],p[26],a[60][60];
queue<int> q;
void mkfail()
{
	q.push(0);
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=0;i<t;i++)
		{
			if(trie[x][i])
			{
				if(x) fail[trie[x][i]]=trie[fail[x]][i];
				q.push(trie[x][i]);
			}else trie[x][i]=trie[fail[x]][i];
		}
	}
}
void Gauss(int n)
{
	for(int i=0;i<=n;i++)
	{
		ld mx=0;int pos;
		for(int j=i;j<=n;j++)
		{
			if(fabs(a[j][i])>mx)
			{
				mx=fabs(a[j][i]);
				pos=j;
			}
		}
		for(int j=i;j<=n+1;j++) swap(a[i][j],a[pos][j]);
		for(int j=i+1;j<=n;j++)
		{
			ld f=a[j][i]/a[i][i];
			for(int k=i;k<=tot+1;k++)
				a[j][k]-=f*a[i][k];
		}
	}
	for(int i=n;i>=0;i--)
	{
		for(int j=i+1;j<=n;j++)
			a[i][tot+1]-=a[i][j]*a[j][tot+1];
		a[i][tot+1]/=a[i][i];
	}
}

void calc(int x)
{
	memset(a,0,sizeof a);
	for(int i=0;i<=tot;i++)
	{
		a[i][i]=1;
		if(pos[i]!=-1&&((1<<pos[i])&x)) a[i][tot+1]=f[i][x^(1<<pos[i])];
		else
		{
			a[i][tot+1]=1;
			for(int j=0;j<t;j++)
				a[i][trie[i][j]]-=p[j];
		}
	}
	Gauss(tot);
	for(int i=0;i<=tot;i++) f[i][x]=a[i][tot+1];
}
int main()
{
	scanf("%d",&tt);
	while(tt--)
	{
		memset(trie,0,sizeof trie);
		memset(pos,-1,sizeof pos);
		memset(fail,0,sizeof fail);
		memset(f,0,sizeof f);
		tot=0;
		scanf("%d%d%d",&n,&l,&t);
		for(int i=0;i<n;i++)
		{
			scanf("%s",s);
			int id=0;
			for(int j=0;s[j];j++)
				if(trie[id][s[j]-'a']) id=trie[id][s[j]-'a'];
				else id=trie[id][s[j]-'a']=++tot;
			pos[id]=i;
		}
		for(int i=0,x;i<t;i++)
		{
			scanf("%d",&x);
			p[i]=x/10000.0;
		}
		mkfail();
		for(int i=1;i<(1<<n);i++)
			calc(i);
		printf("%.10f\n",(double)f[0][(1<<n)-1]);
	}
	return 0;
}
Problem3590

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int S = 1<<12;
const int N = 13;
const int M = 85;
const int INF = 5e8;
struct E
{int next,to,val;}e[M];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
int g[S][N][N],h[S][N][2],n,m;
int f[S];
void graph_init()
{
	memset(head,0,sizeof(head));
	tot = 0;
	int x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
}
void edge_init()
{
	for(int i = 0;i<1<<n;i++)for(int j = 0;j<= n;j++)for(int k = 0;k<= n;k++)
		g[i][j][k] = INF;
	for(int i = 0;i<1<<n;i++)for(int j = 0;j<= n;j++)for(int k = 0;k<= 1;k++)
		h[i][j][k] = INF;
	for(int i = 0;i<n;i++)
		g[i<<1][i+1][i+1] = 0;
	for(int i = 1;i<=n;i++)
		for(int j = head[i];j;j = e[j].next)
		{
			int l = i,r = e[j].to;
			int s = (1<<(l-1))|(1<<(r-1));
			g[s][l][r] = min(g[s][l][r],e[j].val);
		}
	for(int s = 0;s<1<<n;s++)
	{
		for(int l = 1;l<= n;l++)
			for(int r = 1;r<= n;r++)
				if((s|(1<<(l-1))|(1<<(r-1)))==s)
					for(int p = head[r];p;p=e[p].next)
					{
						int nr = e[p].to;
						if((s|(1<<(nr-1)))!=s)
							g[s|(1<<(nr-1))][l][nr] = 
							min(g[s|(1<<(nr-1))][l][nr],g[s][l][r]+e[p].val);
					}
	}
	for(int s = 0;s<1<<n;s++)
		for(int i = 1;i<= n;i++)
			if((s|(1<<(i-1)))==s)
				for(int j = head[i];j;j = e[j].next)
				{
					int to = e[j].to;
					if((s|(1<<(to-1)))!=s)
					{
						if(e[j].val<=h[s][to][0])
						{
							h[s][to][1] = h[s][to][0];
							h[s][to][0] = e[j].val;
						}else if(e[j].val<h[s][to][1])
							h[s][to][1] = e[j].val;
					}
				}
}
int calc_sta(int x)
{
	int sta = 1;
	for(x = x&(x-1);x;x = x&(x-1))
		sta++;
	return sta;
}
void dp()
{
	for(int i = 1;i<1<<n;i++)
		f[i] = INF;
	for(int i = 0;i<n;i++)
		f[1<<i] = 0;
	for(int i = 1;i<1<<n;i++)
		if(calc_sta(i)>=2)
			for(int s = i&(i-1);s;s = (s-1)&i)
			{
				int t = i-s;
				for(int l = 1;l<= n;l++)
					for(int r = 1;r<= n;r++)
						if((s|(1<<(l-1)))==s&&(s|(1<<(r-1)))==s)
						{
							if(l==r)
								f[i] = min(f[i],f[t]+g[s][l][r]+h[t][l][0]+h[t][l][1]);
							else 
								f[i] = min(f[i],f[t]+g[s][l][r]+h[t][l][0]+h[t][r][0]);
						}

			}
	if(f[(1<<n)-1]<INF)printf("%d\n",f[(1<<n)-1]);
	else printf("impossible\n");
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		graph_init();
		edge_init();
		dp();
	}
	return 0;
}
Problem3597

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-5;
const int N = 5005;
const int M = 6005;
struct Road
{int x,y,a,b,c,d;}r[M];
struct E
{int next,to;double val;}e[M];
int head[N],tot,n,m;
void add(int x,int y,double f)
{e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].val=f;}
bool vis[N];double dis[N];
bool flag;
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(dis[e[i].to]>dis[x]+e[i].val)
		{
			if(vis[e[i].to])flag = true;
			else
			{
				dis[e[i].to] = dis[x]+e[i].val;
				dfs(e[i].to);
			}
		}
	}
	vis[x] = false;
}
void init()
{
	memset(head,0,sizeof(head));
	memset(dis,0,sizeof(dis));
	memset(vis,0,sizeof(vis));
	flag = false;tot = 0;
}
bool check(double ans)
{
	init();
	for(int i = 1;i<= m;i++)
	{
		add(r[i].x,r[i].y,r[i].b+r[i].d+ans);
		if(r[i].c)add(r[i].y,r[i].x,r[i].a-r[i].d+ans);
	}
	for(int i = 1;i<= n && !flag;i++)
		dfs(i);
	return flag;
}
int main()
{
	scanf("%d%d",&n,&m);
	n+=2;
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d%d%d%d",&r[i].x,&r[i].y,&r[i].a,&r[i].b,&r[i].c,&r[i].d);
	double l = 0,r = 1e8;
	while(fabs(r-l)>eps)
	{
		double mid = (l+r)/2;
		if(check(mid))l=mid;
		else r = mid;
	}
	printf("%.2lf\n",l);
	return 0;
}
Problem3611

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+1000;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;};
int dep[N],fa[N][22],dfn[N],Dfn;
struct Gragh
{
	E e[N<<1];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dfs(int x,int ff)
	{
		dep[x] = dep[ff]+1;
		fa[x][0]=ff;
		dfn[x] =++Dfn;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=ff)
				dfs(e[i].to,x);
	}
	void init(int n)
	{
		for(int j = 1;j<= 21;j++)
			for(int i = 1;i<= n;i++)
				fa[i][j] = fa[fa[i][j-1]][j-1];
	}
	int lca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i = 21;i>=0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 21;i>=0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
}tree;
vector<int>to[N];
vector<int>val[N];
void add(int x,int y,int f)
{
	if(x==y)return ;
	to[x].push_back(y);
	to[y].push_back(x);
	val[x].push_back(f);
	val[y].push_back(f);
}
int size[N];
bool v[N];
ll ans1,ans2,ans3;
void Tree_DP(int x,int from)
{
	static long long f[N],g[N],max_dis[N],min_dis[N];
	//f[x]表示以x为根的子树中有多少关键点
	//g[x]表示以x为根的子树中所有关键点到x的距离之和
	//max_dis[x]/min_dis[x]表示节点x为根的子树中的关键点到x的距离的最大/最小值
	int i;
	f[x]=v[x];g[x]=0;
	max_dis[x]=(v[x]?0:-INF);
	min_dis[x]=(v[x]?0:INF);
	int sz = to[x].size();
	for(i=0;i<sz;i++)
	{
		int t = to[x][i];
		if(t==from)
			continue;
		Tree_DP(t,x);
		int dis=val[x][i];
		ans1+=(g[x]+f[x]*dis)*f[t]+g[t]*f[x];
		ans2=min(ans2,min_dis[x]+min_dis[t]+dis);
		ans3=max(ans3,max_dis[x]+max_dis[t]+dis);
		f[x]+=f[t];
		g[x]+=g[t]+f[t]*dis;
		max_dis[x]=max(max_dis[x],max_dis[t]+dis);
		min_dis[x]=min(min_dis[x],min_dis[t]+dis);
	}
	v[x] = false,to[x].clear(),val[x].clear();
}
/*void dfs(int x,int ff,int dis)
{
	size[x] = v[x];
	if(v[x]&&dis)ans2 = min(ans2,dis),dis = 0;
	int sz = to[x].size();
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
		{
			dfs(t,x,dis+val[x][i]);
			size[x]+=size[t];
			ans1+=(ll)(tn-size[t])*size[t]*val[x][i];
		}
	}
	v[x] = false;
	to[x].clear(),val[x].clear();
}
int end,maxdis;
void get_rope(int x,int dis,int ff)
{
	if(dis&&dis>maxdis&&v[x])
	{
		maxdis = dis;
		end = x;
	}
	int sz = to[x].size();
	for(int i = 0;i<sz;i++)
	{
		int t = to[x][i];
		if(t!=ff)
			get_rope(t,dis+val[x][i],x);
	}
}*/
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int h[N],stk[N],top;
int main()
{
	int n,q,x,y;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		tree.add(x,y);
	}
	tree.dfs(1,0);
	tree.init(n);
	scanf("%d",&q);
	while(q--)
	{
		int k;
		scanf("%d",&k);
		for(int i = 1;i<= k;i++)
			scanf("%d",&h[i]),v[h[i]]=true;
		sort(h+1,h+k+1,cmp);
		top = 0;
		stk[++top]=h[1];
		for(int i = 2;i<= k;i++)
		{
			int u = h[i];
			int lca = tree.lca(u,stk[top]);
			while(true)
			{
				if(dep[lca]>=dep[stk[top-1]])
				{
					int len = dep[stk[top]]-dep[lca];
					add(lca,stk[top--],len);
					break;
				}
				add(stk[top-1],stk[top],dep[stk[top]]-dep[stk[top-1]]);
				top--;
			}
			if(stk[top]!=lca)stk[++top]=lca;
			if(stk[top]!=u)stk[++top]=u;
		}
		for(int i = 1;i<top;i++)
			add(stk[i],stk[i+1],dep[stk[i+1]]-dep[stk[i]]);
		ans1 = 0,ans2 = INF,ans3 = -INF;
		Tree_DP(h[1],-1);
		printf("%lld %lld %lld\n",ans1,ans2,ans3);
	}
	return 0;
}
Problem3613

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int mod;
typedef long long LL;
const int N = 5000005;
int a[N],sa,sb,sc,sd,n;
int F(int x)
{
	LL ans = 0;
	LL x2 = (LL)x*x%mod;LL x3 = x2*x%mod;
	ans = (((ans+(LL)sa*x3%mod)%mod+(LL)sb*x2%mod)%mod+(LL)sc*x%mod)%mod+sd;
	ans = ans%mod;
	return ans;
}
bool judge(int b)
{
	int mx = 1;
	for(int i = 1;i<= n;i++)
	{
		mx = max(mx,a[i]-b);
		if(mx>a[i]+b)return false;
	}
	return true;
}
int main()
{
	scanf("%d%d%d%d%d%d%d",&n,&sa,&sb,&sc,&sd,&a[1],&mod);
	for(int i = 2;i<= n;i++)
		a[i] = (F(a[i-1])+F(a[i-2]))%mod;
	int l = 0,r = mod+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(judge(mid))r = mid;
		else l = mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem3622

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int mod =1e9+9;
typedef long long ll;
int n,k;
ll f[N][N];
ll c[N][N],fac[N],g[N];
void init()
{
	fac[0] = 1;
	for(int i = 1;i<N;i++)
		fac[i] = fac[i-1]*i%mod;
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}	
}
int a[N],b[N],next[N];
int main()
{
	init();
	int n,k;
	scanf("%d%d",&n,&k);
	if((n+k)&1){printf("0\n");return 0;}
	k=(k+n)/2;
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	int j = 1;
	for(int i = 1;i<= n;i++)
	{
		while(b[j]<a[i]&&j<=n)j++;
		next[i]=j-1;
	}
	f[0][0] = 1;
	for(int i = 1;i<= n;i++)
	{
		f[i][0]=1;
		for(int j = 1;j<= i;j++)
			(f[i][j]+=f[i-1][j-1]*max(next[i]-j+1,0)+f[i-1][j])%=mod;
	}
	for(int i = n;i>=k;i--)
	{
		g[i] = (ll)f[n][i]*fac[n-i]%mod;
		for(int j = i+1;j<= n;j++)
			(g[i]+=mod-g[j]*c[j][i]%mod)%=mod;
	}
	printf("%lld\n",g[k]);
	return 0;
}
Problem3624

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 20005;
const int M = 100005;
int fa[N];
struct E{int x,y;}e1[M],e2[M];
int cnt1,cnt2;
int ansx[M],ansy[M],ansc[M];
int ans_cnt,n,m,k;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	int fx = getfa(x),fy = getfa(y);
	if(fx!=fy)
		fa[fx] = fy;
}
bool Find_Must()
{
	int block = n;
	for(int i = 1;i<= cnt2;i++)
	{
		int fx = getfa(e2[i].x),fy = getfa(e2[i].y);
		if(fx==fy)continue;
		block--;
		uni(e2[i].x,e2[i].y);
		if(block==1)break;
	}
	for(int i = 1;i<= cnt1;i++)
	{
		int fx = getfa(e1[i].x),fy = getfa(e1[i].y);
		if(fx==fy)continue;
		block--;
		ans_cnt++;
		ansx[ans_cnt] = e1[i].x;ansy[ans_cnt] = e1[i].y;
		ansc[ans_cnt] = 0;
		uni(e1[i].x,e1[i].y);
		if(block==1)break;
	}
	if(ans_cnt>k)return false;
	else return true;
}
bool build()
{
	int block = n,tmp = 0;
	for(int i = 1;i<= ans_cnt;i++)
	{
		uni(ansx[i],ansy[i]);
		block--;
		tmp++;
	}
	for(int i = 1;i<= cnt1;i++)
	{
		int fx = getfa(e1[i].x),fy = getfa(e1[i].y);
		if(fx==fy)continue;
		block--;
		tmp++;
		ans_cnt++;
		ansx[ans_cnt] = e1[i].x;ansy[ans_cnt] = e1[i].y;
		ansc[ans_cnt] = 0;
		uni(e1[i].x,e1[i].y);
		if(block==1||tmp==k)break;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		int fx = getfa(e2[i].x),fy = getfa(e2[i].y);
		if(fx==fy)continue;
		block--;
		ans_cnt++;
		ansx[ans_cnt] = e2[i].x;ansy[ans_cnt] = e2[i].y;
		ansc[ans_cnt] = 1;
		uni(e2[i].x,e2[i].y);
		if(block==1)break;
	}
	if(tmp!=k)return false;
	else return true;
}
int main()
{
	int x,y,c;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		if(c==0){e1[++cnt1].x = x;e1[cnt1].y = y;}
		else {e2[++cnt2].x = x;e2[cnt2].y = y;}
	}
	if(!Find_Must())printf("no solution\n");
	memset(fa,0,sizeof(fa));
	if(!build())printf("no solution\n");
	else
	{
		for(int i = 1;i<= ans_cnt;i++)
			printf("%d %d %d\n",ansx[i],ansy[i],ansc[i]);
	}
	return 0;
}
Problem3625

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 261244<<1;
typedef long long ll;
const int mod = 998244353;
const int Inv2 = 499122177;
int a[N],b[N],c[N],cnt=0;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
void NTT(int *a,int len,int type)
{
	int t = 0,i,j,k,wn,tmp,w;
	for(i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(j = len>>1;(t^=j)<j;j=j>>1);
	}
	for(i = 2;i<= len;i<<=1)
	{
		wn = quick_pow(5,(mod-1)/i);
		for(j = 0;j<len;j+=i)
		{
			w = 1;
			for(k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
			{
				tmp = (ll)a[j+k+(i>>1)]*w%mod;
				a[j+k+(i>>1)] = (a[j+k]-tmp+mod)%mod;
				a[j+k] = (a[j+k]+tmp)%mod;
			}
		}
	}
	if(type==-1)
	{
		for(i = 1;i<(len>>1);i++)
			swap(a[i],a[len-i]);
		int Inv = quick_pow(len,mod-2);
		for(i = 0;i<len;i++)
			a[i] = (ll)a[i]*Inv%mod;
	}
	/*printf("#case %d:",++cnt);
	for(int i = 0;i<len;i++)
		printf("%d ",a[i]);
	printf("\n");*/
}
void Get_Inv(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = quick_pow(a[0],mod-2);
		return ;
	}
	Get_Inv(a,b,len>>1);
	static int tmp[N];
	memcpy(tmp,a,sizeof(int)*len);
	memset(tmp+len,0,sizeof(int)*len);
	NTT(tmp,len<<1,1);
	NTT(b,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i] = (ll)b[i]*(2-(ll)b[i]*tmp[i]%mod+mod)%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(ll)*len);
}
void Get_Root(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0] = 1;
		return ;
	}
	Get_Root(a,b,len>>1);
	static int tmpa[N],tmpb[N];
	memset(tmpb,0,sizeof(int)*len);  
    memset(tmpb+len,0,sizeof(int)*len);
	Get_Inv(b,tmpb,len);
	memcpy(tmpa,a,sizeof(int)*len);
	memset(tmpa+len,0,sizeof(int)*len);
	NTT(tmpa,len<<1,1),NTT(b,len<<1,1),NTT(tmpb,len<<1,1);
	for(int i = 0;i<len<<1;i++)b[i] = (ll)(b[i]+(ll)tmpa[i]*tmpb[i]%mod)%mod*Inv2%mod;
	NTT(b,len<<1,-1);
	memset(b+len,0,sizeof(int)*len);
}
int main()
{
	int n,m,k;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		if(k<=m)a[k]++;
	}
	int len = 1;
	for(int i=1<<30;i;i>>=1)  
        if(m&i)  
            {len=i<<1;break;} 
	for(int i = 0;i<len;i++)
		if(a[i])a[i]=mod-4;
	a[0]++;
	Get_Root(a,b,len);
	memcpy(a,b,sizeof(int)*len);
	a[0]++;
	memset(b,0,sizeof(int)*len);
	Get_Inv(a,b,len);
	for(int i = 1;i<= m;i++)
		printf("%d\n",b[i]*2%mod);
	return 0;
}
Problem3627

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e4+5;
const int M = 2e4+5;
const int P = 60;
const int T = 80;
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
struct Trie
{
	int ch[N*20][T],cnt;
	int lazy[N*20],sign;
	char s[T];
	int insert()
	{
		scanf("%s",s+1);
		int x = 0,alp;
		for(int i = 1;s[i];i++)
		{
			alp = s[i]-'0';
			if(!ch[x][alp])ch[x][alp]=++cnt;
			x = ch[x][alp];
		}
		if(!lazy[x])lazy[x] = ++sign;
		return lazy[x];
	}
	int judge()
	{
		for(int i=1;s[i];i++)
            if(i>=5&&s[i]=='t'&&s[i-1]=='r'&&s[i-2]=='a'&&s[i-3]=='t'&&s[i-4]=='s')return 1;
        for(int i=1;s[i];i++)
        	if(i>=3&&s[i]=='s'&&s[i-1]=='a'&&s[i-2]=='g')return 2;
        for(int i=1;s[i];i++)
        	if(i>=3&&s[i]=='d'&&s[i-1]=='n'&&s[i-2]=='e')return 3;
        return 0;
	}
}trie;
struct E
{
	int u,v,next;
	double val;
}e[M<<1],E[15][P*P*2];
int head[N],tot;
int Head[15][P],cnt[15];
void add(int x,int y,double f)
{
	e[++tot].u = x;
	e[tot].v = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
void ADD(int l,int x,int y,double f)
{
	E[l][++cnt[l]].u = x;
	E[l][cnt[l]].v = y;
	E[l][cnt[l]].val = f;
	E[l][cnt[l]].next = Head[l][x];
	Head[l][x] = cnt[l];
	//printf("%d %d %d %.5lf\n",l,x,y,f);
}
struct Point
{
	int x,y;
	Point(){}
	Point(int x,int y):x(x),y(y){}
};
queue<Point>Q;
double dis[15][N],aver[N];
bool in[15][N];
int n,m,light,gas,cost;
bool red[N];
int sta[N],gass[N],num;
char tmp[T];
void SPFA(int s)
{
	while(!Q.empty())Q.pop();
	memset(dis,0x7f,sizeof(dis));
	dis[0][s] = 0;
	in[0][s] = true;
	Q.push(Point(0,s));
	while(!Q.empty())
	{
		Point tt = Q.front();
		Q.pop();
		in[tt.x][tt.y] = false;
		for(int i = head[tt.y];i;i=e[i].next)
		{
			int to = e[i].v,temp = tt.x+red[to];
			if(temp<=light&&dis[tt.x][tt.y]+e[i].val+aver[to]<=gas&&dis[temp][to]>dis[tt.x][tt.y]+e[i].val+aver[to])
			{
				dis[temp][to] = dis[tt.x][tt.y]+e[i].val+aver[to];
				if(!in[temp][to])
				{
					in[temp][to] =true;
					Q.push(Point(temp,to));
				}
			}
		}
	}
}
double spfa(int s,int t)
{
	while(!Q.empty())Q.pop();
	memset(dis,0x7f,sizeof(dis));
	dis[0][s] = 0;
	in[0][s] = true;
	Q.push(Point(0,s));
	while(!Q.empty())
	{
		Point tt = Q.front();
		Q.pop();
		in[tt.x][tt.y] = false;
		for(int j = 0;j+tt.x<=light;j++)
		{
			for(int i = Head[j][tt.y];i;i=E[j][i].next)
			{
				int to = E[j][i].v;
				if(dis[j+tt.x][to]>dis[tt.x][tt.y]+cost+E[j][i].val)
				{
					dis[j+tt.x][to] = dis[tt.x][tt.y]+cost+E[j][i].val;
					if(!in[j+tt.x][to])
					{
						in[j+tt.x][to] = true;
						Q.push(Point(j+tt.x,to));
					}
				}
			}
		}
	}
	double ans = 99999999999.999;
	for(int i = 0;i<= light;i++)
		ans = min(ans,dis[i][t]);
	return ans;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&m,&light,&gas,&cost);
	int k,s,t,v,ia,ib;
	double a,b,c;
	for(int i = 1;i<= n;i++)
	{
		trie.insert();
		if(k = trie.judge())
		{
			sta[i] = ++num;
			gass[num] = i;
			if(k==1)s=i;
			if(k==3)t=i;
		}
		scanf("%lf%lf",&a,&b);
		if(k==1||k==3)continue;
		if(a>eps)
            red[i]=1,aver[i]=a*a/2.0/(a+b);
	}
	for(int i = 1;i<= m;i++)
	{
		ia = trie.insert();
		ib = trie.insert();
		scanf("%s",tmp);
		scanf("%lf",&c);
		add(ia,ib,c),add(ib,ia,c);
	}
	for(int i = 1;i<= num;i++)
	{
		SPFA(gass[i]);
		for(int j = 1;j<= num;j++)
		{
			v = gass[j];
			if(j!=i)
			{
				for(int k = 0;k<=light;k++)
					if(dis[k][v]<INF)
						ADD(k,i,j,dis[k][v]);
			}
		}
	}
	printf("%.3lf\n",spfa(sta[s],sta[t])-cost);
	return 0;
}
Problem3629

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int prime[N],cnt;
ll Ans[10000005];
bool v[N];
void quick_prime()
{
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
			prime[++cnt]=i;
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
bool check_prime(int x)
{
	if(x==1)return false;
	for(int i = 1;prime[i]*prime[i]<= x;i++)
		if(x%prime[i]==0)return false;
	return true;
}
void getans(ll ans,int pos,ll left)
{
	if(left==1)
	{
		Ans[++Ans[0]]=ans;
		return ;
	}
	if(left-1>=prime[pos]&&check_prime(left-1))
		Ans[++Ans[0]] = ans*(left-1);
	for(int i = pos;prime[i]*prime[i]<=left;i++)
	{
		ll sum = 1+prime[i],powe = prime[i];
		for(;sum<=left;powe*=prime[i],sum+=powe)
			if(left%sum==0)
			{
				getans(ans*powe,i+1,left/sum);
			}
	}
}
int main()
{
	ll n;
	quick_prime();
	while(scanf("%lld",&n)!=EOF)
	{
		Ans[0] = 0;
		getans(1,1,n);
		sort(Ans+1,Ans+Ans[0]+1);
		printf("%lld\n",Ans[0]);
		for(int i = 1;i<= Ans[0];i++)
			printf("%lld%c",Ans[i],i==Ans[0]?'\n':' ');
	}
	return 0;
}
Problem3630

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
queue<int>Q;
const int N = 6010;
const int M = 2e5+5;
const int INF = 0x3f3f3f3f;
typedef long long ll;
struct S
{
	int x1,y1,x2,y2,x,y,r;
	int k;
}s[N];
ll getdis(int x1,int y1,int x2,int y2)
{
	return (ll)(x1-x2)*(x1-x2)+(ll)(y1-y2)*(y1-y2);
}
bool check(int i,int j)
{
	int typ = s[i].k+s[j].k;
	if(typ==2)
	{
		return getdis(s[i].x,s[i].y,s[j].x,s[j].y)<=(ll)(s[i].r+s[j].r)*(s[i].r+s[j].r);
	}
	if(typ==3)
	{
		if(s[i].k==1)swap(i,j);
		if(getdis(s[i].x1,s[i].y1,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x1,s[i].y2,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x2,s[i].y1,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(getdis(s[i].x2,s[i].y2,s[j].x,s[j].y)<=(ll)s[j].r*s[j].r)return true;
		if(s[i].y1<=s[j].y&&s[i].y2>=s[j].y)
			if(abs(s[i].x2-s[j].x)<=s[j].r||abs(s[i].x1-s[j].x)<=s[j].r)
				return true;
		if(s[i].x1<s[j].x&&s[i].x2>s[j].x)
			if(abs(s[i].y2-s[j].y)<=s[j].r||abs(s[i].y1-s[j].y)<=s[j].r)
				return true;
		if(s[i].x1<=s[j].x&&s[i].x2>=s[j].x&&s[i].y1<=s[j].y&&s[i].y2>=s[j].y)
			return true;
	}
	if(typ==4)
	{
		if((s[i].x1>=s[j].x1&&s[i].x1<=s[j].x2)||(s[i].x2>=s[j].x1&&s[i].x2<=s[j].x2))
        if((s[i].y1>=s[j].y1&&s[i].y1<=s[j].y2)||(s[i].y2>=s[j].y1&&s[i].y2<=s[j].y2))return 1;
        if(s[i].x1<=s[j].x1&&s[j].x2<=s[i].x2&&s[j].y1<=s[i].y1&&s[i].y2<=s[j].y2)return 1;
        swap(i,j);
        if((s[i].x1>=s[j].x1&&s[i].x1<=s[j].x2)||(s[i].x2>=s[j].x1&&s[i].x2<=s[j].x2))
        if((s[i].y1>=s[j].y1&&s[i].y1<=s[j].y2)||(s[i].y2>=s[j].y1&&s[i].y2<=s[j].y2))return 1;
        if(s[i].x1<=s[j].x1&&s[j].x2<=s[i].x2&&s[j].y1<=s[i].y1&&s[i].y2<=s[j].y2)return 1;
	}
	return false;
}
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f1,int f2)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f1;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f2;
}
int d[N],st,ed;
bool bfs(int s,int t)
{
	for(int i = st;i<= ed;i++)
		d[i] = -1;
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
void display(int S,int T)
{
	for(int i = S;i<= T;i++)
		for(int j = head[i];j;j=e[j].next)
			printf("%d %d:%d\n",i,e[j].to,e[j].f);
}
int main()
{
	int cx,cy,n;
	scanf("%d%d%d",&cx,&cy,&n);
	int S = 1,T = (n+1)<<1;
	st = S,ed = T;
	s[0].k = 2,s[0].x1 = 0,s[0].y1 = cy,s[0].x2 = cx,s[0].y2 = cy;
	s[n+1].k = 2,s[n+1].x1 = 0,s[n+1].y1 = 0,s[n+1].x2=cx,s[n+1].y2 = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&s[i].k);
		if(s[i].k==1)scanf("%d%d%d",&s[i].x,&s[i].y,&s[i].r);
		else scanf("%d%d%d%d",&s[i].x1,&s[i].y1,&s[i].x2,&s[i].y2);
		for(int j = 0;j<i;j++)
			if(check(i,j))
				add(j<<1|1,i<<1,INF,0),add(i<<1|1,j<<1,INF,0);
	}
	for(int i = 1;i<= n;i++)
		if(check(i,n+1))
			add(i<<1|1,(n+1)<<1,INF,0),add((n+1)<<1|1,i<<1,INF,0);
	for(int i = 1;i<= n;i++)add(i<<1,i<<1|1,1,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem3631

#include <stdio.h>
#include <algorithm>
using namespace std;
#define N 300005
struct M
{
    int next,to;    
}edge[N*2];
int head[N],tot,num[N],cnt[N],fa[N][20],dep[N],line[N];
void add(int x,int y)
{
    edge[++tot].to = y;
    edge[tot].next = head[x];
    head[x] = tot;
}
bool v[N];
void dfs(int x)
{
    v[x] = true;
    for(int i = head[x];i;i = edge[i].next)
    {
        if(!v[edge[i].to])
        {
            fa[edge[i].to][0] = x;
            dep[edge[i].to] = dep[x]+1;
            dfs(edge[i].to);
        }
    }    
    return ;
}
void work(int n)
{
    for(int j = 1;j<= 18;j++)
        for(int i = 1;i<= n;i++)
            fa[i][j] = fa[fa[i][j-1]][j-1];
    return ;
}
int lca(int x,int y)
{
    int re;
    if(dep[x]<dep[y])swap(x,y);
    for(int j = 18;j>= 0;j--)
    {
        if(dep[fa[x][j]]>=dep[y])
            x = fa[x][j];
    }
    if(x==y)return x;
    for(int j = 18;j>= 0;j--)
    {
        if(fa[x][j]!=fa[y][j])
            x = fa[x][j],y = fa[y][j];
        else re = fa[x][j];
    }
    return re;
}
bool cha[N];
void dfs2(int x)  
{   
    for (int i=head[x];i;i=edge[i].next)       
        if (edge[i].to!=fa[x][0])          
        {           
            dfs2(edge[i].to);              
			cnt[x] = cnt[x]+cnt[edge[i].to];  
        }
    return ;  
}  
int main()
{
    int n,x,y,z;
    scanf("%d",&n);
    for(int i = 1;i<= n;i++)
    {
        scanf("%d",&num[i]);
    }
    for(int i = 1;i<n;i++)
    {
        scanf("%d%d",&x,&y);
        add(x,y);
        add(y,x);
    }
    fa[1][0] = 1;
    dfs(1);
    work(n);
    for(int i = 1;i<n;i++)
    {
        x = num[i],y = num[i+1];
        int tmp = lca(x,y);
        cnt[x]++;cnt[y]++;
        cnt[tmp]--;
		if(tmp!=1)cnt[fa[tmp][0]]--;
    }
    dfs2(1);
   	for(int i = 2;i<= n;i++)cnt[num[i]]--;
    for(int i = 1;i<= n;i++)
    {
        printf("%d\n",cnt[i]);
    }
    return 0;
}
Problem3631

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int fa[300005],top[300005],son[300005],size[300005],w[300005],deep[300005],id[300005];
struct E
{int next,to;}e[600005];
int head[300005],tot,n;
bool v[300005];
int me = (300000<<1)+1;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs1(int x,int dep)
{
	v[x] = true;
	size[x]++;
	deep[x] = dep;
	for(int i = head[x];i;i = e[i].next)
	{
		int t = e[i].to;
		if(!v[t])
		{
			dfs1(t,dep+1);
			size[x]+=size[t];
			if(size[t]>size[son[x]])son[x] = t;
			fa[t] = x;
		}
	}
}
int cnt;
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	id[cnt] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int num[300005],ans[300005];
int f[300005<<2];
void push_down(int p)
{
	f[p<<1]+=f[p];
	f[(p<<1)+1]+=f[p];
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b){f[p]++;return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)
		update(p<<1,l,mid,a,b);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b);
	return ;
}
void getans(int p,int l,int r)
{
	if(l==r){ans[id[l]] = f[p];return ;}
	if(f[p])push_down(p);
	int mid = (l+r)>>1;
	getans(p<<1,l,mid);
	getans((p<<1)+1,mid+1,r);
}
void get_cut(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		update(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	update(1,1,n,w[y],w[x]);
}
int main()
{
	int x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<n;i++)
		get_cut(num[i],num[i+1]);
	getans(1,1,n);
	for(int i = 1;i<= n;i++)
	{
		if(num[1]!=i)printf("%d\n",ans[i]-1);
		else printf("%d\n",ans[i]);
	}
	return 0;
}
Problem3653

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int M = 1e7+5;
typedef long long ll;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int dfn[N],Dfn,dep[N],size[N],end[N],R,root[N];
struct P
{
	int dep,size,dfn;
	P(){}
	P(int dep,int size,int dfn):dep(dep),size(size),dfn(dfn){}
	bool operator <(const P &s)const
	{
		return dfn<s.dfn;
	}
}p[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x,int fa)
{
	dep[x]=dep[fa]+1;
	R = max(R,dep[x]);
	size[x]=1;
	dfn[x]=++Dfn;
	for(int i =head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			size[x]+=size[e[i].to];
		}
	end[x] = Dfn;
}
int ls[M],rs[M];
ll sum[M];
void update(int &p,int pre,int l,int r,int pos,int v)
{
	p = ++tot;
	sum[p] = sum[pre];
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(l==r)
	{
		sum[p]+=v;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,v);
	else update(rs[p],rs[pre],mid+1,r,pos,v);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
ll getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	ll ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs(1,0);
	for(int i = 1;i<= n;i++)
		p[i] = P(dep[i],size[i],dfn[i]);
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],1,R,p[i].dep,p[i].size-1);
	int p,k;
	while(q--)
	{
		scanf("%d%d",&p,&k);
		ll ans = getans(root[end[p]],1,R,dep[p]+1,min(dep[p]+k,R));
		ans = ans-getans(root[dfn[p]-1],1,R,dep[p]+1,min(dep[p]+k,R));
		ans+=(ll)(size[p]-1)*min(k,dep[p]-1);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem3669

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 1e5+5;
struct E
{
	int x,y,a,b;
	bool operator <(const E &s)const
	{
		return a<s.a;
	}
}e[M];
int Fa[N];
int getfa(int x)
{
	if(Fa[x]==x||!Fa[x])return Fa[x]=x;
	else   return Fa[x] = getfa(Fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	Fa[x] = y;
}
int ch[N+M][2],fa[N+M],size[N+M],val[N+M],mx[N+M];
bool rev[N+M];
inline bool is_root(int p)
{
	return ch[fa[p]][0]!=p&&ch[fa[p]][1]!=p;
}
inline void init(int p,int v)
{
	ch[p][0]=ch[p][1]=fa[p]=0;
	val[p]=v,mx[p] = p;
}
inline void reverse(int p)
{
	rev[p]^=1;
	swap(ch[p][0],ch[p][1]);
}
inline void Push_down(int p)
{
	if(!is_root(p))Push_down(fa[p]);
	if(rev[p])
	{
		if(ch[p][0])reverse(ch[p][0]);
		if(ch[p][1])reverse(ch[p][1]);
		rev[p] = false;
	}
}
inline void Push_up(int p)
{
	size[p] = size[ch[p][0]]+1+size[ch[p][1]];
	int ls = mx[ch[p][0]],rs = mx[ch[p][1]];
	if(val[ls]>=val[p]&&val[ls]>=val[rs])mx[p] = ls;
	else if(val[rs]>=val[p]&&val[rs]>=val[ls])mx[p] = rs;
	else mx[p] = p;
}
void rotate(int x)
{
	int y = fa[x],z = fa[y];
	int d = ch[y][1]==x;
	if(!is_root(y))
	{
		if(ch[z][0]==y)ch[z][0] = x;
		else if(ch[z][1]==y)ch[z][1] = x;
	}
	fa[y] = x,fa[x] = z,fa[ch[x][d^1]] = y;
	ch[y][d] = ch[x][d^1],ch[x][d^1] = y;
	Push_up(y),Push_up(x);
}
void splay(int x)
{
	Push_down(x);
	while(!is_root(x))
	{
		int y = fa[x],z = fa[y];
		if(!is_root(y))
		{
			if((ch[z][0]==y)^(ch[y][0]==x))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	Push_up(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		ch[x][1] = t;
		Push_up(x);
		t = x;
		x = fa[x];
	}
}
void move_to_root(int x)
{
	access(x);
	splay(x);
	reverse(x);
}
void link(int x,int y)
{
	move_to_root(x);
	fa[x] = y;
}
void cut(int x,int y)
{
	move_to_root(x);
	access(y);
	splay(y);
	fa[x] = 0;
	ch[y][0] = 0;
	Push_up(y);
}
int getans(int x,int y)
{
	move_to_root(x);
	access(y);splay(y);
	return mx[y];
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d%d",&e[i].x,&e[i].y,&e[i].a,&e[i].b);
	sort(e+1,e+m+1);
	for(int i = 1;i<= m;i++)val[i+n] = e[i].b;
	int ans = 0x3f3f3f3f;
	for(int i = 1;i<= m;i++)
	{
		x = e[i].x,y = e[i].y;
		int fx = getfa(x),fy = getfa(y);
		if(fx!=fy)
		{
			link(x,i+n);link(i+n,y);
			merge(fx,fy);
		}else
		{
			int k = getans(x,y);
			if(val[k]>e[i].b)
			{
				cut(e[k-n].x,k);
				cut(k,e[k-n].y);
				link(x,i+n);link(i+n,y);
			}
		}
		if(getfa(1)==getfa(n))
			ans = min(ans,e[i].a+val[getans(1,n)]);
	}
	if(ans!=0x3f3f3f3f)printf("%d\n",ans);
	else puts("-1");
	return 0;
}
Problem3670

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
const int mod = 1e9+7;
char s[N];
int nxt[N],dep[N],len;
void getnxt()
{
	int i = 0,j = -1;
	nxt[i] = j;
	dep[i] = 0;
	while(i<len)
	{
		if(j==-1||s[i]==s[j])
		{
			i++,j++;
			dep[i] = dep[j]+1;
			nxt[i] = j;
		}else j = nxt[j];
	}
}
void getans()
{
	int i = 0,j = -1;
	ll ans = 1;
	while(i<len)
	{
		if(j==-1||s[i]==s[j])
		{
			i++,j++;
			while(j!=-1&&(j<<1)>i)
				j = nxt[j];
			if(j!=-1&&i!=-1)
				ans = ans*(dep[j]+1)%mod;
		}else
			j = nxt[j];
	}
	printf("%lld\n",ans);
}	
int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%s",s);
		len = strlen(s);
		getnxt();
		getans();
	}
	return 0;
}
Problem3671

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5001;
typedef long long ll;
int X[N*N],mp[N][N];
bool us[N][N];
int l[N],r[N],ans[N<<1],top;
int main()
{
	int a,b,c,d,n,m,q;
	scanf("%d%d%d%d%d",&X[0],&a,&b,&c,&d);
	scanf("%d%d%d",&n,&m,&q);
	int end = n*m;
	for(int i = 1;i<= end;i++)
		X[i] = ((ll)a*X[i-1]%d*X[i-1]%d+(ll)b*X[i-1]%d+c)%d;
	for(int i = 1;i<= end;i++)
		mp[(i-1)/m+1][(i-1)%m+1] = i;
	for(int i = 1;i<= end;i++)
	{
		int j = X[i]%i+1;
		swap(mp[(i-1)/m+1][(i-1)%m+1],mp[(j-1)/m+1][(j-1)%m+1]);
	}
	for(int t = 1;t<= q;t++)
	{
		int i,j;
		scanf("%d%d",&i,&j);
		swap(mp[(i-1)/m+1][(i-1)%m+1],mp[(j-1)/m+1][(j-1)%m+1]);
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			X[mp[i][j]] = (i-1)*m+j;
	for(int i = 1;i<= n;i++)l[i]=1,r[i]=m;
	for(int i = 1;i<= end;i++)
	{
		if(us[(X[i]-1)/m+1][(X[i]-1)%m+1])continue;
		ans[++top] = i;
		if(top>=n+m-1)break;
		int x = (X[i]-1)/m+1,y = (X[i]-1)%m+1;
		for(int j = x+1;j<= n;j++)
			for(int k = l[j];k<y;k++)us[j][k]=true,l[j]++;
		for(int j = x-1;j>=1;j--)
			for(int k = r[j];k>y;k--)us[j][k]=true,r[j]--;
	}
	for(int i = 1;i< top;i++)
		printf("%d ",ans[i]);
	printf("%d\n",ans[top]);
	return 0;
}
Problem3672

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
typedef long long ll;
struct E
{int next,to;ll val;}e[N<<1];
int head[N],tot,fa[N];
ll dis[N];
void add(int x,int y,ll f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}
void dfs(int x)
{
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa[x])
	{
		fa[e[i].to] = x;
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to);
	}
}
ll p[N],q[N],l[N];
int f[N],size[N],sum,root;
bool used[N];
void get_root(int x,int pre)
{
	f[x] = 0,size[x] = 1;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre&&!used[e[i].to])
	{
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int seq[N];
inline bool cmp(int x,int y){return dis[x]-l[x]>dis[y]-l[y];}
void Dfs(int x,int pre)
{
	seq[++tot] = x;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre&&!used[e[i].to])
		Dfs(e[i].to,x);
}
ll dp[N];
inline double slope(int x,int y)
{
	return (double)(dp[x]-dp[y])/(double)(dis[x]-dis[y]);
}
int stack[N],top;
double k[N];
void Insert(int x)
{
	while(top>1&&slope(x,stack[top])>slope(stack[top],stack[top-1]))
		top--;
	stack[++top] = x;
	k[top] = -slope(x,stack[top-1]);
}
void solve(int x)
{
	if(sum<=1)return ;
	root = 0;
	get_root(x,0);
	int now = root;
	for(int i = head[fa[now]];i;i=e[i].next)
		if(e[i].to==now&&!used[e[i].to])
		{
			used[now] = true;
			sum = size[x]-size[now];
			solve(x);
			break;
		}
	for(int i = fa[now];i!=fa[x];i=fa[i])
		if(dis[now]-dis[i]<=l[now])
			dp[now]=min(dp[now],dp[i]+(dis[now]-dis[i])*p[now]+q[now]);
	tot = 0;
	for(int i = head[now];i;i=e[i].next)
		if(e[i].to!=fa[now]&&!used[e[i].to])
			Dfs(e[i].to,now);
	sort(seq+1,seq+tot+1,cmp);
	top = 0;
	for(int i = 1,j = now;i<= tot;i++)
	{
		for(;j!=fa[x]&&dis[j]>=dis[seq[i]]-l[seq[i]];j=fa[j])
			Insert(j);
		if(top==1)
		{	
			if(dis[seq[i]]-dis[stack[top]]<=l[seq[i]])
				dp[seq[i]] = min(dp[seq[i]],dp[stack[top]]+
								(dis[seq[i]]-dis[stack[top]])*p[seq[i]]+q[seq[i]]);
		}else
		{
			int ot=min(top,upper_bound(k+2,k+top+1,-p[seq[i]])-k-1);
			if(dis[seq[i]]-dis[stack[ot]]<=l[seq[i]])
			dp[seq[i]] = min(dp[seq[i]],dp[stack[ot]]+
							(dis[seq[i]]-dis[stack[ot]])*p[seq[i]]+q[seq[i]]);
		}
	}
	for(int i = head[now];i;i=e[i].next)
		if(e[i].to!=fa[now]&&!used[e[i].to])
		{
			used[e[i].to] = true;
			sum = size[e[i].to];
			solve(e[i].to);
		}
}
int main()
{
	int n,t,a;ll b;
	scanf("%d%d",&n,&t);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%lld",&a,&b);
		add(i,a,b);
		scanf("%lld%lld%lld",&p[i],&q[i],&l[i]);
	}
	dfs(1);
	for(int i = 2;i<= n;i++)dp[i]=1ll<<60;
	sum = f[root=0] = n;
	used[1] = true;
	solve(1);
	for(int i = 2;i<= n;i++)printf("%lld\n",dp[i]);
	return 0; 
}
Problem3685

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int sum[N<<2],n,m;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
void update(int p,int l,int r,int x,int c)
{
	if(l==r)
		{sum[p]+=c;return ;}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,c);
	else update(p<<1|1,mid+1,r,x,c);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int getans(int p,int l,int r,int no,int s)
{
	if(l==r)return l;
	int mid = (l+r)>>1;
	if(s+sum[p<<1]<no)
		return getans(p<<1|1,mid+1,r,no,s+sum[p<<1]);
	else return getans(p<<1,l,mid,no,s);
}
int check(int p,int l,int r,int a,int b)
{
	if(a>b)return 0;
	if(l>=a&&r<=b)
		return sum[p];
	int mid = (l+r)>>1;
	int ret = 0;
	if(a<=mid)ret+=check(p<<1,l,mid,a,b);
	if(b>mid)ret+=check(p<<1|1,mid+1,r,a,b);
	return ret;
}
void work(int opt)
{
	int x;
	if(opt<=2||opt>=5)x = read();
	x++;
	if(opt==1){if(check(1,1,n,x,x)==0)update(1,1,n,x,1);}
	else if(opt==2){if(check(1,1,n,x,x)==1)update(1,1,n,x,-1);}
	else if(opt==3){if(sum[1]==0)printf("-1\n");else printf("%d\n",getans(1,1,n,1,0)-1);}
	else if(opt==4){if(sum[1]==0)printf("-1\n");else printf("%d\n",getans(1,1,n,sum[1],0)-1);}
	else if(opt==5)
		{	
			int tmp = check(1,1,n,1,x-1);
			if(tmp==0)printf("-1\n");
			else printf("%d\n",getans(1,1,n,tmp,0)-1);
		}
	else if(opt==6)
		{
			int tmp = check(1,1,n,x+1,n);
			if(tmp==0)printf("-1\n");
			else printf("%d\n",getans(1,1,n,sum[1]-tmp+1,0)-1);
		}
	else{if(check(1,1,n,x,x)==1)printf("1\n");else printf("-1\n");}
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		x = read();
		work(x);
	}
	return 0;
}
Problem3688

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int MOD = 100007;
const int TOP = 100000;
struct Tree_s
{
	int c[TOP+5];
	void update(int x,int y)
	{
		for(int i = x;i<TOP;i+=i&(-i))
			(c[i] +=y)%=MOD;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			(ans+=c[i])%=MOD;
		return ans;
	}

}g[2][15],f[2][15];
int G[N][15],F[N][15];
struct P
{int x,y;}pos[N];
bool cmp(P a,P b)
{
	return a.x<b.x;
}
int main()
{	
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&pos[i].x,&pos[i].y);
	sort(pos+1,pos+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		F[i][0] = 1;
		G[i][0] = 1;
		f[0][0].update(pos[i].y,F[i][0]),f[1][0].update(TOP-pos[i].y,F[i][0]);
		g[0][0].update(pos[i].y,G[i][0]),g[1][0].update(TOP-pos[i].y,G[i][0]);
		for(int j = 1;j<= k;j++)
		{
			F[i][j] = (F[i][j]+g[0][j-1].getans(pos[i].y-1)+f[0][j].getans(pos[i].y-1))%MOD;
			G[i][j] = (G[i][j]+g[1][j].getans(TOP-pos[i].y-1)+f[1][j-1].getans(TOP-pos[i].y-1))%MOD;
			f[0][j].update(pos[i].y,F[i][j]),f[1][j].update(TOP-pos[i].y,F[i][j]);
			g[0][j].update(pos[i].y,G[i][j]),g[1][j].update(TOP-pos[i].y,G[i][j]);
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		ans = (ans+F[i][k]+G[i][k])%MOD;
	printf("%d\n",ans);
	return 0;
}
Problem3694

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 100005;
const int N = 4005;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,dis[N],dep[N],top[N],son[N],size[N],w[N],fa[N],cnt,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
	e[++tot].to = x;
	e[tot].next = head[y];
	e[tot].val = f;
	head[y] = tot;
}
struct S
{int u,v,val;}b[M<<1];
int snum;
void add_s(int x,int y,int f)
{
	b[++snum].u = x;
	b[snum].v = y;
	b[snum].val = f;
}
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x]++;
	dep[x] = dep[f]+1;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=f)
		{
			dis[e[i].to] = dis[x]+e[i].val;
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
void dfs2(int x,int tp)
{
	w[x] = ++cnt;
	top[x] = tp;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
int minn[N<<2],lazy[N<<2];
void push_down(int l,int r,int p)
{
	if(l==r||lazy[p]==INF)return ;
	minn[p<<1] = min(minn[p<<1],lazy[p]);
	minn[p<<1|1] = min(minn[p<<1|1],lazy[p]);
	lazy[p<<1] = min(lazy[p<<1],lazy[p]);
	lazy[p<<1|1] = min(lazy[p<<1|1],lazy[p]);
	lazy[p] = INF;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(l,r,p);
	if(l>=a&&r<=b)
	{
		minn[p] = min(minn[p],c);
		lazy[p] = min(lazy[p],c);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid) update(p<<1|1,mid+1,r,a,b,c);
	minn[p] = min(minn[p<<1],minn[p<<1|1]);
}
int getans(int p,int l,int r,int x)
{
	push_down(l,r,p);
	if(l==r)
		return minn[p];
	int mid = (l+r)>>1;
	if(x<=mid)return getans(p<<1,l,mid,x);
	else return getans(p<<1|1,mid+1,r,x);
}
int get_cut(int x,int y,int c,int opt)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		if(opt)update(1,1,n,w[top[x]],w[x],c);
		x = fa[top[x]];
	}
	if(x==y)return x;
	if(dep[x]<dep[y])swap(x,y);
	if(opt)update(1,1,n,w[y]+1,w[x],c);
	return y;
}
int main()
{
	int a,d,l,t;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&a,&d,&l,&t);
		if(t)add(a,d,l);
		else add_s(a,d,l);
	}
	dfs1(1,0);
	dfs2(1,1);
	memset(minn,0x3f,sizeof(minn));
	memset(lazy,0x3f,sizeof(lazy));
	for(int i = 1;i<= snum;i++)
	{
		int lca = get_cut(b[i].u,b[i].v,0,0);
		int tmp = dis[b[i].u]+b[i].val+dis[b[i].v];
		get_cut(b[i].v,lca,tmp,1);
		get_cut(b[i].u,lca,tmp,1);
	}
	for(int i = 2;i<=n;i++)
	{
		int tmp = getans(1,1,n,w[i]);
		if(tmp==INF)printf("-1 ");
		else printf("%d ",tmp-dis[i]);
	}
	return 0;
}
Problem3697

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int sum,root,f[N],size[N],n;
bool used[N];
void get_root(int x,int fa)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa||used[e[i].to])continue;
		get_root(e[i].to,x);
		size[x]+=size[e[i].to];
		f[x] = max(f[x],size[e[i].to]);
	}
	f[x] =max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int G[N<<1][2],F[N<<1][2],t[N<<1];
int maxdep;
void get_sum(int x,int fa,int num,int dep)
{
	maxdep = max(maxdep,dep);
	if(t[num])G[num][1]++;
	else G[num][0]++;
	t[num]++;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			get_sum(e[i].to,x,num+e[i].val,dep+1);
	t[num]--;
}
LL ans;
void calc(int x)
{
	F[n][0] = 1;
	int mx = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			maxdep = 0;
			get_sum(e[i].to,x,n+e[i].val,1);
			mx = max(mx,maxdep);
			ans+=(F[n][0]-1)*G[n][0];
			for(int j = -maxdep;j<= maxdep;j++)
			{
				ans+=(LL)F[n-j][0]*G[n+j][1];
				ans+=(LL)F[n-j][1]*G[n+j][0];
				ans+=(LL)F[n-j][1]*G[n+j][1];
			}
			for(int j = n-maxdep;j<= n+maxdep;j++)
				{F[j][0]+=G[j][0],F[j][1]+=G[j][1];G[j][0] = G[j][1] = 0;}
		}
	for(int i = n-mx;i<= n+mx;i++)
		F[i][0] = F[i][1] = 0;
}
void work(int x)
{
	calc(x);
	used[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(used[e[i].to])continue;
		sum = size[e[i].to];
		root = 0;
		get_root(e[i].to,0);
		work(root);
	}
}
int main()
{
	int x,y,z;
	scanf("%d",&n);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(!z)z = -1;
		add(x,y,z),add(y,x,z);
	}
	f[0] = 0x3f3f3f3f;
	root = 0;sum = n;
	get_root(1,0);
	work(1);
	printf("%lld\n",ans);
	return 0;
}
Problem3702

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL cnt1,cnt2;
const int N = 200005;
int root[N<<1],L[N<<1],R[N<<1],ls[4000005],rs[4000005],sum[4000005],cv[N<<1],tot,seg,n;
void scantree(int x)
{
	scanf("%d",&cv[x]);
	if(!cv[x])
	{
		L[x]=++tot;
		scantree(L[x]);
		R[x]=++tot;
		scantree(R[x]);
	}
}
void build(int &p,int l,int r,int c)
{
	if(!p)p = ++seg;
	if(l==r)
	{
		sum[p] = 1;
		return ;
	}
	int mid = (l+r)>>1;
	if(c<=mid)build(ls[p],l,mid,c);
	else build(rs[p],mid+1,r,c);
	sum[p] = sum[rs[p]]+sum[ls[p]];
}
int merge(int x,int y)
{
	if(!x)return y;
	if(!y)return x;
	cnt1+=(LL)sum[ls[x]]*sum[rs[y]];
	cnt2+=(LL)sum[rs[x]]*sum[ls[y]];
	ls[x] = merge(ls[x],ls[y]);
	rs[x] = merge(rs[x],rs[y]);
	sum[x] = sum[ls[x]]+sum[rs[x]];
	return x;
}
LL ans;
void solve(int x)
{
	if(!x)return ;
	solve(L[x]);solve(R[x]);
	if(!cv[x])
	{
		cnt1 = cnt2 = 0;
		root[x] = merge(root[L[x]],root[R[x]]);
		ans+=min(cnt1,cnt2);
	}
}
int main()
{
	scanf("%d",&n);
	tot++;
	scantree(1);
	for(int i = 1;i<= tot;i++)
		if(cv[i])build(root[i],1,n,cv[i]);
	solve(1);
	printf("%lld\n",ans);
	return 0;
}
Problem3709

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct Data{int x,y,id;}a[N],b[N];
bool cmp1(const Data &m,const Data &n)
{
	return m.x<n.x;
}
bool cmp2(const Data &m,const Data &n)
{
	return m.y>n.y;
}
int main()
{
	int cnt1,cnt2;
	cnt1 = cnt2 = 0;
	int n,x,y;
	long long z;
	scanf("%d%lld",&n,&z);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		if(y>=x){a[++cnt1].x = x,a[cnt1].y = y,a[cnt1].id = i;}
		else{b[++cnt2].x = x,b[cnt2].y = y,b[cnt2].id = i;}
	}
	sort(a+1,a+cnt1+1,cmp1);
	sort(b+1,b+cnt2+1,cmp2);
	for(int i = 1;i<= cnt1;i++)
	{
		if(z-a[i].x<=0){printf("NIE\n");return 0;}
		z+=a[i].y-a[i].x;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		if(z-b[i].x<=0){printf("NIE\n");return 0;}
		z+=b[i].y-b[i].x;
	}
	printf("TAK\n");
	for(int i = 1;i<= cnt1;i++)
		printf("%d ",a[i].id);
	for(int i = 1;i<= cnt2;i++)
		printf("%d ",b[i].id);
	return 0;
}
Problem3711

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define P 1000000007
#define GET (ch>='0'&&ch<='9')
#define MAXN 1000005
#define lchild rt<<1,l,mid
#define rchild rt<<1|1,mid+1,r
#define ln rt<<1
#define rn rt<<1|1
#define MAXINT 1000000
using namespace std;
int n;
int c[MAXN],d[MAXN],g[MAXN];
struct node
{
	int x,y;
	node()  {   x=y=0;  }
	node(int tx,int ty) {   x=tx;y=ty;  }
	inline node operator + (const node& b)
	{
		if (x<b.x)  return  b;
		if (x>b.x)  return  (node){x,y};
		return (node){x,(y+b.y)%P};
	}
	inline node operator + (int tx) {   return (node){x+tx,y};  }
	inline void operator +=(const node& b)  {   *this=*this+b;  }
}f[MAXN];
struct seg
{
	int l,r;
	int pos,vald;
	node f,flag;
}tree[(MAXN<<1)+(int)(1e5)];
inline void build1(int rt=1,int l=0,int r=n)
{
	tree[rt].l=l;tree[rt].r=r;
	if (l==r)   {   tree[rt].pos=l;tree[rt].vald=d[l];return;   }
	int mid=(l+r)>>1;build1(lchild);build1(rchild);
	tree[rt].pos=c[tree[ln].pos]>c[tree[rn].pos]?tree[ln].pos:tree[rn].pos;
	tree[rt].vald=min(tree[ln].vald,tree[rn].vald);
}
inline void build2(int rt=1,int l=0,int r=n)
{
	tree[rt].flag=(node){-MAXINT,0};
	if (l==r)   {   tree[rt].vald=d[l];tree[rt].f=f[l];return;  }
	int mid=(l+r)>>1;build2(lchild);build2(rchild);
	tree[rt].f=tree[ln].f+tree[rn].f;
	tree[rt].vald=min(tree[ln].vald,tree[rn].vald);
}
inline void modify_add(int rt,int l,int r,node delta)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&R<=r) {   tree[rt].flag+=delta;return;    }
	if (r<=mid) modify_add(ln,l,r,delta);
	else    if (l>mid)  modify_add(rn,l,r,delta);
	else    modify_add(ln,l,mid,delta),modify_add(rn,mid+1,r,delta);
}
inline int query_c(int rt,int l,int r)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].pos;
	if (r<=mid) return query_c(ln,l,r);
	if (l>mid)  return query_c(rn,l,r);
	int t1=query_c(ln,l,mid),t2=query_c(rn,mid+1,r);    
	return c[t1]>c[t2]?t1:t2;
}
inline int query_d(int rt,int l,int r)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].vald;
	if (r<=mid) return query_d(ln,l,r);
	if (l>mid)  return query_d(rn,l,r);
	return min(query_d(ln,l,mid),query_d(rn,mid+1,r));
}
inline node query_f(int rt,int l,int r)
{
	if (l>r)    return node(-MAXINT,0);
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (l<=L&&r>=R) return tree[rt].f;
	if (r<=mid) return query_f(ln,l,r);
	if (l>mid)  return query_f(rn,l,r);
	return query_f(ln,l,mid)+query_f(rn,mid+1,r);
}
inline void modify_cov(int rt,int x,node delta)
{
	int L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	if (L==R)   {   tree[rt].f=delta;return;    }
	if (x<=mid) modify_cov(ln,x,delta); else    modify_cov(rn,x,delta);
	tree[rt].f=tree[ln].f+tree[rn].f;
}
node ask(int x)
{
	int rt=1,L=tree[rt].l,R=tree[rt].r,mid=(L+R)>>1;
	node t=node(-MAXINT,0);
	while (L!=R)
	{
		t+=tree[rt].flag;
		mid=(L+R)>>1;rt<<=1;
		if (x>mid)  rt|=1;
		L=tree[rt].l,R=tree[rt].r;
	}
	t+=tree[rt].flag;
	return t;
}
inline void update(int l,int mid,int r)
{
	int i=max(c[mid]+l,mid);
	if (i>r||g[i]>=mid) return;
	int newl=max(l,g[i]),newr=i-c[mid];
	node tmp=query_f(1,newl,newr)+1;
	for (;i<=mid-1+c[mid]&&i<=r;i++)
	{
		if (g[i]>newl)
		{
			if (g[i]>=mid)  return;
			newl=g[i];tmp=query_f(1,newl,newr)+1;
		}
		f[i]+=tmp;newr++;
		if (newr>=newl) tmp+=f[newr]+1;
	}
	while (i<=r)
	{
		if (g[i]>newl)
		{
			if (g[i]>=mid)  return;
			newl=g[i];
		}
		tmp=query_f(1,newl,mid-1)+1;
		int t=query_d(1,newl+1,n);
		if (t>r)    {   modify_add(1,i,r,tmp);return;   }
		modify_add(1,i,t-1,tmp);i=t;
	}
}
void solve(int l,int r)
{
	if (l==r)
	{
		if (l)  modify_cov(1,l,f[l]=f[l]+ask(l));
		return;
	}
	int mid=query_c(1,l+1,r);
	solve(l,mid-1);update(l,mid,r);solve(mid,r);
}
int main()
{
	scanf("%d",&n);
	int i=0,j=0;
	for (i=1;i<=n;i++)scanf("%d%d",&c[i],&d[i]);	
	build1();
	for (i=0;i<=n;i++)  d[i]=n+1,f[i]=node(-MAXINT,0);
	f[0]=node(0,1);
	for (i=0;i<=n;i++)
	{
		while (j<i&&i-j>query_d(1,j+1,i))   j++;
		g[i]=j;
		if (d[g[i]]>n)  d[g[i]]=i;
	}
	build2();solve(0,n);
	printf(f[n].x>0?"%d %d\n":"NIE\n",f[n].x,f[n].y);
}
Problem3712

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e5+5;
const int K = 5e5+5;
int no[N],g[N],dep[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,fa[N][20],dfn[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	fa[y][0] = x;
}
struct Opt
{int x,y,dp,no;}opt[K];
bool cmp(const Opt &a,const Opt &b)
{
	if(a.dp==b.dp)return a.no<b.no;
	else return a.dp>b.dp;
}
void dfs(int x,int id)
{
	dfn[x] = id;
	for(int j = 1;j<= 19;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
	for(int i = head[x];i;i=e[i].next)
		dep[e[i].to] = dep[x]+1,
		dfs(e[i].to,id);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 19;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 19;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&g[i]),no[i]=i;
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(n+i,no[x]),add(n+i,no[y]);
		no[y] = n+i;
	}
	int tot = 0;
	for(int i = 1;i<= n+m;i++)if(!fa[i][0])dfs(i,++tot);
	int ask = 0;
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&x,&y);
		if(dfn[x]==dfn[y])opt[++ask] = (Opt){x,y,dep[getlca(x,y)],i};
	}
	sort(opt+1,opt+ask+1,cmp);
	long long ans = 0;
	for(int i = 1;i<= ask;i++)
	{
		int gd = min(g[opt[i].x],g[opt[i].y]);
		g[opt[i].x]-=gd,g[opt[i].y]-=gd;
		ans+=2*gd;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3714

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const int M = 4e6+5;
struct E
{int x,y,val;}e[M];
bool cmp(const E &a,const E &b)
{
	return a.val<b.val;
}
int fa[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
int main()
{
	int n;
	scanf("%d",&n);
	int x,tot = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)
		{
			scanf("%d",&x);
			e[++tot].x = i-1,e[tot].y = j,e[tot].val = x;
		}
	for(int i = 0;i<=n;i++)fa[i] = i;
	sort(e+1,e+tot+1,cmp);
	long long ans = 0;
	for(int i = 1;i<= tot;i++)
	{
		int tx = e[i].x,ty = e[i].y;
		tx = getfa(tx),ty = getfa(ty);
		if(tx==ty)continue;
		ans+=e[i].val;
		uni(tx,ty);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3716

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 200005;
int n,m;
ll w,h,x,y,v,ans;
struct data
{
	ll x,y,v;
	bool operator<(const data &s)const
	{
		if(x==s.x)return y<s.y;
		return x<s.x;
	}
}p[N<<1];
struct Data
{
	ll y,v;
	bool operator<(const Data &s)const
	{
		return y<=s.y;
	}
};
set<Data>s;
set<Data>::iterator it;
int main()
{
	scanf("%d%d%lld%lld",&n,&m,&w,&h);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&v);
		x = x*h,y = y*w;
		p[i].x = x+y,p[i].y = y-x,p[i].v=v;
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&v);
		x = x*h,y = y*w;
		p[n+i].x = x+y,p[n+i].y = y-x,p[n+i].v=-v;
	}
	sort(p+1,p+m+n+1);
	for(int i = 1;i<= n+m;i++)
		for(y=p[i].y,v=p[i].v;v;ans-=it->v,v+=it->v,s.erase(it))
		{
			it = s.lower_bound((Data){y,0});
			if(it==s.end()||it->y!=y)
			{
				if(v>0){s.insert((Data){y,v});ans+=v;break;}
				else if(it==s.begin())break;
				else y = (--it)->y;
			}
		}
	printf("%lld\n",ans);
	return 0;
}
Problem3717

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = (1<<24)+5;
int f[N],g[N];
int a[N],c[105];
bool cmp(const int &a,const int &b)
{
	return a>b;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&c[i]);
	for(int i = n;i;i--)a[1<<(i-1)]=a[i];
	sort(c+1,c+m+1,cmp);
	int end = (1<<n),tmp,x;
	for(int i = 1;i<end;i++)
	{
		f[i] = m+1,g[i] = -1;
		for(int j = i;j;j-=tmp)
		{
			tmp = j&(-j),x = i-tmp;
			if(a[tmp]<=g[x]&&(f[x]<f[i]||(f[x]==f[i]&&g[x]-a[tmp]>g[i])))f[i]=f[x],g[i]=g[x]-a[tmp];
			else if((f[x]+1<f[i]||(f[x]+1==f[i]&&c[f[x]+1]-a[tmp]>g[i]))&&c[f[x]+1]>=a[tmp])f[i]=f[x]+1,g[i]=c[f[x]+1]-a[tmp];
		}
	}
	if(f[end-1]>m)printf("NIE\n");
	else printf("%d\n",f[end-1]);
	return 0;
}
Problem3718

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct C
{int a,b,c;}car[N];
int id[N];
bool cmp(const C &x,const C &y)
{
	return x.a>y.a;
}
int getid(int x,int tot)
{
	int l = 1,r = tot+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(id[mid]<x)l=mid+1;
		else r = mid;
	}
	return l;
}
int c[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = max(c[i],y);
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans = max(ans,c[i]);
	return ans;
}
void work()
{
	memset(c,0,sizeof(c));
	int x1,x2,y1,y2;
	int n,w;
	scanf("%d%d",&n,&w);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		car[i].a = min(x1,x2);
		car[i].c = abs(y2-y1);
	}
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		car[i].b = min(x1,x2);id[i] = car[i].b;
	}
	sort(id+1,id+n+1);
	int tot = 0;
	id[0]=-1;
	for(int i = 1;i<= n;i++)
		if(id[tot]!=id[i])
			id[++tot] = id[i];
	sort(car+1,car+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		int pos = getid(car[i].b,tot);
		int maxn = getans(pos-1);
		if(w-maxn<car[i].c){printf("NIE\n");return ;}
		update(pos,car[i].c);
	}
	printf("TAK\n");
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)work();
	return 0;
}
Problem3719

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int S = 1e6+5;
const int size = 1e6;
struct data
{
	int x1,y1,x2,y2;
	bool operator <(const data &s)const
	{
		if(x1==s.x1)
		{
			if(x2==s.x2)
			{
				if(y1==s.y1)return y1<s.y1;
				else return y2<s.y2;
			}else return x2<s.x2;
		}else return x1<s.x1;
	}
}s[N],Ans[N];
int fa[N],st[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void merge(int a,int b)
{
	int x = getfa(a),y = getfa(b);
	if(x==y)return ;
	s[a].x1 = min(s[a].x1,s[b].x1),s[a].x2 = max(s[a].x2,s[b].x2);
	s[a].y1 = min(s[a].y1,s[b].y1),s[a].y2 = max(s[a].y2,s[b].y2);
	fa[y] = a;
}
struct node{ vector<int>q1,q2;}tr[S<<2];
bool cmp(int a,int b)
{
	return s[a].y2==s[b].y2?a<b:s[a].y2<s[b].y2;
}
int sta[S],top;
void Insert(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b){sta[++top]=p;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Insert(p<<1,l,mid,a,b);
	if(b >mid)Insert(p<<1|1,mid+1,r,a,b);
}
void update(int rt,int x)
{
	for(;rt;rt>>=1)tr[rt].q1.push_back(x);
}
int find_rt(int p,int l,int r,int x)
{
	if(l==r)return p;
	int mid = (l+r)>>1;
	if(x<=mid)return find_rt(p<<1,l,mid,x);
	else return find_rt(p<<1|1,mid+1,r,x);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&s[i].x1,&s[i].x2,&s[i].y1,&s[i].y2);
		s[i].x1++,s[i].y1++;fa[i]=st[i]=i;
	}
	sort(st+1,st+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		bool flag = true;
		while(flag)
		{
			top = 0;flag = false;
			Insert(1,1,size,s[st[i]].x1,s[st[i]].x2);
			for(int j = 1;j<= top;j++)
				for(int k = tr[sta[j]].q1.size()-1;k>=0;k--)
				{
					int y = tr[sta[j]].q1[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[sta[j]].q1.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[sta[j]].q1.pop_back();
				}
			for(int now = find_rt(1,1,size,s[st[i]].x1);now;now>>=1)
				for(int k = tr[now].q2.size()-1;k>=0;k--)
				{
					int y = tr[now].q2[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[now].q2.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[now].q2.pop_back();
				}
			for(int now = find_rt(1,1,size,s[st[i]].x2);now;now>>=1)
				for(int k = tr[now].q2.size()-1;k>=0;k--)
				{
					int y = tr[now].q2[k];
					if(fa[y]!=y||getfa(y)==getfa(st[i]))
						{tr[now].q2.pop_back();continue;}
					if(s[y].y2<s[st[i]].y1)break;
					merge(st[i],y);
					flag = true;
					tr[now].q2.pop_back();
				}
		}
		update(find_rt(1,1,size,s[st[i]].x1),st[i]);
		if(s[st[i]].x1!=s[st[i]].x2)
			update(find_rt(1,1,size,s[st[i]].x2),st[i]);
		top = 0;
		Insert(1,1,size,s[st[i]].x1,s[st[i]].x2);
		for(int j = 1;j<= top;j++)
			tr[sta[j]].q2.push_back(st[i]);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i)
		{
			Ans[++ans] = s[i];
			Ans[ans].x1--,Ans[ans].y1--;
		}
	printf("%d\n",ans);
	sort(Ans+1,Ans+ans+1);
	for(int i = 1;i<= ans;i++)
		printf("%d %d %d %d\n",Ans[i].x1,Ans[i].x2,Ans[i].y1,Ans[i].y2);
	return 0;
}
Problem3722

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int col[N],typ[N];
int dfs(int x,int fa)
{
	if(typ[x]<=0)return col[x];
	int sum = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			sum+=dfs(e[i].to,x);
	if(sum<0)return -1;
	else if(sum>0)return 1;
	return 0;
}
int ans[N],top;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&typ[i]);
		if(typ[i]==-2)col[i] = 1;
		else if(typ[i]==-1)col[i] = -1;
		else if(typ[i]>0)
		{
			int m = typ[i],x;
			while(m--)
				scanf("%d",&x),add(i,x);
		}
	}
	if(dfs(1,0)<0)printf("NIE\n");
	else
	{
		for(int i = 1;i<= n;i++)
			if(typ[i]==0)
			{
				col[i] = 1;
				if(dfs(1,0))ans[++top] = i;
				col[i] = 0;
			}
		printf("TAK %d\n",top);
		for(int i = 1;i<= top;i++)
		{
			printf("%d",ans[i]);
			if(i!=top)printf(" ");
		}
	}
	return 0;
}
Problem3725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
char s[N];
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	int last,now = 0,mn = n;
	for(int i = 1;i<= n;i++)
		if(s[i]!='*')
		{
			if(!last||last == s[i])last = s[i],now = i;
			else
			{
				mn = min(mn,i-now);
				last = s[i],now = i;
			}
		}
	printf("%d\n",n-mn+1);
	return 0;
}
Problem3726

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
char s[N];
int l0[N],r0[N],l1[N],r1[N],a[N],b[N],nxt[N],pre[N],G[N],NXT[N];
int L[N],R[N],ans;
void add(int x,int y){NXT[y]=G[x];G[x]=y;}
void del(int x){nxt[pre[x]]=nxt[x];pre[nxt[x]]=pre[x];}
int main()
{
	int n,m,i,j;
	scanf("%d%d",&n,&m);
	for(i = 1;i<= m;i++)l0[i]=l1[i]=1,r0[i]=r1[i]=m;
	for(int T = 1;T<= n;T++)
	{
		scanf("%s",s+1);
		for(i=j=1;i<=m;i++)
			if(s[i]=='.')
			{
				a[i]++,b[i]++;
				if(l0[i]<j)l0[i]=j;
				if(l1[i]<j)l1[i]=j;
			}else
			{
				b[i]=a[i]+1,a[i]=0;
				l1[i]=l0[i],l0[i]=1;
				if(l1[i]<j)l1[i]=j;
				j=i+1;
			}
		for(i=j=m;i>=1;i--)
			if(s[i]=='.')
			{
				if(r0[i]>j)r0[i]=j;
				if(r1[i]>j)r1[i]=j;
			}else
			{
				r1[i]=r0[i],r0[i]=m;
				if(r1[i]>j)r1[i]=j;
				j=i-1;
			}
		for(i = 0;i<= T;i++)G[i]=0;
		for(i = m;i;i--)add(a[i],i),pre[i]=i-1,nxt[i]=i+1;
		for(pre[1]=0,nxt[m]=m+1,i=T;~i;i--)
			for(j=G[i];j;j=NXT[j])
				L[j]=pre[pre[j]],del(j);
		for(i = 0;i<= T;i++)G[i]=0;
		for(i = 1;i<=m;i++)add(a[i],i),pre[i]=i-1,nxt[i]=i+1;
		for(pre[1]=0,nxt[m]=m+1,i=T;~i;i--)
			for(j=G[i];j;j=NXT[j])
				R[j]=nxt[nxt[j]],del(j);
		for(i = 1;i<=m;i++)
		{
			ans = max(ans,(r1[i]-l1[i]+1)*b[i]);
			if(!a[i])continue;
			j = l0[i];
			if(j>1&&b[j-1]>=a[i]){if(L[i])j=L[i]+1;else j--;}
			ans = max(ans,(r0[i]-j+1)*a[i]);
			j = r0[i];
			if(j<m&&b[j+1]>=a[i]){if(R[i])j=R[i]-1;else j++;}
			ans = max(ans,(j-l0[i]+1)*a[i]);
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem3727

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 3e5+5;
int fa[N],dis[N];
struct EDGE
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct Fac
{
	LL c,a;
	void operator +=(const Fac &S)
		{c+=S.c;a+=S.a;}
	void operator -=(const Fac &S)
		{c-=S.c;a-=S.a;}
	void operator *=(int y)
		{c*=y,a*=y;}
}two_size[N],two_a[N];
void dfs(int x,int f)
{
	fa[x] = f;
	if(x!=1)dis[x] = dis[f]+1;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
}
LL size[N],a[N],b[N];
int main()
{
	int n;
	scanf("%d",&n);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		scanf("%lld",&b[i]);
	dfs(1,0);
	for(int i = 2;i<= n;i++)
		two_size[i] = (Fac){b[fa[i]]-b[i],1};
	for(int i = 2;i<= n;i++)
	{
		two_a[i]+=two_size[i];
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to!=fa[i])
				two_a[i]-=two_size[e[j].to];
	}
	Fac b1;
	b1.c = 0,b1.a = 0;
	for(int i = 2;i<= n;i++)
	{
		Fac tmp = two_a[i];
		tmp*=dis[i];
		b1+=tmp;
	}
	size[1] = (b[1]*2-b1.c)/b1.a;
	for(int i = 2;i<= n;i++)
		size[i] = (two_size[i].c+size[1])/2;
	for(int i = 1;i<= n;i++)
	{
		a[i]+=size[i];
		for(int j = head[i];j;j = e[j].next)
			if(e[j].to!=fa[i])
				a[i]-=size[e[j].to];
		printf("%lld",a[i]);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem3728

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
bool cmp1(const int &a,const int &b){return a<b;}
bool cmp2(const int &a,const int &b){return b<a;}
int heap[N],ans[N],cnth,cnta;
int lamp[N],lst[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&lamp[i]);
	for(int i = 1;i<= n;i++)
		scanf("%d",&lst[i]);
	sort(lamp+1,lamp+n+1,cmp2);
	sort(lst+1,lst+n+1,cmp2);
	int j = 1;
	long long tans = 0;
	for(int i = 1;i<= n;i++)
	{
		while(j<=n&&lamp[j]>=lst[i])
		{
			heap[++cnth] = lamp[j];
			push_heap(heap+1,heap+cnth+1,cmp2);
			j++;
		}
		if(cnth<=0&&k>=1)k--,tans+=lst[i];
		else if(cnth<=0){printf("NIE\n");return 0;}
		else
		{
			tans+=heap[1];
			ans[++cnta] = heap[1]-lst[i];
			push_heap(ans+1,ans+cnta+1,cmp1);
			pop_heap(heap+1,heap+cnth+1,cmp2);
			cnth--;
		}
	}
	while(k&&cnta)
	{
		tans-=ans[1];
		pop_heap(ans+1,ans+cnta+1,cmp1);
		cnta--,k--;
	}
	printf("%lld\n",tans);
	return 0;
}
Problem3730

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e7;
int rot[N][2],cnt,n,m;
int ls[M],rs[M],sum[M],a[N];
void update(int &p,int l,int r,int pos,int val)
{
	if(!p)p = ++cnt;
	sum[p]+=val;
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],l,mid,pos,val);
	else update(rs[p],mid+1,r,pos,val);
	//sum[p] = sum[ls[p]]+sum[rs[p]];
}
int getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	if(a>b)return 0;
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int pos[N],T,log_2[N<<1];
int min_dpt[N<<1][18],dpt[N];
void dfs(int x,int from)
{
	min_dpt[pos[x]=++T][0] = dpt[x];
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=from)
		{
			dpt[e[i].to] = dpt[x]+1;
			dfs(e[i].to,x);
			min_dpt[++T][0] = dpt[x];
		}
}
void build_lca()
{
	for(int i = 2;i<=T;i++)
		log_2[i] = log_2[i>>1]+1;
	for(int j = 1;j<= log_2[T];j++)
		for(int i = 1;i+(1<<j)-1<=T;i++)
			min_dpt[i][j] = min(min_dpt[i][j-1],min_dpt[i+(1<<(j-1))][j-1]);
}
int get_lcadpt(int x,int y)
{
	x = pos[x],y = pos[y];
	if(x>y)swap(x,y);
	int l = log_2[y-x+1];
	return min(min_dpt[x][l],min_dpt[y-(1<<l)+1][l]);
}
int getdis(int x,int y)
{
	return dpt[x]+dpt[y]-2*get_lcadpt(x,y);
}
bool used[N];
int size[N],f[N],Sum,father[N];
void get_size(int x,int pre)
{
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_size(e[i].to,x);
			size[x]+=size[e[i].to];
		}
}
int root;
void get_root(int x,int pre)
{
	size[x] = 1,f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],Sum-size[x]);
	if(f[x]<f[root])root = x;
}
int stack[N],top;
void DFS(int x,int pre)
{
	stack[++top] = x;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
			DFS(e[i].to,x);
}
void Build(int x,int pre)
{
	get_size(x,0);
	Sum = size[x];f[0] = Sum,root = 0;
	get_root(x,0);
	x = root;
	father[x] = pre;
	used[x] = true;
	top = 0;
	DFS(x,0);
	for(int i = 1;i<= top;i++)
	{
		int y = stack[i];
		update(rot[x][0],0,n,getdis(y,x),a[y]);
		update(rot[x][1],0,n,getdis(y,father[x]),a[y]);
	}
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
			Build(e[i].to,x);
}
void Update(int x,int del)
{
	for(int i = x;i;i=father[i])
	{
		update(rot[i][0],0,n,getdis(x,i),del);
		if(father[i])update(rot[i][1],0,n,getdis(x,father[i]),del);
	}
	a[x]+=del;
}
int Getans(int x,int k)
{
	int ans = 0;
	for(int i = x;i;i=father[i])
	{
		int Dis = getdis(i,x);
		if(Dis<=k)
			ans = ans+getans(rot[i][0],0,n,0,k-Dis);
		if(father[i])
		{
			int Dis2 = getdis(father[i],x);
			if(Dis2<=k)ans = ans-getans(rot[i][1],0,n,0,k-Dis2);
		}
	}
	return ans;
}
int main()
{
	//freopen("x.in","r",stdin);
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	int opt;
	dpt[1] = 1;
	dfs(1,0);
	build_lca();
	Build(1,0);
	int lastans = 0;
	while(m--)
	{
		scanf("%d%d%d",&opt,&x,&y);
		x = x^lastans,y = y^lastans;
		if(opt==0)
			printf("%d\n",lastans = Getans(x,y));
		else Update(x,y-a[x]);
	}
	return 0;
}
Problem3733

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e4+10;
typedef long long ll;
ll f[N][35];
int fac[N],n,m,k;
bool dfs(int now,int x,int pro)
{
	if(!x)return pro==n;
	x--;
	for(;now+x<=m;now++)
	{
		if(f[now][x]<0)return false;
		if((ll)pro*f[now][x]>n)return false;
		if(dfs(now+1,x,pro*fac[now]))return true;
	}
	return false;
}
int main()
{
	int test;
	scanf("%d",&test);
	while(test--)
	{
		m=0;
		scanf("%d%d",&n,&k);
		for(int i = 1;i*i<=n;i++)
			if(n%i==0)
			{
				fac[++m] = i;
				if(i*i!=n)fac[++m] = n/i;
			}
		sort(fac+1,fac+m+1);
		ll pro = 1;
		for(int i = 1;i<= m;i++)
		{
			pro = 1;
			for(int j = 0;j<k&&i+j<=m;f[i][j++]=pro)
			if(pro>0)
			{
				pro = pro*fac[i+j];
				if(pro>n)pro = -1;
			}
		}
		if(dfs(1,k,1))printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;
}
Problem3735

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	ll pos;int i;
	data(){}
	data(ll _pos,int _i):pos(_pos),i(_i){}
	bool operator <(const data &s)const
	{
		if(pos==s.pos)return i>s.i;
		return pos>s.pos;
	}
}heap[N];
int cnt,a[N];ll n,L,R,now;int k;
ll Ans[N];
bool check(ll mid)
{
	ll ans = n;
	for(int i = 1;i<= k;i++)
	{
		ans-=mid/a[i];
		if(ans<0)return false;
	}
	return true;
}
int main()
{
	scanf("%lld%d",&n,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d",&a[i]);
		R = max(R,1ll*a[i]);
	}
	L = R+1,R = R*n;
	ll ans = 0;
	while(L<=R)
	{
		ll mid = (L+R)>>1;
		if(check(mid))L=mid+1,ans=mid;
		else R = mid-1;
	}
	R = ans;
	for(int i = 1;i<= k;i++)R = min(R,max((ans/a[i]-1)*a[i],0ll));
	cnt = 0;
	for(int i = 1;i<= k;i++)
	{
		now+=R/a[i];
		heap[++cnt] = data(R/a[i]*a[i],i);
		push_heap(heap+1,heap+cnt+1);
	}
	while(now<n)
	{
		data tmp = heap[1];
		pop_heap(heap+1,heap+cnt+1);
		Ans[tmp.i] = ++now;
		tmp.pos+=a[tmp.i];
		heap[cnt] = tmp;
		push_heap(heap+1,heap+cnt+1);
	}
	for(int i = 1;i< k;i++)
		printf("%lld ",Ans[i]);
	printf("%lld\n",Ans[k]);
	return 0;
}
Problem3736

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2505;
int n,m,ml,mw,s,tmp[N][N],f[2][N],L[2][N],R[2][N],l[N],r[N];
int mxc[N],mxr[N];
char str[N];
bool a[N][N];
void solve(int mxc[])
{
	for(int j = 1;j<= m;j++)
		L[0][j] = 0,R[0][j] = m+1,f[0][j] = 0;
	for(int i = 1,cur = 1;i<= n;i++)
	{
		l[0] = 0,r[m+1] = m+1;
		for(int j = m;j;j--)
			if(a[i][j])r[j]=r[j+1];
			else r[j]=j;
		for(int j = 1;j<= m;j++)
			if(a[i][j])
			{
				l[j] = l[j-1];
				f[cur][j] = f[cur^1][j]+1;
				L[cur][j] = max(L[cur^1][j],l[j]);
				R[cur][j] = min(R[cur^1][j],r[j]);
				int r = f[cur][j],c = R[cur][j]-L[cur][j]-1;
				mxc[r] = min(mxc[r],c);
				if(!a[i+1][j])
				{
					for(int p = r+1;p<= n;p++)
						if(mxc[p])
							mxc[p]=0;
						else break;
				}
			}else
				l[j] = j,f[cur][j]=L[cur][j]=0,R[cur][j]=m+1;
		cur^=1;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",str+1);
		for(int j = 1;j<= m;j++)
			a[i][j]=str[j]=='X';
	}
	memset(mxc,0x3f,sizeof(mxc));
	memset(mxr,0x3f,sizeof(mxr));
	solve(mxc);
	for(int j = 1;j<= m;j++)
		for(int i = 1;i<= n>>1;i++)
			swap(a[i][j],a[n-i+1][j]);
	solve(mxc);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			tmp[j][i]=a[i][j],a[i][j]=false;
	for(int i = 1;i<= m;i++)
		for(int j = 1;j<= n;j++)
			a[i][j]=tmp[i][j];
	swap(n,m);
	solve(mxr);
	for(int j = 1;j<= m;j++)
		for(int i = 1;i<= n>>1;i++)
			swap(a[i][j],a[n-i+1][j]);
	solve(mxr);
	swap(n,m);
	mxr[0] = n+1;
	for(int i = n,j=1;j<= m;j++)
		for(;i>mxr[j];i--)
			mxc[i] = min(mxc[i],j-1);
	for(int i = 1;i<=n;i++)
		if(i*mxc[i]>s)
			s=i*mxc[i],ml=i,mw=mxc[i];
	printf("%d %d\n",ml,mw);
	return 0;
}
Problem3737

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <algorithm>
using namespace std;
typedef long long LL;
#define rep(i,j,n) for(int i=j;i<=n;i++)
char c;
bool t[4010010];
LL n,p[1000000],ans[1000000];
int T,tot,tott,len,S=10;
void pre()
{
    memset(t,true,sizeof(t));
    rep(i,2,4010000) 
    	if(t[i])
    	{
        	p[++len]=i;
       		rep(j,i,4010000/i) t[i*j]=false;
    	}
}
inline LL muti_mod(LL a,LL b,LL c)
{
    a%=c;
    b%=c;
    LL ret=0;
    while(b)
    {
        if(b&1){ret+=a;if(ret>=c)ret-=c;}
        a<<=1;
        if(a>=c)a-=c;
        b>>=1;
    }
    return ret;
}
inline LL pow_mod(LL x,LL n,LL mod)
{
    if(n==1)return x%mod;
    int bit[50],k=0;
    while(n)
    {
        bit[k++]=n&1;
        n>>=1;
    }
    LL ret=1;
    for(;k>0;k--)
    {
        ret=muti_mod(ret,ret,mod);
        if (bit[k-1]==1) ret=muti_mod(ret,x,mod);
    }
    return ret;
}
inline bool check(LL a,LL n,LL x,LL t)
{
    LL ret=pow_mod(a,x,n),last=ret;
    for(int i=1;i<=t;i++)
    {
        ret=muti_mod(ret,ret,n);
        if(ret==1&&last!=1&&last!=n-1) return true;
        last=ret;
    }
    if(ret!=1) return true;
    return false;
}
inline bool prime(LL n)
{
    if(n<2)return false;
    if(n==2)return true;
    if((n&1)==0) return false;
    LL x=n-1;LL t=0;
    while((x&1)==0){x>>=1;t++;}
    for(int i=0;i<S;i++)
    {
        LL a=rand()%(n-1)+1;
        if(check(a,n,x,t)) return false;
    }
    return true;
}
void find(LL n,int list,LL now)
{
    if(n==1){ans[tot++]=now;return;}
    if(1&n) return;
    LL N=now,m,maxi=int(sqrt(n))+1;
    rep(i,list,len) if(p[i]>maxi)break;else if(n%(p[i]-1)==0)
    {
        m=n/(p[i]-1);
        N*=p[i];
        find(m,i+1,N);
        while(m%p[i]==0)
        {
            m/=p[i];N*=p[i];
            find(m,i+1,N);
        }
        N=now;
    }
    if(n+1>=p[list])
    {
        if(n+1>p[len]){if(prime(n+1))ans[tot++]=N*(n+1);}
        else{if(t[n+1])ans[tot++]=N*(n+1);}
    }
}
int main()
{
    scanf("%d",&T);
    pre();
    while(T--)
    {
        scanf("%lld",&n);tot=0;
        if(1&n){
            if(n==1){puts("2");puts("1 2");}else puts("0"),puts("");
            continue;
        }
        find(n,1,1);
        sort(ans,ans+tot);
        printf("%d\n",tot);
        rep(i,0,tot-2) printf("%lld ",ans[i]);
        if(tot)printf("%lld\n",ans[tot-1]);else{puts("");};
    }
}
Problem3744

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
const int B = 305;
int c[N],sum[B][B],Sum[B][N];
int a[N],b[N],bel[N],bs[B],be[B],n,L,cnt,size;
int Find(int x)
{
	int l = 1,r = L+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(b[mid]<x)l=mid+1;
		else r = mid;
	}
	return l;
}
void update(int x,int y)
{
	for(int i = x;i<=n;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void Update(int id,int x,int y)
{
	for(int i = x;i<=cnt;i+=i&(-i))
		sum[id][i]+=y;
}
int Getans(int id,int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=sum[id][i];
	return ans;
}
void UPDATE(int id,int x,int y)
{
	for(int i = x;i<=n;i+=i&(-i))
		Sum[id][i]+=y;
}
int GETANS(int id,int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=Sum[id][i];
	return ans;
}
int ni[B];
int main()
{
	//freopen("noon.in","r",stdin);
	//freopen("noon.out","w",stdout);
	//freopen("x.in","r",stdin);
	scanf("%d",&n);
	size = floor(sqrt(n));
	for(int i = 1;i<= n;i+=size)
	{
		bs[++cnt]=i;be[cnt]=min(n,i+size-1);
		for(int j = bs[cnt];j<=be[cnt];j++)
			bel[j]=cnt;
	}
	for(int i =1;i<= n;i++)
		scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	for(int i = 1;i<= n;i++)
		if(b[i]!=b[L])
			b[++L]=b[i];
	for(int i = 1;i<= n;i++)a[i]=Find(a[i]);
	//for(int i = 1;i<= n;i++)printf("%d ",a[i]);
	//printf("\n");
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],1);
		for(int j = i+1;j<=cnt;j++)
		{
			int t = 0;
			for(int k = bs[j];k<=be[j];k++)
				t+=getans(n)-getans(a[k]);
			Update(i,j,t);
		}
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],-1);
	}
	for(int i=1;i<=cnt;i++)
		for(int j = 1;j<=be[i];j++)
			UPDATE(i,a[j],1);
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = bs[i];j<=be[i];j++)
		{
			ni[i]+=getans(n)-getans(a[j]);
			update(a[j],1);
			//if(i==1)printf("%d\n",ni[i]);
		}
		for(int j = bs[i];j<=be[i];j++)
			update(a[j],-1);
	}
	//for(int i = 1;i<= cnt;i++)
	//	printf("%d\n",ni[i]);
	int q,ans=0;
	scanf("%d",&q);
	while(q--)
	{
		int l,r,j,k;
		scanf("%d%d",&j,&k);
		j^=ans,k^=ans;
		ans = 0;
		l = bel[j],r=bel[k];
		if(r-l<=1)
		{
			for(int i = j;i<= k;i++)
			{
				ans+=getans(n)-getans(a[i]);
				update(a[i],1);
			}
			for(int i = j;i<=k;i++)
				update(a[i],-1);
		}else
		{
			for(int i = l+1;i<= r-1;i++)
			{
				ans+=ni[i];
				ans+=Getans(i,r-1)-Getans(i,i);
				//printf("%d\n",ans);
			}
			for(int i = j;i<=be[l];i++)
			{
				ans+=getans(n)-getans(a[i]);
				ans+=GETANS(r-1,a[i]-1)-GETANS(l,a[i]-1);
				update(a[i],1);
				//printf("%d\n",ans);
			}
			for(int i = bs[r];i<=k;i++)
			{
				ans+=getans(n)-getans(a[i]);
				ans+=GETANS(r-1,n)-GETANS(r-1,a[i])-GETANS(l,n)+GETANS(l,a[i]);
				update(a[i],1);
				//printf("%d\n",ans);
			}
			for(int i=j;i<=be[l];i++)update(a[i],-1);
			for(int i=bs[r];i<=k;i++)update(a[i],-1);
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem3747

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long LL;
int w[N],f[N],next[N],last[N];
LL maxn[N<<2],lazy[N<<2];
void push_down(int p,int l,int r)
{
	if(lazy[p]==0||l==r)return ;
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=c;
		maxn[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update(p<<1|1,mid+1,r,a,b,c);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
/*LL getans(int p,int l,int r,int a,int b)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
		return maxn[p];
	LL ans = 0;
	int mid = (l+r)>>1;
	if(a<=mid)ans = max(ans,getans(p<<1,l,mid,a,b));
	if(b>mid)ans = max(ans,getans(p<<1|1,mid+1,r,a,b));
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
	return ans;
}*/
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&f[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d",&w[i]);
	for(int i = n;i>=1;i--)
	{
		next[i] = last[f[i]];
		last[f[i]] = i;
	}
	for(int i = 1;i<= m;i++)
		if(last[i])
		{
			if(!next[last[i]])update(1,1,n,last[i],n,w[i]);
			else update(1,1,n,last[i],next[last[i]]-1,w[i]);
		}
	LL ans = 0;
	for(int i = 1;i<= n;i++)
	{
		ans = max(ans,maxn[1]);
		int t = next[i];
		if(t)
		{
			update(1,1,n,i,t-1,-w[f[i]]);
			if(next[t])update(1,1,n,t,next[t]-1,w[f[i]]);
			else update(1,1,n,t,n,w[f[i]]);
		}else update(1,1,n,i,n,-w[f[i]]);
	}
	printf("%lld",ans);
	return 0;
}
Problem3748

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 507;
int f[N] = {0,1,0,0,2,2,0,0,0,3,3,0,0,3,3,0,4,4,0,0,4,4,0,0,0,4,4,0,0,4,4,0,0,0,5,5,6,6,5,5,6,5,5,0,0,5,5,0,0,6,5,5,6,6,5,5,6,6,7,7,0,6,6,7,8,6,6,0,8,7,6,6,0,8,6,6,0,6,6,7,8,6,6,7,7,7,6,6,7,7,6,6,0,8,7,7,0,9,7,7,7,7,7,7,7,7,7,9,0,8,7,7,0,8,7,7,8,8,8,7,7,8,8,7,7,8,7,7,0,8,7,7,9,8,8,7,7,9,8,7,7,8,8,8,9,8,8,8,8,8,8,8,8,8,8,8,9,10,8,8,9,9,8,8,8,8,8,8,8,8,8,9,9,10,8,8,9,10,8,8,9,9,9,8,8,9,9,8,8,10,8,8,9,10,8,8,9,9,9,8,8,9,9,8,8,9,9,9,9,10,9,9,9,10,9,9,9,9,10,9,9,9,9,9,9,10,9,9,9,9,9,9,9,9,9,9,9,10,10,9,9,10,10,9,9,9,9,9,9,9,9,9,10,10,10,9,9,11,10,9,9,10,10,10,9,9,10,10,9,9,10,9,9,11,10,9,9,11,10,10,9,9,10,10,9,9,10,10,10,11,10,10,10,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,10,10,10,11,10,10,10,10,11,10,10,10,10,10,10,11,10,10,10,10,10,10,10,10,10,10,10,11,11,10,10,11,11,10,10,10,10,10,10,10,10,10,11,11,11,10,10,11,11,10,10,11,11,11,10,10,11,11,10,10,11,10,10,11,11,10,10,11,12,11,10,10,11,11,10,10,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,12,11,11,11,11,12,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,12,12,11,11,11,11,11,11,11,11,11,12,12,12,11,11,12,12,11,11,12,12,12,11,11,12,12,11,11,12,11,11,12,12,11,11,12,12,12,11,11,12,12,11,11};
int v[N],sum[N];
LL F(LL x)
{
	return x*(x+1)*(x*2+1)/6;
}
int main()
{
	LL n;
	scanf("%lld",&n);
	for(int i = 2;i<N;i++)
		if(f[i])
			for(int j = 1;j<i;j++)
				if(!f[j]||f[i]<f[j])v[j] = 1;
	for(int i = 2;i<N;i++)sum[i] = sum[i-1]+v[i];
	if(n<N)
	{
		if(f[n]!=0)printf("%d %d\n",f[n],sum[n]);
		else printf("- %d\n",sum[n]);
		return 0;
	}
	int L = 1,R = 2e6;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(F(mid)<n)L = mid+1;
		else R = mid;
	}
	bool flag = false;
	if(F(L)-n<=(LL)506&&F(L)-n>0)
		if(f[F(L)-n]==0)
			printf("%d ",L+1),flag = true;
	if(!flag)printf("%d ",L);
	LL ans;
	int i;
	for(ans=(LL)(L-12)*31+sum[N-1],i=1;i<=128;i++)if(!f[i]&&F(L)-i<=n)ans++;
	printf("%lld",ans);
	return 0;
}
Problem3749

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int f[N][5],a[N],n,ans[N];
bool work(int u)
{
	memset(f,0,sizeof(f));
	f[1][u] = 1;
	for(int i = 2;i<= n;i++)
	{
		if(f[i-1][1]&&a[i-1]<=2*a[i])f[i][1] = 1;
		if(f[i-1][4]&&a[i-1]<=a[i])f[i][1] = 4;
		if(f[i-1][2]&&a[i-1]*2>=a[i])f[i][2] = 2;
		if(f[i-1][3]&&a[i-1]>=a[i])f[i][2] = 3;
		if(f[i-1][1]&&a[i-1]<=a[i])f[i][3] = 1;
		if(f[i-1][4]&&2*a[i-1]<=a[i])f[i][3] = 4;
		if(f[i-1][2]&&a[i-1]>=a[i])f[i][4] = 2;
		if(f[i-1][3]&&a[i-1]>=a[i]*2)f[i][4] = 3;
	}
	if(f[n][u]==0)return false;
	for(int i=n;i>=1;i--)
	{
        if(u==1)ans[i-1]=(i-1)%(n-1)+1;
        if(u==2)ans[i]=(i-1)%(n-1)+1;
        if(u==3)ans[i-1]=ans[i]=(i-1)%(n-1)+1;
        u=f[i][u];
    }
    for(int i = 1;i<n-1;i++)printf("%d ",ans[i]);
    printf("%d\n",ans[n-1]);
	return true;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	a[++n] = a[1];
	for(int i = 1;i<=4;i++)if(work(i))return 0;
	printf("NIE\n");
	return 0;
}
Problem3771

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double x = 0,double y = 0):x(x),y(y){}
	friend cp operator+(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator-(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator*(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+b.x*a.y);
	}
}a[N],b[N],c[N],d[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[i],a[t]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i=2;i<=len;i=i<<1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w = cp(1,0),t;
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int A[N];
int main()
{
	int maxa = -1,n;
	scanf("%d",&n);
	n--;
	for(int i = 0;i<= n;i++)
	{
		scanf("%d",&A[i]);
		a[A[i]].x=1,b[2*A[i]].x=1,c[3*A[i]].x=1;
		maxa = max(maxa,3*A[i]);
	}
	int m=maxa,L=0;
    for(n=1;n<=m;n<<=1)L++;
    FFT(a,n,1),FFT(b,n,1),FFT(c,n,1);
	for(int i = 0;i<=n;i++)
	{
		cp tmp = cp(1.0/6.0,0),tmp2 = cp(3.0,0),tmp3 = cp(2.0,0),tmp4 = cp(1.0/2.0,0);
		d[i]=d[i]+(a[i]*a[i]*a[i]-tmp2*a[i]*b[i]+tmp3*c[i])*tmp;
        d[i]=d[i]+(a[i]*a[i]-b[i])*tmp4;
        d[i]=d[i]+a[i];
	}
	FFT(d,n,-1);
	for(int i = 0;i<= maxa;i++)
	{
		int ans = (int)(d[i].x+0.1);
		if(ans!=0)printf("%d %d\n",i,ans);
	}
	return 0;
}
Problem3772

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int M = 4e6+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,m;
struct Ask
{int x,y;}ask[N];
bool cmp(Ask a,Ask b)
{
	if(a.x==b.x)return a.y<b.y;
	return a.x<b.x;
}
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
	e[++tot].to = x;e[tot].next = head[y];head[y]=tot;
}
int fa[N][18],root[N];
int ls[M],rs[M],sum[M];
int in[N],end[N],ind,dep[N],cnt;
int getans(int x,int y,int u,int v,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return sum[x]+sum[y]-sum[u]-sum[v];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans+=getans(ls[x],ls[y],ls[u],ls[v],l,mid,a,b);
	if(b>mid) ans+=getans(rs[x],rs[y],rs[u],rs[v],mid+1,r,a,b);
	return ans;
}
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p] = sum[pre]+val;
		return ;
	}
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)
		update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
	sum[p] = sum[ls[p]]+sum[rs[p]];
}
void dfs(int x)
{
	in[x] = ++ind;
	dep[x] = dep[fa[x][0]]+1;
	for(int j = 1;j<= 17;j++)
		fa[x][j] = fa[fa[x][j-1]][j-1];
	for(int i = head[x];i;i=e[i].next)
	{
		if(e[i].to==fa[x][0])continue;
		fa[e[i].to][0] = x;
		dfs(e[i].to);
	}
	end[x] = ++ind;
}
vector<int>a[N];
void dfs2(int x)
{
	root[x] = root[fa[x][0]];
	for(int i = 0;i<a[x].size();i++)
	{
		update(root[x],root[x],1,ind,in[a[x][i]],1);
		update(root[x],root[x],1,ind,end[a[x][i]],-1);
	}
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
			dfs2(e[i].to);
}
ll ans = 0;
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void solve()
{
	for(int i = 1;i<= m;i++)
	{
		int x=ask[i].x,y = ask[i].y;int u = getlca(x,y),v = fa[u][0];
		ans+=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[x]);
		ans+=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[y]);
		ans-=getans(root[x],root[y],root[u],root[v],1,ind,in[u],in[u]);
		ans--;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		a[x].push_back(y);
		ask[i].x = x,ask[i].y = y;
	}
	sort(ask+1,ask+m+1,cmp);
	dfs(1);
	dfs2(1);
	solve();
	ll b = (ll)m*(m-1)/2;
	int j;
	for(int i = 1;i<= m;i=j)
		for(j=i;ask[i].x==ask[j].x&&ask[i].y==ask[j].y;j++)
			ans-=(ll)(j-i)*(j-i-1)/2;
	ll t = gcd(ans,b);
	ans = ans/t,b = b/t;
	printf("%lld/%lld\n",ans,b);
	return 0;
}
Problem3774

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e4+4;
const int M = 1e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].f = 0;
}
queue <int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] =-1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
	{
		ans+=get_mxf(s,t,INF);
	}
	return ans;
}
int n,m;
int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
inline int id1(int i,int j)
{
	return i*m+j-m;
}
inline int id2(int i,int j)
{
	return i*m+j-m+n*m;
}
int main()
{
	int ans = 0;
	scanf("%d%d",&n,&m);
	int x;
	int S = 0, T = 2*n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			if((i+j)&1)
				add(S,id1(i,j),x);
			else 
				add(id1(i,j),T,x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			ans+=2*x;
			if((i+j)&1)
				add(S,id2(i,j),x),add(id1(i,j),T,x);
			else 
				add(id2(i,j),T,x),add(S,id1(i,j),x);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if((i+j)&1)
			{
				add(id2(i,j),id1(i,j),INF);
				for(int d = 0;d<4;d++)
				{
					int xx = i+dx[d],yy = j+dy[d];
					if(xx<=0||yy<=0||xx>n||yy>m)continue;
					add(id2(i,j),id1(xx,yy),INF);
				}
			}else
			{
				add(id1(i,j),id2(i,j),INF);
				for(int d = 0;d<4;d++)
				{
					int xx = i+dx[d],yy = j+dy[d];
					if(xx<=0||yy<=0||xx>n||yy>m)continue;
					add(id1(xx,yy),id2(i,j),INF);
				}
			}
	ans-=dinic(S,T);
	printf("%d\n",ans);
	return 0;
}
Problem3786

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
const int Inv = 20000307;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
struct Splay
{
	Splay *ls,*rs,*fa;
	int pos,neg,sta,lazy;
	LL num,sum;
	Splay(LL x,int s);
	void push_up();
	void push_down();
	void Add(LL x);
}*null = new Splay(0,0),*root,*tree[N][2];
Splay :: Splay(LL x,int s)
{
	ls = rs = fa = null;
	num = x*(s==1?1:-1);
	sta = s;
	neg = pos = 0;
	if(sta==1)pos++;
	if(sta==2)neg++;
	lazy = 0;
}
void Splay :: push_up()
{
	sum = ls->sum+rs->sum+num;
	pos = ls->pos+rs->pos+(sta==1);
	neg = ls->neg+rs->neg+(sta==2);
}
void Splay :: push_down()
{
	if(lazy)
	{
		ls->Add(lazy);
		rs->Add(lazy);
		lazy = 0;
	}
}
void Splay :: Add(LL x)
{
	if(this==null)return ;
	num+=x*(sta==1?1:-1);
	sum+=x*(pos-neg);
	lazy+=x;
}
void Push_down(Splay *x)
{
	static Splay *stack[N<<1];
	static int top = 0;
	for(;x!=null;x = x->fa)
		stack[++top] = x;
	while(top)
		stack[top--]->push_down();
}
void go_left(Splay *x)
{
	Splay *y = x->fa;
	y->rs = x->ls;
	x->ls->fa = y;
	x->ls = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)
		root = x;
}
void go_right(Splay *x)
{
	Splay *y = x->fa;
	y->ls = x->rs;
	x->rs->fa = y;
	x->rs = y;
	x->fa = y->fa;
	if(y->fa->ls==y)
		y->fa->ls = x;
	else y->fa->rs = x;
	y->fa = x;
	y->push_up();
	if(y==root)
		root = x;
}
void splay(Splay *x,Splay *target)
{
	Push_down(x);
	while(true)
	{
		Splay *y = x->fa;Splay *z = y->fa;
		if(y==target)break;
		if(z==target)
		{
			if(x==y->ls)go_right(x);
			else go_left(x);
			break;
		}
		if(x==y->ls)
		{
			if(y==z->ls)
				go_right(y);
			go_right(x);
		}else
		{
			if(y==z->rs)
				go_left(y);
			go_left(x);
		}
	}
	x->push_up();
}
Splay* Insert(LL x,int s)
{
	Splay *y = root;
	while(y->rs!=null)
		y = y->rs;
	y->rs = new Splay(x,s);
	y->rs->fa = y;
	y->push_up();
	splay(y->rs,null);
	return root;
}
Splay* find_min(Splay *x)
{
	while(x->ls!=null)
		x = x->ls;
	return x;
}
Splay* find_max(Splay *x)
{
	while(x->rs!=null)
		x = x->rs;
	return x;
}
void move_to_root(Splay *x,Splay *y)
{
	splay(x,null);
	Splay *tmp1 = find_max(root->ls);
	splay(y,null);
	Splay *tmp2 = find_min(root->rs);
	splay(tmp1,null);
	splay(tmp2,root);
}
LL a[N];
void dfs(int x)
{
	tree[x][0] = Insert(a[x],1);
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to);
	tree[x][1] = Insert(a[x],2);
}
int main()
{
	int n,f;
	LL x,y;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d",&f);
		add(f,i);
	}
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	root = new Splay(Inv,3);
	dfs(1);
	Insert(Inv,4);
	int m;
	scanf("%d",&m);
	char opt[10];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",opt);
		if(opt[0]=='Q')
		{
			scanf("%lld",&x);
			move_to_root(tree[1][0],tree[x][0]);
			printf("%lld\n",root->rs->ls->sum);
		}else if(opt[0]=='C')
		{
			scanf("%lld%lld",&x,&y);
			move_to_root(tree[x][0],tree[x][1]);
			Splay *tmp = root->rs->ls;
			root->rs->ls = null;
			root->rs->push_up();
			root->push_up();
			splay(tree[y][0],null);
			splay(find_min(root->rs),root);
			root->rs->ls = tmp;
			tmp->fa = root->rs;
			root->rs->push_up();
			root->push_up();
		}
		else
		{
			scanf("%lld%lld",&x,&y);
			move_to_root(tree[x][0],tree[x][1]);
			root->rs->ls->Add(y);
		}
	}
	return 0;
}
Problem3790

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
char s[N];
char a[N];
int no[N];
int p[N],maxp,id;
struct Q
{int l,r;}q[N];
vector<int>w[N];
int f[N],c[N];
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = min(c[i],y);
}
int getans(int x)
{
	int ans = 0x3f3f3f3f;
	for(int i = x;i>0;i-=i&(-i))
		ans = min(ans,c[i]);
	return ans;
}
int main()
{
	while(scanf("%s",s+1)!=EOF)
	{
		memset(p,0,sizeof(p));
		int n = strlen(s+1);
		int len = 0;
		for(int i = 1;i<=n;i++)
		{
			a[++len]=s[i];
			no[len] = i;
			if(i!=n)a[++len]='^';
		}
		maxp = id = 1;
		for(int i = 1;i<= len;i++)
		{
			p[i] = max(0,min(p[2*id-i],maxp-i));
			while(i+p[i]<=len&&i-p[i]>=1&&a[i+p[i]]==a[i-p[i]])p[i]++;
			p[i]--;
			if(i+p[i]>maxp){maxp = i+p[i],id = i;}
			q[i]=(Q){no[i-p[i]]?no[i-p[i]]:no[i-p[i]+1],no[i+p[i]]?no[i+p[i]]:no[i+p[i]-1]};
		}
		for(int i = 1;i<= len;i++)
			w[i].clear();
		for(int i = 1;i<=len;i++)
			if(q[i].l<=q[i].r)
				w[q[i].r].push_back(q[i].l);
		memset(f,0x3f,sizeof(f));
		memset(c,0x3f,sizeof(c));
		update(n+1,0);
		for(int i = 1;i<= n;i++)
		{
			for(int j = 0;j<w[i].size();j++)
				f[i] = min(f[i],getans(n-w[i][j]+2)+1);
			update(n-i+1,f[i]);
		}
		printf("%d\n",f[n]-1);
	}
	return 0;
}
Problem3812

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int S = 1<<15;
const LL mod = 1e9+7;
LL c[250][250];
LL f[S],g[S],h[S],power_2[S];
int in[S],out[S],dig[S];
int Count(int x)
{
	return dig[x>>8] + dig[x&255] ;
}
int main()
{
	int n,m,x,y,i;
	scanf("%d%d",&n,&m);
	for(i = 1;i<1<<8;i++)
		dig[i] = dig[i>>1]+(i&1);
	for(power_2[0]=1,i=1;i<=m;i++)
		power_2[i]=(power_2[i-1]<<1)%mod;
	for(i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		//add(x,y);
		//f[(1<<(x-1))|(1<<(y-1))]+=1;
		out[1<<(x-1)]|=1<<(y-1);
		in[1<<(y-1)]|=1<<(x-1);
	}
	for(i = 1;i<1<<n;i++)
	{
		int one = i&(-i),sta = i^one;
		h[i] = h[sta]+Count(in[one]&sta)+Count(out[one]&sta);
		for(int j = sta;j;j = (j-1)&sta)
			(g[i]+=mod-f[i^j]*g[j]%mod)%=mod;
		static int w[1<<15];
		f[i] = power_2[h[i]];
		for(int j = i;j;j = (j-1)&i)
		{
			if(j==i)w[j] = 0;
			else
			{
				int tmp = (i^j)&(-(i^j));
				w[j] = w[j^tmp]-Count(out[tmp]&(i^j))+Count(j&in[tmp]);
			}
			(f[i]+=mod-power_2[h[i^j]+w[j]]*g[j]%mod)%=mod;
		}
		(g[i]+=f[i])%=mod;
	}
	printf("%lld\n",f[(1<<n)-1]);
	return 0;
}
Problem3813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
const int mod = 19961993;
typedef pair<ll,ll> PLL;
pair <ll,ll> val[N<<2];
int prime[105],env[105],cnt;
bool v[405];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void init()
{
	for(int i = 2;cnt<=60;i++)
	{
		if(!v[i])prime[++cnt]=i;
		for(int j = 1;j<=cnt&&i*prime[j]<=400;j++)
		{
			v[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
	for(int i = 1;i<= 60;i++)
		env[i] = quick_pow(prime[i],mod-2);
}
void push_up(int p)
{
	val[p].first = val[p<<1].first|val[p<<1|1].first;
	val[p].second = val[p<<1].second*val[p<<1|1].second%mod;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		val[p].first|=1<<2;
		val[p].second = 3;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void update(int p,int l,int r,int x,ll v)
{
	if(l==r)
	{
		val[p].first = 0;
		for(int i = 1;i<= 60;i++)
			if(v%prime[i]==0)
				val[p].first|=(1ll<<i);
		val[p].second = v%mod;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x,v);
	else update(p<<1|1,mid+1,r,x,v);
	push_up(p);
}
PLL uni(PLL a,PLL b)
{
	a.first |= b.first;
	(a.second *= b.second)%=mod;
	return a;
}
pair<ll,ll> getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return val[p];
	pair <ll,ll>ans;
	int mid = (l+r)>>1;
	ans.first = 0,ans.second = 1;
	if(a<=mid)ans=uni(ans,getans(p<<1,l,mid,a,b));
	if(b >mid)ans=uni(ans,getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
int main()
{
	int n = 1e5;
	int m;
	init();
	build(1,1,n);
	scanf("%d",&m);
	while(m--)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		if(a==1)
			update(1,1,n,b,c);
		else
		{
			PLL ans = getans(1,1,n,b,c);
			ll Ans = ans.second;
			for(int i =1;i<= 60;i++)
				if((ans.first>>i)&1)
					Ans = Ans*(prime[i]-1)%mod*env[i]%mod;
			printf("%lld\n",Ans);
		}
	}
	return 0;
}
Problem3827

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int INF = 0x3f3f3f3f;
int dis[N],nxt[N<<1],dep[N<<1];
int n,s;
int work(int x)
{
	int fa = x;
	for(;fa<x+n;fa = nxt[fa]);
	for(int i = nxt[x],j = x;i!=fa;j = i,i = nxt[i])nxt[j] = fa;
	return dep[x]-dep[fa];
}
int main()
{
	scanf("%d%d",&n,&s);
	int max_d = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&dis[i]);
		max_d = max(max_d,dis[i]);
	}
	while(s--)
	{
		int d;
		scanf("%d",&d);
		if(d<max_d){printf("NIE\n");continue;}
		int j = 1,sum = 0;
		int end = n<<1;
		for(int i = 1;i<= end;i++)
		{
			while(j<end&&sum+dis[j>n?j-n:j]<=d)
			{
				sum = sum+dis[j>n?j-n:j];
				j++;
			}
			sum-=dis[i>n?i-n:i];
			nxt[i] = j;
		}
		dep[end] = 0;
		for(int i = end;i>=1;i--)
			dep[i] = dep[nxt[i]]+1;
		int ans = INF;
		for(int i = 1;i<= n;i++)ans = min(ans,work(i));
		printf("%d\n",ans);
	}
	return 0;
}
Problem3828

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int last[N],a[N],tmp[N],stack[N],top,cnt,n,k;
struct Line
{
	int lth,col[N],nxt[N],last[N],Min[N],end[N];
	void init()
	{
		top = 0;
		for(int i = 1;i<= lth;i++)scanf("%d",&tmp[i]);
		for(int i = 1;i< lth;i++)nxt[tmp[i]] = tmp[i+1];
		for(int i = n;i>=1;i--)
		{
			end[i] = 0;
			if(col[i]==tmp[lth])end[i] = i;
			else if(nxt[col[i]]&&last[nxt[col[i]]])
				end[i] = end[last[nxt[col[i]]]];
			if(col[i]==tmp[1]&&end[i])stack[++top] = i;
			last[col[i]] = i;
		}
		stack[top+1] = 1;
		for(int i = 1;i<=top;i++)
			for(int j = stack[i]-1;j>= stack[i+1];j--)
				Min[j] = end[stack[i]];
	}
}a1,a2;
struct Seg
{int l,r;}seg[N];
bool cmp(Seg a,Seg b)
{
	return a.l<b.l;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		a1.col[i] = a[i],a2.col[i] = a[n-i+1];
	scanf("%d%d",&a1.lth,&a2.lth);
	a1.init();
	a2.init();
	for(int i = 1;i<= n;i++)
	{
		if(a1.last[a2.col[i]])
		{
			int tmp1 = a1.Min[a1.last[a2.col[i]]],tmp2 = a2.Min[i];
			if(tmp1&&tmp2&&tmp1<=n-tmp2+1)
				seg[++cnt] = (Seg){tmp1,n-tmp2+1};
		}
	}
	sort(seg+1,seg+cnt+1,cmp);
	int L = seg[1].l,R = seg[1].r,top = 0;
	for(int i = 2;i<= cnt;i++)
	{
		if(seg[i].l>R)
		{
			for(int j = L;j<=R;j++)
				if(a[j]==tmp[a2.lth])stack[++top] = j;
			L = seg[i].l,R = seg[i].r;
		}
		else R = max(seg[i].r,R);
	}
	for(int j = L;j<=R;j++)
		if(a[j]==tmp[a2.lth])stack[++top] = j;
	printf("%d\n",top);
	for(int i = 1;i<=top;i++)
		printf("%d ",stack[i]);
	//printf("%d\n",stack[top]);
	return 0;
}
Problem3829

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 500005;
struct P
{
	int f,size;
}p[N];
bool cmp(P a,P b)
{
	return a.f-a.size>b.f-b.size;
}
int size[N],f[N],c[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
P stack[N];
int top;
void dfs(int x,int fa)
{
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	top = 0;
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa)
		{
			p[e[i].to].size+=2;
			p[e[i].to].f = max(p[e[i].to].f+1,p[e[i].to].size);
			stack[++top] = p[e[i].to];
		}
	sort(stack+1,stack+top+1,cmp);
	p[x].f = c[x];
	for(int i = 1;i<=top;i++)
	{
		p[x].f = max(p[x].f,stack[i].f+p[x].size);
		p[x].size+=stack[i].size;
	}
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	printf("%d\n",max(p[1].f,p[1].size+c[1]));
	return 0;
}
Problem3830

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
const LL INF = 1e18;
LL c[N];
LL f[N],a[N];
int n;
LL s;
void update(int x,LL t)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i] = min(c[i],t);
}
LL getans(int x)
{
	LL ans = INF;
	for(int i = x;i>0;i-=i&(-i))
		ans = min(ans,c[i]);
	return ans;
}
int main()
{
	memset(c,0x3f,sizeof(c));
	scanf("%d%lld",&n,&s);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&a[i]);
	for(int i = 2;i<= n;i++)
		a[i] = max(a[i],a[i-1]+1);
	int L,R,mid;
	for(int i = 1;i<= n;i++)
	{
		L = 1,R = i;
		while(L<R)
		{
			mid = (L+R)>>1;
			if(f[mid]-mid-1<=a[i]-i)
				L = mid+1;
			else R = mid;
		}
		f[i] = a[i]-L+i+s*2;
		if(L!=i)f[i] = min(f[i],getans(n-L+1)+s*2+i*2);
		update(n-i+1,f[i]-2*i-2);
	}
	printf("%lld\n",f[n]);
	return 0;
}
Problem3831

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int line[N],L,R,a[N],f[N];
bool smaller(int i,int j)
{
	if(f[i]!=f[j])
		return f[i]<f[j];
	return a[i]>a[j];
}
int main()
{
	int n,k,t;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&k);
		memset(f,0x3f,sizeof(f));
		L = 0,R = 0;line[R] = 1;
		f[1] = 0;
		for(int i = 2;i<= n;i++)
		{
			while(L<=R&&line[L]<i-k)L++;
			f[i] = min(f[i],f[line[L]]+(a[line[L]]<=a[i]));
			while(L<=R&&smaller(i,line[R]))R--;
			line[++R] = i;
		}
		printf("%d\n",f[n]);
	}
	return 0;
}
Problem3832

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e6+5;
const int N = 5e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[M],fe[M];
int head[N],fh[N],tot;
int line[N],top;
int g[N],f[N],ind[N];
void add(int x,int y)
{
	ind[y]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	fe[tot].to = x;
	fe[tot].next = fh[y];
	fh[y] = tot;
}
queue<int>Q;
int heap[M<<1],dele[M<<1],ch,cd;
int main()
{
	//freopen("raj.in","r",stdin);
	//freopen("raj.out","w",stdout);
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i);
	while(!Q.empty())
	{
		x = Q.front();
		Q.pop();
		line[++top] = x;
		for(int i = head[x];i;i = e[i].next)
			if(!--ind[e[i].to])
				Q.push(e[i].to);
	}
	for(int i = 1;i<= top;i++)
	{
		int tmp = line[i];
		f[tmp] = max(f[tmp],1);
		for(int j = head[tmp];j;j = e[j].next)
			f[e[j].to] = max(f[e[j].to],f[tmp]+1);
	}
	for(int i = top;i>= 1;i--)
	{
		int tmp = line[i];
		g[tmp] = max(g[tmp],1);
		for(int j = head[tmp];j;j = e[j].next)
			g[tmp] = max(g[tmp],g[e[j].to]+1);
	}
	for(int i = 1;i<= n;i++)
	{
		heap[++ch] = g[i];
		push_heap(heap+1,heap+ch+1);
	}
	int ans_len = INF,ans;
	for(int i = 1;i<= top;i++)
	{
		x = line[i];
		for(int j = fh[x];j;j = fe[j].next)
		{
			dele[++cd] = f[fe[j].to]+g[x];
			push_heap(dele+1,dele+cd+1);
		}
		dele[++cd] = g[x];
		push_heap(dele+1,dele+cd+1);
		while(dele[1]==heap[1]&&cd>=1&&ch>=1)
		{
			pop_heap(dele+1,dele+cd+1);
			cd--;
			pop_heap(heap+1,heap+ch+1);
			ch--;
		}
		if(ch&&heap[1]<ans_len)
		{
			ans_len = heap[1];
			ans = x;
		}
		for(int j=head[x];j;j = e[j].next)
		{
			heap[++ch] = f[x]+g[e[j].to];
			push_heap(heap+1,heap+ch+1);
		}
		heap[++ch] = f[x];
		push_heap(heap+1,heap+ch+1);
	}
	printf("%d %d\n",ans,ans_len-1);
	return 0;
}
Problem3834

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int main()
{
	int n;
	scanf("%d",&n);
	while(n--)
	{
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		x1--;
		x2--;
		int last = 0,ans = -1;
		for(int i = 1;i<= y1&&i<=y2;i = last+1)
		{
			last = min(y1/(y1/i),y2/(y2/i));
			if(y1/last>x1/last&&y2/last>x2/last)
				ans = max(ans,last);
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem3835

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int sum[N],max_dep;
void dfs(int x,int dep)
{
	max_dep = max(max_dep,dep);
	sum[dep]++;
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to,dep+1);
}
struct Ask
{int k,no,ans;}qur[N];
bool cmp(Ask a,Ask b){return a.k<b.k;}
bool ret(Ask a,Ask b){return a.no<b.no;}
int line[N],L,R;
double calc(int i,int j)
{
	return (double)(sum[i]-sum[j])/(double)(i-j);
}
int main()
{
	int n,q,x;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&qur[i].k);
		qur[i].no = i;
	}
	sort(qur+1,qur+1+q,cmp);
	for(int i = 2;i<=n;i++)
	{
		scanf("%d",&x);
		add(x,i);
	}
	dfs(1,1);
	for(int i = max_dep;i>=1;i--)
		sum[i]+=sum[i+1];
	R = -1;
	for(int i = 1;i<= max_dep;i++)
	{
		while(L<R&&calc(i,line[R-1])>=calc(line[R],line[R-1]))R--;
		line[++R] = i;
	}
	for(int t = 1;t<= q;t++)
	{
		int i = qur[t].k;
		while(L<R&&i*line[L]+sum[line[L]]<i*line[L+1]+sum[line[L+1]])L++;
		qur[t].ans = line[L];
	}
	sort(qur+1,qur+q+1,ret);
	for(int i = 1;i< q;i++)
		printf("%d ",max(max_dep,(sum[qur[i].ans]+qur[i].k-1)/qur[i].k+qur[i].ans-1));
	printf("%d\n",max(max_dep,(sum[qur[q].ans]+qur[q].k-1)/qur[q].k+qur[q].ans-1));
	return 0;
}
Problem3837

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;

const int N = 1e5+5;
const int M = 1e7+5;
int n,Ans1,Ans2,Maxx;
int A[N],B[N];
int p[M],v[M],vis[M],f[M];

inline void First()
{
	for(int i=2;i<=Maxx;i++)
	{
		if(!p[i]) p[++*p]=i,v[i]=*p;
		for(int j=1;j<=*p&&p[j]*i<=Maxx;j++)
		{
			p[p[j]*i]=1; v[p[j]*i]=j;
			if(i%p[j]==0) break;
		}
	}
}

int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}

int main()
{
	srand(2037);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&A[i]),Maxx=max(Maxx,A[i]);
	First();
	for(int K=1;K<=4;K++)
	{
		int x=A[rand()%n+1],cnt=0,w=0,Max=0,nAns=0;
		for(int i=1;i<=n;i++)
			if(A[i]!=x) B[++cnt]=A[i]<x?(x-A[i]):(A[i]-x);
			else w++;
		for(int i=1;i<=*p;i++) vis[i]=f[i]=0;
		for(int i=1;i<=cnt;i++)
		{
			int now=B[i];
			for(;now^1;now/=p[v[now]])
			{
				vis[v[now]]++;
				f[v[now]]=gcd(f[v[now]],B[i]);
				int y=p[v[now]];
				while((now/y)%y==0) now/=y;
			}
		}
		for(int i=1;i<=*p;i++)
			if(vis[i]>vis[Max]||(vis[i]==vis[Max]&&f[i]>nAns)) Max=i,nAns=f[i];
		if(vis[Max]+w>Ans1) Ans1=vis[Max]+w,Ans2=nAns;
		else if(vis[Max]+w==Ans1&&nAns>Ans2) Ans2=nAns;
	}
	printf("%d %d\n",Ans1,Ans2);
	return 0;
}
Problem3838

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
const int M = (N<<1)+5e4;
const int INF = 1e9+10;
ll ans;
int A[N],B[N],aa[M],ab[M],ba[M],bb[M],lazy[M],vm[M],n,k;
struct data
{
	int x,y;
	data(){}
	data(int _x,int _y):x(_x),y(_y){}
	data operator +(const data &b){return A[x]+B[y]<A[b.x]+B[b.y]?*this:b;}
}va[M],vb[M],vc[M],t;
inline void add(int x,int p)
{
	vm[x]+=p;
	lazy[x]+=p;
}
inline void Push_down(int p)
{
	if(!lazy[p])return ;
	add(p<<1,lazy[p]),add(p<<1|1,lazy[p]);
	lazy[p]=0;
}
inline void Push_up(int p)
{
	int ls = p<<1,rs = p<<1|1;
	va[p] = va[ls]+va[rs]+data(aa[ls],ab[rs]);
	vc[p] = vc[ls]+vc[rs]+data(aa[rs],ab[ls]);
	vb[p] = vb[ls]+vb[rs];
	aa[p] = A[aa[ls]]<A[aa[rs]]?aa[ls]:aa[rs];
	ab[p] = B[ab[ls]]<B[ab[rs]]?ab[ls]:ab[rs];
	if(vm[ls]<vm[rs])
	{
		vb[p] = vb[p]+vc[rs]+data(aa[rs],bb[ls]);
		ba[p] = ba[ls];
		bb[p] = B[ab[rs]]<B[bb[ls]]?ab[rs]:bb[ls];
		vm[p] = vm[ls];
	}
	else if(vm[ls]>vm[rs])
	{
		vb[p] = vb[p]+vc[ls]+data(ba[rs],ab[ls]);
		ba[p] = A[aa[ls]]<A[ba[rs]]?aa[ls]:ba[rs];
		bb[p] = bb[rs];
		vm[p] = vm[rs];
	}else
	{
		vb[p] = vb[p]+data(ba[rs],bb[ls]);
		ba[p] = ba[ls];
		bb[p] = bb[rs];
		vm[p] = vm[ls];
	}
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		va[p]=vc[p]=data(l,l),vb[p]=data(0,0);
		aa[p]=ba[p]=ab[p]=l;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	Push_up(p);
}
void Add(int p,int l,int r,int a,int b,int val)
{
	if(l>=a&&r<=b)
	{
		add(p,val);
		return ;
	}
	Push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)Add(p<<1,l,mid,a,b,val);
	if(b >mid)Add(p<<1|1,mid+1,r,a,b,val);
	Push_up(p);
}
void Change(int p,int l,int r,int pos)
{
	if(l==r)return ;
	Push_down(p);int mid = (l+r)>>1;
	if(pos<=mid)Change(p<<1,l,mid,pos);
	else Change(p<<1|1,mid+1,r,pos);
	Push_up(p);
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)scanf("%d",&A[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&B[i]);
	A[0]=B[0]=INF;
	build(1,0,n);
	while(k--)
	{
		t = va[1]+vb[1];
		int i = t.x,j = t.y;
		ans += A[i]+B[j];
		if(i<j)Add(1,0,n,i,j-1,1);
		if(j<i)Add(1,0,n,j,i-1,-1);
		A[i] = INF,Change(1,0,n,i);
		B[j] = INF,Change(1,0,n,j);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem3864

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int S = 1<<15;
char let[]={'A','C','G','T'};
char s[20];
int f[2][S],trs[S][4],cnt[S],n,m,ans[20];
void init()
{
	for(int i = 0;i<1<<n;i++)
	{
		static int f[20],g[20];
		for(int j = 1;j<= n;j++)
			f[j] = f[j-1]+((i&(1<<(j-1)))?1:0);
		cnt[i] = f[n];
		for(int k = 0;k<4;k++)
		{
			for(int j = 1;j<= n;j++)
			{
				g[j] =max(g[j-1],f[j]);
				if(let[k]==s[j])
					g[j] = max(f[j-1]+1,g[j]);
			}
			trs[i][k] = 0;
			for(int j = 1;j<= n;j++)
				if(g[j]-g[j-1]==1)
					trs[i][k]|=1<<(j-1);
		}
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%s%d",s+1,&m);
		n = strlen(s+1);
		init();
		int pre = 0,now = 1;
		memset(f,0,sizeof(f));
		f[pre][0] = 1;
		for(int i = 1;i<= m;i++)
		{
			memset(f[now],0,sizeof(f[now]));
			for(int j = 0;j<1<<n;j++)
				for(int k = 0;k<4;k++)
					(f[now][trs[j][k]]+=f[pre][j])%=mod;
			swap(now,pre);
		}
		memset(ans,0,sizeof(ans));
		for(int i = 0;i<1<<n;i++)
			(ans[cnt[i]]+=f[pre][i])%=mod;
		for(int i = 0;i<= n;i++)
			printf("%d\n",ans[i]);
	}
	return 0;
}
Problem3872

#include <stdio.h>
#include <cctype>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1000005;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
int d[N];
void add(int x,int y)
{
	d[x]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
LL low[N],upn[N],a[N],maxa;
bool v[N];
queue<int>Q;
void bfs(int x)
{
	v[x] = true;
	Q.push(x);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(!v[e[i].to])
			{
				Q.push(e[i].to);
				v[e[i].to] = true;
				if(low[x]*(d[x]-1)>maxa)low[e[i].to] = maxa+1;
				else low[e[i].to] = low[x]*(d[x]-1);
				if(upn[x]*(d[x]-1)+d[x]-2>maxa)upn[e[i].to] = maxa+1;
				else upn[e[i].to] = upn[x]*(d[x]-1)+d[x]-2;
			}
	}
}
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
LL read()
{
	static char ch;
	static LL D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
int main()
{
	int n,g,k;
	n = read(),g = read(),k =read();
	for(int i = 1;i<= g;i++)
	{
		a[i] = read();
		maxa = max(maxa,a[i]);
	}
	int s,t,x,y;
	for(int i = 1;i<n;i++)
	{
		x = read();y = read();
		add(x,y),add(y,x);
		if(i==1)s = x,t = y;
	}
	v[s] = v[t] = true;
	low[s] = low[t] = upn[s] = upn[t] = k;
	bfs(s);bfs(t);
	sort(a+1,a+g+1);
	LL ans = 0;
	for(int i = 1;i<= n;i++)
		if(d[i]==1)
		{
			int l = lower_bound(a+1,a+g+1,low[i])-a;
			int r = upper_bound(a+1,a+g+1,upn[i])-a;
			if(r>g||a[r]>upn[i])r--;
			ans+=(r-l+1);
		}
	printf("%lld\n",ans*k);
	return 0;
}
Problem3881

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 2e6+5;
char s[N];
int ch[N][26],fail[N],q[N],cnt,h,t;
int s_p[N];
int c[N],Dfn,fa[N][22],dfn[N],dep[N],end[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]+=y;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i>0;i-=i&(-i))
		ans+=c[i];
	return ans;
}
void dfs(int x)
{
	dfn[x] = ++Dfn;
	dep[x] = dep[fa[x][0]]+1;
	for(int i = head[x];i;i=e[i].next)
	{
		fa[e[i].to][0] = x;
		dfs(e[i].to);
	}
	end[x] = Dfn;
}
void Init()
{
	for(int j = 1;j<= 21;j++)
		for(int i = 1;i<= cnt;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 21;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 21;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
void init()
{
	cnt = 1;
	for(int i = 0;i<26;i++)
		ch[0][i] = 1;
}
void insert(int id)
{
	int now = 1,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)]=++cnt;
		now = ch[now][s(i)];
		i++;
	}
	s_p[id] = now;
}
void build()
{
	h = 0,t = -1;
	q[++t] = 1,fail[0] = 1;
	while(h<=t)
	{
		int x = q[h++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[x][i];
			if(!j)
			{
				ch[x][i]=ch[fail[x]][i];
				continue;
			}
			int k = fail[x];
			while(!ch[k][i])k = fail[k];
			fail[j] = ch[k][i];
			q[++t]=j;
			add(fail[j],j);
		}
	}
}
int st[N],top;
int match()
{
	int now = 1,i = 0,top = 0;
	while(s[i])
	{
		now = ch[now][s(i)];
		st[++top] = now;
		i++;
	}
	return top;
}
bool cmp(int a,int b)
{
	return dfn[a]<dfn[b];
}
int main()
{
	int n;
	scanf("%d",&n);
	init();
	for(int i= 1;i<= n;i++)
	{
		scanf("%s",s);
		insert(i);
	}
	build();
	dfs(1);
	Init();
	int q;
	scanf("%d",&q);
	int opt,x;
	while(q--)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%s",s);
			int lth = match();
			sort(st+1,st+lth+1,cmp);
			top = 0;
			for(int i = 1;i<= lth;i++)
				if(st[top]!=st[i])
					st[++top] = st[i];
			lth = top;
			for(int i = 1;i<= lth;i++)
			{
				update(dfn[st[i]],1);
				if(i>1)update(dfn[getlca(st[i-1],st[i])],-1);
			}
		}else
		{
			scanf("%d",&x);
			x=s_p[x];
			printf("%d\n",getans(end[x])-getans(dfn[x]-1));
		}
	}
	return 0;
}
Problem3884

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll quick_pow(ll x,ll y,ll mod)
{
	ll re = 1;
	while(y)
	{
		if(y&1)(re*=x)%=mod;
		(x *= x)%=mod;
		y>>=1;
	}
	return re;
}
ll oula(ll x)
{
	ll phi = x;
	for(ll i = 2;i*i<=x;i++)
		if(x%i==0)
		{
			phi = phi/i*(i-1);
			while(x%i==0)x/=i;
		}
	if(x!=1)phi = phi/x*(x-1);
	return phi;
}
ll calc(ll mod)
{
	if(mod==1)return 0;
	ll ans = 1,cnt = 0,MOD = mod;
	while(mod%2==0)
		ans*=2,cnt++,mod/=2;
	int phi = oula(mod);
	ans = ans*quick_pow(2,((calc(phi)-cnt)%phi+phi)%phi,MOD)%MOD;
	return ans;
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int x;
		scanf("%d",&x);
		printf("%lld\n",calc(x));
	}
	return 0;
}
Problem3886

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int c[25][1005];
int lth[25];
int f[1<<20];
int find(int no,int x)
{
	int l = 1,r = c[no][0]+1;
	while(l<r)
	{
		int mid= (l+r)>>1;
		if(c[no][mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,l;
	scanf("%d%d",&n,&l);
	int end = 1<<n;
	memset(c,0x3f,sizeof(c));
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&lth[i],&c[i][0]);
		for(int j = 1;j<= c[i][0];j++)
			scanf("%d",&c[i][j]);
	}
	memset(f,-1,sizeof(f));
	f[0] = 0;
	int ans =50;
	for(int i = 0;i<end;i++)
	{
		if(f[i]==-1)continue;
		for(int j = 1;j<= n;j++)
		if(!(i&(1<<(j-1))))
		{
			int tmp = find(j,f[i]);
			if(c[j][tmp]>f[i])tmp--;
			if(tmp>0)f[i|(1<<(j-1))] = max(f[i|(1<<(j-1))],max(f[i],c[j][tmp]+lth[j]));
		}
		if(f[i]>=l)
		{
			int tmp = i,cnt = 0;
			while(tmp){tmp-=tmp&(-tmp);cnt++;}
			ans = min(ans,cnt);
		}
	}
	if(ans!=50)printf("%d\n",ans);
	else printf("-1\n");
	return 0;
}
Problem3887

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 1e5+5;
int n,m;
struct E
{
	int next,to;
};
struct G
{
	E e[M];
	int head[N],tot;
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
	}
}g,g1,gf;
bool ret[N];
bool vis[N],ins[N];
int dep[N],low[N],stack[N],bel[N],top,dfn,scc,val[N];
void tarjan(int x)
{
	vis[x] = ins[x] = true;
	stack[++top] =x;
	dep[x] = low[x] = ++dfn;
	for(int i = g.head[x];i;i = g.e[i].next)
	{
		int u = g.e[i].to;
		if(!vis[u])
		{tarjan(u);low[x] = min(low[x],low[u]);}
		else if(ins[u])
		{low[x] = min(low[x],dep[u]);}
	}
	if(dep[x]==low[x])
	{
		scc++;
		int tmp;
		do{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = scc;
			val[scc]++;
		}while(tmp!=x);
	}
}
void rebuild()
{
	for(int i = 1;i<= n;i++)
		for(int j = g.head[i];j;j= g.e[j].next)
		{
			int u = g.e[j].to;
			if(bel[i]!=bel[u])
			{
				g1.add(bel[i],bel[u]);
				if(i==1)ret[bel[u]] = true;
				gf.add(bel[u],bel[i]);
			}
		}
}
int dis[2][N];
bool v[N];
queue<int>Q;
void spfa(int s)
{
	memset(dis,-1,sizeof(dis));
	dis[0][s] = val[s];
	Q.push(s);
	v[s] = true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]= false;
		for(int i = g1.head[x];i;i = g1.e[i].next)
		{
			int u = g1.e[i].to;
			if(dis[0][x]+val[u]>dis[0][u])
			{
				dis[0][u] = dis[0][x]+val[u];
				if(!v[u])
				{
					Q.push(u);
					v[u] = true;
				}
			}
		}
	}
	Q.push(s);
	v[s] = true;
	dis[1][s] = val[s];
	while(!Q.empty())
	{
		int x= Q.front();
		Q.pop();
		v[x] = false;
		for(int i = gf.head[x];i;i=gf.e[i].next)
		{
			int u = gf.e[i].to;
			if(dis[1][x]+val[u]>dis[1][u])
			{
				dis[1][u] = dis[1][x]+val[u];
				if(!v[u])
				{
					Q.push(u);
					v[u] = true;
				}
			}
		}
	}
}
int main()
{
	//freopen("wander.in","r",stdin);
	//freopen("wander.out","w",stdout);
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		g.add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			tarjan(i);
	rebuild();
	spfa(bel[1]);
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = g.head[i];j;j= g.e[j].next)
		{
			int u = g.e[j].to;
			if(bel[i]!=bel[u])
				if(dis[0][bel[u]]!=-1&&dis[1][bel[i]]!=-1)
					ans = max(ans,dis[0][bel[u]]+dis[1][bel[i]]-val[bel[1]]);
		}
	printf("%d\n",ans);
	return 0;
}
Problem3889

#include <stdio.h>
#include <queue>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
typedef long long LL;
using namespace std;
const int N = 1005;
LL INF;
int city[N];
bool v[N];
int d2[N],k2[N][N],n;
LL d1[N],k1[N][N];
queue<int>Q;
void spfa(int s)
{
	memset(d1,0x3f,sizeof(d1));
	memset(d2,0x3f,sizeof(d2));
	d1[s] = 0;d2[s] = 0;
	v[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x]=false;
		for(int i = 1;i<= n;i++)
		{
			if(k1[x][i]==INF)continue;
			if(d1[x]+k1[x][i]<d1[i])
			{
				d1[i] = d1[x]+k1[x][i];
				d2[i] = d2[x]+k2[x][i];
				if(!v[i])Q.push(i),v[i] = true;
			}else if(d1[x]+k1[x][i]>d1[i])continue;
			else if(d2[x]+k2[x][i]<d2[i])
			{
				d2[i] = d2[x]+k2[x][i];
				if(!v[i])Q.push(i),v[i] = true;
			}
		}
	}
}
int main()
{
	memset(k1,0x3f,sizeof(k1));
	memset(k2,0x3f,sizeof(k2));
	INF = k1[0][0];
	int s,t,m;
	scanf("%d%d%d",&s,&t,&m);
	for(int i = 1;i<= m;i++)
	{
		int cost,len;
		scanf("%d%d",&cost,&len);
		for(int j = 1;j<= len;j++)
		{
			scanf("%d",&city[j]);
			n = max(n,city[j]);
		}
		for(int j = 1;j<= len;j++)
			for(int k = j+1;k<= len;k++)
			{
				if(k1[city[j]][city[k]]==cost)
					k2[city[j]][city[k]] = min(k2[city[j]][city[k]],k-j);
				if(k1[city[j]][city[k]]>cost)
				{
					k1[city[j]][city[k]] = cost;
					k2[city[j]][city[k]] = k-j;
				}
			}
	}
	spfa(s);
	if(d1[t]!=INF)printf("%lld %d\n",d1[t],d2[t]);
	else printf("-1 -1\n");
	return 0;
}
Problem3890

#include <stdio.h>
#include <queue>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
struct E
{int next,to,val1,val2;}e[N*N];
int head[N],tot;
int d[N];
void add(int x,int y,int f1,int f2)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val1 = f1;
	e[tot].val2 = f2;
	head[x] = tot;
}
bitset<10005>f[N],g[N];
queue<int>Q;
int main()
{
	int n,m,x,y,u,v;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&v);
		add(x,y,u,v);
		d[y]++;
	}
	for(int i = 1;i<= n;i++)
		if(!d[i])
			Q.push(i);
	f[1] = g[1] = 1;
	while(!Q.empty())
	{
		x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
		{
			f[e[i].to]|=f[x]<<e[i].val1;
			g[e[i].to]|=g[x]<<e[i].val2;
			if(!--d[e[i].to])
				Q.push(e[i].to);
		}
	}
	for(int i = 1;i<= 10000;i++)
		if(f[n][i]&&g[n][i])
		{
			printf("%d\n",i);
			return 0;
		}
	printf("IMPOSSIBLE\n");
	return 0;
}
Problem3894

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 30005;
const int M = 1000005;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].flow = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].flow = 0;head[y] = tot;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[s] = 0;
	Q.push(s);
	int x;
	while(!Q.empty())
	{
		x = Q.front();Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].flow!=0)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_maxflow(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].flow!=0&&d[e[i].to]==d[s]+1)
		{
			int tof = get_maxflow(e[i].to,t,min(e[i].flow,last));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s] = -1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_maxflow(s,t,INF);
	return ans;
}
int id,n,m;
inline int getid(int x,int y)
{
	return (x-1)*m+y;
}
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
int main()
{
	int sum = 0,x;
	scanf("%d%d",&n,&m);
	id = n*m+1;
	int st = 0,end = id;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			add(0,getid(i,j),x);sum+=x;
		}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),id,x);sum+=x;
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			++id;
			scanf("%d",&x);
			add(0,id,x);sum+=x;
			add(id,getid(i,j),INF);
			for(int k = 0;k<4;k++)
			{
				int tx = i+dx[k],ty = j+dy[k];
				if(tx&&ty&&tx<=n&&ty<=m)add(id,getid(tx,ty),INF);
			}
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			++id;
			scanf("%d",&x);
			add(id,end,x);sum+=x;
			add(getid(i,j),id,INF);
			for(int k = 0;k<4;k++)
			{
				int tx = i+dx[k],ty = j+dy[k];
				if(tx&&ty&&tx<=n&&ty<=m)add(getid(tx,ty),id,INF);
			}
		}
	sum = sum-dinic(st,end);
	printf("%d\n",sum);
	return 0;
}
Problem3924

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct E
{int next,to,val;};
int pos[N],n,q;
namespace Tree
{
	E e[N<<1];
	int head[N],tot,dis[N],dep[N],fa[N],lg2[N<<1];
	int a[N<<1][20],cnt;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x]=tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y]=tot;e[tot].val = f;
	}
	void dfs(int x)
	{
		static int T=0;
		dep[x] = dep[fa[x]]+1;
		a[pos[x] = ++T][0] = dis[x];
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				dis[e[i].to] = dis[x]+e[i].val;
				dfs(e[i].to);
				a[++T][0] = dis[x];
			}
	}
	void init()
	{
		for(int i = 2;i<(N<<1);i++)
			lg2[i] = lg2[i>>1]+1;
		for(int j = 1;j<= 19;j++)
			for(int i = 1;i+(1<<(j-1))<=(n<<1);i++)
				a[i][j] = min(a[i][j-1],a[i+(1<<(j-1))][j-1]);
	}
	int getlca(int x,int y)
	{
		int l = pos[x],r = pos[y];
		if(l>r)swap(l,r);
		int lth = lg2[r-l+1];
		return min(a[l][lth],a[r-(1<<lth)+1][lth]);
	}
	int getdis(int x,int y)
	{
		return dis[x]+dis[y]-2*getlca(x,y);
	}
};
namespace New_Tree
{
	E e[N<<1];
	int head[N],tot,fa[N];
	ll dis_sum1[N],dis_sum2[N],sum1[N],sum2[N],ROOT;
	void add(int x,int y,int z)
	{
		e[++tot].to = y;
		e[tot].val = z;
		e[tot].next = head[x];
		head[x] =tot;
	}
	int root,sum,f[N],size[N];
	bool used[N];
	void get_root(int x,int pre)
	{
		size[x] = 1;
		f[x] =0;
		for(int i = Tree::head[x];i;i=Tree::e[i].next)
			if(Tree::e[i].to!=pre&&!used[Tree::e[i].to])
			{
				get_root(Tree::e[i].to,x);
				size[x]+=size[Tree::e[i].to];
				f[x] = max(f[x],size[Tree::e[i].to]);
			}
		f[x] = max(f[x],sum-size[x]);
		if(f[x]<f[root])root = x;
	}
	void work(int x)
	{
		used[x] = true;
		for(int i = Tree::head[x];i;i=Tree::e[i].next)
		{
			int to = Tree::e[i].to;
			if(used[to])continue;
			sum = size[to],root = 0;
			get_root(to,0);
			fa[root] = x;
			add(x,root,to);
			work(root);
		}
	}
	void update(int x,int y)
	{
		sum1[x]+=y;
		for(int i = x;fa[i];i=fa[i])
		{
			int dis = Tree::getdis(x,fa[i]);
			dis_sum1[fa[i]]+=(ll)dis*y;
			dis_sum2[i]+=(ll)dis*y;
			sum1[fa[i]]+=y;
			sum2[i]+=y;
		}
		return ;
	}
	ll calc(int x)
	{
		ll ans = dis_sum1[x];
		for(int i = x;fa[i];i=fa[i])
		{
			int dis = Tree::getdis(x,fa[i]);
			ans+=dis_sum1[fa[i]]-dis_sum2[i];
			ans+=(sum1[fa[i]]-sum2[i])*dis;
		}
		return ans;
	}
	ll getans(int x)
	{
		ll cst = calc(x);
		for(int i = head[x];i;i=e[i].next)
		{
			ll tmp = calc(e[i].val);
			if(tmp<cst)
				return getans(e[i].to);
		}
		return cst;
	}
};
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		Tree::add(x,y,c);
	}
	Tree::dfs(1);
	Tree::init();
	New_Tree::f[0] = New_Tree::sum = n;
	New_Tree::root = 0;
	New_Tree::get_root(1,0);
	New_Tree::ROOT = New_Tree::root;
	New_Tree::work(New_Tree::root);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&x,&y);
		New_Tree::update(x,y);
		ll ans = New_Tree::getans(New_Tree::ROOT);
		printf("%lld\n",ans);
	}
	return 0;
}
Problem3925

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<10;
typedef long long ll;
double f[50][N],g[50][N];
int sz[N],cnt[N];
ll c[50][50];
int e[11];
int main()
{
	int n,m,u,v;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&u,&v);
		u--,v--;
		e[u]|=1<<v;
		e[v]|=1<<u;
	}
	c[0][0] = 1;
	for(int i = 1;i<50;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<50;j++)
			c[i][j] = c[i-1][j-1]+c[i-1][j];
	}
	for(int s = 1;s<1<<n;s++)
	{
		sz[s] = sz[s>>1]+(s&1);
		if(sz[s]==1)
		{
			g[0][s] = 1;
			continue;
		}
		for(int i = 0;i<n;i++)
			if(s&(1<<i))
				cnt[s]+=sz[s&e[i]];
		cnt[s]/=2;
		int lb = s&(-s);
		for(int k = (s-1)&s;k;k = s&(k-1))
			if(k&lb)
				for(int i = 0;i<=cnt[k];i++)
					for(int j = 0;j<=cnt[s^k];j++)
						f[i+j][s]+=g[i][k]*c[cnt[s^k]][j];
		for(int i = 0;i<=cnt[s];i++)
			g[i][s] = c[cnt[s]][i]-f[i][s];
	}
	double ans = 0;
	int end = (1<<n)-1;
	for(int i = 0;i<= m;i++)
		ans+=(double)f[i][end]/(double)c[cnt[end]][i];
	ans/=(double)(m+1);
	printf("%.6lf\n",ans);
	return 0;
}
Problem3926

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 4e6+5;
struct E
{int next,to;};
E e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int ch[M][10],fa[M],len[M],last,cnt;
int insert(int p,int x)
{
	int np = ++cnt,q,nq;
	last = np,len[np] = len[p]+1;
	for(;p&&!ch[p][x];p = fa[p])ch[p][x] = np;
	if(!p)fa[np] = 1;
	else
	{
		q = ch[p][x];
		if(len[q]==len[p]+1)fa[np] = q;
		else
		{
			fa[nq=++cnt] = fa[q];
			len[nq] = len[p]+1;
			memcpy(ch[nq],ch[q],sizeof(ch[q]));
			fa[np] = fa[q] = nq;
			for(;p&&ch[p][x]==q;p=fa[p])ch[p][x]=nq;
		}
	}
	return last;
}
long long ans;
void solve()
{
	for(int i=1;i<= cnt;i++)
		ans+=len[i]-len[fa[i]];
}
int id[N],val[N],ind[N];
void dfs(int x,int f,int p)
{
	int t = insert(p,val[x]);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x,t);
}
int main()
{
	int n,c,x,y;
	scanf("%d%d",&n,&c);
	for(int i = 1;i<= n;i++)scanf("%d",&val[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
		ind[x]++,ind[y]++;
	}
	id[0] = 1;
	cnt = 1;
	for(int i = 1;i<= n;i++)
		if(ind[i]==1)
			dfs(i,0,1);
	solve();
	printf("%lld\n",ans);
	return 0;
}
Problem3930

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
int d[2*N];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int main()
{
	ll n,k,a,b;
	scanf("%lld%lld%lld%lld",&n,&k,&a,&b);
	ll l = a/k,r=b/k;
	if(a%k)l++;
	for(int i = N-5;i>=1;i--)
	{
		ll L = l/i,R = r/i;
		if(l%i)L++;
		if(l<=r)
		{
			d[i]=quick_pow(R-L+1,n%(mod-1));
			d[i]=(d[i]-(R-L+1)+mod)%mod;
			for(int j = i*2;j<N;j+=i)
				d[i]=(d[i]-d[j]+mod)%mod;
		}
	}
	if(l==1)d[1] = (d[1]+1)%mod;
	printf("%d\n",d[1]);
	return 0;
}
Problem3931

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1005;
const int M = 500005;
const ll INF = 1e18;
const int inf = 0x3f3f3f3f;
struct E
{int next,to;ll f;};
ll dis[N];
int d[N];
bool v[N];
queue<int>Q;
struct G
{
	int head[N],tot;
	E e[M];
	void addE(int x,int y,int z)
	{e[++tot].to=y;e[tot].next = head[x];head[x]=tot;e[tot].f=z;}
	void addF(int x,int y,ll f)
	{
		e[++tot].to=y;e[tot].next=head[x];e[tot].f=f;head[x]=tot;
		e[++tot].to=x;e[tot].next=head[y];e[tot].f=0;head[y]=tot;
	}
	void spfa(int s,int n)
	{
		for(int i = 1;i<= n;i++)dis[i]=INF;
		dis[s]=0;v[s]=true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i=e[i].next)
				if(dis[x]+e[i].f<dis[e[i].to])
				{
					dis[e[i].to]=dis[x]+e[i].f;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to]=true;
					}
				}
		}
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[t]=0;
		Q.push(t);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(d[e[i].to]==-1&&e[i^1].f)
				{
					d[e[i].to] = d[x]+1;
					Q.push(e[i].to);
				}
		}
		return d[s]!=-1;
	}
	ll get_maxflow(int s,int t,ll mf)
	{
		if(s==t)return mf;
		ll last = mf;
		for(int i = head[s];i;i=e[i].next)
			if(d[e[i].to]==d[s]-1&&e[i].f)
			{
				ll tof = get_maxflow(e[i].to,t,min(e[i].f,last));
				if(tof)
				{
					e[i].f-=tof;
					e[i^1].f+=tof;
					if(!(last-=tof))return mf;
				}
			}
		d[s]=-1;
		return mf-last;
	}
	ll dinic(int s,int t)
	{
		ll ans=0,nowflow;
		while(bfs(s,t))
			while((nowflow=get_maxflow(s,t,INF)))
				ans+=nowflow;
		return ans;
	}
}F,G;
int c[N],x[M],y[M],z[M];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x[i],&y[i],&z[i]);
		G.addE(x[i],y[i],z[i]);
		G.addE(y[i],x[i],z[i]);
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	G.spfa(1,n);
	F.tot = 1;
	for(int i = 1;i<= m;i++)
	{
		if(dis[x[i]]+z[i]==dis[y[i]])
			F.addF(x[i]+n,y[i],INF);
		if(dis[y[i]]+z[i]==dis[x[i]])
			F.addF(y[i]+n,x[i],INF);
	}
	for(int i = 1;i<= n;i++)
		F.addF(i,i+n,c[i]);
	ll ans = F.dinic(n+1,n);
	printf("%lld\n",ans);
	return 0;
}
Problem3932

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
const int M = 4000005;
typedef long long ll;
int ls[M],rs[M],sum[M],ans[M];
int root[N],n,m;
int a[N];
int st[N],ed[N],cnt;
struct P
{int val,id;}T[N];
bool cmpT(P a,P b){return a.val<b.val;}
struct Up
{int pos,val,aa;}ask[N<<1];
int cnt_ask;
bool cmp(Up a,Up b){return a.pos<b.pos;}
int a_T[N];
void init()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d",&st[i],&ed[i],&a[i]);
		ask[++cnt_ask] = (Up){st[i],1,i};
		ask[++cnt_ask] = (Up){ed[i]+1,-1,i};
		T[i] = (P){a[i],i};
	}
	sort(T+1,T+n+1,cmpT);
	for(int i = 1;i<= n;i++)
		a_T[T[i].id] = i;
	sort(ask+1,ask+cnt_ask+1,cmp);
}
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	if(l==r)
	{
		sum[p]=sum[pre]+val;
		ans[p]=ans[pre]+val*T[l].val;
		return ;
	}
	int mid = (l+r)>>1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
	sum[p] = sum[ls[p]]+sum[rs[p]];
	ans[p] = ans[ls[p]]+ans[rs[p]];
}
ll Ans;
void getans(int p,int k)
{
	int l = 1,r = n;
	Ans = 0;
	p = root[p];
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(sum[ls[p]]>=k)
			p = ls[p],r = mid;
		else
			Ans+=ans[ls[p]],k-=sum[ls[p]],p = rs[p],l = mid+1;
	}
	Ans+=ans[p];
	printf("%lld\n",Ans);
}
int main()
{
	init();
	int j=1;
	for(int i = 1;i<= n;i++)
	{
		root[i] = root[i-1];
		while(j<=cnt_ask&&ask[j].pos==i)
		{
			update(root[i],root[i],1,n,a_T[ask[j].aa],ask[j].val);
			j++;
		}
	}
	int x,a,b,c,k;
	Ans=1;
	while(m--)
	{
		scanf("%d%d%d%d",&x,&a,&b,&c);
		k = ((ll)a*Ans+b)%c+1;
		//scanf("%d%d",&x,&k);
		getans(x,k);
	}
	return 0;
}
Problem3940

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define s(i) (s[i]-'a')
const int N = 1e5+5;
int ch[N][26],fail[N];
int sum[N],cnt;
char s[N];
void insert()
{
	int now = 0,i = 0;
	while(s[i])
	{
		if(!ch[now][s(i)])ch[now][s(i)] = ++cnt;
		now = ch[now][s(i)];
		i++;
	}
	sum[now]=i;
}
int q[N],h,t;
void build()
{
	h = 0,t = -1;
	for(int i = 0;i<26;i++)
		if(ch[0][i])
			q[++t]=ch[0][i];
	while(h<=t)
	{
		int x= q[h++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[fail[x]][i];
			if(ch[x][i])
			{
				fail[ch[x][i]] = j;
				q[++t]=ch[x][i];
			}else
				ch[x][i] = j;
		}
	}
}
char str[N],st1[N];
int st2[N],top;
int main()
{
	scanf("%s",str);
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s);
		insert();
	}
	build();
	int now = 0;
	for(int i = 0;str[i];i++)
	{
		st1[++top] = str[i];
		now = ch[now][str[i]-'a'];
		st2[top] = now;
		if(sum[now])
		{
			top-=sum[now];
			now = st2[top];
		}
	}
	for(int i = 1;i<= top;i++)printf("%c",st1[i]);
	return 0;
}
Problem3942

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
char A[N],B[N];
int fail[N],f[N],pos[N];
int main()
{
	scanf("%s",A+1);
	scanf("%s",B+1);
	int lenA = strlen(A+1),lenB = strlen(B+1);
	int j = 0;
	for(int i = 2;i<= lenB;i++)
	{
		while(B[i]!=B[j+1]&&j)
			j = fail[j];
		if(B[i]==B[j+1])j++;
		fail[i] = j;
	}
	for(int i = 1;i<= lenA;i++)
	{
		j = f[pos[pos[0]]];
		while(A[i]!=B[j+1]&&j)
			j = fail[j];
		if(A[i]==B[j+1])j++;
		if(j==lenB)pos[0]-=lenB-1;
		else {f[i] = j;pos[++pos[0]] = i;}
	}
	for(int i = 1;i<= pos[0];i++)
		printf("%c",A[pos[i]]);
	return 0;
}
Problem3944

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int M = 2e6+5;
const int N = 1e5+5;
const int m = 2e6;
bool v[M];
int prime[M],cnt,n;
ll mu[M],phi[M],p[N],q[N];
bool vis[N];
void quick_shai()
{
	phi[1] = mu[1] = 1;
	for(int i = 2;i<M;i++)
	{
		if(!v[i])
		{
			phi[i] = i-1;
			mu[i] = -1;
			prime[++cnt] = i;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<M;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])
			{
				mu[i*prime[j]] = -mu[i];
				phi[i*prime[j]] = phi[i]*(prime[j]-1);
			}else
			{
				mu[i*prime[j]] = 0;
				phi[i*prime[j]] = phi[i]*prime[j];
				break;
			}
		}
	}
	for(int i = 1;i<M;i++)
		phi[i]+=phi[i-1],mu[i]+=mu[i-1];
}
ll getp(int x)
{
	if(x<=m)return phi[x];
	else return p[n/x];
}
ll getq(int x)
{
	if(x<=m)return mu[x];
	else return q[n/x];
}
void solve(int x)
{
	if(x<=m)return ;
	int i,j = 1,t=n/x;
	if(vis[t])return ;
	vis[t] = true;
	p[t] = ((ll)x+1)*x/2;q[t] = 1;
	while(j<x)
	{
		i = j+1;
		j = x/(x/i);
		solve(x/i);
		q[t]-=getq(x/i)*(j-i+1);
		p[t]-=getp(x/i)*(j-i+1);
	}
}
int main()
{
	quick_shai();
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(vis,0,sizeof(vis));
		scanf("%d",&n);
		if(n<=m)printf("%lld %lld\n",phi[n],mu[n]);
		else
		{
			solve(1ll*n);
			printf("%lld %lld\n",p[1],q[1]);
		}
	}
	return 0;
}
Problem3963

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	int d,p,r,g,id;
	ll x,y;
	void read()
	{
		scanf("%d%d%d%d",&d,&p,&r,&g);
		x = g,y = r-p-(ll)d*g-g;
	}
}a[N],t[N];
struct Point
{
	ll x,y;
	Point(ll _x=0,ll _y=0):x(_x),y(_y){}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double operator *(const Point &a,const Point &b)
	{return (double)a.x*b.y-(double)a.y*b.x;}
}ch[N],p[N];
ll f[N];
inline bool cmp1(const data &a,const data &b)
{return a.d<b.d;}
inline bool cmp2(int i,int j)
{return a[i].x==a[j].x?a[i].y+f[a[i].id]<a[j].y+f[a[j].id]:a[i].x<a[j].x;}
inline ll Val(ll k,const Point &p){return k*p.x+p.y;}
void solve(int l,int r)
{
	if(l==r){f[l] = max(f[l-1],f[l]);return ;}
	int mid = (l+r)>>1;
	solve(l,mid);
	int n = 0,m = 0;
	for(int i = l;i<= mid;i++)if(f[a[i].id]>=a[i].p)
		p[++n] = Point(a[i].x,a[i].y+f[a[i].id]);
	for(int i = 1;i<= n;i++)
	{
		while(m>1&&(ch[m]-ch[m-1])*(p[i]-ch[m-1])>=0)m--;
		ch[++m] = p[i];
	}
	int j = 1;
	for(int i = mid+1;i<= r;i++)
	{
		while(j<m&&Val(a[i].d,ch[j+1])>=Val(a[i].d,ch[j]))j++;
		if(j<=m)f[i] = max(f[i],Val(a[i].d,ch[j]));
	}
	solve(mid+1,r);
	int p1 = l,p2 = mid+1;
	for(int i = l;i<=r;i++)
	{
		if(p2>r||(p1<=mid&&cmp2(p1,p2)))t[i]=a[p1++];
		else t[i] = a[p2++];
	}
	for(int i = l;i<= r;i++)a[i]=t[i];
}
int main()
{
	int n,d;
	int cas = 0;
	while(scanf("%d%lld%d",&n,&f[0],&d)!=EOF)
	{
		if(n==0&&f[0]==0&&d==0)break;
		for(int i = 1;i<= n;i++)a[i].read();
		a[++n].d = d+1;
		sort(a+1,a+n+1,cmp1);
		for(int i = 1;i<= n;i++)a[i].id = i,f[i] = 0;
		solve(1,n);
		printf("Case %d: %lld\n",++cas,f[n]);
	}
	return 0;
}
Problem3992

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MOD = 1004535809;
const int M = 16400;
const int G = 3;
int n,m,d,X,S;
int ind[M];
ll quick_pow(ll x,ll y,ll mod)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1,mod);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void NTT(int a[],int len,int type)
{
	static int tmp[M];
	if(len==1)return ;
	for(int i = 0;i<len;i+=2)
		tmp[i>>1] = a[i],tmp[(i+len)>>1]=a[i+1];
	memcpy(a,tmp,sizeof(a[0])*len);
	int *l = a,*r = a+(len>>1);
	NTT(l,len>>1,type);
	NTT(r,len>>1,type);
	ll w = quick_pow(G,(ll)type*(MOD-1)/len%(MOD-1),MOD),wn=1;
	for(int i = 0;i<(len>>1);i++,(wn*=w)%=MOD)
		tmp[i]=(l[i]+wn*r[i]%MOD)%MOD,tmp[i+(len>>1)]=((l[i]-wn*r[i]%MOD)%MOD+MOD)%MOD;
	memcpy(a,tmp,sizeof(a[0])*len);
	return ;
}
struct F
{
	int a[M];
	F(){}
	F(bool x)
	{
		memset(a,0,sizeof(a));
		a[0]=1;
	}
	int& operator[](int x)
	{
		return a[x];
	}
	F& operator*=(const F &s)
	{
		static int b[M];
		memcpy(b,s.a,sizeof(b));
		NTT(a,d,1);
		NTT(b,d,1);
		for(int i = 0;i<d;i++)
			a[i]=(ll)a[i]*b[i]%MOD;
		NTT(a,d,MOD-2);
		for(int i = m-1;i<= (m-2)<<1;i++)
			(a[i-(m-1)]+=a[i])%=MOD,a[i]=0;
		ll inv = quick_pow(d,MOD-2,MOD);
		for(int i=0;i<=m-2;i++)
			a[i]=a[i]*inv%MOD;
		return *this;
	}
}f;
int GPR()
{
	static int s[30];
	int x = m-1;
	for(int i = 2;i*i<=x;i++)
		if(x%i==0)
		{
			s[++s[0]]=i;
			while(x%i==0)x/=i;
		}
	if(x!=1)s[++s[0]]=x;
	for(int g = 2;;g++)
	{
		int j;
		for(j = 1;j<=s[0];j++)
			if(quick_pow(g,(m-1)/s[j],m)==1)
				break;
		if(j==s[0]+1)return g;
	}
}
F Quick_pow(F &a,int y)
{
	F re(true);
	while(y)
	{
		if(y&1)re*=a;
		a*=a,y>>=1;
	}
	return re;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&X,&S);
	for(d=1;d<=m+m;d<<=1);
	int g = GPR();
	for(int i = 0,x=1;i<m-1;i++,(x*=g)%=m)
		ind[x]=i;
	int x;
	for(int i = 1;i<= S;i++)
	{
		scanf("%d",&x);
		if(!x)continue;
		f[ind[x]] = 1;
	}
	F ans = Quick_pow(f,n);
	printf("%d\n",ans[ind[X]]);
	return 0;
}
Problem3995

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6e4+5;
int a[N][2],b[N],n,m;
struct data
{
	int l,r,sum;
	int mx,cnt;
	int lmx,rmx,lv,rv;
	data(){}
	data(int pos)
	{
		int x = b[pos];
		l = r = pos;
		sum = x;
		mx = 0,cnt=1;
		lmx=rmx=lv=rv=x;
	}
	friend data operator+(const data &x,const data &y)
	{
		data res;
		res.l = x.l,res.r = y.r;
		res.mx = max(max(a[x.r][0],a[x.r][1]),max(x.mx,y.mx));
		int max_val = max(max(a[x.r][0],a[x.r][1]),max(x.rmx,y.lmx));
		res.sum = x.sum+y.sum+a[x.r][0]+a[x.r][1]-max_val;
		res.cnt = x.cnt+y.cnt;
		res.lv = x.lv,res.rv = y.rv;
		res.lmx = x.lmx,res.rmx = y.rmx;
		if(x.rv==max_val)
		{
			res.cnt--;
			if(x.cnt==1)
			{
				res.lv = y.lv;
				res.lmx = max(max(x.mx,y.lmx),max(a[x.r][0],a[x.r][1]));
			}
		}else if(y.lv==max_val)
		{
			res.cnt--;
			if(y.cnt==1)
			{
				res.rv = x.rv;
				res.rmx = max(max(y.mx,x.rmx),max(a[x.r][0],a[x.r][1]));
			}
		}
		return res;
	}
}tr[N<<3];
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p] = data(l);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
void update1(int p,int l,int r,int pos)
{
	if(l==r)
	{
		tr[p] = data(l);
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update1(p<<1,l,mid,pos);
	else update1(p<<1|1,mid+1,r,pos);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
void update2(int p,int l,int r,int pos)
{
	int mid = (l+r)>>1;
	if(mid==pos)
	{
		tr[p] = tr[p<<1]+tr[p<<1|1];
		return ;
	}
	if(pos<=mid)
		update2(p<<1,l,mid,pos);
	else update2(p<<1|1,mid+1,r,pos);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
data getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans(p<<1|1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans(p<<1|1,mid+1,r,a,b);
}
void update(int x0,int y0,int x1,int y1,int z)  
{  
    if(y0==y1)//修改了一条竖边  
    {  
        b[y0]=z;  
        update1(1,1,n,y0);  
    }  
    else//修改了一条横边  
    {  
        if(y0>y1) swap(y0,y1);  
        a[y0][x0-1]=z; 
        update2(1,1,n,y0); 
    }  
}  
int main()
{
	scanf("%d%d",&n,&m);
	for(int j = 0;j<2;j++)
		for(int i = 1;i<= n-1;i++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);
	build(1,1,n);
	char opt[3];
	int x0,y0,x1,y1,w;
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='C')
		{
			scanf("%d%d%d%d%d",&x0,&y0,&x1,&y1,&w);
			update(x0,y0,x1,y1,w);
		}else
		{
			scanf("%d%d",&x0,&y0);
			data ans = getans(1,1,n,x0,y0);
			printf("%d\n",ans.sum);
		}
	}
	return 0;
}
Problem3996

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 4e6+5;
const int INF = 0x3f3f3f3f;
struct F
{int next,to,flow;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to=y;e[tot].next=head[x];e[tot].flow=f;head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];e[tot].flow=0;head[y]=tot;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t]=0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i=head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].flow)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].flow)
		{
			int tof = get_mf(e[i].to,t,min(last,e[i].flow));
			if(tof)
			{
				e[i].flow-=tof;
				e[i^1].flow+=tof;
				if(!(last-=tof))return mf;
			}
		}
	d[s]=-1;
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0,nf;
	while(bfs(s,t))
		while((nf=get_mf(s,t,INF)))
			ans+=nf;
	return ans;
}
int main()
{
	int n,x,sum=0;
	scanf("%d",&n);
	int st = 0,end = n*n+n+1,id = n;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
		{
			id++;
			scanf("%d",&x);
			add(i,id,INF),add(j,id,INF);
			add(id,end,x);
			sum+=x;
		}
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		add(st,i,x);
	}
	printf("%d\n",sum-dinic(st,end));

	return 0;
}
Problem4001

#include <stdio.h>
int main()
{
	double x;
	scanf("%lf",&x);
	printf("%.9lf",x*(x+1)/2/(2*x-1));
}
Problem4002

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ll;
const ll mod = 7528443412579576937ll;
ll quick_plus(ll x,ll y)
{
	if(y==0)return 0;
	ll tmp = quick_plus(x,y>>1);
	if(y&1)return ((tmp+tmp)%mod+x)%mod;
	else return (tmp+tmp)%mod;
}
struct Matrix
{
	ll d[2][2];
	Matrix(){memset(d,0,sizeof(d));}
	void operator*=(const Matrix &s)
	{
		Matrix res;
		for(int i = 0;i<2;i++)for(int k = 0;k<2;k++)if(d[i][k])
			for(int j = 0;j<2;j++)
				(res.d[i][j]+=quick_plus(d[i][k],s.d[k][j]))%=mod;
		*this = res;
	}
	friend Matrix quick_pow(Matrix x,ll y)
	{
		Matrix ans;
		for(int i = 0;i<2;i++)ans.d[i][i]=1;
		while(y)
		{
			if(y&1)ans*=x;
			x*=x;
			y>>=1;
		}
		return ans;
	}
}a;
int main()
{
	ll b,d,n;
	scanf("%llu%llu%llu",&b,&d,&n);
	a.d[0][0] = 0;
	a.d[1][0] = 1;
	a.d[0][1] = (d-b*b)/4;
	a.d[1][1] = b;
	Matrix ans = quick_pow(a,n);
	ll Ans = (quick_plus(ans.d[0][0],2)+quick_plus(ans.d[1][0],b))%mod;
	Ans = Ans-(b!=d*d&&(~n&1));
	printf("%llu\n",(Ans+mod)%mod);
	return 0;
}
Problem4003

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
typedef long long ll;
const ll INF = 1e18;
int root[N],fa[N],d[N],a[N],death[N],ans[N];
ll h[N],v[N];
struct Merge_Heap
{
	#define ls son[p][0]
	#define rs son[p][1]
	int son[N][2],cnt;
	int id[N],level[N],exper[N];ll val[N],add[N],mul[N];
	void Push_down(int p)
	{
		if(mul[p]!=1)
		{
			val[p] = val[p]*mul[p];
			mul[ls]*=mul[p],mul[rs]*=mul[p];
			add[ls]*=mul[p],add[rs]*=mul[p];
			mul[p] = 1;
		}
		if(add[p])
		{
			val[p] = val[p]+add[p];
			add[ls]+=add[p],add[rs]+=add[p];
			add[p] = 0;
		}
		if(exper[p])
		{
			level[p]+=exper[p];
			exper[ls]+=exper[p],exper[rs]+=exper[p];
			exper[p] = 0;
		}
	}
	int merge(int x,int y)
	{
		if(!x||!y)return x+y;
		Push_down(x),Push_down(y);
		if(val[x]>val[y])swap(x,y);
		int tmp = rand()&1;
		son[x][tmp] = merge(son[x][tmp],y);
		return x;
	}
	void init(int p,ll _val,int _id)
	{
		++cnt;
		val[cnt] = _val,id[cnt] = _id;
		mul[cnt] = 1,add[cnt] = 0;
		root[p] = merge(root[p],cnt);
	}
	void Fight(int k)
	{
		for(int p = root[k];p;p=root[k])
		{
			Push_down(p);
			if(val[p]>=h[k])return ;
			ans[id[p]] = level[p];
			death[k]++;
			root[k] = merge(ls,rs);
		}
	}
	void Go(int k)
	{
		Push_down(root[k]);
		if(a[k])mul[root[k]]=v[k];
		else add[root[k]]=v[k];
		exper[root[k]]++;
		root[fa[k]] = merge(root[fa[k]],root[k]);
	}
}mh;
int stack[N],top;
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lld",&h[i]);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d%lld",&fa[i],&a[i],&v[i]);
		d[fa[i]]++;
	}
	int s;ll c;
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%d",&c,&s);
		mh.init(s,c,i);
	}
	d[0] = 1,h[0] = INF;
	for(int i = 1;i<= n;i++)if(!d[i])stack[++top]=i;
	while(top)
	{
		int x = stack[top];
		top--;
		mh.Fight(x);
		if(x)
		{
			mh.Go(x);
			d[fa[x]]--;
			if(!d[fa[x]])stack[++top]=fa[x];
		}
	}
	for(int i = 1;i<= n;i++)
		printf("%d\n",death[i]);
	for(int i = 1;i<= m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4004

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
typedef long long ll;
const int mod = 1e9+7;
int b[N];
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
struct P
{
	int a[N];
	int val;
	bool operator <(const P &s)const
	{
		return val<s.val;
	}
}p[N];

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			scanf("%d",&p[i].a[j]);
	for(int i = 1;i<= n;i++)scanf("%d",&p[i].val);
	sort(p+1,p+n+1);
	int ans = 0,ansv = 0;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(p[i].a[j])
			{
				if(!b[j])
				{
					b[j] = i;
					ans++;
					ansv+=p[i].val;
					break;
				}else
				{
					int tmp = (ll)p[i].a[j]*quick_pow(p[b[j]].a[j],mod-2)%mod;
					for(int k = j;k<= m;k++)
						p[i].a[k]=(p[i].a[k]-(ll)p[b[j]].a[k]*tmp%mod+mod)%mod;
				}
			}
	printf("%d %d\n",ans,ansv);
	return 0;
}
Problem4006

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<10;
const int N = 1005;
const int M = 6005;
const int P = 15;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
int head[N],tot,cnt,n,m,p;
void add(int x,int y,int f)
{
    e[++tot].to = y;
    e[tot].next = head[x];
    e[tot].val = f;
    head[x] = tot;
    e[++tot].to = x;
    e[tot].next = head[y];
    e[tot].val = f;
    head[y] = tot;
}
struct Point{int c,d;}po[P];
bool cmp(Point a,Point b){return a.c<b.c;}
int dis[S][N];
int g[S];
int Q[65540];
unsigned short l,r;
bool v[N];
void spfa(int dis[])
{
    while(l!=r)
    {
        int x = Q[l];
        l++;
        v[x] = false;
        for(int i = head[x];i;i = e[i].next)
        {
            if(dis[x]+e[i].val<dis[e[i].to])
            {
                dis[e[i].to] = dis[x]+e[i].val;
                if(!v[e[i].to])
                {
                    v[e[i].to] = true;
                    Q[r++] = e[i].to;
                }
            }
        }
    }
}
int DP()
{
    l = 1,r = 1;
    for(int i = 1;i<1<<cnt;i++)
    {
        //memset(v,0,sizeof(v));
        for(int j = 1;j<= n;j++)
        {
            for(int k = i&(i-1);k;k = (k-1)&i)
                dis[i][j] = min(dis[k][j]+dis[i^k][j],dis[i][j]);
            if(dis[i][j]!=INF){Q[r++] = j;v[j] = true;}
        }
        spfa(dis[i]);
    }
    int ans = INF;
    for(int i = 1;i<= n;i++)
        ans = min(ans,dis[(1<<cnt)-1][i]);
    return ans;
}
int main()
{
    int x,y,z;
    scanf("%d%d%d",&n,&m,&p);
    for(int i = 1;i<= m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
    }
    for(int i = 1;i<= p;i++)
        scanf("%d%d",&po[i].c,&po[i].d);
    int col = 0;
    int true_col[20]={};
    sort(po+1,po+p+1,cmp);
    for(int i=1;i<=p;i++)
    {
        if(i==1||po[i].c!=po[i-1].c)
            ++col;
        true_col[i]=col;
    }
    for(int i=1;i<=p;i++)
        po[i].c = true_col[i];
    memset(g,0x3f,sizeof(g));
    int end = 1<<col;
    for(int i = 0;i<end;i++)
    {
        cnt = 0;
        for(int j = 1;j<= p;j++)
            if(i&(1<<(po[j].c-1)))
                cnt++;
        memset(dis,0x3f,sizeof(dis[0][0])*N*(1<<cnt));
        cnt = 0;
        for(int j = 1;j<= p;j++)
            if(i&(1<<(po[j].c-1)))
                dis[1<<cnt++][po[j].d] = 0;
        g[i] = DP();
    }
    for(int i=1;i<end;i++)
        for(int j=i&(i-1);j;j = (j-1)&i)
            g[i]=min(g[i],g[j]+g[i^j]);
    printf("%d\n",g[(1<<col)-1]);
    return 0;
}
Problem4007

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = (1<<10)+5;
int dp[N][N],w[N][12],f[N][12],n,m;
void dfs(int x,int y,int sta,int cnt)
{
	for(int i = 0;i<= cnt;i++)dp[x][i] = 0;
	if(y==n-1)
	{
		for(int i = 0;i<y;i++)
			if(sta&(1<<i))dp[x][1]+=w[x-(1<<y)][i];
			else dp[x][0]+=f[x-(1<<y)][i];
		return ;
	}
	dfs(x<<1,y+1,sta,cnt>>1),dfs(x<<1|1,y+1,sta,cnt>>1);
	for(int i = 0;i<= cnt>>1;i++)
		for(int j = 0;j<= cnt>>1;j++)
			dp[x][i+j]=max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
	dfs(x<<1,y+1,sta|(1<<y),cnt>>1),dfs(x<<1|1,y+1,sta|(1<<y),cnt>>1);
	for(int i = 0;i<= cnt>>1;i++)
		for(int j = 0;j<= cnt>>1;j++)
			dp[x][i+j]=max(dp[x][i+j],dp[x<<1][i]+dp[x<<1|1][j]);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i< 1<<(n-1);i++)
		for(int j = n-2;j>=0;j--)
			scanf("%d",&w[i][j]);
	for(int i = 0;i< 1<<(n-1);i++)
		for(int j = n-2;j>=0;j--)
			scanf("%d",&f[i][j]);
	dfs(1,0,0,1<<(n-1));
	int ans = 0;
	for(int i = 0;i<= m;i++)ans = max(ans,dp[1][i]);
	printf("%d\n",ans);
}
Problem4008

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 220+5;
const int R = 132+5;
double f[N][R],Pow[N][R];
double p[N];
int w[N];
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		memset(f,0,sizeof(f));
		memset(Pow,0,sizeof(Pow));
		int n,r;
		scanf("%d%d",&n,&r);
		for(int i = 1;i<= n;i++)
			scanf("%lf%d",&p[i],&w[i]);
		for(int i = 1;i<= n;i++)
		{
			Pow[i][0] = 1;
			for(int j = 1;j<=r;j++)
				Pow[i][j] = Pow[i][j-1]*(1.0-p[i]);
		}
		f[0][r] = 1;
		double ans = 0;
		for(int i = 0;i<n;i++)
		{
			for(int j = 0;j<=r;j++)
			{
				f[i+1][j] += f[i][j]*Pow[i+1][j];
				if(j-1>=0)
				{
					f[i+1][j-1] += f[i][j]*(1.0-Pow[i+1][j]);
					ans += f[i][j]*(1.0-Pow[i+1][j])*w[i+1];
				}
			}
		}
		printf("%.10f\n",ans);
	}
	return 0;
}
Problem4009

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,fa[N][20];
struct Plate
{int xd,xu,yd,yu,v;}plate[N];
struct Event
{int x,yd,yu,v,id;}event[N];
struct Poi
{int x,y,k,id;}poi[N],tmp1[N],tmp2[N];
bool operator <(Plate a,Plate b){return a.v<b.v;}
bool operator <(Event a,Event b){return a.x==b.x?a.id<b.id:a.x<b.x;}
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int last[N],dfn[N],dep[N],cnt,n,m,q,Cnt;
void dfs(int x,int f)
{
	dfn[x] = ++cnt;
	dep[x] = dep[f]+1;
	fa[x][0] = f;
	for(int i= head[x];i;i=e[i].next)
		if(e[i].to!=f)
			dfs(e[i].to,x);
	last[x] = cnt;
}
void init()
{
	for(int j = 1;j<= 18;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 18;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 18;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int jump(int x,int h)
{
	for(int j = 18;j>= 0;j--)
		if(h>=(1<<j))
			x = fa[x][j],h-=(1<<j);
	return x;
}
struct Tree
{
	int val[N];
	void update(int l,int r,int x)
	{
		for(int i = l;i<N;i+=i&(-i))
			val[i]+=x;
		for(int i = r+1;i<N;i+=i&(-i))
			val[i]-=x;
	}
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i>0;i-=i&(-i))
			ans+=val[i];
		return ans;
	}
}T;
int ans[N],sum[N];
void solve(int l,int r,int st,int ed)
{
	if(ed<st)return ;
	if(l==r)
	{
		for(int i = st;i<= ed;i++)
			ans[poi[i].id] = plate[l].v;
		return ;
	}
	int mid = (l+r)>>1,siz=0;
	for(int i = l;i<= mid;i++)
	{
		event[++siz]=(Event){plate[i].xd,plate[i].yd,plate[i].yu,1,0};
		event[++siz]=(Event){plate[i].xu,plate[i].yd,plate[i].yu,-1,n+1};
	}
	for(int i = st;i<=ed;i++)
		event[++siz]=(Event){poi[i].x,poi[i].y,0,0,i};
	sort(event+1,event+siz+1);
	for(int i = 1;i<= siz;i++)
		if(event[i].id>=st&&event[i].id<=ed)
			sum[event[i].id]=T.getans(event[i].yd);
		else T.update(event[i].yd,event[i].yu,event[i].v);
	int a = 0,b = 0;
	for(int i = st;i<=ed;i++)
		if(sum[i]>=poi[i].k)tmp1[++a] = poi[i];
		else tmp2[++b] = (Poi){poi[i].x,poi[i].y,poi[i].k-sum[i],poi[i].id};
	for(int i = st;i<= st+a-1;i++)poi[i]=tmp1[i-st+1];
	for(int i = st+a;i<= ed;i++)poi[i] = tmp2[i-st-a+1];
	solve(l,mid,st,st+a-1),solve(mid+1,r,st+a,ed);
}
int main()
{
	int x,y,z,lca;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	init();
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		lca = getlca(x,y);
		if(dfn[x]>dfn[y])swap(x,y);
		if(lca!=x)plate[++Cnt] = (Plate){dfn[x],last[x],dfn[y],last[y],z};
		else
		{
			int t = jump(y,dep[y]-dep[x]-1);
			plate[++Cnt]=(Plate){1,dfn[t]-1,dfn[y],last[y],z};
			if(last[t]<n)
				plate[++Cnt]=(Plate){dfn[y],last[y],last[t]+1,n,z};
		}
	}
	sort(plate+1,plate+Cnt+1);
	for(int i =1;i<=q;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(dfn[x]>dfn[y])swap(x,y);
		poi[i]=(Poi){dfn[x],dfn[y],z,i};
	}
	solve(1,Cnt,1,q);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4010

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to;}e[N];
int head[N],tot,deg[N],n,m;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	deg[y]++;
}
int ans[N],top,heap[N],cnt;
void topo()
{
	for(int i = n;i>=1;i--)
		if(!deg[i])
			heap[++cnt] = i;
	while(cnt)
	{
		int x = heap[1];
		ans[++top] = x;
		pop_heap(heap+1,heap+cnt+1);
		cnt--;
		for(int i = head[x];i;i=e[i].next)
			if(!(--deg[e[i].to]))
				heap[++cnt] = e[i].to,push_heap(heap+1,heap+cnt+1);
	}
}
void init()
{
	memset(head,0,sizeof(head));
	tot = 0;
	memset(deg,0,sizeof(deg));
	cnt = top = 0;
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		scanf("%d%d",&n,&m);
		int x,y;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(y,x);
		}
		topo();
		if(top!=n)printf("Impossible!\n");
		else
		{
			for(int i = n;i>= 1;i--)
				printf("%d ",ans[i]);
			printf("\n");
		}
	}
	return 0;
}
Problem4011

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
int deg[N],tdeg[N],invdeg[N],n,m,s,t;
ll ans;
void init()
{
	for(int i = 1;i<= n;i++)
		invdeg[i] = quick_pow(deg[i],mod-2);
}
queue<int>Q;
ll f[N];
void topo()
{
	f[t] = ans;
	for(int i = 1;i<= n;i++)
		if(!tdeg[i])
			Q.push(i);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		f[x] = (ll)f[x]*invdeg[x]%mod;
		for(int i = head[x];i;i=e[i].next)
		{
			(f[e[i].to]+=f[x])%=mod;
			if(!(--tdeg[e[i].to]))
				Q.push(e[i].to);
		}
	}
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&s,&t);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
		deg[y]++;
		tdeg[y]++;
	}
	deg[t]++;
	ans = 1;
	for(int i = 2;i<= n;i++)
		ans = ans*deg[i]%mod;
	if(t==1)
		printf("%lld\n",ans);
	else
	{
		init();
		topo();
		printf("%lld\n",(ans-f[s]+mod)%mod);
	}
	return 0;
}
Problem4012

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 150005;
typedef long long ll;
typedef vector<pair<int,ll> >P;
const ll INF = 1e18;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
bool ban[N<<1];
void init()
{
	memset(head,0,sizeof(head));
	memset(ban,0,sizeof(ban));
	tot = 1;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
bool used[N];
int size[N],f[N],sum,root;
void get_root(int x,int from)
{
	size[x] = 1;f[x] = 0;
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to]&&e[i].to!=from)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int a[N],fa[N],dis[N];
P sum1[N];
P sum2[N];
void get_dis(int x,int from,P &s1,P &s2,ll dis)
{
	s1.push_back(pair<int,ll>(a[x],dis));
	s2.push_back(pair<int,ll>(a[x],dis));
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to]&&e[i].to!=from)
			get_dis(e[i].to,x,s1,s2,dis+e[i].val);
}
int work(int x)
{
	used[x] = true;
	sum1[x].push_back(pair<int,ll>(a[x],0));
	for(int i = head[x];i;i = e[i].next)
		if(!used[e[i].to])
		{
			sum=size[e[i].to];
			root = 0;
			P tmp;
			get_dis(e[i].to,x,sum1[x],tmp,e[i].val);
			get_root(e[i].to,0);
			fa[root] = x;sum2[root] = tmp;
			sum2[root].push_back(pair<int,ll>(-1,0));
			sort(sum2[root].begin(),sum2[root].end());
			for(int j = 1;j<sum2[root].size();j++)
				sum2[root][j].second+=sum2[root][j-1].second;
			work(root);
		}
	sum1[x].push_back(pair<int,ll>(-1,0));
    sort(sum1[x].begin(),sum1[x].end());
    for(int j=1;j<sum1[x].size();j++)
        sum1[x][j].second+=sum1[x][j-1].second;
}
int pos[N],T,log_2[N<<1];
ll min_dpt[N<<1][20],dpt[N];
void DFS(int x,int from)
{
	min_dpt[pos[x]=++T][0] = dpt[x];
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=from)
		{
			dpt[e[i].to] = dpt[x]+e[i].val;
			DFS(e[i].to,x);
			min_dpt[++T][0] = dpt[x];
		}
}
void build_lca()
{
	for(int i = 2;i<=T;i++)
		log_2[i] = log_2[i>>1]+1;
	for(int j = 1;j<= log_2[T];j++)
		for(int i = 1;i+(1<<j)-1<=T;i++)
			min_dpt[i][j] = min(min_dpt[i][j-1],min_dpt[i+(1<<(j-1))][j-1]);
}
ll get_lcadpt(int x,int y)
{
	x = pos[x],y = pos[y];
	if(x>y)swap(x,y);
	int l = log_2[y-x+1];
	return min(min_dpt[x][l],min_dpt[y-(1<<l)+1][l]);
}
ll get_distance(int x,int y)
{
	return dpt[x]+dpt[y]-2*get_lcadpt(x,y);
}
ll sumv1,sumv2;int cnt1,cnt2;
int qurey1(const P &s,int x)
{
	int l = 0,r = s.size();
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(s[mid].first<=x)l = mid+1;
		else r = mid;
	}
	l--;
	if(l<0)l = 0;
	return l;
}
int qurey2(const P &s,int x)
{
	int l = 0,r = s.size();
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(s[mid].first<x)l = mid+1;
		else r = mid;
	}
	l--;
	if(l<0)l = 0;
	return l;
}
ll ans;
void qurey(int x,int i,int l,int r)
{
	int r1 = qurey1(sum1[fa[i]],r),l1 = qurey2(sum1[fa[i]],l);
	int r2 = qurey1(sum2[i],r),l2 = qurey2(sum2[i],l);
	ans+=sum1[fa[i]][r1].second-sum1[fa[i]][l1].second-sum2[i][r2].second+sum2[i][l2].second;
	ans+=(ll)(r1-l1-r2+l2)*get_distance(x,fa[i]);
}
void qurey(int x,int l,int r)
{
	ans = 0;
	int L = qurey2(sum1[x],l),R = qurey1(sum1[x],r);
	ans+=sum1[x][R].second-sum1[x][L].second;
	for(int i = x;fa[i];i = fa[i])
		qurey(x,i,l,r);
}
void debug1(int x)
{
	printf("%d\n",sum1[x].size());
	for(int i = 0;i<sum1[x].size();i++)
		printf("%d:%I64d ",sum1[x][i].first,sum1[x][i].second);
	printf("\n");
}
void debug2(int x)
{
	printf("%d\n",sum2[x].size());
	for(int i = 0;i<sum2[x].size();i++)
		printf("%d:%I64d ",sum2[x][i].first,sum2[x][i].second);
	printf("\n");
}
int main()
{
	int n,q,A;
	scanf("%d%d%d",&n,&q,&A);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int x,y,z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	DFS(1,0);
	build_lca();
	f[0] = sum = n;
	root = 0;
	get_root(1,0);
	work(root);
	ll last_ans = 0;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&z,&x,&y);
		x = (x+last_ans)%A;
		y = (y+last_ans)%A;
		if(x>y)swap(x,y);
		qurey(z,x,y);
		printf("%lld\n",last_ans = ans);
	}
	return 0;
}
Problem4013

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 405;
struct E
{int next,to;}e[N];
int head[N],tot,deg[N];
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	deg[y]++;
}
int fa[N],f[N][N],g[N],size[N],c[N][N];
bool vis[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
bool dfs(int x,int pre)
{
	vis[x] = true;
	bool flag = false;
	for(int i = head[x];i;i=e[i].next)if(e[i].to!=pre)
	{
		if(vis[e[i].to])return false;
		if(!dfs(e[i].to,x))return false;
		if(flag)
		{
			memset(g,0,sizeof(g));
			for(int j = 1;j<= size[x];j++)
				for(int k = 1;k<= size[e[i].to];k++)
					if(f[x][j]&&f[e[i].to][k])
					for(int I = max(j,k);I<=j+k;I++)
						(g[I]+=(ll)f[x][j]*f[e[i].to][k]%mod*c[j][j+k-I]%mod*c[I][j]%mod)%=mod;
			size[x]+=size[e[i].to];
			for(int I = 1;I<= size[x];I++)
				f[x][I] = g[I];
		}else
		{
			size[x]= size[e[i].to];
			flag = true;
			for(int I = 1;I<= size[x];I++)
				f[x][I] = f[e[i].to][I];
		}	
	}
	if(x)
	{
		size[x]++;
		if(flag)for(int i = size[x];i;i--)f[x][i] = f[x][i-1];
		else f[x][1] = 1;
	}
	return true;
}
void uni(int x,int y)
{
	x = getfa(x),y =getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
int X[N],Y[N];
int main()
{
	int n,m,x,y;
	char opt[3];
	scanf("%d%d",&n,&m);
	c[0][0]=1;
	for(int i = 1;i<= 400;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<= 400;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
	int cnt = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%s%d",&x,opt,&y);
		if(opt[0]=='=')
			uni(x,y);
		else
			X[++cnt] =x,Y[cnt] = y;
	}
	for(int i = 1;i<= cnt;i++)
	{
		x = getfa(X[i]),y = getfa(Y[i]);
		if(x==y){printf("0\n");return 0;}
		add(x,y);
	}
	for(int i=1;i<=n;i++)if(!deg[getfa(i)])add(0,getfa(i));
	if(!dfs(0,-1))return printf("0\n"),0;
	for(int i = 1;i<= n;i++)
		if(fa[i]==i&&!vis[i])return printf("0\n"),0;
	int ans = 0;
	for(int i = 1;i<= size[0];i++)ans=(ans+f[0][i])%mod;
	printf("%d\n",ans);
	return 0;
}
Problem4015

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define inf 0x1f1f1f1f
const int N = 210;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void clear()
{
	memset(head,0,sizeof(head));
	tot = 0;
}
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int q[N],fr,ta,fa[N],size[N];
vector <int> grav;
const int mod = 10007;
void Add(int &x,int y)
{
	if((x+=y)>=mod)
		x-=mod;
}
namespace solve1
{
	int f[N][N],g[N],fa[N],size[N];
	void dfs(int x)
	{
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				dfs(e[i].to);
				size[x]+=size[e[i].to];
			}
	}
	void dp(int x)
	{
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
				dp(e[i].to);
		f[x][1] = 1;
		memset(g,0,sizeof(g));
		g[0] = 1;
		for(int j = head[x];j;j=e[j].next)
			if(e[j].to!=fa[x])
				for(int k = size[x]-1;k>=0;k--)
					for(int i = 1;i<= size[e[j].to] && i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
		for(int i = 1;i<size[x];i++)
			f[x][i+1] = g[i];
	}
	void work(int root)
	{
		memset(fa,0,sizeof(fa));
		dfs(root);
		memset(f,0,sizeof(f));
		dp(root);
		int res = 0;
		for(int all = 1;all<= size[root];all++)
		{
			memset(g,0,sizeof(g));
			g[0] = 1;
			for(int j = head[root];j;j=e[j].next)
				for(int k = all-1;k>= 0;k--)
					for(int i = 1;i<=size[e[j].to]&&i*2<all&&i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
			Add(res,g[all-1]);
		}
		printf("%d\n",res);
	}
}

namespace solve2
{
	int f[N][N],g[N],size[N];
	void dp(int x,int fa)
	{
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa)
			{
				dp(e[i].to,x);
				size[x]+=size[e[i].to];
			}
		f[x][1] = 1;
		memset(g,0,sizeof(g));
		g[0] = 1;
		for(int j = head[x];j;j=e[j].next)
			if(e[j].to!=fa)
				for(int k = size[x]-1;k>=0;k--)
					for(int i = 1;i<= size[e[j].to]&&i<=k;i++)
						Add(g[k],g[k-i]*f[e[j].to][i]%mod);
		for(int i = 1;i<size[x];i++)
			f[x][i+1] = g[i];
	}
	void work(int r1,int r2)
	{
		memset(f,0,sizeof(f));
		dp(r1,r2),dp(r2,r1);
		int res = 0;
		for(int i = 1;i<= size[r1]&&i<= size[r2];i++)
			Add(res,f[r1][i]*f[r2][i]%mod);
		printf("%d\n",res);
	}
}
int main()
{
	//freopen("4015.in","r",stdin);
	//freopen("4015.out","w",stdout);
	int cas;
	scanf("%d",&cas);
	int n,a,b;
	for(int Cas = 1;Cas<= cas;Cas++)
	{
		printf("Case %d: ",Cas);
		clear();
		scanf("%d",&n);
		for(int i = 1;i<n;i++)
		{
			scanf("%d%d",&a,&b);
			add(a,b);
		}
		if(n<=2)puts("1");
		else
		{
			fr = 0;
			ta = -1;
			q[++ta] = 1;
			while(fr<=ta)
			{
				int x = q[fr++];
				for(int i = head[x];i;i=e[i].next)
					if(e[i].to!=fa[x])
					{
						fa[e[i].to] = x;
						q[++ta] = e[i].to;
					}
			}
			memset(size,0,sizeof(size));
			for(int i = ta;i>=0;i--)
				size[fa[q[i]]]+=++size[q[i]];
			size[0] = 0;
			grav.clear();
			int Min = inf,now;
			for(int i = 1;i<= n;i++)
			{
				now=n-size[i];
				for(int j = head[i];j;j=e[j].next)
					if(fa[e[j].to]==i)
						now = max(now,size[e[j].to]);
				if(now<Min)
				{
					Min = now;
					grav.clear();
					grav.push_back(i);
				}
				else if(now==Min)
					grav.push_back(i);
			}
			if(grav.size()==1)
				solve1::work(grav[0]);
			else
				solve2::work(grav[0],grav[1]);
		}
	}
	return 0;
}
Problem4016

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 6e4+5;
struct E
{int next,to,val;};
bool v[N],used[N];
int dis[N],f[N],size[N],dep[N],ft[N];
int F[N][2],G[N][2];
int sum,root,n,m,K,ans1,ans2;
struct Gragh
{
	E e[M<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val = f;
		head[x] = tot;
	}
	void spfa(int s)
	{
		queue<int>Q;
		memset(dis,0x3f,sizeof(dis));
		memset(v,0,sizeof(v));
		dis[s] = 0,v[s] = true;
		Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			v[x] = false;
			for(int i = head[x];i;i = e[i].next)
				if(dis[x]+e[i].val<dis[e[i].to])
				{
					dis[e[i].to] = dis[x]+e[i].val;
					if(!v[e[i].to])
					{
						Q.push(e[i].to);
						v[e[i].to] = true;
					}
				}
		}
	}
	void get_root(int x,int fa)
	{	
		size[x] = 1;f[x] = 0;
		for(int i = head[x];i;i = e[i].next)
			if(!used[e[i].to]&&e[i].to!=fa)
			{
				get_root(e[i].to,x);
				f[x] = max(f[x],size[e[i].to]);
				size[x]+=size[e[i].to];
			}
		f[x] = max(f[x],sum-size[x]);
		if(f[x]<=f[root])root = x;
	}
	void calc(int x)
	{
		queue<int>Q;
		for(int i = 1;i<= K;i++)
			G[i][0] = G[i][1] = F[i][0] = F[i][1] = 0;
		F[0][1] = 1;
		dep[x] = 0,dis[x] = 0;
		for(int i = head[x];i;i = e[i].next)
		{
			if(used[e[i].to])continue;
			dep[e[i].to] = dep[x]+1;dis[e[i].to] = e[i].val;
			ft[e[i].to] = x;
			if(e[i].val>G[dep[e[i].to]][0])
			{
				G[dep[e[i].to]][0] = e[i].val;
				G[dep[e[i].to]][1] = 1;
			}
			else if(e[i].val==G[dep[e[i].to]][0])
				G[dep[e[i].to]][1]++;
			Q.push(e[i].to);
			while(!Q.empty())
			{
				int tp = Q.front();
				Q.pop();
				if(dep[tp]>=K)continue;
				for(int j = head[tp];j;j = e[j].next)
					if(e[j].to!=ft[tp]&&!used[e[j].to])
					{
						ft[e[j].to] = tp;
						dep[e[j].to] = dep[tp]+1;
						dis[e[j].to] = dis[tp]+e[j].val;
						if(dis[e[j].to]>G[dep[e[j].to]][0])
							G[dep[e[j].to]][0] = dis[e[j].to],G[dep[e[j].to]][1] = 1;
						else if(G[dep[e[j].to]][0]==dis[e[j].to])G[dep[e[j].to]][1]++;
						Q.push(e[j].to);
					}
			}
			for(int j = 1;j<= K;j++)
			{
				if(F[K-j][0]+G[j][0]>ans1)
					{ans1 = F[K-j][0]+G[j][0];ans2 = F[K-j][1]*G[j][1];}
				else if(F[K-j][0]+G[j][0]==ans1)
					{ans2+=F[K-j][1]*G[j][1];}
			}
			for(int j = 1;j<= K;j++)
			{
				if(G[j][0]>F[j][0]){F[j][0] = G[j][0],F[j][1] = G[j][1];}
				else if(G[j][0]==F[j][0]){F[j][1]+=G[j][1];}
				G[j][0] = G[j][1] = 0;
			}
		}
	}
	void work(int x)
	{
		calc(x);
		used[x] = true;
		for(int i = head[x];i;i= e[i].next)
			if(!used[e[i].to])
			{
				root = 0;
				sum= size[e[i].to];
				get_root(e[i].to,0);
				if(size[root]>=K)
					work(root);
			}
	}
	void dis_edge()
	{
		for(int i = 1;i<= n;i++)
			for(int j = head[i];j;j = e[j].next)
				if(i<=e[j].to)
					printf("%d %d %d\n",i,e[j].to,e[j].val);
	}
}g,t;
void rebuild(int x)
{
	v[x] = true;
	for(int i = g.head[x];i;i = g.e[i].next)
	{
		int to = g.e[i].to;
		if(!v[to]&&dis[x]+g.e[i].val==dis[to])
		{
			t.add(x,to,g.e[i].val),t.add(to,x,g.e[i].val);
			rebuild(to);
		}
	}
}
struct Edge
{int u,v,w;}edge[M<<1];
bool cmp(const Edge &a,const Edge &b)
{
	if(a.u==b.u)
		return a.v>b.v;
	return a.u<b.u;
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	K--;
	for(int i=1;i<= m;i++)
	{
		scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
		edge[i+m] = edge[i];
		swap(edge[i].u,edge[i].v);
	}
	sort(edge+1,edge+2*m+1,cmp);
	for(int i = 1;i<= 2*m;i++)
		g.add(edge[i].u,edge[i].v,edge[i].w);
	g.spfa(1);
	memset(v,0,sizeof(v));
	rebuild(1);
	//t.dis_edge();
	f[0] = sum= n;
	t.get_root(1,0);
	t.work(root);
	printf("%d %d\n",ans1,ans2);
	return 0;
}
Problem4016

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 6e4+5;
struct E
{int next,to,val;};
bool v[N],used[N];
int dis[N],f[N],size[N],dep[N],ft[N];
int F[N][2],G[N][2];
int sum,root,n,m,K,ans1,ans2;
struct Gragh
{
    E e[M<<1];
    int head[N],tot;
    void add(int x,int y,int f)
    {
        e[++tot].to = y;
        e[tot].next = head[x];
        e[tot].val = f;
        head[x] = tot;
    }
    void spfa(int s)
    {
        queue<int>Q;
        memset(dis,0x3f,sizeof(dis));
        memset(v,0,sizeof(v));
        dis[s] = 0,v[s] = true;
        Q.push(s);
        while(!Q.empty())
        {
            int x = Q.front();
            Q.pop();
            v[x] = false;
            for(int i = head[x];i;i = e[i].next)
                if(dis[x]+e[i].val<dis[e[i].to])
                {
                    dis[e[i].to] = dis[x]+e[i].val;
                    if(!v[e[i].to])
                    {
                        Q.push(e[i].to);
                        v[e[i].to] = true;
                    }
                }
        }
    }
    void get_root(int x,int fa)
    {   
        size[x] = 1;f[x] = 0;
        for(int i = head[x];i;i = e[i].next)
            if(!used[e[i].to]&&e[i].to!=fa)
            {
                get_root(e[i].to,x);
                f[x] = max(f[x],size[e[i].to]);
                size[x]+=size[e[i].to];
            }
        f[x] = max(f[x],sum-size[x]);
        if(f[x]<=f[root])root = x;
    }
    void calc(int x)
    {
        queue<int>Q;
        for(int i = 0;i<= K;i++)
            G[i][0] = G[i][1] = F[i][0] = F[i][1] = 0;
        F[0][1] = 1;
        dep[x] = 0,dis[x] = 0;
        for(int i = head[x];i;i = e[i].next)
        {
            if(used[e[i].to])continue;
            dep[e[i].to] = dep[x]+1;dis[e[i].to] = e[i].val;
            ft[e[i].to] = x;
            Q.push(e[i].to);
            while(!Q.empty())
            {
                int tp = Q.front();
                Q.pop();
                if(dep[tp]>K)continue;
                if(dis[tp]>G[dep[tp]][0])
                    G[dep[tp]][0] = dis[tp],G[dep[tp]][1] = 0;
                if(G[dep[tp]][0]==dis[tp])G[dep[tp]][1]++;
                for(int j = head[tp];j;j = e[j].next)
                    if(e[j].to!=ft[tp]&&!used[e[j].to])
                    {
                        ft[e[j].to] = tp;
                        dep[e[j].to] = dep[tp]+1;
                        dis[e[j].to] = dis[tp]+e[j].val;
                        Q.push(e[j].to);
                    }
            }
            for(int j = 0;j<= K;j++)
            {
                if(F[K-j][0]+G[j][0]>ans1)
                    {ans1 = F[K-j][0]+G[j][0];ans2 = F[K-j][1]*G[j][1];}
                else if(F[K-j][0]+G[j][0]==ans1)
                    {ans2+=F[K-j][1]*G[j][1];}
            }
            for(int j = 0;j<= K;j++)
            {
                if(G[j][0]>F[j][0]){F[j][0] = G[j][0],F[j][1] = G[j][1];}
                else if(G[j][0]==F[j][0]){F[j][1]+=G[j][1];}
                G[j][0] = G[j][1] = 0;
            }
        }
    }
    void work(int x,int S)
    {
        calc(x);
        used[x] = true;
        for(int i = head[x];i;i= e[i].next)
            if(!used[e[i].to])
            {
                root = 0;
                sum= size[e[i].to];
                if(size[e[i].to]>size[x])size[e[i].to]=S-size[e[i].to];
                if(sum>=K)get_root(e[i].to,0);
                work(root,size[e[i].to]);
            }
    }
    void dis_edge()
    {
        for(int i = 1;i<= n;i++)
            for(int j = head[i];j;j = e[j].next)
                if(i<=e[j].to)
                    printf("%d %d %d\n",i,e[j].to,e[j].val);
    }
}g,t;
void rebuild(int x)
{
    v[x] = true;
    for(int i = g.head[x];i;i = g.e[i].next)
    {
        int to = g.e[i].to;
        if(!v[to]&&dis[x]+g.e[i].val==dis[to])
        {
            t.add(x,to,g.e[i].val),t.add(to,x,g.e[i].val);
            rebuild(to);
        }
    }
}
struct Edge
{int u,v,w;}edge[M<<1];
bool cmp(const Edge &a,const Edge &b)
{
    if(a.u==b.u)
        return a.v>b.v;
    return a.u<b.u;
}
int main()
{
    scanf("%d%d%d",&n,&m,&K);
    K--;
    for(int i=1;i<= m;i++)
    {
        scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
        edge[i+m] = edge[i];
        swap(edge[i].u,edge[i].v);
    }
    sort(edge+1,edge+2*m+1,cmp);
    for(int i = 1;i<= 2*m;i++)
        g.add(edge[i].u,edge[i].v,edge[i].w);
    g.spfa(1);
    memset(v,0,sizeof(v));
    rebuild(1);
    //t.dis_edge();
    f[0] = sum= n;
    t.get_root(1,0);
    t.work(root,sum);
    printf("%d %d\n",ans1,ans2);
    return 0;
}
Problem4025

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
struct Edge
{
	int x,y,st,ed;
	Edge(int _x,int _y,int _s,int _e):x(_x),y(_y),st(_s),ed(_e){}
};
const int N = 100005;
int fa[N],rnk[N],stack[N<<2],a[N],top;
int getfa(int x)
{
	while(fa[x]!=x)x=fa[x];
	return fa[x]=x;
}
int getdis(int x)
{
	int res = 0;
	while(fa[x]!=x&&fa[x])res^=a[x],x=fa[x];
	return res;
}
void uni(int x,int y,int z)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(rnk[x]>rnk[y])swap(x,y);
	if(rnk[x]==rnk[y])
		rnk[y]++,stack[++top] = y;
	fa[x] = y,a[x] = z;stack[++top] = x;
}
void reset(int bot)
{
	while(top>bot)
	{
		if(stack[top]<0)
			rnk[-stack[top]]--;
		else 
			fa[stack[top]] = stack[top],a[stack[top]] = 0;
		top--;
	}
}
void solve(int l,int r,vector<Edge> &e)
{
	int mid = (l+r)>>1,bot = top;
	vector<Edge>L,R;
	for(int i = 0;i<e.size();i++)
	{
		if(e[i].st==l&&e[i].ed==r)
		{
			int _x = getfa(e[i].x),_y = getfa(e[i].y);
			int _z =getdis(e[i].x)^getdis(e[i].y)^1;
			if(_x!=_y)uni(_x,_y,_z);
			else if(_z&1)
			{
				for(int i = l;i<= r;i++)
					printf("No\n");
				reset(bot);
				return ;
			}
		}
		else if(e[i].ed<=mid)L.push_back(e[i]);
		else if(e[i].st>mid)R.push_back(e[i]);
		else
			L.push_back(Edge(e[i].x,e[i].y,e[i].st,mid)),
			R.push_back(Edge(e[i].x,e[i].y,mid+1,e[i].ed));
	}
	if(l==r)printf("Yes\n");
	else 
		solve(l,mid,L),solve(mid+1,r,R);
	reset(bot);
}
int main()
{
	int n,m,T,x,y,s,e;
	scanf("%d%d%d",&n,&m,&T);
	for(int i = 1;i<= n;i++)fa[i]=i;
	vector<Edge>E;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&s,&e);
		s++;
		if(s>e)continue;
		E.push_back(Edge(x,y,s,e));
	}
	solve(1,T,E);
	return 0;
}
Problem4027

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2000005;
int top,c[N],k[N],val[N],n,m,ans;
int stack[N];
bool cmp(int a,int b)
{
	return val[a]<val[b];
}
struct E
{int next,to;}e[N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void dfs(int x)
{
	for(int i = head[x];i;i = e[i].next)
		dfs(e[i].to);
	top = 0;
	for(int i= head[x];i;i = e[i].next)
		stack[++top] = e[i].to;
	sort(stack+1,stack+top+1,cmp);
	for(int i = 1;i<= top;i++)
	{
		if(val[x]+val[stack[i]]-1<=m)
		{
			ans++;
			val[x]+=val[stack[i]]-1;
		}else break;
	}
}
int main()
{
	int x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&c[i]);
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&k[i]);
		val[i] = k[i]+c[i];
		for(int j = 1;j<= k[i];j++)
		{
			scanf("%d",&x);
			add(i,x+1);
		}
	}
	dfs(1);
	printf("%d\n",ans);
	return 0;
}
Problem4028

#include <stdio.h>
#include <math.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 100005;
const int B = 5005;
int g[N],x[N],a[N];
int pos[N],lb[N],rb[N];
int gcd(int a,int b)
{
	if(a==-1)return b;
	if(b==0)return a;
	return gcd(b,a%b);
}
map<ll,int>s[B];
void debug(int b)
{
	printf("Bolck No #%d\n",b);
	map<ll,int>::iterator it;
	for(it = s[b].begin();it!=s[b].end();it++)
		printf("%lld %d\n",it->first,it->second);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int block = sqrt(n);
	for(int i = 1;i<= n;i++)
		pos[i] = (i-1)/block+1;
	int tot = pos[n];
	for(int i = 1;i<= tot;i++)
		lb[i] = (i-1)*block+1,rb[i] = i*block;
	rb[tot] = n;
	for(int i = 1;i<= tot;i++)
	{
		g[lb[i]] = a[lb[i]],x[lb[i]] = a[lb[i]];
		s[i][x[lb[i]]] = lb[i];
		for(int j = lb[i]+1;j<= rb[i];j++)
		{
			g[j] = gcd(g[j-1],a[j]),x[j] = x[j-1]^a[j];
			if(s[i].find(x[j])==s[i].end())s[i][x[j]] = j;
		}
		//debug(i);
	}
	int q,id,nv;
	ll p;
	scanf("%d",&q);
	while(q--)
	{
		char opt[10];
		scanf("%s",opt);
		if(opt[0]=='M')
		{
			scanf("%d%d",&id,&nv);
			id++;
			int Pos = pos[id];
			for(int i = id;i<= rb[Pos];i++)
				if(s[Pos][x[i]]==i)s[Pos].erase(x[i]);
			if(id==lb[Pos])g[id] = x[id] = nv;
			else g[id] = gcd(g[id-1],nv),x[id] = x[id-1]^nv;
			if(s[Pos].find(x[id])==s[Pos].end())s[Pos][x[id]] = id;
			for(int i = id+1;i<= rb[Pos];i++)
			{
				g[i] = gcd(g[i-1],a[i]),x[i] = x[i-1]^a[i];
				if(s[Pos].find(x[i])==s[Pos].end())s[Pos][x[i]] = i;
			}
			a[id] = nv;
			//debug(Pos);
		}
		else
		{
			scanf("%lld",&p);
			int lastgcd = -1;
			int lastxor = 0;
			bool flag = false;
			for(int i = 1;i<= tot&&!flag;i++)
			{
				int tmp_gcd = gcd(lastgcd,g[rb[i]]);
				if(tmp_gcd==lastgcd)
				{
					ll goal = (p/lastgcd)^lastxor;
					if(p%lastgcd)goal = -1;
					if(s[i].find(goal)!=s[i].end())
					{
						printf("%d\n",s[i][goal]-1);
						flag = true;
					}
				}else
				{
					for(int j = lb[i];j<= rb[i];j++)
					{
						ll tg = gcd(lastgcd,g[j]);
						ll tx = lastxor^x[j];
						if(tg*tx==p)
						{
							printf("%d\n",j-1);
							flag = true;break;
						}
					}
				}
				lastgcd = gcd(lastgcd,g[rb[i]]);
				lastxor = lastxor^x[rb[i]];
			}
			if(!flag)printf("no\n");
		}
	}
	return 0;
}
/*
10

1353600 5821200 10752000 1670400 3729600 6844320 12544000 117600 59400 640

10

MODIFY 7 20321280

QUERY 162343680

QUERY 1832232960000

MODIFY 0 92160

QUERY 1234567

QUERY 3989856000

QUERY 833018560

MODIFY 3 8600

MODIFY 5 5306112

QUERY 148900352

6

0

no

2

8

8
*/
Problem4029

#include <set>
#include <map>
#include <ctime>
#include <queue>
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int T,l,r,ans,mn;
int add(int x)
{
    int k=1;
    while(x%10==0)
    {
        k*=10;
        x/=10;
    }
    return k;
}
int cal(int x)
{
    while(x%10==0)
        x/=10;
    int t=x%10,a=0;
    while(x)
    {
        x/=10;
        a++;
    }
    if(t==5)
        return 2*a-1;
    return 2*a;
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%d",&l,&r);
        mn=cal(l);ans=l;
        while(1)
        {
            l+=add(l);
            if(l>r)break;
            int t=cal(l);
            if(t<mn)mn=t,ans=l;
        }
        printf("%d\n",ans);
    }
    return 0;
}
Problem4033

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
typedef long long LL;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,n,K;
LL f[N][N];
int size[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val  = f;
	head[x] = tot;
}
void dp(int x,int fa,int val)
{
	size[x]++;
	f[x][0] = f[x][1] = 0;
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to==fa)continue;
		dp(e[i].to,x,e[i].val);
		size[x]+=size[e[i].to];
		for(int j = min(size[x],K);j>= 0;j--)
			for(int k = 0;k<= j&&k<=size[e[i].to];k++)
				if(j-k>=0&&f[x][j-k]!=-1)f[x][j] = max(f[x][j],f[x][j-k]+f[e[i].to][k]);
	}
	for(int bn = 0;bn<= K&&bn<=size[x];bn++)
	{
		if(f[x][bn]==-1)f[x][bn] = 0;
		f[x][bn] = f[x][bn]+(LL)val*(LL)bn*(K-bn)+(LL)val*(LL)(size[x]-bn)*(n-K-size[x]+bn);
	}
}
int main()
{
	int x,y,c;
	scanf("%d%d",&n,&K);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%d",&x,&y,&c);
		add(x,y,c),add(y,x,c);
	}
	memset(f,-1,sizeof(f));
	dp(1,0,0);
	printf("%lld\n",f[1][K]);
	return 0;
}
Problem4034

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int w[N],top[N],deep[N],son[N],size[N],fa[N],end[N],cnt;
bool v[N];
void dfs1(int x,int dep)
{
	deep[x] = dep;
	size[x]++;
	v[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			fa[tmp] = x;
			if(size[tmp]>size[son[x]])son[x] = tmp;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	end[x] = cnt;
}
long long sum[N<<3],f[N<<3];
void push_down(int p,int l,int r)
{
	f[p<<1]+=f[p];
	f[(p<<1)+1]+=f[p];
	int mid = (l+r)>>1;
	sum[p<<1]+=f[p]*(mid-l+1);
	sum[(p<<1)+1]+=f[p]*(r-mid);
	f[p] = 0;
}
void update(int p,int l,int r,int a,int b,long long c)
{
	if(f[p])push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		f[p]+=c;
		sum[p]+=c*(r-l+1);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid)update((p<<1)+1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
long long getans(int p,int l,int r,int a,int b)
{
	if(f[p])push_down(p,l,r);
	if(l>=a&&r<=b)return sum[p];
	int mid = (l+r)>>1;
	long long ans = 0;
	if(a<=mid)ans+=getans(p<<1,l,mid,a,b);
	if(b>mid)ans+=getans((p<<1)+1,mid+1,r,a,b);
	return ans;
}
long long qurey(int x,int y)
{
	long long ans = 0;
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]])
			swap(x,y);
		ans+=getans(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])
		swap(x,y);
	ans+=getans(1,1,n,w[y],w[x]);
	return ans;
}
int num[N];
int main()
{
	int x,y,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		update(1,1,n,w[i],w[i],num[i]);
	int opt;
	long long z;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&opt,&x);
		if(opt==1)
		{
			scanf("%lld",&z);
			update(1,1,n,w[x],w[x],z);
		}else if(opt==2)
		{
			scanf("%lld",&z);
			update(1,1,n,w[x],end[x],z);
		}else
			printf("%lld\n",qurey(1,x));
	}
	return 0;
}
Problem4036

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<20;
const double eps = 1e-8;
double a[N+5];
int f[N+5];
int main()
{
	int n;
	scanf("%d",&n);
	f[0] = ((n+1)&1)?-1:1;
	for(int i = 0;i<(1<<n);i++)
	{
		scanf("%lf",&a[i]);
		if(i>0)f[i] = -f[i-(i&(-i))];
	}
	for(int k = 1;k<(1<<n);k<<=1)
		for(int i = 0;i<(1<<n);i++)
		{
			if(i&k)continue;
			a[i+k]+=a[i];
		}
	bool flag = true;
	for(int i = 0;flag&&i<(1<<n)-1;i++)
		if(a[i]+eps>1)
			flag = false;
	if(!flag)printf("INF\n");
	else
	{
		double ans = 0;
		for(int i = 0;i<(1<<n)-1;i++)
			ans+=f[i]/(1-a[i]);
		printf("%.7lf\n",ans);
	}
	return 0;
}
Problem4055

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 8e3+5;
typedef long double ld;
struct E
{int next,to,b;ld c;};
struct H
{int v,no;}heap[M];
bool cmp(H a,H b)
{
    return a.v>b.v;
}
bool on_tree[M];
int dis[N],ind[N],rei[N],a[N],n,m,cnt;bool v[N];
ld arc[N][N];
ld R[N],tr[N];
queue<int>Q;
struct Gragh
{
	E e[M];
	int head[N],tot;
	void init()
	{
		memset(head,0,sizeof(head));
		tot = 1;
	}
	void add(int x,int y,int b,ld c)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
		e[tot].b = b,e[tot].c = c;
	}
	void spfa(int s)
	{
		cnt = 0;
		memset(dis,0x3f,sizeof(dis));
		memset(v,false,sizeof(v));
		dis[s]=0;
		heap[1].v = 0;heap[1].no = s;
		cnt++;
		push_heap(heap+1,heap+cnt+1,cmp);
		while(cnt)
		{
			int now=heap[1].no;
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			if(v[now])continue;
			v[now]=1;
			for(int i=head[now];i;i=e[i].next)
				if(dis[now]+e[i].b<dis[e[i].to]&&!v[e[i].to])
				{
					dis[e[i].to]=dis[now]+e[i].b;
					heap[++cnt].v = dis[e[i].to];
					heap[cnt].no = e[i].to;
					push_heap(heap+1,heap+cnt+1,cmp);
				}
		}
		for(int i = 1;i<= n;i++)
			for(int j = head[i];j;j=e[j].next)
				if(dis[i]+e[j].b==dis[e[j].to])
					on_tree[j] = true,ind[e[j].to]++,rei[i]++;
	}
	void topo(int s)
	{
		arc[s][s] = 1;
		for(int i = 1;i<= n;i++)
			if(!ind[i])
				Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(on_tree[i])
				{
					arc[s][e[i].to]+=e[i].c*arc[s][x];
					if(!--ind[e[i].to])
						Q.push(e[i].to);
				}
		}
	}
	void retopo(int s)
	{
		for(int i = 1;i<= n;i++)
		{
			if(!rei[i])
				Q.push(i);
			tr[i] = 0;
		}
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
			if(on_tree[i^1])
			{
				tr[e[i].to]+=e[i].c*tr[x];
				tr[e[i].to]+=e[i].c*a[x]/arc[s][x];
				if(!--rei[e[i].to])
					Q.push(e[i].to);
			}
		}
	}
	void getR(int s)
	{
		for(int i=1;i<= n;i++)
			if(i!=s)
				R[i]+=arc[s][i]*a[s]*tr[i];
	}
}g;
int main()
{
	//freopen("misc.in","r",stdin);
	//freopen("misc.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]);
	int u,v,d;ld c;
	g.init();
	for(int i = 1;i<=m;i++)
	{
		scanf("%d%d%d%Lf",&u,&v,&d,&c);
		g.add(u,v,d,c);
		g.add(v,u,d,c);
	}
	for(int i= 1;i<= n;i++)
	{
		memset(ind,0,sizeof(ind));
		memset(rei,0,sizeof(rei));
		memset(on_tree,0,sizeof(on_tree));
		g.spfa(i);
		g.topo(i);
		g.retopo(i);
		g.getR(i);
	}
	for(int i = 1;i<= n;i++)
		printf("%.8Lf\n",R[i]);
	return 0;
}
Problem4071

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
LL sum[N<<3];
int size[N<<3];
struct P{int a,b;}per[N];
int pos[N<<1],cnt,tot,d[N<<1];
bool cmp(const P &x,const P &y)
{
	return (x.a+x.b)<(y.a+y.b);
}
void init()
{
	sort(pos+1,pos+cnt+1);
	int tmp = cnt;cnt = 0;
	pos[0] = -1e9;
	for(int i = 1;i<= tmp;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt] = pos[i];
}
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void push_up(int p)
{
	sum[p] = sum[p<<1]+sum[p<<1|1];
	size[p] = size[p<<1]+size[p<<1|1];
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		sum[p] = size[p] = 0;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	push_up(p);
}
void update(int p,int l,int r,int x)
{
	if(l==r)
	{
		sum[p]+=d[l];
		size[p]++;
		return ;
	}
	int mid = (l+r)>>1;
	if(x<=mid)update(p<<1,l,mid,x);
	else update(p<<1|1,mid+1,r,x);
	push_up(p);
}
LL get_sum(int p,int l,int r,int cnt)
{
	if(size[p]<=cnt)return sum[p];
	if(l==r)return (LL)cnt*d[l];
	int mid = (l+r)>>1;
	if(size[p<<1]>=cnt)return get_sum(p<<1,l,mid,cnt);
	else return sum[p<<1]+get_sum(p<<1|1,mid+1,r,cnt-size[p<<1]);
}
LL Ask(LL k)
{
	LL s = get_sum(1,1,cnt,k);
	return sum[1]-(LL)2*s;
}
LL ans[N];
int main()
{
	int k,n;
	scanf("%d%d",&k,&n);
	LL pre = 0;
	char x1[5],x2[5];int x,y;
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d%s%d",x1,&x,x2,&y);
		if(x1[0]==x2[0])pre+=abs(y-x);
		else
		{
			pre++;
			pos[++cnt] = x;pos[++cnt] = y;
			per[++tot].a = x;per[tot].b = y;
		}
	}
	init();
	sort(per+1,per+tot+1,cmp);
	if(cnt)
	{
		n = tot;
		for(int i = 1;i<= n;i++)
			d[find(per[i].a)] = per[i].a,d[find(per[i].b)] = per[i].b;
		build(1,1,cnt);
		for(int i = 1;i<= n;i++)
		{
			update(1,1,cnt,find(per[i].a));
			update(1,1,cnt,find(per[i].b));
			ans[i] = Ask(i);
		}
	}
	if(k==1){printf("%lld\n",ans[n]+pre);return 0;}
	else
	{
		LL Ans = ans[n];
		if(cnt)
		{
			build(1,1,cnt);
			for(int i = n;i>1;i--)
			{
				update(1,1,cnt,find(per[i].a));
				update(1,1,cnt,find(per[i].b));
				Ans = min(Ans,ans[i-1]+Ask(n-i+1));
			}
		}
		printf("%lld\n",Ans+pre);
	}
	return 0;
}
Problem4078

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 405;
const int M = 805;
const int INF = 0x3f3f3f3f;
struct Edge
{int u,v,w;}edge[N*N];
struct E
{int next,to;}e[M*M];
int head[N],tot,n;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x]=tot;
}
bool cmp(const Edge &a,const Edge &b)
{
	if(a.w==b.w)
	{
		if(a.u==b.u)return a.v>b.v;
		else return a.u>b.u;
	}	
	else return a.w>b.w;
}
int fa[N],d[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	int res = getfa(fa[x]);
	d[x]^=d[fa[x]];
	return fa[x] = res;
}
int a[N][N];
bool ins[N];
int low[N],dfn[N],stack[N],top,dcc,bel[N],cnt;
void tarjan(int x)
{
	stack[++top] =x;
	dfn[x]=low[x]=++cnt;
	ins[x] = true;
	for(int i = head[x];i;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			tarjan(e[i].to);
			low[x] = min(low[x],low[e[i].to]);
		}else if(ins[e[i].to])
			low[x] = min(low[x],dfn[e[i].to]);
	}
	if(low[x]==dfn[x])
	{
		dcc++;
		int tmp;
		do
		{
			tmp = stack[top--];
			ins[tmp] = false;
			bel[tmp] = dcc;
		}while(tmp!=x);
	}
}
bool check(int s1,int s2)
{
	for(int i = 1;i<= 2*n;i++)head[i]=low[i]=dfn[i]=bel[i]=ins[i]=0;
	top = dcc = tot = cnt = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
		{
			if(a[i][j]>s1)
			{
				add(i*2-1,j*2);
				add(j*2-1,i*2);
			}if(a[i][j]>s2)
			{
				add(i*2,j*2-1);
				add(j*2,i*2-1);
			}
		}
	for(int i = 1;i<= 2*n;i++)if(!dfn[i])tarjan(i);
	for(int i = 1;i<= n;i++)if(bel[i*2]==bel[i*2-1])return false;
	return true;
}
int getans(int c)
{
	int l = 0,r = c;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(check(c,mid))r = mid-1;
		else l = mid+1;
	}
	return l;
}
int main()
{
	int id = 0;
	scanf("%d",&n);
	if(n<=2){printf("0\n");return 0;}
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
		{
			id++;
			scanf("%d",&a[i][j]);a[j][i]=a[i][j];
			edge[id]=(Edge){i,j,a[i][j]};
		}
	for(int i = 1;i<= n;i++)fa[i]=i,d[i]=0;
	sort(edge+1,edge+id+1,cmp);
	int ans = INF;
	for(int i = 1;i<= id;i++)
	{
		int u = edge[i].u,v = edge[i].v,w = edge[i].w;
		int x = getfa(u),y = getfa(v);
		if(x!=y)
		{
			ans = min(ans,w+getans(w));
			d[x] = d[u]^d[v]^1;
			fa[x] = y;
		}else if(d[u]==d[v])
		{
			ans=min(ans,w+getans(w));
			break;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem4098

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int mod = 1e9+7;
char s[N][N];
int f[2][N][N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	f[0][1][n] = 1;
	for(int i = 1;i<=n;i++)
	{
		int now = i&1,pre = (i-1)&1;
		memset(f[now],0,sizeof(f[now]));
		for(int x1 = 1;x1<= i;x1++)
		{
			int y1 = i-x1+1;
			for(int x2 = n;x2>=n-i;x2--)
			{
				int y2 = n-(i-(n-x2))+1;
				if(s[x1][y1]==s[x2][y2])
					f[now][x1][x2] = ((f[pre][x1][x2]+f[pre][x1-1][x2])%mod+(f[pre][x1][x2+1]+f[pre][x1-1][x2+1])%mod)%mod;
			}
		}
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		(ans+=f[n&1][i][i])%=mod;
	printf("%d\n",ans);
	return 0;
}
Problem4100

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
LL v[7][7];
int main()
{
	int n,x;
	char tmp[3];
	scanf("%d",&n);
	for(int i= 1;i<= n;i++)
	{
		scanf("%s%d",tmp,&x);
		if(tmp[0]=='B')v[0][(x%7+7)%7]++;
		else if(tmp[0]=='E')v[1][(x%7+7)%7]++;
		else if(tmp[0]=='S')v[2][(x%7+7)%7]++;
		else if(tmp[0]=='I')v[3][(x%7+7)%7]++;
		else if(tmp[0]=='G')v[4][(x%7+7)%7]++;
		else if(tmp[0]=='O')v[5][(x%7+7)%7]++;
		else v[6][(x%7+7)%7]++;
	}
	LL ans = 0;
	for(int B = 0;B<7;B++)
	for(int E = 0;E<7;E++)
	for(int S = 0;S<7;S++)
	for(int I = 0;I<7;I++)
	for(int G = 0;G<7;G++)
	for(int O = 0;O<7;O++)
	for(int M = 0;M<7;M++)
	{
		if((B+E+S+S+I+E)*(G+O+E+S)*(M+O+O)%7==0)
			ans += v[0][B]*v[1][E]*v[2][S]*v[3][I]*v[4][G]*v[5][O]*v[6][M];
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4101

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct G
{int s,p;}g[N];
bool cmp(G a,G b)
{
	return a.p<b.p;
}
int n,b;
int find(int x)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(g[mid].p<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	scanf("%d%d",&n,&b);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&g[i].s,&g[i].p);
	sort(g+1,g+n+1,cmp);
	int l = find(b)-1;
	int r = l+1;
	int ans = 0x3f3f3f3f;
	for(int i = l;i>=1;i--)
	{
		while(r<=n&&g[r].p-g[i].p<=g[i].s)
		{
			ans = min(ans,g[r].p-g[i].p-g[r].s);
			r++;
		}
	}
	r = l+1;
	for(int i = r;i<=n;i++)
	{
		while(l&&g[i].p-g[l].p<=g[i].s)
		{
			ans = min(ans,g[i].p-g[l].p-g[l].s);
			l--;
		}
	}
	if(ans!=0x3f3f3f3f)printf("%d\n",max(ans,0));
	else printf("-1\n");
	return 0;
}
Problem4102

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 20005;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
queue<int>Q;
int dis[N][N];
void bfs(int s)
{
	memset(dis[s],-1,sizeof(dis[s]));
	Q.push(s);
	dis[s][s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i = e[i].next)
			if(dis[s][e[i].to]==-1)
			{
				dis[s][e[i].to] = dis[s][x]+1;
				Q.push(e[i].to);
			}
	}
	return ;
}
struct P
{int no,val;}p[N];
bool cmp(P a,P b)
{
	return a.val>b.val;
}
int f[N];
int main()
{
	int n,en;
	scanf("%d%d",&n,&en);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&p[i].val);
		p[i].no = i;
		int d,x;
		scanf("%d",&d);
		for(int j = 1;j<= d;j++)
		{
			scanf("%d",&x);
			add(i,x);
		}
	}
	for(int i = 1;i<= n;i++)
	{
		bfs(i);
		for(int j = 1;j<= n;j++)
			dis[i][j]*=en;
		dis[0][i] = 0;
	}
	sort(p+1,p+n+1,cmp);
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<i;j++)
			if(dis[p[j].no][p[i].no]>=0)
				f[i] = max(f[i],f[j]-dis[p[j].no][p[i].no]+p[i].val);
	int ans =0;
	for(int i = 1;i<= n;i++)
		ans = max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4103

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e3+5;
const int M = 3e5+5;
const int W = M*35;
int n,m,cnt,U,D,L,R,k;
int a[N],b[M];
int ch[W][2],sum[W],root[M];
struct data{int x,y;}q[N];
void insert(int x,int &y,int num,int dep)
{
	y = ++cnt;
	sum[y] = sum[x]+1;
	ch[y][0]=ch[x][0],ch[y][1]=ch[x][1];
	if(dep<0)return ;
	int t = num&(1<<dep);t = t>>dep;
	insert(ch[x][t],ch[y][t],num,dep-1);
}
int solve(int k,int dep)
{
	if(dep==-1)return 0;
	int tmp = 0,t;
	for(int i = U;i<= D;i++)
	{
		t = a[i]&(1<<dep);t = t>>dep;
		tmp+=sum[ch[q[i].y][t^1]]-sum[ch[q[i].x][t^1]];
	}
	if(tmp>=k)
	{
		for(int i = U;i<=D;i++)
		{
			t = a[i]&(1<<dep);t = t>>dep;
			q[i].x = ch[q[i].x][t^1];
			q[i].y = ch[q[i].y][t^1];
		}
		return solve(k,dep-1)+(1<<dep);
	}else
	{
		for(int i = U;i<=D;i++)
		{
			t = a[i]&(1<<dep);t = t>>dep;
			q[i].x = ch[q[i].x][t];
			q[i].y = ch[q[i].y][t];
		}
		return solve(k-tmp,dep-1);
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&b[i]);
	for(int i = 1;i<= m;i++)insert(root[i-1],root[i],b[i],30);
	int Q;
	scanf("%d",&Q);
	for(int i = 1;i<= Q;i++)
	{
		scanf("%d%d%d%d%d",&U,&D,&L,&R,&k);
		for(int i = U;i<= D;i++)
			q[i].x = root[L-1],q[i].y = root[R];
		printf("%d\n",solve(k,30));
	}
	return 0;
}
Problem4140

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 500010;
int n,opt,top,num;
int l[40],r1[40],r2[40];
bool t;
double A,B,C,sum;
inline double sqr(double x){return x*x;}
struct Point
{
	double x,y;
}ins[N],newq[N],q1[N],q2[N];
inline bool cmp1(const Point &a,const Point &b)   
{return a.x==b.x?a.y>b.y:a.x<b.x;}
inline bool cmp2(const Point &a,const Point &b)   
{return a.x==b.x?a.y<b.y:a.x<b.x;}
void rebuild() 
{
	while (num&&top-l[num]==l[num]-l[num-1])    
		num--;
	l[++num]=top;
	int L=l[num-1]+1,R=L-1,cnt=0;
	for (int i=L;i<=top;i++)    
		newq[++cnt]=ins[i];
	sort(newq+1,newq+cnt+1,cmp1);
	for (int i=1;i<=cnt;i++)
	{
		while (R>L&&(q1[R].y-q1[R-1].y)*(newq[i].x-q1[R].x)<=(newq[i].y-q1[R].y)*(q1[R].x-q1[R-1].x))   
			R--;
		q1[++R]=newq[i];
	}
	r1[num]=R;
	R=L-1;
	sort(newq+1,newq+cnt+1,cmp2);
	for (int i=1;i<=cnt;i++)
	{
		while (R>L&&(q2[R].y-q2[R-1].y)*(newq[i].x-q2[R].x)>=(newq[i].y-q2[R].y)*(q2[R].x-q2[R-1].x))   
			R--;
		q2[++R]=newq[i];
	}
	r2[num]=R;
}
inline double calc(Point x) 
{return A*x.x+B*x.y;}
bool query1(int l,int r)
{
	int mid1,mid2,len;double s1,s2;
	while (l<=r)
	{
		len=(r-l)/3;
		mid1=l+len;
		mid2=r-len;
		s1=calc(q1[mid1]);
		s2=calc(q1[mid2]);
		if (s1<s2)  
			{if (s1<C)  return t=1;r=mid2-1;}
		else    
			{if (s2<C)  return t=1;l=mid1+1;}
	}
	return 0;
}
bool query2(int l,int r)
{
	int mid1,mid2,len;double s1,s2;
	while (l<=r)
	{
		len=(r-l)/3;
		mid1=l+len;
		mid2=r-len;
		s1=calc(q2[mid1]);
		s2=calc(q2[mid2]);
		if (s1<s2)  
			{if (s1<C)  return t=1;r=mid2-1;}
		else    
			{if (s2<C)  return t=1;l=mid1+1;}
	}
	return 0;
}
inline void Query()
{
	t=0;
	for (int i=1;i<=num;i++)
	{
		if (B<0)    
			query1(l[i-1]+1,r1[i]); 
		else    
			query2(l[i-1]+1,r2[i]);
		if (t)  return;
	}
}
int main()
{
	scanf("%d",&n);
	while (n--)
	{
		scanf("%d%lf%lf",&opt,&A,&B);A+=sum,B+=sum;
		if  (opt==0)    
			ins[++top].x=A,ins[top].y=B,rebuild();
		else    
		{
			if (!top)   
				{puts("No");continue;}
			C=sqr(A)+sqr(B);
			A*=2;B*=2;
			Query();
			puts(t?"No":"Yes");
			if (!t) sum++;
		}
	}
}
Problem4145

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1<<16;
const int INF = 0x3f3f3f3f;
int d[105],c[105][20];
int f[105][N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&d[i]);
		for(int j = 1;j<= m;j++)
			scanf("%d",&c[i][j]);
	}
	memset(f,0x3f,sizeof(f));
	f[0][0] = 0;
	for(int i = 1;i<= n;i++)
	{
		for(int sta = 0;sta<1<<m;sta++)
			f[i][sta] = f[i-1][sta]+d[i];
		for(int sta = 0;sta<1<<m;sta++)
		{
			if(f[i][sta]==INF)continue;
			for(int k = 0;k<m;k++)
			{
				if(sta&(1<<k))continue;
				f[i][sta|(1<<k)] = min(f[i][sta|(1<<k)],f[i][sta]+c[i][k+1]);
			}
		}
		for(int sta = 0;sta<1<<m;sta++)
			f[i][sta] = min(f[i-1][sta],f[i][sta]);
	}
	printf("%d\n",f[n][(1<<m)-1]);
	return 0;
}
Problem4147

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int gcd(int a,int b)
{
	if(!b)return a;
	else return gcd(b,a%b);
}
bool calc(int n,int p,int q)
{
	return n%p<q&&n%p%(p-q)==0;
}
int main()
{
	int cas;
	int p,q,n;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d%d",&p,&q,&n);
		int d = gcd(p,q);
		if(n%d){puts("R");continue;}
		p/=d,q/=d,n/=d;
		if(p==q)puts("E");
		else if(p>q)
		{
			if(n<p)puts("P");
			else puts(calc(n,p,q)?"E":"P");
		}else
		{
			if(n<p)
			{
				if(n+p<q)puts("E");
				else puts(calc(n+p,q,p)?"P":"E");
			}
			else puts("E");
		}
	}
}
Problem4173

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 998244353;
ll oula(ll x)
{
	ll ans = x;
	for(ll i = 2;i*i<= x;i++)
	{
		if(x%i==0)ans = ans/i*(i-1);
		while(x%i==0)x/=i;
	}
	if(x!=1)ans = ans/x*(x-1);
	return ans%mod;
}
int main()
{
	ll n,m;
	scanf("%lld%lld",&n,&m);
	printf("%lld\n",(n%mod)*(m%mod)%mod*oula(n)%mod*oula(m)%mod);
	return 0;
}
Problem4174

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int mod = 998244353;
typedef long long ll;
int mu[N],prime[N],cnt,sum[N];
bool v[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!v[i])
		{
			prime[++cnt] =i;
			mu[i] = mod-1;
		}
		for(int j = 1;j<=cnt&&prime[j]*i<N;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])mu[i*prime[j]]=(mod-mu[i])%mod;
			else
			{
				mu[i*prime[j]]=0;
				break;
			}
		}
	}
}
ll getsum(ll n)
{
	return (n*(n+1)>>1)%mod;
}
int main()
{
	int n,m,x;
	scanf("%d%d%d",&n,&m,&x);
	quick_mu();
	ll ans = 0;
	ans=((getsum(n)*getsum(m)-n*getsum(m)-m*getsum(n))%mod+mod)%mod;
	if(n>m)swap(n,m);
	for(int i = 1;i<= n;i++)
	{
		ll tmp = i+x/i*i*2;
		for(int j = 1;j*i<=n;j++)
			(ans+=tmp*mu[j]%mod*(n/i/j)%mod*(m/i/j)%mod)%=mod;
	}
	ans = ans*((mod+1)>>1)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4176

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
const int mod = 1e9+7;
int n,S;
int mu[N],prime[N/10],cnt,sum2[N];
bool v[N];
void quick_mu()
{
	mu[1] = 1;
	for(int i = 2;i<=S;i++)
	{
		if(!v[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&prime[j]*i<=S;j++)
		{
			v[i*prime[j]] = true;
			if(i%prime[j])
				mu[prime[j]*i] = -mu[i];
			else {mu[prime[j]*i]=0;break;}
		}
	}
}
int Get_Sum(int n)
{
	int i,ans=0,last;
	for(i=1;i<=n;i=last+1)
	{
		last = n/(n/i);
		(ans+=(ll)(last-i+1)*(n/i)%mod)%=mod;
	}
	return ans;
}
int get_sum(int x)
{
	if(x<=S)return mu[x];
	else return sum2[n/x];
}
void init()
{
	quick_mu();
	for(int i = 2;i<=S;i++)
		mu[i]+=mu[i-1];
	int i,j,last;
	for(i=1;n/i>S;i++);
	for(j=i;j;j--)
	{
		int n = ::n/j;
		sum2[j] = 1;
		for(i=2;i<=n;i=last+1)
		{
			last = n/(n/i);
			(sum2[j]-=(ll)(last-i+1)*get_sum(n/i)%mod)%=mod;
		}
	}
}
int main()
{
	int i,last,ans =0;
	scanf("%d",&n);
	S = ceil(pow(n,0.75)-1e-7)+1e-7;
	init();
	for(i=1;i<=n;i=last+1)
	{
		last = n/(n/i);
		ll tmp = Get_Sum(n/i);
		(ans+=(get_sum(last)-get_sum(i-1))*tmp%mod*tmp%mod)%=mod;
	}
	printf("%d\n",(ans+mod)%mod);
	return 0;
}
Problem4180

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
const ll INF = 1ll<<62;
ll n;
char s[N];
struct Matrix
{
	ll d[4][4];
	Matrix()
	{
		memset(d,0,sizeof(d));
	}
	Matrix(bool flag)
	{
		memset(d,0,sizeof(d));
		for(int i = 0;i<4;i++)d[i][i]=1;
	}
	void operator *=(const Matrix &s)
	{
		Matrix res;
		for(int i = 0;i<4;i++)for(int j  =0;j<4;j++)
		{
			res.d[i][j] = INF;
			for(int k = 0;k<4;k++)
				res.d[i][j] = min(res.d[i][j],d[i][k]+s.d[k][j]);
		}
		*this = res;
	}
	friend Matrix quick_pow(Matrix s,ll d)
	{
		Matrix res(true);
		while(d)
		{
			if(d&1)res*=s;
			s*=s;
			d>>=1;
		}
		return res;
	}
};
struct SAM
{
	int trs[N][4],fa[N],len[N];
	int cnt,last;
	void init(){cnt=last=1;}
	void insert(int x)
	{
		int p,newp,q,newq;
		p = last,newp = ++cnt;
		last = newp,len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)fa[newp] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[newp] = q;
			else
			{
				newq = ++cnt;
				fa[newq] = fa[q];
				len[newq] = len[p]+1;
				memcpy(trs[newq],trs[q],sizeof(trs[q]));
				fa[newp] = fa[q] = newq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x] = newq;
			}
		}
	}
	ll mn[N][4];
	bool vis[N];
	void dfs(int x)
	{
		vis[x] = true;
		for(int i = 0;i<4;i++)
		{
			if(!vis[trs[x][i]])dfs(trs[x][i]);
			if(trs[x][i])mn[x][i] = INF;
			else mn[x][i]=1;
		}
		for(int i = 0;i<4;i++)if(trs[x][i])
			for(int j = 0;j<4;j++)
				mn[x][j] = min(mn[x][j],mn[trs[x][i]][j]+1);
	}	
}sam;
Matrix go;
bool check(ll x)
{
	Matrix ans = quick_pow(go,x);
	for(int i= 0;i<4;i++)
		for(int j = 0;j<4;j++)
			if(ans.d[i][j]+1<=n)return true;
	return false;
}
int main()
{
	scanf("%lld",&n);
	scanf("%s",s+1);
	sam.init();
	sam.vis[0] = true;
	for(int i = 1;s[i];i++)
		sam.insert(s[i]-'A');
	sam.dfs(1);
	for(int i = 0;i<4;i++)
		for(int j = 0;j<4;j++)
			go.d[i][j] = sam.mn[sam.trs[1][i]][j];
	ll l = 0,r = n+1,ans=0;
	while(l<=r)
	{
		ll mid = (l+r)>>1;
		if(check(mid))l=mid+1;
		else r = mid-1,ans = mid;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4195

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int fa[N<<1];
int idx[N<<1],cnt;
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
}
void init()
{
	for(int i = 1;i<= cnt;i++)fa[i]=i;
}
struct seg
{
	int x,y,o;
}a[N];
int find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(idx[mid]<=x)l=mid+1;
		else r = mid;
	}
	return l-1;
}
int main()
{
	int cas;
	int n;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d",&n);
		cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].o);
			idx[++cnt]=a[i].x,idx[++cnt]=a[i].y;
		}
		sort(idx+1,idx+cnt+1);
		int tmp = cnt;cnt = 0;
		for(int i = 1;i<= tmp;i++)
			if(i==1||idx[i]!=idx[i-1])
				idx[++cnt] = idx[i];
		init();
		for(int i = 1;i<= n;i++)
			if(a[i].o)uni(find(a[i].x),find(a[i].y));
		bool flag = true;
		for(int i = 1;i<= n&&flag;i++)
			if(a[i].o==0)
			{
				if(getfa(find(a[i].x))==getfa(find(a[i].y)))
					flag = false;
			}
		if(flag)puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem4196

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
struct E
{int next,to;}e[N<<1];
int head[N],tot,cnt;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int top[N],deep[N],fa[N],w[N],size[N],son[N],t[N];
int sum[N<<2],f[N<<2],n;
bool v[N];
void dfs1(int x,int dep)
{
	v[x] = true;
	deep[x] = dep;
	size[x]++;
	for(int i = head[x];i;i = e[i].next)
	{
		int tmp = e[i].to;
		if(!v[tmp])
		{
			dfs1(tmp,dep+1);
			size[x]+=size[tmp];
			if(size[tmp]>size[son[x]])son[x] = tmp;
			fa[tmp] = x;
		}
	}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	w[x] = ++cnt;
	if(son[x]!=n)dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
	t[x] = cnt;
}
void push_down(int p,int l,int r)
{
	int mid = (l+r)>>1;
	sum[p] = (r-l+1)*f[p];
	f[p<<1] = f[p];
	sum[p<<1] = f[p]*(mid-l+1);
	f[(p<<1)+1] = f[p];
	sum[(p<<1)+1] = f[p]*(r-mid);
	f[p] = -1;
}
void update(int p,int l,int r,int a,int b,int c)
{
	if(l>=a&&r<=b){f[p] =c;sum[p] = (r-l+1)*f[p];return ;}
	if(f[p]!=-1)push_down(p,l,r);
	int mid = (l+r)>>1;
	if(a<= mid)
		update(p<<1,l,mid,a,b,c);
	if(b>mid)
		update((p<<1)+1,mid+1,r,a,b,c);
	sum[p] = sum[p<<1]+sum[(p<<1)+1];
}
int getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	if(f[p]!=-1)push_down(p,l,r);
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans((p<<1)+1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans((p<<1)+1,mid+1,r,a,b);
}
int t_ans;
void get_update(int x,int y,int c,int opt)
{
	while(top[x]!=top[y])
	{
		if(deep[x]<deep[y])swap(x,y);
		if(opt==1)update(1,1,n,w[top[x]],w[x],c);
		else t_ans+=getans(1,1,n,w[top[x]],w[x]);
		x = fa[top[x]];
	}
	if(deep[x]<deep[y])swap(x,y);
	if(opt==1)update(1,1,n,w[y],w[x],c);
	else t_ans+=getans(1,1,n,w[y],w[x]);
}
int main()
{
	memset(f,-1,sizeof(f));
	int x;
	scanf("%d",&n);
	for(int i = 0;i< n;i++)
		son[i] = n;
	for(int i = 1;i< n;i++)
		{scanf("%d",&x);add(x,i);}
	dfs1(0,1);
	dfs2(0,0);
	char j[20];
	int q,tmp1,tmp2;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d",j,&x);
		if(j[0]=='i')
		{
			t_ans = 0;
			get_update(0,x,0,0);
			tmp1 = t_ans;
			get_update(0,x,1,1);
			t_ans = 0;
			get_update(0,x,0,0);
			printf("%d\n",t_ans-tmp1);
		}else
		{
			tmp1= getans(1,1,n,w[x],t[x]);
			update(1,1,n,w[x],t[x],0);
			tmp2 = getans(1,1,n,w[x],t[x]);
			printf("%d\n",tmp1-tmp2);
		}
	}
	return 0;
}
Problem4197

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
const int S = 1<<8;
int prime[N],cnt;
bool vis[N];
void quick_prime()
{
	for(int i = 2;i<=500;i++)
	{
		if(!vis[i])
			prime[cnt++] = i;
		for(int j = 0;j<cnt&&i*prime[j]<=500;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
struct Num
{
	int l,p,i;
	bool operator <(const Num &s)const
	{
		return p<s.p;
	}
}num[N];
int f[S][S],dp[S][S][2];
void calc(int x)
{
	int tmp = x;
	for(int i = 0;i<8;i++)
		if(tmp%prime[i]==0)
		{
			num[x].l|=1<<i;
			while(tmp%prime[i]==0)tmp/=prime[i];
		}
	num[x].p = tmp;
}
int main()
{
	int n,mod;
	quick_prime();
	scanf("%d%d",&n,&mod);
	for(int i = 2;i<= n;i++)
		calc(i);
	sort(num+2,num+n+1);
	f[0][0] = 1;
	int end = (1<<8)-1,i,j,k;
	for(i = 2;i<= n;i++)
	{
		if(i==2||num[i].p==1||num[i-1].p!=num[i].p)
			for(j = end;j>=0;j--)
				for(k = end;k>=0;k--)
					dp[j][k][0]=dp[j][k][1]=f[j][k];
		for(j = end;j>=0;j--)
			for(k = end;k>=0;k--)
			{
				if((j&num[i].l)==0)
					(dp[j][k|num[i].l][1]+=dp[j][k][1])%=mod;
				if((k&num[i].l)==0)
					(dp[j|num[i].l][k][0]+=dp[j][k][0])%=mod;
			}
		if(i==n||num[i].p==1||num[i].p!=num[i+1].p)
			for(j = end;j>=0;j--)
				for(k = end;k>=0;k--)
				{
					f[j][k] = dp[j][k][0]+dp[j][k][1]-f[j][k];
					f[j][k] = (f[j][k]%mod+mod)%mod;
				}
	}
	int ans = 0;
	for(j = 0;j<=end;j++)
		for(k = 0;k<=end;k++)
			if((j&k)==0)(ans+=f[j][k])%=mod;
	printf("%d\n",ans);
	return 0;
}
Problem4198

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
struct Heap
{
	ll w;int l;
	Heap(){}
	Heap(ll _w,int _l):w(_w),l(_l)
	{}
	bool operator <(const Heap &s)const
	{
		if(w!=s.w)return s.w<w;
		else return s.l<l;
	}
};
priority_queue<Heap>heap;
int n,k,nn;
ll ans = 0;
int main()
{
	scanf("%d%d",&n,&k);
	nn = n;ll x;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&x);
		heap.push(Heap(x,1));
	}
	if((n-1)%(k-1))nn+=(k-1)-(n-1)%(k-1);
	for(int i = n+1;i<= nn;i++)
		heap.push(Heap(0,1));
	while(nn>1)
	{
		ll s1 = 0;int s2 = 0;
		for(int i = 1;i<= k;i++)
		{
			Heap x = heap.top();
			heap.pop();
			s1+=x.w;s2=max(s2,x.l);
		}
		ans+=s1,nn-=(k-1);
		heap.push(Heap(s1,s2+1));
	}
	printf("%lld\n%d\n",ans,heap.top().l-1);
	return 0;
}
Problem4199

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
typedef long long ll;
const int INF = 2e9;
char s[N];
int fa[N],mx[N],mn[N],cnt[N];
int sa[N],c[N],v[N],nv[N],q[N],h[N],rk[N];
ll ans,tot;
bool is_same(int a,int b,int hl,int len)
{
	return v[a]==v[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&v[a+hl]==v[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i=0;i<lim;i++)c[i]=0;
	for(i=0;i<len;i++)c[v[i]=s[i]-'a']++;
	for(i=1;i<lim;i++)c[i]+=c[i-1];
	for(i=len-1;i>=0;i--)sa[--c[v[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i=len-hl;i<len;i++)q[id++]=i;
		for(i=0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;

		for(i=0;i<lim;i++)c[i]=0;
		for(i=0;i<len;i++)c[v[q[i]]]++;
		for(i=1;i<lim;i++)c[i]+=c[i-1];
		for(i=len-1;i>=0;i--)sa[--c[v[q[i]]]]=q[i];

		lim = 0;
		for(i=0;i<len;lim++)
		{
			for(j=i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		for(i=0;i<len;i++)v[i]=nv[i];
		if(lim==len)break;
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rk[i])
		{
			int j = 0;
			if(i)j = max(0,h[rk[i-1]]-1);
			while(i+j<len&&sa[rk[i]-1]+j<len&&s[i+j]==s[sa[rk[i]-1]+j])j++;
			h[rk[i]]=j;
		}
}
int a[N];
void init(int len)
{
	for(int i = 0;i< len;i++)
		fa[i]=i,mx[i]=mn[i]=a[sa[i]],cnt[i]=1;
}
vector<int>Q[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(x>y)swap(x,y);
	ll tmp = max(1ll*mx[x]*mx[y],1ll*mn[x]*mn[y]);
	if(tmp>ans||!tot)ans = tmp;
	tot+=1ll*cnt[x]*cnt[y];
	fa[y] = x;
	mx[x] = max(mx[x],mx[y]),mn[x]=min(mn[x],mn[y]);
	cnt[x]+=cnt[y];
}
ll Ans[N][2];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s);
	for(int i = 0;i<n;i++)scanf("%d",&a[i]);
	build_sa(n,26);
	build_rank(n);
	build_height(n);
	init(n);
	for(int i = 1;i<=n;i++)
		Q[h[i]].push_back(i);
	for(int i = n-1;i>=0;i--)
	{
		for(int j = 0;j<Q[i].size();j++)
			uni(Q[i][j],Q[i][j]-1);
		Ans[i][0] = tot,Ans[i][1] = ans;
	}
	for(int i = 0;i<n;i++)
		printf("%lld %lld\n",Ans[i][0],Ans[i][1]);
	return 0;
}
Problem4199

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 300005;
typedef long long ll;
int sa[N],cnt[N],val[N],nv[N],q[N],h[N],rnk[N];
char s[N];
bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int lim,int len)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i]=0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]-'a']++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]]=i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++]=sa[i]-hl;
		
		for(i =0;i<lim;i++)cnt[i]=0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]]=q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k=i,i=j+1;k<=j;k++)nv[sa[k]]=lim;
		}
		if(lim==len)return ;
		for(i = 0;i<len;i++)val[i] = nv[i];
	}
}
void build_rank(int len)
{
	for(int i = 0;i<len;i++)
		rnk[sa[i]]=i;
}
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(0,h[rnk[i-1]]-1);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])
				j++;
			h[rnk[i]]=j;
		}
}
int fa[N],size[N],n;
ll mx[N],mn[N],a[N];
ll tot,ans;
ll Ans[N][2];
void init()
{
	for(int i = 0;i<n;i++)
		fa[i]=i,mx[i]=mn[i]=a[sa[i]],size[i]=1;
}
int getfa(int x)
{
	if(fa[x]==x)return fa[x];
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(x>y)swap(x,y);
	ll tmp = max(mx[x]*mx[y],mn[x]*mn[y]);
	if(tmp>ans||!tot)ans = tmp;
	tot+=(ll)size[x]*size[y];
	fa[y] = x;
	mx[x] = max(mx[x],mx[y]),mn[x] =min(mn[x],mn[y]);
	size[x] = size[x]+size[y];
}
vector<int>Q[N];
int main()
{
	scanf("%d",&n);scanf("%s",s);
	for(int i = 0;i<n;i++)scanf("%lld",&a[i]);
	build_sa(26,n);
	build_rank(n);
	build_height(n);
	init();
	for(int i = 1;i<=n;i++)
		Q[h[i]].push_back(i);
	for(int i = n-1;i>= 0;i--)
	{
		for(int j = 0;j<Q[i].size();j++)
			uni(Q[i][j],Q[i][j]-1);
		Ans[i][0]=tot,Ans[i][1] = ans;
	}
	for(int i = 0;i<n;i++)
		printf("%lld %lld\n",Ans[i][0],Ans[i][1]);
	return 0;
}
Problem4200

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+10;
const int S = 5e4+3,T = 5e4+4,SS = 5e4+1,TT = 5e4+2;
const int M = 5e5+5;
const int INF = 0x3f3f3f3f;
struct P
{
	int x,y,id;
}p[N];
inline bool cmp1(const P &a,const P &b)
{return a.x+a.y==b.x+b.y?a.y<b.y:a.x+a.y<b.x+b.y;}
inline bool cmp2(const P &a,const P &b)
{return a.x-a.y==b.x-b.y?a.y<b.y:a.x-a.y<b.x-b.y;}
inline bool cmp3(const P &a,const P &b)
{return a.x==b.x?a.y<b.y:a.x<b.x;}
inline bool cmp4(const P &a,const P &b)
{return a.y==b.y?a.x<b.x:a.y<b.y;}
int s[N],t1[N],t2[N],t3[N],f[N],ff[N],l[N],r[N],lf[N],rf[N],a[N],an;
vector<int>v,t[N];
namespace Max_Flow
{
	queue<int>Q;
	struct E
	{int next,to,f;}e[M];
	int head[N],_head[N],tot,d[N];
	void add(int x,int y,int f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f=f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f=0;
	}
	bool bfs(int s,int t)
	{
		memset(d,-1,sizeof(d));
		d[s] = 0;Q.push(s);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int i = head[x];i;i=e[i].next)
				if(e[i].f&&d[e[i].to]==-1)
				{
					d[e[i].to] = d[x]+1;
					Q.push(e[i].to);
				}
		}
		memcpy(_head,head,sizeof(head));
		return d[t]!=-1;
	}
	int get_mxf(int s,int t,int mx)
	{
		if(s==t)return mx;
		int last = mx;
		for(int &i = _head[s];i;i=e[i].next)
			if(e[i].f&&d[e[i].to]==d[s]+1)
			{
				int tof = get_mxf(e[i].to,t,min(last,e[i].f));
				if(tof)
				{
					e[i].f-=tof;e[i^1].f+=tof;
					if(!(last-=tof))return mx;
				}
			}
		d[s] = -1;
		return mx-last;
	}
	int dinic(int s,int t)
	{
		int ans = 0;
		while(bfs(s,t))
			ans+=get_mxf(s,t,INF);
		return ans;
	}
}
void update(int x,int y)
{
	if(ff[y]+1>f[x])f[x]=ff[y]+1,t[x].clear();
	if(ff[y]+1==f[x])t[x].push_back(y);
}
void getans(int x)
{
	a[++an] = x;
	int i,j,u=1;
	if(f[x]==ff[x])
	{
		u = 0;
		if(p[x].id)getans(t[x][0]);
	}
	for(i=l[x];u&&i<x;i++)if(f[i]+x-l[x]==ff[x])
	{
		u=0;
        for(j=x;--j>i;)a[++an]=j;
        for(j=l[x];j<=i;++j)a[++an]=j;
        if(p[i].id)getans(t[i][0]);
	}
	for(i=r[i];u&&i>x;--i)if(f[i]+r[x]-x==ff[x])
	{
        u=0;
        for(j=x;++j<i;)a[++an]=j;
        for(j=r[x];j>=i;--j)a[++an]=j;
        if(p[i].id)getans(t[i][0]);
	}
}
int d[N],u[N],c[N];
void Insert(int x,int y)
{
	Max_Flow::add(x,y,INF);
	c[x]++,c[y]--;
}
void dfs(int x)
{
    if(d[x])return;
    int i,j;d[x]=1;
    if(f[x]==ff[x]&&!u[x])
    	for(u[x]=1,i=0;i<t[x].size();++i)
    		Insert(t[x][i],x),dfs(t[x][i]);
    for(i=l[x];i<x;++i)
    	if(f[i]+x-l[x]==ff[x]&&!u[i])
    		for(u[i]=1,j=0;j<t[i].size();++j)
    			Insert(t[i][j],i),dfs(t[i][j]);
    for(i=r[x];i>x;--i)
    	if(f[i]+r[x]-x==ff[x]&&!u[i])
    		for(u[i]=1,j=0;j<t[i].size();++j)
    			Insert(t[i][j],i),dfs(t[i][j]);
}
int main()
{
	int n,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		p[i].id = i;
	}
	sort(p,p+n+1,cmp1);
	for(int i = 0;i<n;i++)if(p[i].x+p[i].y==p[i+1].x+p[i+1].y)t1[p[i].id]=p[i+1].id;
	sort(p,p+n+1,cmp2);
	for(int i = 0;i<n;i++)if(p[i].x-p[i].y==p[i+1].x-p[i+1].y)t2[p[i].id]=p[i+1].id;
	sort(p,p+n+1,cmp3);
	for(int i = 0;i<n;i++)if(p[i].x==p[i+1].x)t3[p[i].id] = p[i+1].id;
	sort(p,p+n+1,cmp4);for(int i = 0;i<= n;i++)s[p[i].id] = i;
	memset(f,0xef,sizeof(f));
	f[s[0]] = 0;
	for(int i = 0;i<= n;i=r[i]+1)
	{
		for(l[i]=r[i]=i;r[i]<n&&p[r[i]].y==p[r[i]+1].y;++r[i]);
		for(int j = l[i];++j<=r[i];)
			l[j]=l[i],r[j]=r[i];
		lf[l[i]] = -INF;
		for(int j = l[i];++j<=r[i];)lf[j] = max(lf[j-1],f[j-1]);
		rf[r[i]] = -INF;
		for(int j = r[i];--j>=l[i];)rf[j] = max(rf[j+1],f[j+1]);
		for(int j = l[i];j<=r[i];j++)
		{
			ff[j] = max(f[j],max(lf[j]+j-l[i],rf[j]+r[i]-j));
			if(t1[p[j].id])update(s[t1[p[j].id]],j);
			if(t2[p[j].id])update(s[t2[p[j].id]],j);
			if(t3[p[j].id])update(s[t3[p[j].id]],j);
			if(ff[j]>ans)ans=ff[j],v.clear();
			if(ff[j]==ans)v.push_back(j);
		}
	}
	Max_Flow::tot = 1;
	printf("%d\n",ans);
	getans(v[0]);
	for(int i = an;--i;)
		printf("%d ",p[a[i]].id);
	printf("\n");
	for(int i = 0;i<v.size();i++)dfs(v[i]);
	for(int i = 0;i<= n;i++)
	{
		if(c[i]<0)Max_Flow::add(S,i,-c[i]);
		if(c[i]>0)Max_Flow::add(i,T,c[i]);
		Max_Flow::add(SS,i,INF),Max_Flow::add(i,TT,INF);
	}
	Max_Flow::dinic(S,T);
	Max_Flow::add(TT,SS,INF);
	printf("%d\n",Max_Flow::dinic(S,T));
	return 0;
}
Problem4205

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 7e4+5;
const int M = 4e6+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M];
int head[N],_head[N],tot = 1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	for(int i = s;i<= t;i++)d[i]=-1;
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(e[i^1].f&&d[e[i].to]==-1)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	if(d[s]==-1)return false;
	memcpy(_head,head,sizeof(head));
	return true;
}
int get_mxf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last=mf;
	for(int i = _head[s];i;i=e[i].next)
	{
		_head[s] = i;
		if(e[i].f&&d[e[i].to]==d[s]-1)
		{
			int tof = get_mxf(e[i].to,t,min(e[i].f,last));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mf;
			}
		}
	}
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
const int P = 205;
bool vis[P];
int prime[P],cnt;
vector<int>fac[P];
int id[50][50];
void quick_prime()
{
	for(int i = 2;i<=200;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<=200;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = prime[i];j<=200;j+=prime[i])
			fac[j].push_back(i);
	}
}
struct Card
{int a,b,c;}c0[30005],c1[30005];
int S,T;
int n1,n2;
void build(int no,int tp)
{
	int a,b,c;
	if(tp)a = c1[no].a,b = c1[no].b,c = c1[no].c;
	else a = c0[no].a,b = c0[no].b,c = c0[no].c;
	for(int i = 0;i<fac[a].size();i++)
		for(int j = 0;j<fac[b].size();j++)
			if(tp)add(id[fac[a][i]][fac[b][j]]+n1+n2,n1+no,1);
			else add(no,id[fac[a][i]][fac[b][j]]+n1+n2,1);
	for(int i = 0;i<fac[a].size();i++)
		for(int j = 0;j<fac[c].size();j++)
			if(tp)add(id[fac[a][i]][fac[c][j]]+cnt*cnt+n1+n2,n1+no,1);
			else add(no,id[fac[a][i]][fac[c][j]]+cnt*cnt+n1+n2,1);
	for(int i = 0;i<fac[b].size();i++)
		for(int j = 0;j<fac[c].size();j++)
			if(tp)add(id[fac[b][i]][fac[c][j]]+cnt*cnt*2+n1+n2,n1+no,1);
			else add(no,id[fac[b][i]][fac[c][j]]+cnt*cnt*2+n1+n2,1);
}
int main()
{
	scanf("%d%d",&n1,&n2);
	quick_prime();
	int Id = 0;
	for(int i = 1;i<= cnt;i++)
		for(int j = 1;j<= cnt;j++)
			id[i][j] = ++Id;
	S = 0,T = n1+n2+3*Id+1;
	for(int i = 1;i<= n1;i++)
		scanf("%d%d%d",&c0[i].a,&c0[i].b,&c0[i].c);
	for(int i = 1;i<= n2;i++)
		scanf("%d%d%d",&c1[i].a,&c1[i].b,&c1[i].c);
	for(int i = 1;i<= n1;i++)
		add(S,i,1),build(i,0);
	for(int i = 1;i<= n2;i++)
		add(i+n1,T,1),build(i,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem4206

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 2005;
const double PI = acos(-1.0);
const double INF = 1e18;
double R,x,y,len,ang1,ang2;
double stack[N];
int top;
struct Point
{
	double x,y;
	bool flag;
	bool operator <(const Point &s)const
	{
		if(flag==s.flag)
		{
			if(x==s.x)return y<s.y;
			return x<s.x;
		}
		return flag<s.flag;
	}
}p[N];
double getdis(double x,double y)
{
	return sqrt(x*x+y*y);
}
int Find(double x)
{
	int l = 0,r = top,ans = 0;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(stack[mid]>=x)ans = mid,r = mid-1;
		else l = mid+1;
	}
	return ans;
}
int main()
{
	int n;
	scanf("%d%lf",&n,&R);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf",&p[i].x,&p[i].y);
		if(getdis(p[i].x,p[i].y)<R)
		{
			p[i].flag = true;
			continue;
		}
		ang1 = atan2(p[i].y,p[i].x),ang2 = acos(R/getdis(p[i].x,p[i].y));
		p[i].x = ang1-ang2;p[i].y = ang1+ang2;
		if(p[i].y>PI)p[i].y-=PI*2,swap(p[i].x,p[i].y);
		if(p[i].x<-PI)p[i].x+=PI*2,swap(p[i].x,p[i].y);
	}
	sort(p+1,p+n+1);
	for(int i = 1;i<= n;i++)
		if(p[i].flag)
			{n = i-1;break;}
	stack[0] = -INF;
	int ans = 0;
	for(int i = 1;i<= n;i++)
	{
		stack[top=1]=p[i].y;
		for(int j = i+1;j<= n;j++)
		{
			if(p[j].x>p[i].y)break;
			if(p[j].y>stack[top])
				stack[++top] = p[j].y;
			else
			{
				int tmp = Find(p[j].y);
				if(tmp!=1)stack[tmp]=p[j].y;
			}
		}
		ans = max(ans,top);
	}
	printf("%d\n",ans);
	return 0;
}
Problem4212

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Lth = 2000005;
const int N = 2005;
char s[Lth],s1[Lth],s2[Lth];
struct STR{int bg,ed;}str[N];
int trie[Lth][26],Max[Lth],Min[Lth],root[Lth],tot;
struct Trie
{
	int ch[Lth][26],sum[Lth],cnt;
	int insert(int id,int pre)
	{
		int tmp,y;
		tmp = y = ++cnt;
		for(int i = str[id].ed;i>=str[id].bg;i--)
		{
			for(int j = 0;j<26;j++)ch[y][j]=ch[pre][j];
			sum[y] = sum[pre]+1;
			int p = s[i]-'a';
			pre = ch[pre][p];
			ch[y][p] = ++cnt;
			y = ch[y][p];
		}
		sum[y] = sum[pre]+1;
		return tmp;
	}
	int getans(int L,int R,int lth)
	{
		for(int i = lth;i>=1;i--)
		{
			//fprintf(stderr, "%d %d\n",L,R);
			L = ch[L][s2[i]-'a'],R = ch[R][s2[i]-'a'];
		}
		return sum[R]-sum[L];
	}
}tr;
bool cmp(const STR &a,const STR &b)
{
	int p1 = a.bg,p2 = b.bg;
	while(p1<=a.ed&&p2<=b.ed)
	{
		if(s[p1]<s[p2])return true;
		else if(s[p1]>s[p2])return false;
		p1++,p2++;
	}
	if (p1<=a.ed) return 0;
	else if (p2<=b.ed) return 1;
	else return 0;
}
char tmp[Lth];
int main()
{
	//freopen("x.in","r",stdin);
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",tmp+1);
		str[i].bg = str[i-1].ed+1;
		str[i].ed = str[i].bg+strlen(tmp+1)-1;
		for(int j = str[i].bg;j<=str[i].ed;j++)s[j]=tmp[j-str[i].bg+1];
	}
	sort(str+1,str+n+1,cmp);
	for(int i = 1;i<= n;i++)
	{
		int now = 0;
		for(int j = str[i].bg;j<= str[i].ed;j++)
		{
			int p = s[j]-'a';
			if(!trie[now][p])trie[now][p] = ++tot;
			now = trie[now][p];
			if(Min[now]==0)Min[now] = i;
			Max[now] = max(Max[now],i);
		}
	}
	for(int i = 1;i<= n;i++)
		root[i] = tr.insert(i,root[i-1]);
	int ans = 0;
	int m;
	scanf("%d",&m);
	while(m--)
	{
		scanf("%s",s1+1);int lth1 = strlen(s1+1);
		scanf("%s",s2+1);int lth2 = strlen(s2+1);
		for(int i = 1;i<= lth1;i++)s1[i] = (s1[i]-'a'+ans)%26+'a';
		for(int i = 1;i<= lth2;i++)s2[i] = (s2[i]-'a'+ans)%26+'a';
		int now = 0,l = -1,r = -1;
		for(int i = 1;i<= lth1;i++)
		{
			int p = s1[i]-'a';
			if(!trie[now][p])break;
			now = trie[now][p];
			if(i==lth1){l=Min[now],r=Max[now];}
		}
		if(l==-1&&r==-1){ans = 0;printf("%d\n",ans);continue;}
		ans = tr.getans(root[l-1],root[r],lth2);
		printf("%d\n",ans);
	}
	return 0;
}
Problem4227

#include <stdio.h>
#include <queue>
#include <vector>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 3e5+5;
const int M = 8e5+5;
struct E{int next,to,val;};
struct Edge{int x,y,f;}a[M];
ll dis[N];
bool vis[N];
queue<int>Q;
E e[M];
int head[N],tot,deg[N],n,m,id[N],cnt;
void add(int x,int y,int f=0)
{e[++tot].to=y;e[tot].next=head[x];e[tot].val=f;head[x]=tot;deg[y]++;}
void spfa(int s)
{
	memset(dis,0x3f,sizeof(dis));
	dis[s] = 0;vis[s] = true;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].val)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(!vis[e[i].to])
				{
					vis[e[i].to]=true;
					Q.push(e[i].to);
				}
			}
	}
}
int dep[N],fa[N][18],size[N],sum[M];
void rebuild()
{
	memset(head,0,sizeof(head));
	memset(deg,0,sizeof(deg));
	tot = 0;cnt = n;
	for(int i = 1;i<= n;i++)size[i]=dis[i]<dis[0];
	for(int i = 1;i<= m;i++)
	{
		if(dis[a[i].x]+a[i].f==dis[a[i].y])
			id[++cnt]=i,add(a[i].x,cnt),add(cnt,a[i].y);
		if(dis[a[i].y]+a[i].f==dis[a[i].x])
			id[++cnt]=i,add(a[i].y,cnt),add(cnt,a[i].x);
	}
	for(int i = 1;i<= cnt;i++)
		if(!deg[i])
			add(cnt+1,i);
	cnt++;
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
vector<int>E[N];
void dfs(int x)
{
	for(int i = 0;i<E[x].size();i++)
	{
		dfs(E[x][i]);
		size[x]+=size[E[x][i]];
	}
	sum[id[x]]=size[x];
}
ll ans[N];
int main()
{
	int s;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].f);
		add(a[i].x,a[i].y,a[i].f),add(a[i].y,a[i].x,a[i].f);
	}
	scanf("%d",&s);
	spfa(s);
	rebuild();
	Q.push(cnt);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		if(fa[x][0])E[fa[x][0]].push_back(x);
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<18;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
		for(int i = head[x];i;i=e[i].next)
		{
			if(!fa[e[i].to][0])fa[e[i].to][0]=x;
			else fa[e[i].to][0]=getlca(fa[e[i].to][0],x);
			if(!--deg[e[i].to])Q.push(e[i].to);
		}	
	}
	dfs(cnt);
	for(int i = 1;i<= m;i++)
		ans[a[i].x]+=sum[i],ans[a[i].y]+=sum[i];
	for(int i = 1;i<= n;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem4237

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 2e9;
struct P
{
	int x,y;
}a[N],q1[N],q2[N];
bool cmpy(const P &a,const P &b)
{
	return a.y>b.y;
}
bool cmpx(const P &a,const P &b)
{
	return a.x<b.x;
}
long long ans;
int find(int x,int lim)
{
	int l = 1,r = lim;
	while(l<=r)
	{
		int mid = (l+r)>>1;
		if(q1[mid].y<=x)r = mid-1;
		else l = mid+1;
	}
	return r;
}
void CDQ(int l,int r)
{
	int mid = (l+r)>>1;
	if(l==r)return ;
	CDQ(l,mid);
	sort(a+l,a+mid+1,cmpy);
	sort(a+mid+1,a+r+1,cmpy);
	int top1 = 0,top2 = 0,p = mid+1;
	q1[0].y = q2[0].y = INF;
	int ll,rr;
	for(int i = l;i<=mid;i++)
	{
		while(p<=r&&a[p].y>a[i].y)
		{
			while(top1&&a[p].x<q1[top1].x)
				top1--;
			q1[++top1] = a[p];
			p++;
		}
		while(top2&&a[i].x>q2[top2].x)
			top2--;
		q2[++top2] = a[i];
		ll = find(q2[top2-1].y,top1)+1;
		rr = find(q2[top2].y,top1);
		if(ll<=rr)
			ans+=rr-ll+1;
	}
	sort(a+l,a+mid+1,cmpx);
	sort(a+mid+1,a+r+1,cmpx);
	CDQ(mid+1,r);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<= n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,cmpx);
	CDQ(1,n);
	printf("%lld\n",ans);
	return 0;
}
Problem4238

#include<stdio.h>
#include<string.h>
#include<algorithm>
#define N 110000
#define M 210000
using namespace std;
int next[M<<1],to[M<<1],head[N],tot=1;
int deep[N],fa[N],good[N],bad[N],gc,bc;
bool vis[N];
void add(int x,int y)
{
  to[++tot]=y;
  next[tot]=head[x];
  head[x]=tot;
}
void dfs(int x,int pre)
{
  deep[x]=deep[fa[x]]+1,vis[x]=1;
  int i;
  for(i=head[x];i;i=next[i])
  {
    if((i^1)==pre)  continue;
    if(!vis[to[i]])
    {
      fa[to[i]]=x;
      dfs(to[i],i);
      good[x]+=good[to[i]];
      bad[x]+=bad[to[i]];
    }
    else
    {
      if(deep[to[i]]>deep[x]) continue;
      if(deep[x]-deep[to[i]]&1)
        good[x]++,good[to[i]]--,gc++;
      else
        bad[x]++,bad[to[i]]--,bc++;
    }
  }
}
int main()
{
  int n,m,i,j,k,x,y,ans;
  scanf("%d%d",&n,&m);
  for(i=1;i<=m;i++)
  {
    scanf("%d%d",&x,&y);
    add(x,y),add(y,x);
  }
  for(i=1;i<=n;i++)
  {
    if(!vis[i])
      dfs(i,0);
  }
  for(i=1,ans=0;i<=n;i++)
  {
    if(fa[i]&&bad[i]==bc&&!good[i])
      ans++;
  }
  if(bc==1)
    ans++;
  printf("%d\n",ans);
  return 0;
}
Problem4243

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 2e5+5;
struct E
{int next,to;}e[M<<1];
int head1[N],head2[N],tot;
void add1(int x,int y){e[++tot].to=y;e[tot].next=head1[x];head1[x]=tot;}
void add2(int x,int y){e[++tot].to=y;e[tot].next=head2[x];head2[x]=tot;}
int fa[N],size[N],outd[N];
bool bo[N];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(size[x]<size[y])swap(x,y);
	fa[y] = x;size[x]+=size[y];
}
queue<int>Q;
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add1(x,y),add2(y,x),outd[x]++;
	}
	for(int i = 1;i<= n;i++)fa[i]=i,size[i]=1;
	for(int i = 1;i<= n;i++)
	{
		for(int id = head1[i];id;id=e[id].next)bo[e[id].to]=true;
		for(int id = head2[i];id;id=e[id].next)
			if(bo[e[id].to])merge(i,e[id].to);
		for(int id = head1[i];id;id=e[id].next)bo[e[id].to]=false;
	}
	for(int i = 1;i<= n;i++)
	{
		int y = 0;
		for(int id = head1[i];id;id=e[id].next)
			if(y)merge(y,e[id].to);
			else y = e[id].to;
	}
	memset(bo,true,sizeof(bo));
	for(int i = 1;i<= n;i++)
		if(size[getfa(i)]>1)Q.push(i),bo[i]=false;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head1[x];i;i=e[i].next)
		{
			merge(x,e[i].to);
			if(bo[e[i].to]){bo[e[i].to]=false;Q.push(e[i].to);}
		}
	}
	long long ans = 0;
	for(int i = 1;i<= n;i++)
		if(getfa(i)==i)
		{
			if(size[i]>1)ans+=(long long)size[i]*(size[i]-1);
			else ans+=outd[i];
		}
	printf("%lld\n",ans);
	return 0;
}
Problem4246

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define fir first
#define sec second
typedef long long ll;
const double eps = 1e-10;
const int N = 3005;
const double PI = 3.1415926535897323;
int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	if(x>0)return 1;else return -1;
}
struct Point
{
	int x,y;
	Point(int _x=0,int _y=0):x(_x),y(_y){}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double arctan2(const Point &p)
	{
		double ang = atan2(p.y,p.x);
		if(ang<=0)return ang+PI;
		else return ang;
	}
}O;
pair<Point,int>point[N],stack[N];
int top;
ll ans;
void calc(int c)
{
	static pair<double,int>b[N];
	bool v[N];
	static pair<Point,int>_stack[N];
	int cnt[2][3]={};
	for(int i = 1;i<= top;i++)
		b[i] = make_pair(arctan2(stack[i].fir-O),i);
	sort(b+1,b+top+1);
	for(int i = 1;i<= top;i++)
		_stack[i]=stack[b[i].sec];
	memcpy(stack+1,_stack+1,sizeof(stack[0])*top);
	for(int i = 1;i<= top;i++)
	{
		if(stack[i].fir.y<O.y||stack[i].fir.y==O.y&&stack[i].fir.x>O.x)
			cnt[v[i]=false][stack[i].sec]++;
		else 
			cnt[v[i]=true][stack[i].sec]++;
	}
	int cnt0,cnt1;
	for(int i = 1;i<= top;i++)
	{
		cnt[v[i]][stack[i].sec]--;
		cnt0 = (c==0?1:cnt[0][0])*(c==1?1:cnt[0][1])*(c==2?1:cnt[0][2]);
		int C = stack[i].sec;
		cnt1 = (C==0?1:cnt[1][0])*(C==1?1:cnt[1][1])*(C==2?1:cnt[1][2]);
		//cnt0/=cnt[0][c],cnt1/=cnt[1][stack[i].sec];
		ans+=(ll)cnt0*cnt1;
		cnt0 = (c==0?1:cnt[1][0])*(c==1?1:cnt[1][1])*(c==2?1:cnt[1][2]);
		cnt1 = (C==0?1:cnt[0][0])*(C==1?1:cnt[0][1])*(C==2?1:cnt[0][2]);
		//cnt0/=cnt[1][c],cnt1/=cnt[0][stack[i].sec];
		ans+=(ll)cnt0*cnt1;
		cnt[v[i]^1][stack[i].sec]++;
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d%d",&point[i].fir.x,&point[i].fir.y,&point[i].sec);
	for(int i = 1;i<= n;i++)
	{
		top = 0;
		for(int j = 1;j<= n;j++)
			if(i!=j)
				stack[++top]=point[j];
		O = point[i].fir;
		calc(point[i].sec);
	}
	printf("%lld\n",ans>>2);
	return 0;
}
Problem4260

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e5+5;
const int M = 35*N;
struct Trie
{
	int ch[M][2],sum[M];
	int cnt;
	int insert(int x,int num)
	{
		int tmp,y;
		tmp=y=++cnt;
		for(int i = 30;i>=0;i--)
		{
			int t = num&(1<<i);t = t>>i;
			ch[y][0]=ch[x][0],ch[y][1]=ch[x][1];
			x = ch[x][t];
			y = ch[y][t]=++cnt;
			sum[y] = sum[x]+1;
		}
		return tmp;
	}
	int getans(int l,int r,int val)
	{
		int ans = 0;
		for(int i = 30;i>= 0;i--)
		{
			int t = val&(1<<i);t=t>>i;
			if(sum[ch[r][t^1]]-sum[ch[l][t^1]]>0)
				l=ch[l][t^1],r=ch[r][t^1],ans+=(1<<i);
			else l = ch[l][t],r=ch[r][t];
		}
		return ans;
	} 
}trie;
int z[N],y[N],a[N],root[N];
int main()
{
	int n;
	scanf("%d",&n);
	n++;
	a[1] = 0;
	for(int i = 2;i<= n;i++)
	{
		scanf("%d",&a[i]);
		a[i] = a[i-1]^a[i];
	}
	for(int i = 1;i<= n;i++)
		root[i] = trie.insert(root[i-1],a[i]);
	for(int i = 2;i<=n;i++)
	{
		z[i] = trie.getans(root[0],root[i],a[i]);
		y[i] = trie.getans(root[i-1],root[n],a[i]);
	}
	for(int i = 1;i<= n;i++)z[i] = max(z[i],z[i-1]);
	for(int i = n;i>= 1;i--)y[i] = max(y[i],y[i+1]);
	int ans = 0;
	for(int i = 2;i<=n;i++)
		ans = max(ans,z[i]+y[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4276

#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<iostream>
#define maxn 30010
#define maxm 200010
#define inf 1000000000

using namespace std;

struct yts
{
	int l,r,num;
}a[20010];

int head[maxn],to[maxm],c[maxm],len[maxm],next[maxm],p[maxm],fr[maxn],dis[maxn],q[maxn];
bool vis[maxn];
int n,m,s,t,num,ans,cnt;

void addedge(int x,int y,int z,int w)
{
	num++;to[num]=y;c[num]=z;len[num]=w;p[num]=x;next[num]=head[x];head[x]=num;
	num++;to[num]=x;c[num]=0;len[num]=-w;p[num]=y;next[num]=head[y];head[y]=num;
}

void build(int i,int l,int r)
{
	a[i].l=l;a[i].r=r;a[i].num=++cnt;
	if (l==r)
	{
		addedge(a[i].num,t,1,0);
		return;
	}
	int mid=(l+r)/2;
	build(i*2,l,mid);build(i*2+1,mid+1,r);
	addedge(a[i].num,a[i*2].num,inf,0);
	addedge(a[i].num,a[i*2+1].num,inf,0);
}

void query(int i,int l,int r,int x)
{
	if (l<=a[i].l && a[i].r<=r)
	{
		addedge(x,a[i].num,1,0);
		return;
	}
	int mid=(a[i].l+a[i].r)/2;
	if (l<=mid) query(i*2,l,r,x);
	if (mid<r) query(i*2+1,l,r,x);
} 

bool spfa()
{
	for (int i=s;i<=t;i++) dis[i]=-inf;
	int l=0,r=1;
	q[1]=s;dis[s]=0;vis[s]=1;
	while (l!=r)
	{
		l++;if (l==maxn) l=0;
		int x=q[l];
		for (int p=head[x];p;p=next[p])
		  if (c[p] && dis[x]+len[p]>dis[to[p]])
		  {
		  	dis[to[p]]=dis[x]+len[p];
		  	fr[to[p]]=p;
		  	if (!vis[to[p]])
		  	{
		  		r++;if (r==maxn) r=0;
		  		q[r]=to[p];vis[to[p]]=1;
		  	}
		  }
		vis[x]=0;
	}
	if (dis[t]==-inf) return 0; else return 1;
}

void mcf()
{
	int x=inf;
	for (int i=fr[t];i;i=fr[p[i]]) x=min(x,c[i]);
	for (int i=fr[t];i;i=fr[p[i]]) ans+=x*len[i],c[i]-=x,c[i^1]+=x;
}

void costflow()
{
	while (spfa()) mcf();
}

int main()
{
	scanf("%d",&n);
	num=1;s=0,t=30000;
	build(1,1,5000);
	for (int i=1;i<=n;i++)
	{
		int l,r,x;
		scanf("%d%d%d",&l,&r,&x);
		r--;
		addedge(s,++cnt,1,x);
		query(1,l,r,cnt);
	}
	costflow();
	printf("%d\n",ans);
	return 0;
}
Problem4291

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int a[N];
int main()
{
	int n;
	ll ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),ans+=a[i];
	sort(a+1,a+n+1);
	if(n==1)
	{
		if(a[1]%2==1)printf("NIESTETY\n");
		else printf("%d\n",a[1]);
	}
	else
	{
		if(ans%2==0)printf("%lld\n",ans);
		else
		{
			for(int i = 1;i<= n;i++)
				if(a[i]%2==1)
					{ans-=a[i];break;}
			printf("%lld\n",ans);
		}
	}
	return 0;
}
Problem4292

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
bool check(ll ans,int num)
{
	int tmp = 0;
	while(ans)
	{
		int k = ans%10;
		ans/=10;
		tmp +=k*k;
	}
	return tmp==num;
}
int main()
{
	ll k,a,b,ans=0;
	scanf("%lld%lld%lld",&k,&a,&b);
	for(int i = max(a/k-2,0ll);i<= min(b/k+2,1458ll);i++)
		if(check(k*i,i)&&k*i<=b&&k*i>=a)
			ans++;
	printf("%lld\n",ans);
	return 0;
}
Problem4293

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
struct Seg
{
	ll sum,v,lazy,del;
	Seg(){lazy = -1;}
}t[N<<2];
ll a[N],sum[N];
inline int id(int l,int r){return (l+r)|(l!=r);}
void add_day(int l,int r,ll d)
{
	t[id(l,r)].v += d*a[r];
	t[id(l,r)].sum += (sum[r]-sum[l-1])*d;
	t[id(l,r)].del+=d;
}
void push_down(int l,int r)
{
	int mid = (l+r)>>1;
	int p = id(l,r);
	if(t[p].lazy!=-1)
	{
		int lf = id(l,mid),rt = id(mid+1,r);
		t[lf].lazy=t[rt].lazy=t[p].lazy;
		t[lf].v=t[rt].v=t[p].lazy;
		t[lf].sum=(ll)(mid-l+1)*t[p].lazy,t[rt].sum=(ll)(r-mid)*t[p].lazy;
		t[lf].del=t[rt].del=0;
		t[p].lazy=-1;
	}
	if(t[p].del)
	{
		add_day(l,mid,t[p].del);
		add_day(mid+1,r,t[p].del);
		t[p].del=0;
	}
}
void push_up(int l,int r)
{
	int mid = (l+r)>>1;
	t[id(l,r)].sum= t[id(l,mid)].sum+t[id(mid+1,r)].sum;
	t[id(l,r)].v = t[id(mid+1,r)].v;
}
int L;
int Find(int l,int r,ll x)
{
	if(l==r)return l;
	int mid = (l+r)>>1;
	push_down(l,r);
	if(t[id(l,mid)].v>=x)return Find(l,mid,x);
	else return Find(mid+1,r,x);
}
ll Update(int l, int r,ll b) 
{
    if(r<L) return 0;
    int mid = (l+r)>>1,p = id(l,r); 
	ll ans = 0;
    if(L<=l) 
	{ 
		ans = t[p].sum; 
		t[p].del = 0; 
		t[p].sum = (ll)(r-l+1)*b; 
		t[p].v = b; 
		t[p].lazy = b; 
		return ans; 
	}
	push_down(l,r);
	ans = Update(l,mid,b)+Update(mid+1,r,b);
    push_up(l,r);
    return ans;
}
int main()
{
	int n,m;
	ll last = 0,d,b;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	for(int i = 1;i<= n;i++)sum[i] = sum[i-1]+a[i];
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld",&d,&b);
		ll dt = d-last;last = d;
		add_day(1,n,dt);
		if(t[id(1,n)].v<b){printf("0\n");continue;}
		L = Find(1,n,b);
		printf("%lld\n",Update(1,n,b)-b*(n-L+1));
	}
	return 0;
}
Problem4294

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll base = 6000000000000000000ull;
const int N = 20;
ll quick_plus(ll x,ll y,ll mod)
{
	ll ans = 0;
	while(y)
	{
		if(y&1)(ans+=x)%=mod;
		x = (x+x)%mod;
		y>>=1;
	}
	return ans;
}
void getfib(ll n,ll &x,ll &y,ll mod)
{
	if(!n){x=0,y=1;return ;}
	else if(n==1){x=y=1;return ;}
	if(n&1){getfib(n-1,y,x,mod);y=(x+y)%mod;return;}
	ll a,b;
	getfib(n>>1,a,b,mod);
	x = (quick_plus(a,b,mod)+quick_plus(a,b>a?b-a:b-a+mod,mod))%mod;
	y = (quick_plus(a,a,mod)+quick_plus(b,b,mod))%mod;
}
ll Pow[N],b[N];
char s[N];
bool flag;
ll ans;
void dfs(int n,ll now,ll mod)
{
	if(flag)return ;
	ll x,y;
	getfib(now,x,y,Pow[n]);
	if(x!=b[n])return ;
	if(n==1){flag = true;ans = base+now;return ;}
	for(int i = 0;i<10;i++)
		dfs(n-1,(now+mod*i)%(mod*10),mod*10);
}
int main()
{
	scanf("%s",s+1);
	int n = strlen(s+1);
	for(int i = n;i;i--)
	{
		if(i==n)Pow[i]=1;
		else Pow[i]=Pow[i+1]*10;
		b[i]=b[i+1]+Pow[i]*(s[i]-'0');
	}
	for(int i = 1;i<= n;i++)Pow[i]*=10;
	for(int i = 0;i<60;i++)
		dfs(n,i,60);
	if(flag)printf("%llu\n",ans);
	else printf("NIE\n");
	return 0;
}
Problem4295

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define ll long long
#define inf 2000000000000000000ll
#define eps 1e-10
#define md
#define N 5000010
using namespace std;
const int D=2000000;
struct QQ { int dt,id;} q[N];
int a[N],b[N],r[N],sum[N],mn[N],T[N];
char st[N];
bool vis[N];
ll lun[N],ed[N],win[N],last[N];
int main()
{
	int n,m;
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",&a[i]);
	scanf("%d",&m); scanf("%s",st);
	for (int i=0;i<m;i++) b[i]=st[i]=='W'?1:-1;
	for (int i=0;i<m;i++)
		if (!vis[i])
		{
		int x=i,tot=0;
		while (!vis[x])
		{
			vis[x]=1; r[++tot]=x; sum[tot]=sum[tot-1]+b[x];
			x=(x+n)%m;
		}
		for (int j=1;j<=tot;j++)
		{
			r[j+tot]=r[tot];
			sum[j+tot]=sum[j+tot-1]+b[r[j]];
		}
		int h=1,w=0;
		for (int j=1;j<=tot;j++)
		{
			while (h<=w&&q[w].dt>=sum[j]) w--;
			q[++w].id=j; q[w].dt=sum[j];
		}
		for (int j=1;j<=tot;j++)
		{
			while (h<=w&&q[h].id<j) h++;
			mn[j]=-(q[h].dt-sum[j-1]);
			win[j]=sum[j+tot-1]-sum[j-1];
			while (h<=w&&q[w].dt>=sum[j+tot]) w--;
			q[++w].id=j+tot; q[w].dt=sum[j+tot];
		}
		for (int j=D-(tot<<1);j<=D+(tot<<1);j++) last[j]=inf;
		for (int j=(tot<<1);j>tot;j--)
			last[sum[j]+D]=j;
		for (int j=tot;j;j--)
		{
			x=r[j]; T[x]=tot;
			last[sum[j]+D]=j;
			while (x<n)
			{
				if (win[j]>=0&&a[x]>mn[j]) lun[x]=inf;
				else
				{
					if (a[x]<=mn[j]) lun[x]=0;
					else lun[x]=(a[x]-mn[j]-1)/(-win[j])+1;
					ed[x]=a[x]+lun[x]*win[j];
					ed[x]=last[-ed[x]+sum[j-1]+D]-(j-1);
				}
				x+=m;
			}
		}
	}
	ll ans=inf;
	for (int i=0;i<n;i++)
	{
		if (lun[i]==inf) continue;
		ans=min(ans,(lun[i]*T[i]+ed[i]-1)*n+i+1);
	}
	if (ans==inf) printf("-1\n");
		else printf("%lld\n",ans);
	return 0;
}
Problem4296

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
int fa[N],size[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,d[N];
int n,m,D;
bool v[N];
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;d[x]++;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;d[y]++;
}
queue<int>Q;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[x] = y;
	size[y]=size[x]+size[y];
	size[x] = 0;
}
int main()
{
	int x,y;
	scanf("%d%d%d",&n,&m,&D);
	for(int i = 1;i<= n;i++)size[fa[i]=i]=1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	for(int i = 1;i<= n;i++)
		if(d[i]<D)
			Q.push(i),v[i]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(!v[e[i].to])
			{
				d[e[i].to]--;
				if(d[e[i].to]<D)Q.push(e[i].to),v[e[i].to]=true;
			}
	}
	for(int i = 1;i<= n;i++)
		if(!v[i])
			for(int j = head[i];j;j=e[j].next)
				if(!v[e[j].to])
					uni(i,e[j].to);
	int maxi = 0;
	for(int i = 1;i<= n;i++)
		if(!v[i]&&getfa(i)==i)
			if(size[i]>size[maxi])
				maxi = i;
	if(maxi==0)printf("NIE\n");
	else
	{
		printf("%d\n",size[maxi]);
		for(int i = 1;i<= n;i++)
			if(!v[i]&&getfa(i)==maxi)
				printf("%d ",i);
	}
	return 0;
}
Problem4297

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;
int l[N],r[N],del[N],a[N<<1],c,n,m;
ll s,now,ans,tmp;
struct E
{int next,to;};
struct Gragh
{
	E e[N<<1];
	int head[N],tot,d[N],f[N];
	void add(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		head[x] = tot;
		d[y]++;
		f[y] = x;
	}
}g,G;
void dfs(int x)
{
	if(!G.head[x])return ;
	for(int i = G.head[x];i;i=G.e[i].next)
		dfs(G.e[i].to);
	tmp = 1ll<<60;
	c = m = s = 0;
	for(int j = 0,i = G.head[x];i;i=G.e[i].next)
	{
		int to = G.e[i].to;
		a[m++]=l[to];
		a[m++]=r[to];
		c--;
		s+=l[to];
	}
	std::sort(a,a+m);
	for(int i = 0;i<m;i++)
	{
		c++;
		s-=a[i];
		now=s+1ll*a[i]*c;
		if(now<tmp)
			l[x]=a[i],tmp = now;
		if(now==tmp)
			r[x]=a[i];
	}
	ans+=tmp;
}
int q[N],h,t,ed;
int main()
{
	int o,u;
	scanf("%d%d",&n,&m);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&o,&u);
		g.add(o,u),g.add(u,o);
	}
	for(int i = 1;i<= m;i++)
		scanf("%d",&l[i]),r[i]=l[i];
	if(n==m)
	{
		for(int i = 1;i<= n;i++)
			for(int j = g.head[i];j;j=g.e[j].next)
			{
				int to = g.e[j].to;
				ans+=abs(l[i]-l[to]);
			}
		printf("%lld\n",ans>>1);
		return 0;
	}
	h = 1,t = 0;
	for(int i = 1;i<= m;i++)
		del[q[++t]=i]=1;
	int x=0;
	while(h<=t)
	{
		for(int i = h;i<= t;i++)
			for(int j = g.head[q[i]];j;j=g.e[j].next)
				if(!del[g.e[j].to])
				{
					int to = g.e[j].to;
					G.add(to,q[i]);
				}
		x = t;
		for(int i = h;i<= x;i++)
			for(int j = g.head[q[i]];j;j=g.e[j].next)
				if(!del[g.e[j].to])
				{
					int to = g.e[j].to;
					if((--g.d[to])<=1)
						del[q[++t]=to]=1;
				}
		h = x+1;
	}
	for(int i = 1;i<= n;i++)
		if(!G.f[i])
			G.add(0,i);
	dfs(0);
	printf("%lld\n",ans);
	return 0;
}
Problem4298

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int base = 60383;
const int mod = 793999;
const int T = 205;
const int N = 5005;
const int M = 1000005;
struct HASH
{int next,cnt;ull to;}Hash[M];
int hd[mod+5],Cnt;
ull pow[T],hash[N];
int id[T][N],size[T][N],ans;
void Insert(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans+=(Hash[i].cnt<<1)+1;
			Hash[i].cnt++;
			return ;
		}
	ans++;
	Hash[++Cnt].to = x;Hash[Cnt].next = hd[p];hd[p] = Cnt;
	Hash[Cnt].cnt = 1;
}
void Delete(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans-=(Hash[i].cnt<<1)-1;
			--Hash[i].cnt;
			return ;
		}
}
struct E
{int next,to;}e[M<<1];
int head[T][N],tot;
void add(int d,int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[d][x];
	head[d][x] = tot;
}
void dfs(int d,int x,int pre,int fa)
{
	Delete(hash[x]);
	hash[x]-=pow[d]*id[d][x];
	id[d][x] = fa;
	hash[x]+=pow[d]*id[d][x];
	Insert(hash[x]);
	for(int i = head[d][x];i;i=e[i].next)if(e[i].to!=pre)
		dfs(d,e[i].to,x,fa);
}
void uni(int d,int x,int y)
{
	if(id[d][x]==id[d][y])return ;
	if(size[d][id[d][x]]<size[d][id[d][y]])swap(x,y);
	size[d][id[d][x]]+=size[d][id[d][y]];
	add(d,x,y),add(d,y,x);
	dfs(d,y,x,id[d][x]);
}
int main()
{
	int d,n,m;
	scanf("%d%d%d",&d,&n,&m);
	pow[0]=1;
	for(int i = 1;i<= d;i++)pow[i]=pow[i-1]*base;
	for(int i = 1;i<= d;i++)
		for(int j = 1;j<= n;j++)
			id[i][j]=j,size[i][j]=1,hash[j]+=pow[i]*j;
	for(int j = 1;j<=n;j++)Insert(hash[j]);
	int a,b,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&k);
		uni(k,a,b);
		printf("%d\n",ans);
	}
}
Problem4298

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
const int base = 60383;
const int mod = 1747969;
const int T = 205;
const int N = 5005;
const int M = 1000005;
struct HASH
{int next,cnt;ull to;}Hash[M];
int hd[mod+5],Cnt;
ull pow[T],hash[N];
int id[T][N],size[T][N],ans;
void Insert(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans+=(Hash[i].cnt<<1)+1;
			Hash[i].cnt++;
			return ;
		}
	ans++;
	Hash[++Cnt].to = x;Hash[Cnt].next = hd[p];hd[p] = Cnt;
	Hash[Cnt].cnt = 1;
}
void Delete(ull x)
{
	int p = x%mod;
	for(int i = hd[p];i;i=Hash[i].next)
		if(Hash[i].to==x)
		{
			ans-=(Hash[i].cnt<<1)-1;
			--Hash[i].cnt;
			return ;
		}
}
struct E
{int next,to;}e[M<<1];
int head[T][N],tot;
void add(int d,int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[d][x];
	head[d][x] = tot;
}
void dfs(int d,int x,int pre,int fa)
{
	Delete(hash[x]);
	hash[x]-=pow[d]*id[d][x];
	id[d][x] = fa;
	hash[x]+=pow[d]*id[d][x];
	Insert(hash[x]);
	for(int i = head[d][x];i;i=e[i].next)if(e[i].to!=pre)
		dfs(d,e[i].to,x,fa);
}
void uni(int d,int x,int y)
{
	if(id[d][x]==id[d][y])return ;
	if(size[d][id[d][x]]<size[d][id[d][y]])swap(x,y);
	size[d][id[d][x]]+=size[d][id[d][y]];
	add(d,x,y),add(d,y,x);
	dfs(d,y,x,id[d][x]);
}
int main()
{
	int d,n,m;
	scanf("%d%d%d",&d,&n,&m);
	pow[0]=1;
	for(int i = 1;i<= d;i++)pow[i]=pow[i-1]*base;
	for(int i = 1;i<= d;i++)
		for(int j = 1;j<= n;j++)
			id[i][j]=j,size[i][j]=1,hash[j]+=pow[i]*j;
	for(int j = 1;j<=n;j++)Insert(hash[j]);
	int a,b,k;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&a,&b,&k);
		uni(k,a,b);
		printf("%d\n",ans);
	}
}
Problem4305

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 3e5+5;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int fac[N],inv[N];
void init()
{
	fac[0] = inv[0] = 1;
	for(int i = 1;i<N;i++)fac[i]=(ll)fac[i-1]*i%mod;
	inv[N-1] = quick_pow(fac[N-1],mod-2);
	for(int i = N-2;i>= 1;i--)inv[i] = (ll)inv[i+1]*(i+1)%mod;
}
int a[N],cnt[N],ans[N];
int C(int n,int m)
{
	if(m>n)return 0;
	return (ll)fac[n]*inv[n-m]%mod*inv[m]%mod;
}
int main()
{
	int n,m,k;
	init();
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&a[i]),cnt[a[i]]++;
	for(int i = 1;i<= m;i++)
		for(int j = i+i;j<= m;j+=i)
			cnt[i]+=cnt[j];
	for(int i = 1;i<= m;i++)
		if(cnt[i]>=n-k)
			ans[i] = (ll)C(cnt[i],n-k)*quick_pow(m/i-1,cnt[i]-n+k)%mod*quick_pow(m/i,n-cnt[i])%mod;
	for(int i = m;i>= 1;i--)
		for(int j = i+i;j<= m;j+=i)
			(ans[i]+=mod-ans[j])%=mod;
	for(int i = 1;i< m;i++)printf("%d ",ans[i]);
	printf("%d\n",ans[m]);
	return 0;
}
Problem4316

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 6e4+5;
const int INF = 0x3f3f3f3f;
int f[M<<1][2];
namespace Cactus
{
	struct E
	{int next,to;}e[M<<1];
	int head[N],tot=1,n;
	int dfn[N],low[N],Dfn,stk[N],top;
}
namespace R_S_Tree
{
	struct E
	{int next,to;}e[M<<2];
	int head[N<<1],tot=1,n;
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dp(int x,int fa)
	{
		f[x][1]=1;
		if(x<=Cactus::n)
		{
			for(int i = head[x];i;i=e[i].next)
				if(e[i].to!=fa)
				{
					dp(e[i].to,x);
					if(e[i].to>Cactus::n)continue;
					f[x][0]+=max(f[e[i].to][0],f[e[i].to][1]);
					f[x][1]+=f[e[i].to][0];
				}
		}else
		{
			static int g[M<<1][2];
			int top = 0;
			for(int i = head[x];i;i=e[i].next)
				if(e[i].to!=fa)
					dp(e[i].to,x);
			for(int i = head[x];i;i=e[i].next)
			{
				g[++top][0] = f[e[i].to][0];
				g[top][1] = f[e[i].to][1];
			}
			for(int i = top-1;i>=1;i--)
			{
				g[i][0]+=max(g[i+1][0],g[i+1][1]);
				g[i][1]+=g[i+1][0];
			}
			f[fa][0] = g[1][0];
			for(int i = 1;i<top;i++)
			{
				g[i][0]-=max(g[i+1][0],g[i+1][1]);
				g[i][1]-=g[i+1][0];
			}
			g[top][1] = -INF;
			for(int i = top-1;i>=1;i--)
			{
				g[i][0]+=max(g[i+1][0],g[i+1][1]);
				g[i][1]+=g[i+1][0];
			}
			f[fa][1] = g[1][1];
		}
	}
}
namespace Cactus
{
	void add(int x,int y)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
	}
	void dfs(int x,int pre)
	{
		stk[++top] = x;
		dfn[x] = low[x] = ++Dfn;
		for(int i = head[x];i;i=e[i].next)if(i!=(pre^1))
		{
			if(!dfn[e[i].to])
			{
				dfs(e[i].to,i);
				low[x] =min(low[x],low[e[i].to]);
				if(low[e[i].to]>=dfn[x])
				{
					int tmp;
					R_S_Tree::n++;
					do
					{
						tmp = stk[top--];
						R_S_Tree::add(tmp,R_S_Tree::n);
					}while(tmp!=e[i].to);
					R_S_Tree::add(x,R_S_Tree::n);
				}
			}else low[x] = min(low[x],dfn[e[i].to]);
		}
	}
};
int main()
{
	int m;
	scanf("%d%d",&Cactus::n,&m);
	R_S_Tree::n = Cactus::n;
	int x,y;
	while(m--)
	{
		scanf("%d%d",&x,&y);
		Cactus::add(x,y);
	}
	Cactus::top = 0,Cactus::Dfn = 0;
	Cactus::dfs(1,0);
	R_S_Tree::dp(1,0);
	printf("%d\n",max(f[1][0],f[1][1]));
	return 0;
}
Problem4318

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100000+5;
double f[N],l1[N],l2[N];
double p[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf",&p[i]);
	for(int i = 1;i<= n;i++)
	{
		l1[i] = p[i]*(l1[i-1]+1);
		l2[i] = p[i]*(l2[i-1]+2*l1[i-1]+1);
		f[i] = p[i]*(f[i-1]+3.0*l2[i-1]+3.0*l1[i-1]+1)+(1-p[i])*f[i-1];
	}
	printf("%.1f",f[n]);
	return 0;
}
Problem4320

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int X = 300005;
const int N = 100005;
struct A{int opt,num;}ask[N];
int ans[N],modn[605],fa[X];
bool v[X];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x] = x;
	else return fa[x] = getfa(fa[x]);
}
int main()
{
	int n;
	char x[2];
	scanf("%d",&n);
	memset(ans,-1,sizeof(ans));
	memset(modn,0x3f,sizeof(modn));
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",x,&ask[i].num);
		if(x[0]=='A')
		{
			for(int j = 1;j<= 600;j++)
				modn[j] = min(modn[j],ask[i].num%j);
			ask[i].opt = 1;
			v[ask[i].num] = true;
		}
		else 
		{
			if(ask[i].num<=600)ans[i] = modn[ask[i].num];
			ask[i].opt = 2;
		}
	}
	for(int i = 1;i<=X-5;i++)
		if(!v[i])
			fa[i] =i+1;
	for(int i = n;i>= 1;i--)
	{
		if(ask[i].opt==1)fa[ask[i].num] = ask[i].num+1;
		else if(ask[i].num>600)
		{
			int tmp = 0x3f3f3f3f;
			for(int j = 0;j<= X-5;j+=ask[i].num)
			{
				int tt = getfa(max(1,j));
				if(tt<=X-5)tmp = min(tmp,tt%ask[i].num);
			}
			ans[i] = tmp;
		}
	}
	for(int i = 1;i<= n;i++)
		if(ans[i]!=-1)
			printf("%d\n",ans[i]);
	return 0;
}
Problem4346

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int INF = 1e9;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][3][3],g[N][3],p[N][3],q[N][3],c[3][3];
void dp(int x,int fa)
{
	p[x][1] = 1,p[x][2] = 2;
	memset(g[x],0x3f,sizeof(g[x]));
	memset(f[x],0x3f,sizeof(f[x]));
	f[x][0][0] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			int y = e[i].to;
			dp(y,x);
			int tmp = min(min(p[y][1],p[y][2]),q[y][1]);
			for(int j = 0;j<3;j++)
				tmp = min(tmp,g[y][j]);
			p[x][1]+=tmp,p[x][2]+=min(tmp,q[y][2]);
			memset(c,0x3f,sizeof(c));
			for(int j = 0;j<3;j++)
				for(int k = 0;k<3;k++)
					if(f[x][j][k]<INF)
					{
						tmp = f[x][j][k];
						for (int l=1; l<3; l++) c[min(2,j+l)][k]=min(c[min(2,j+l)][k],tmp+p[y][l]);  
                   		for (int l=0; l<3; l++) c[j][max(k,2-l)]=min(c[j][max(k,2-l)],tmp+g[y][l]);  
					}
			memcpy(f[x],c,sizeof(c));
		}
	for (int i=0; i<3; i++)  
        for (int j=0; j<=i; j++) g[x][i]=min(g[x][i],f[x][i][j]);  
    q[x][1]=min(f[x][0][1],f[x][1][2]);  
    q[x][2]=f[x][0][2];  
}
int main()
{
	int n,x,y;
	scanf("%d",&n);
    for (int i=1; i<n; i++){  
    	scanf("%d%d",&x,&y); 
        add(x,y);
    }  
    dp(1,0); 
    int ans=min(p[1][1],p[1][2]);  
    for (int i=0; i<3; i++) ans=min(ans,g[1][i]);  
    printf("%d\n",ans);  
	return 0;
}
Problem4348

#include <stdio.h>
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define N 1005
int n,m,i,j,x,y,l,r,f[N][N],ans,t,q[10005][3],cnt;bool a[N][N];char ch[N];
struct P {int x,y,l,r,s;}s[N*N];
inline void up(int b) {if(ans<b)ans=b;}
inline void add(int x,int y,int z) 
{
	if(x&&x==y)return;
	q[++cnt][0]=x,q[cnt][1]=y,q[cnt][2]=z;
}
int main() 
{
	scanf("%d",&n);
	gets(ch);
	if(n==1){printf("1",ans);return 0;}
	for(int i = 1;i<= n;i++)
		for(gets(ch+1),j=1;j<=n;j++)
			if(ch[j]=='B')a[i][j]=1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(a[i][j]&&!f[i][j]) 
			{
				for(x=i;a[x][j];x++);
				for(y=j;a[i][y];y++);
				s[++m].x=i,s[m].y=--x,s[m].l=j,s[m].r=--y;
				up(s[m].s=(x-i+1)*(y-j+1));
				for(int I = i;I<= x;I++)
					for(int J = j;J<=y;J++)
						f[I][J]=m;
			}
	if(ans==n*n){printf("%d",ans);return 0;}
	for(i=n;~i;i--)
		for(j=n;~j;j--)
			f[i+1][j+1]=f[i][j];
	for(i=1;i<=m;i++)
		s[i].x++,s[i].y++,s[i].l++,s[i].r++;
	n+=2;
	ans=2;
	rep(i,1,m) 
	{
		x=s[i].x,y=s[i].y,l=s[i].l,r=s[i].r,cnt=0;
		if(x>2)rep(j,l,r) 
		{
			if(f[x-2][j])add(f[x-2][j],0,0);
			else 
			{
				t=s[i].s+2+s[f[x-2][j-1]].s+s[f[x-2][j+1]].s;
				if(f[x-2][j-1]!=f[x-1][j-1])t+=s[f[x-1][j-1]].s;
				if(f[x-2][j+1]!=f[x-1][j+1])t+=s[f[x-1][j+1]].s;
				if(x>3)t+=s[f[x-3][j]].s;
				up(t);
			}
		}
		if(y+2<=n)rep(j,l,r) 
		{
			if(f[y+2][j])add(f[y+2][j],0,0);
			else 
			{
				t=s[i].s+2+s[f[y+2][j-1]].s+s[f[y+2][j+1]].s;
				if(f[y+2][j-1]!=f[y+1][j-1])t+=s[f[y+1][j-1]].s;
				if(f[y+2][j+1]!=f[y+1][j+1])t+=s[f[y+1][j+1]].s;
				if(y+3<=n)t+=s[f[y+3][j]].s;
				up(t);
			}
		}
		if(l>2)rep(j,x,y) 
		{
			if(f[j][l-2])add(f[j][l-2],0,0);
			else 
			{
				t=s[i].s+2+s[f[j-1][l-2]].s+s[f[j+1][l-2]].s;
				if(f[j-1][l-2]!=f[j-1][l-1])t+=s[f[j-1][l-1]].s;
				if(f[j+1][l-2]!=f[j+1][l-1])t+=s[f[j+1][l-1]].s;
				if(l>3)t+=s[f[j][l-3]].s;
				up(t);
			}
		}
		if(r+2<=n)rep(j,x,y) 
		{
			if(f[j][r+2])add(f[j][r+2],0,0);
			else 
			{
				t=s[i].s+2+s[f[j-1][r+2]].s+s[f[j+1][r+2]].s;
				if(f[j-1][r+2]!=f[j-1][r+1])t+=s[f[j-1][r+1]].s;
				if(f[j+1][r+2]!=f[j+1][r+1])t+=s[f[j+1][r+1]].s;
				if(r+3<=n)t+=s[f[j][r+3]].s;
				up(t);
			}
		}
		if(f[x-1][l-1]) 
		{
			if(x>2)add(f[x-1][l-1],f[x-2][l],0);
			if(l>2)add(f[x-1][l-1],f[x][l-2],0);
		}
		if(f[y+1][l-1]) 
		{
			if(y+2<=n)add(f[y+1][l-1],f[y+2][l],0);
			if(l>2)add(f[y+1][l-1],f[y][l-2],0);
		}
		if(f[x-1][r+1]) 
		{
			if(x>2)add(f[x-1][r+1],f[x-2][r],0);
			if(r+2<=n)add(f[x-1][r+1],f[x][r+2],0);
		}
		if(f[y+1][r+1]) 
		{
			if(y+2<=n)add(f[y+1][r+1],f[y+2][r],0);
			if(r+2<=n)add(f[y+1][r+1],f[y][r+2],0);
		}
		if(x==y) 
		{
			if(l>2)add(f[x][l-2],f[x-1][l-1],f[x+1][l-1]);
			if(r+2<=n)add(f[x][r+2],f[x-1][r+1],f[x+1][r+1]);
		}
		if(l==r) 
		{
			if(x>2)add(f[x-2][l],f[x-1][l-1],f[x-1][l+1]);
			if(y+2<=n)add(f[y+2][l],f[y+1][l-1],f[y+1][l+1]);
		}
		up(s[i].s+2);
		rep(j,1,cnt) 
		{
			up(s[i].s+2+s[q[j][0]].s+s[q[j][1]].s+s[q[j][2]].s);
			rep(k,j+1,cnt) 
			{
				t=s[i].s+2+s[q[j][0]].s+s[q[j][1]].s+s[q[j][2]].s+s[q[k][0]].s+s[q[k][1]].s+s[q[k][2]].s;
				if(q[k][0]==q[j][0]||q[k][0]==q[j][1]||q[k][0]==q[j][2])t-=s[q[k][0]].s;
				if(q[k][1]==q[j][0]||q[k][1]==q[j][1]||q[k][1]==q[j][2])t-=s[q[k][1]].s;
				if(q[k][2]==q[j][0]||q[k][2]==q[j][1]||q[k][2]==q[j][2])t-=s[q[k][2]].s;
				up(t);
			}
		}
		if(x>1&&l>1&&!f[x-1][l-1]) 
		{
			t=s[i].s+2+s[f[x-2][l-1]].s+s[f[x-1][l-2]].s;
			if(x==y&&l==r) 
			{
				if(f[x-1][l-2]!=f[x][l-2])up(t+s[f[x][l-2]].s+s[f[x+1][l-1]].s);else up(t+s[f[x+1][l-1]].s);
				if(f[x-2][l-1]!=f[x-2][l])up(t+s[f[x-2][l]].s+s[f[x-1][l+1]].s);else up(t+s[f[x-1][l+1]].s);
			}else 
			{
				if(f[x-1][l-2]!=f[x][l-2])up(t+s[f[x][l-2]].s);
				if(f[x-2][l-1]!=f[x-2][l])up(t+s[f[x-2][l]].s);
			}
		}
		if(x>1&&r<n&&!f[x-1][r+1]) 
		{
			t=s[i].s+2+s[f[x-2][r+1]].s+s[f[x-1][r+2]].s;
			if(x==y&&l==r) 
			{
				if(f[x-1][r+2]!=f[x][r+2])up(t+s[f[x][r+2]].s+s[f[x+1][l+1]].s);else up(t+s[f[x+1][l+1]].s);
				if(f[x-2][r+1]!=f[x-2][r])up(t+s[f[x-2][r]].s+s[f[x-1][l-1]].s);else up(t+s[f[x-1][l-1]].s);
			}else 
			{
				if(f[x-1][r+2]!=f[x][r+2])up(t+s[f[x][r+2]].s);
				if(f[x-2][r+1]!=f[x-2][r])up(t+s[f[x-2][r]].s);
			}
		}
		if(y<n&&l>1&&!f[y+1][l-1]) 
		{
			t=s[i].s+2+s[f[y+2][l-1]].s+s[f[y+1][l-2]].s;
			if(x==y&&l==r) 
			{
				if(f[y+1][l-2]!=f[y][l-2])up(t+s[f[y][l-2]].s+s[f[x-1][l-1]].s);else up(t+s[f[x-1][l-1]].s);
				if(f[y+2][l-1]!=f[y+2][l])up(t+s[f[y+2][l]].s+s[f[x+1][l+1]].s);else up(t+s[f[x+1][l+1]].s);
			}else 
			{
				if(f[y+1][l-2]!=f[y][l-2])up(t+s[f[y][l-2]].s);
				if(f[y+2][l-1]!=f[y+2][l])up(t+s[f[y+2][l]].s);
			}
		}
		if(y<n&&r<n&&!f[y+1][r+1]) 
		{
			t=s[i].s+2+s[f[y+2][r+1]].s+s[f[y+1][r+2]].s;
			if(x==y&&l==r) 
			{
				if(f[y+1][r+2]!=f[y][r+2])up(t+s[f[y][r+2]].s+s[f[x-1][l+1]].s);else up(t+s[f[x-1][l+1]].s);
				if(f[y+2][r+1]!=f[y+2][r])up(t+s[f[y+2][r]].s+s[f[x+1][l-1]].s);else up(t+s[f[x+1][l-1]].s);
			}else 
			{
				if(f[y+1][r+2]!=f[y][r+2])up(t+s[f[y][r+2]].s);
				if(f[y+2][r+1]!=f[y+2][r])up(t+s[f[y+2][r]].s);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
Problem4349

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int M = 2505;
const int INF = 0x3f3f3f3f;
const double eps = 1e-7;
struct E
{int u,v;double val;}e[M];
int p[N],num[N],pre[N],vis[N],mark[N];
double c[N],in[N];
double work(int root,int n,int m)
{
	double ans = 0;
	while(true)
	{
		for(int i = 1;i<= n;i++)in[i] = INF;
		for(int i = 1;i<= m;i++)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].val<in[v])
			{
				in[v] = e[i].val;
				pre[v] = u;
			}
		}
		for(int i = 1;i<= n;i++)
		{
			if(i==root)continue;
			if(fabs(in[i]-INF)<eps)return -1;
		}
		memset(mark,-1,sizeof(mark));
		memset(vis,-1,sizeof(vis));
		in[root] = 0;int cnt = 0;
		for(int i = 1;i<= n;i++)
		{
			ans+=in[i];
			int v=i;
			while(v!=root&&mark[v]==-1&&vis[v]!=i)
			{
				vis[v] = i;
				v = pre[v];
			}
			if(v!=root&&mark[v]==-1)
			{
				++cnt;
				for(int u = pre[v];u!=v;u = pre[u])
					mark[u] = cnt;
				mark[v] = cnt;
			}
		}
		if(cnt==0)break;
		for(int i = 1;i<= n;i++)
			if(mark[i]==-1)mark[i]=++cnt;
		for(int i = 1;i<=m;i++)
		{
			int u = e[i].u,v = e[i].v;
			e[i].u = mark[u],e[i].v = mark[v];
			if(e[i].u!=e[i].v)
				e[i].val-=in[v];
		}
		n=cnt,root = mark[root];
	}
	return ans;
}
int main()
{
	int n,m=0;
	scanf("%d",&n);
	int tmp = n;n = 1;
	double x;int t;
	for(int i = 1;i<= tmp;i++)
	{
		scanf("%lf%d",&x,&t);
		if(t)
		{
			p[i]=++n;
			e[++m] = (E){1,n,x};
			c[n] = x;num[n] = t;
		}
	}
	int a,b,k;
	scanf("%d",&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d%lf",&a,&b,&x);
		if(p[a]&&p[b])
		{
			e[++m] = (E){p[a],p[b],x};
			c[p[b]] = min(c[p[b]],x);
		}
	}
	double ans = work(1,n,m);
	for(int i = 2;i<= n;i++)
		if(num[i]>1)ans+=c[i]*(num[i]-1);
	printf("%.2f\n",ans);
	return 0;
}
Problem4377

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int M = 1e6+5;
int n,a,b,p,m,cnt;
struct S
{int l,r;}seg[M<<2];
char s[M];
void add(int l,int r)
{
	if(l<=r){seg[++cnt].l = l;seg[cnt].r = r;}
	else 
	{
		seg[++cnt].l = l;seg[cnt].r = n-1;
		seg[++cnt].l = 0;seg[cnt].r = r;
	}
}
bool cmp(S a,S b)
{
	return a.l<b.l;
}
int main()
{
	scanf("%d%d%d%d%d",&n,&a,&b,&p,&m);
	scanf("%s",s);
	int now = 0;
	for(int i = 0;i<m;i++,now = (now+a)%n)
	{
		if(s[i]=='0')add((p-now+n)%n,(n-1-now+n)%n);
		else add((n-now)%n,(p-1-now+n)%n);
	}
	for(int i=1,c=(b-a+n)%n;i<m;i++,c=(c-a+n)%n)
        add(c,c);
    sort(seg+1,seg+cnt+1,cmp);
    int end = -1,ans = 0;
    for(int i = 1;i<= cnt;i++)
    {
    	if(seg[i].l>end)
    	{
    		ans+=seg[i].l-end-1;
    		end = seg[i].r;
    	}
    	end = max(seg[i].r,end);
    }
    printf("%d\n",ans+n-1-end);
	return 0;
}
Problem4378

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e6+5;
int a[N],num[N],cnt;
LL cn[N],cs[N];
struct opt
{int kind;LL x,y;}Opt[N];
int Find(int x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(num[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
void update(int pos,int xn,int xs)
{
	for(int i = pos;i<N;i+=i&(-i))
		cn[i]+=xn,cs[i]+=xs;
	return ;
}
LL getn(int pos)
{
	LL ans = 0;
	for(int i = pos;i>0;i-=i&(-i))
		ans+=cn[i];
	return ans;
}
LL gets(int pos)
{
	LL ans = 0;
	for(int i = pos;i>0;i-=i&(-i))
		ans+=cs[i];
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	char o[3];
	for(int i = 1;i<= m;i++)
	{
		scanf("%s",o);
		if(o[0]=='U')
			Opt[i].kind = 1;
		else
			Opt[i].kind = 2;
		scanf("%lld%lld",&Opt[i].x,&Opt[i].y);
		num[++cnt] = Opt[i].y;
	}
	memset(a,-1,sizeof(a));
	sort(num+1,num+cnt+1);
	for(int i = 1;i<= m;i++)
	{
		if(Opt[i].kind==1)
		{
			int tmp = a[Opt[i].x];
			if(tmp!=-1)update(Find(tmp),-1,-tmp);
			update(Find(Opt[i].y),1,Opt[i].y);
			a[Opt[i].x] = Opt[i].y;
		}else
		{
			LL tmp = getn(cnt)-getn(Find(Opt[i].y)-1);
			if(tmp>=Opt[i].x)printf("TAK\n");
			else if(gets(Find(Opt[i].y)-1)>=(Opt[i].x-tmp)*Opt[i].y)printf("TAK\n");
			else printf("NIE\n");
		}
	}
	return 0;
}
Problem4379

#include<iostream>
#include<cstdio>
#include<cstring>
#include <cctype>
#define N 1000010
using namespace std;
int to[N],nxt[N],pre[N],cnt;
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
void ae(int ff,int tt)
{
	cnt++;
	to[cnt]=tt;
	nxt[cnt]=pre[ff];
	pre[ff]=cnt;
}
int fa[N],d1[N],fir[N],sec[N],thr[N];
int fd[N],sd[N];
void dfs(int x)
{
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==fa[x]) continue;
		fa[j]=x;
		dfs(j);
		thr[x]=max(fir[j]+1,thr[x]);
		if(thr[x]>sec[x]) swap(thr[x],sec[x]);
		if(sec[x]>fir[x]) swap(sec[x],fir[x]);
		d1[x]=max(d1[x],d1[j]);
		sd[x]=max(d1[j],sd[x]);
		if(sd[x]>fd[x]) swap(sd[x],fd[x]);
	}
	d1[x]=max(d1[x],fir[x]+sec[x]);
}
int minn=707185547,x4,y4;
int maxn,x5,y5;
int cal(int x,int y)
{
	if(x>y) swap(x,y);
	int yy=y;
	x=x/2+x%2;y=y/2+y%2;
	return max(x+y+1,yy);
}
void solve(int x,int d2,int lg)
{
//	cout<<d1[x]<<' '<<x<<' '<<d2<<' '<<lg<<endl;
	int t,tmp;
	if(x!=1)
	{
		t=cal(d1[x],d2);
	//	cout<<fa[x]<<' '<<x<<' '<<d1[x]<<' '<<d2<<endl;
		if(t<minn) minn=t,x4=fa[x],y4=x;
		if(d1[x]+d2+1>maxn) maxn=d1[x]+d2+1,x5=fa[x],y5=x;
	}
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==fa[x]) continue;
		t=fir[x];tmp=fd[x];
		if(tmp==d1[j]) tmp=sd[x];
		if(t==fir[j]+1)
		{
			t=sec[x];
			tmp=max(tmp,sec[x]+max(thr[x],lg));
		}
		else if(sec[x]==fir[j]+1) tmp=max(tmp,fir[x]+max(thr[x],lg));
		else tmp=max(tmp,fir[x]+max(sec[x],lg));
		t=max(lg,t);tmp=max(tmp,d2);
		solve(j,tmp,t+1);
	}
}
int t[5],T,ma;
bool del[N];
void dfs1(int x,int ff,int dd)
{
	int i,j;
	if(dd>ma) ma=dd,t[T]=x;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==ff||del[i]) continue;
		dfs1(j,x,dd+1);
	}
}
int ans[3],TT;
bool getans(int x,int ff,int dd)
{
	if(x==t[T])
	{
		if(ma==0) ans[TT]=x;
		return true;
	}
	int i,j;
	for(i=pre[x];i;i=nxt[i])
	{
		j=to[i];
		if(j==ff||del[i]) continue;
		if(getans(j,x,dd+1))
		{
			if(dd==ma/2) ans[TT]=x;
			return true;
		}
	}
	return false;
}
void findmin(int x,int y)
{
	int i;
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=true;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=true;
	ma=-1;T=1;
	dfs1(x,y,0);
	ma=-1;T=2;
	dfs1(t[1],0,0);
	TT=1;
	getans(t[1],0,0);
	ma=-1;T=3;
	dfs1(y,x,0);
	ma=-1;T=4;
	dfs1(t[3],0,0);
	TT=2;
	getans(t[3],0,0);
	printf("%d %d %d %d %d\n",minn,x,y,ans[1],ans[2]);
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=false;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=false;
}
void findmax(int x,int y)
{
	int i;
	for(i=pre[x];i;i=nxt[i])
	if(to[i]==y) del[i]=true;
	for(i=pre[y];i;i=nxt[i])
	if(to[i]==x) del[i]=true;
	ma=-1;T=1;
	dfs1(x,y,0);
	ma=-1;T=2;
	dfs1(t[1],0,0);
	ma=-1;T=3;
	dfs1(y,x,0);
	ma=-1;T=4;
	dfs1(t[3],0,0);
	printf("%d %d %d %d %d",maxn,x,y,t[1],t[3]);
}
int main()
{
	int n,m;
	n = read();
	int i,j,x,y;
	for(i=1;i<n;i++)
	{
		x = read();y = read();
		ae(x,y);ae(y,x);
	}
	dfs(1);
	solve(1,0,0);
	findmin(x4,y4);
	findmax(x5,y5);
}
Problem4380

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 52;
const int M = 4002;
const int INF = 500000;
int L[M],R[M],c[M],stack[M],pos[N][N][M],val[N][N][M];
LL f[N][N][M],sum[N][N][M];
int pid[N];
void printans(int l,int r,int t)
{
	if(l>r)return ;
	int tmp = val[l][r][t];
	printans(l,pos[l][r][t]-1,tmp);
	printf("%d ",pid[tmp]);
	printans(pos[l][r][t]+1,r,tmp);
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&L[i],&R[i],&c[i]);
		pid[i] = c[i];
	}
	sort(pid+1,pid+m+1);
	for(int lth = 1;lth<=n;lth++)
	{
		for(int l = 1;l+lth-1<= n;l++)
		{
			int r = l+lth-1;
			for(int k = l;k<= r;k++)
			{
				int top = 0;
				for(int t = 1;t<= m;t++)
					if(L[t]>=l&&R[t]<=r&&k>=L[t]&&k<=R[t])
						stack[++top] = c[t];
				sort(stack+1,stack+top+1);
				int head = 1;
				for(int t = 1;t<= m;t++)
				{
					while(head<=top&&stack[head]<pid[t])head++;
					LL tmp = sum[l][k-1][t]+sum[k+1][r][t]+(LL)(top-head+1)*pid[t];
					if(tmp>=f[l][r][t])
					{
						f[l][r][t] = tmp;
						pos[l][r][t] = k;
					}
				}
			}
			for(int k = m;k>=1;k--)
			{
				val[l][r][k] = k;
				if(f[l][r][k]<sum[l][r][k+1])
				{
					val[l][r][k] = val[l][r][k+1];
					pos[l][r][k] = pos[l][r][k+1];
				}
				sum[l][r][k] = max(sum[l][r][k+1],f[l][r][k]);
			}
		}
	}
	printf("%lld\n",sum[1][n][1]);
	printans(1,n,1);
	return 0;
}
Problem4381

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int fa[N],size[N],son[N],top[N],id[N],pos[N],dep[N],sum[N][155],a[N];
void dfs1(int x,int f)
{
	fa[x] = f;
	size[x]++;
	dep[x] = dep[f]+1;
	int p = fa[x];
	for(int i =1;i<= 150&&p;p = fa[p],i++)sum[x][i] = sum[p][i]+a[x];
	for(int i = head[x];i;i = e[i].next)
	{
		if(e[i].to!=f)
		{
			dfs1(e[i].to,x);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
	}
}
int cnt;
void dfs2(int x,int tp)
{
	top[x] = tp;
	id[++cnt] = x;
	pos[x] = cnt;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i = e[i].next)
		if(e[i].to!=son[x]&&e[i].to!=fa[x])
			dfs2(e[i].to,e[i].to);
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
int find(int x,int y)
{
	while(dep[x]-dep[top[x]]<y)
	{
		y-=dep[x]-dep[top[x]]+1;
		x = fa[top[x]];
	}
	return id[pos[x]-y];
}
int ask(int x,int y,int z)
{
	int ans = 0;
	if(z<=150)return sum[x][z]-sum[y][z]+a[y];
	while(top[x]!=top[y])
	{
		int i;
		for(i = pos[x];i>=pos[top[x]];i-=z)ans+=a[id[i]];
		x = find(x,pos[x]-i);
	}
	for(int i = pos[x];i>=pos[y];i-=z)ans+=a[id[i]];
	return ans;
}
int solve(int x,int y,int z)
{
	int ans = 0,lca = getlca(x,y);
	int lth = dep[x]+dep[y]-2*dep[lca];
	if(lth%z)ans+=a[y];
	y = find(y,lth%z);
	int t1 = find(x,(dep[x]-dep[lca])/z*z);
	if(dep[y]<=dep[lca])return ans+ask(x,t1,z);
	int t2 = find(y,(dep[y]-dep[lca])/z*z);
	if(t1==t2)ans-=a[t1];
	return ans+ask(x,t1,z)+ask(y,t2,z);
}
int b[N],c[N];
int main()
{
	int n,x,y;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs1(1,0);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	for(int i = 1;i< n;i++)
	{
		scanf("%d",&x);
		printf("%d\n",solve(b[i],b[i+1],x));
	}
	return 0;
}
Problem4382

#include <stdio.h>
#include <map>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
typedef unsigned long long ull;
const int N = 1000005;
const LL seed = 131133;
map<ull,int>id;
LL cnt;
ull pw[N],val[N],sum[N];
int pre[N],next[N],a[N];
bool vis[N];
int stack[N],top,n,k,ans,tot;
int calc(int x,int y)
{
	int t = y-x;
	return abs(t-n+t);
}
int main()
{
	scanf("%d%d",&n,&k);
	pw[0] = 1;
	for(int i = 1;i<= n;i++)pw[i] = pw[i-1]*seed;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		if(pre[a[i]])
		{
			val[pre[a[i]]]+=pw[++tot];
			val[i]-=pw[tot];
		}
		pre[a[i]] = i;
	}
	for(int i = 1;i<= n;i++)
		sum[i] = sum[i-1]+val[i];
	for(int i = 1;i<= n;i++)
	{
		if(id.count(sum[i]))
			next[id[sum[i]]] = i;
		id[sum[i]] = i;
	}
	ans = n;
	for(int i = 1;i<= n;i++)
		if(!vis[i])
		{
			top = 0;
			for(int j = i;j;j = next[j])
				stack[++top] = j,vis[j] = true;
			cnt+=(LL)top*(top-1)>>1;
			int k = 1;
			for(int j = 1;j<= top;j++)
			{
				while(k<j&&calc(stack[k],stack[j])>calc(stack[k+1],stack[j]))k++;
				ans = min(ans,calc(stack[k],stack[j]));
			}
		}
	printf("%lld %d",cnt,ans);
	return 0;
}
Problem4383

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int Ed = 2e6+5;
const int N = 6e5+5;
const int INF = 1e9;
struct E
{int next,to,val;}e[Ed];
int ls[N],rs[N],L[N],R[N];
int sit[N];
int head[N],tot,cnt,ind[N],c[N],d[N],ans[N];
bool done[N];
void add(int x,int y,int f)
{
	ind[y]++;
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
int build(int l,int r)
{
	cnt++;
	L[cnt] = l,R[cnt] = r;
	int p = cnt;
	if(l==r)
	{
		sit[l] = cnt;
		return p;
	}
	int mid = (l+r)>>1;
	ls[p] = build(l,mid);
	add(p,ls[p],0);
	rs[p] = build(mid+1,r);
	add(p,rs[p],0);
	return p;
}
void update(int p,int a,int b,int c)
{
	if(L[p]>=a&&R[p]<=b)
	{
		add(c,p,0);return ;
	}
	int mid = (L[p]+R[p])>>1;
	if(a<=mid)update(ls[p],a,b,c);
	if(b>mid)update(rs[p],a,b,c);
	return ;
}
void dfs(int x)
{
	done[x] = true;
	for(int i = head[x];i;i = e[i].next)
	{
		ans[e[i].to] = min(ans[e[i].to],ans[x]-e[i].val);
		ind[e[i].to]--;
		if(!ind[e[i].to])dfs(e[i].to);
	}
}
int main()
{
	int n,s,m;
	scanf("%d%d%d",&n,&s,&m);
	build(1,n);
	for(int i = 1;i<= cnt;i++)ans[i] = INF;
	int tmp = cnt;
	for(int i = 1;i<= s;i++)
	{
		scanf("%d%d",&c[i],&d[i]);
		ans[sit[c[i]]] = d[i];
	}
	int left,right,k;
	int y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&left,&right,&k);
		y = left;
		cnt++;
		for(int i = 1;i<= k;i++)
		{
			int x;
			scanf("%d",&x);
			add(sit[x],cnt,1);
			if(x>y)update(1,y,x-1,cnt);
			y = x+1;
		}
		if(right>=y)update(1,y,right,cnt);
	}
	for(int i = tmp+1;i<= cnt;i++)ans[i] = INF;
	dfs(1);
	for(int i = 1;i<= n;i++)
		if(!done[sit[i]]||ans[sit[i]]<1)
			{printf("NIE\n");return 0;}
	for(int i = 1;i<= s;i++)
		if(ans[sit[c[i]]]!=d[i])
			{printf("NIE\n");return 0;}
	printf("TAK\n");
	for(int i = 1;i< n;i++)
		printf("%d ",ans[sit[i]]);
	printf("%d\n",ans[sit[n]]);
	return 0;
}
Problem4385

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 2e6+5;
LL sum[N];
int a[N];
int line[N],L,R;
int main()
{
	int n,d;
	LL p;
	scanf("%d%lld%d",&n,&p,&d);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum[i] = sum[i-1]+a[i];
	}
	int i = 0,ans = 0;
	L = 0,R = -1;
	for(int j = d;j<= n;j++)
	{
		while(L<=R&&sum[j]-sum[j-d]>sum[line[R]]-sum[line[R]-d])R--;
		line[++R] = j;
		while(sum[j]-sum[i]-sum[line[L]]+sum[line[L]-d]>p)
		{
			i++;
			if(line[L]-d<i)L++;
		}
		ans = max(ans,j-i);
	}
	printf("%d\n",ans);
	return 0;
}
Problem4386

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 41;
int n,m,cnt;
LL K,mx;
struct Martix
{
	LL a[N*3][N*3];
	Martix()
	{
		memset(a,0,sizeof(a));
	}
	Martix operator*(const Martix &S)const
	{
		Martix ans;
		int i,j,k;
		for (i=0; i<=cnt; i++)
			for (j=0; j<=cnt; j++)
				if (S.a[i][j]<0 || a[i][j]<0)
				{
					ans.a[0][0]=-1; return ans;
				}
		for (i=0; i<=cnt; i++)
			for (j=0; j<=cnt; j++) 
				if (S.a[i][j])
				for (k=0; k<=cnt; k++) 
					if(a[j][k]){
					if (S.a[i][j]>K/a[j][k]){
						ans.a[0][0]=-1; return ans;
					}
					ans.a[i][k]+=S.a[i][j]*a[j][k];
					if (ans.a[i][k]>K){
						ans.a[0][0]=-1; return ans;
					}
				}
		return ans;
	}
};
Martix quick[65],b,c;
int id[N][3],st[N*3];
bool check()
{
	if (b.a[0][0]<0) return 0; 
	LL tmp=0;
	for (int i=1; i<=cnt; i++) 
		if (b.a[0][i] && st[i])
		{
			if(b.a[0][i]>K/st[i]) return 0;
			tmp+=b.a[0][i]*st[i];
			if (tmp>=K) return 0;
		}
	return 1;
}
int main()
{
	int x,y,C;
	scanf("%d%d%lld",&n,&m,&K);
	mx = K*3;
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<3;j++)
			id[i][j] = ++cnt;
	Martix A;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 0;j<2;j++)
			A.a[id[i][j]][id[i][j+1]]++;
		A.a[0][id[i][0]] = 1;
	}
	A.a[0][0] = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&C);
		A.a[id[x][C-1]][id[y][0]]++;
		st[id[x][C-1]]++;
	}
	int len = 0;
	while((LL)1<<len<=mx)len++;
	len--;
	quick[0] = A;
	for(int i = 1;i<= len;i++)
		quick[i] = quick[i-1]*quick[i-1];
	c.a[0][0] = 1;
	LL ans = 0;
	for(int i = len;i>=0;i--)
	{
		b = quick[i]*c;
		if(check())
		{
			ans|=((LL)1<<i);
			memcpy(c.a[0],b.a[0],sizeof(b.a[0]));
		}
	}
	ans++; 
	printf("%lld\n",(ans<=mx)?ans:-1);
	return 0;
}
Problem4398

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e5+5;
const int N = 4e4+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;};
struct p
{
	int v,no;
}heap[N<<2];
bool cmp(p a,p b)
{
	return a.v>b.v;
}
int dist[N],pre[N],cnt;
bool v[N];
struct G
{
	E e[M<<1];
	int head[N],tot;
	void add(int x,int y,int f)
	{
		e[++tot].to = y;
		e[tot].next = head[x];
		e[tot].val  = f;
		head[x] = tot;
	}
	void spfa()
	{
		dist[1]=0;
		heap[1].v = 0;heap[1].no = 1;
		cnt++;
		push_heap(heap+1,heap+cnt+1,cmp);
		while(cnt)
		{
			int now=heap[1].no;
			pop_heap(heap+1,heap+1+cnt,cmp);
			cnt--;
			if(v[now])continue;
			v[now]=1;
			for(int i=head[now];i;i=e[i].next)
				if(dist[now]+e[i].val<dist[e[i].to]&&!v[e[i].to])
				{
					dist[e[i].to]=dist[now]+e[i].val;
					if(now==1)pre[e[i].to]=e[i].to;
					else pre[e[i].to]=pre[now];
					heap[++cnt].v = dist[e[i].to];
					heap[cnt].no = e[i].to;
					push_heap(heap+1,heap+cnt+1,cmp);
				}
		}
	}
}g1,g2;
int main()
{
	int n,m,x,y,u,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&u,&w);
		g1.add(x,y,u);
		g1.add(y,x,w);
	}
	memset(dist,0x3f,sizeof(dist));
	g1.spfa();
	int end = n+1;
	for(int i = g1.head[1];i;i = g1.e[i].next)
	{
		if(pre[g1.e[i].to]!=g1.e[i].to)
			g2.add(1,g1.e[i].to,g1.e[i].val);
		//else g2.add(1,g1.e[i].to,dist[g1.e[i].to]);
	}
	for(int i = 2;i<= n;i++)
	{
		for(int j = g1.head[i];j;j = g1.e[j].next)
		{
			if(g1.e[j].to==1)
			{
				if(pre[i]!=i)
					g2.add(1,end,dist[i]+g1.e[j].val);
				else g2.add(i,end,g1.e[j].val);
			}else
			{
				if(pre[g1.e[j].to]!=pre[i])
					g2.add(1,g1.e[j].to,dist[i]+g1.e[j].val);
				else g2.add(i,g1.e[j].to,g1.e[j].val);
			}
		}
	}
	memset(dist,0x3f,sizeof(dist));
	memset(v,0,sizeof(v));
	g2.spfa();
	if(dist[end]==INF)printf("-1\n");
	else printf("%d\n",dist[end]);
	return 0;
}
Problem4412

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
int c[N<<1];
int q[N],l,r;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&c[i]);
		c[i+n] = c[i];
	}
	int last = 0,sum = 0,st = 0,beg = 0;
	for(int i = 1;i<= 2*n;i++)
	{
		if(last<0)
			last = 0,beg = i;
		last+=c[i]-1;
		if(last>sum)
			sum = last,st = beg;
	}
	LL ans = 0;
	r = -1;
	for(int i = st;i<st+n;i++)
	{
		while(c[i]--)
			q[++r] = i;
		ans+=(LL)(i-q[l])*(i-q[l]);
		l++;
	}
	printf("%lld",ans);
	return 0;
}
Problem4422

#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
const int X=1000001,Y=1000000,N=2000005;
struct FEN{
    int xl,xr,y,i;
    bool flag;
    bool operator < (const FEN &o)const{
        return y!=o.y?y>o.y:xl<o.xl;
    }
} fen[N<<1];

struct FLO{
    int x,y;
    bool operator < (const FLO &o)const{
        return y>o.y;
    }
} flo[N];
struct CS{
    int x,y,i;
    bool operator < (const CS &o)const{
        return y>o.y;
    }
} cow[N];
struct SS{
    int nm;
    bool cov,cut;
} tr[X<<2];
int ans[N],fs[N];;
char * cp=(char *)malloc(20000000);
inline void in(int &x){
    for (;*cp<'0'||*cp>'9';cp++);
    for (x=0;*cp>='0'&&*cp<='9';cp++)
        x=x*10+*cp-'0';
}
inline void pushup(int x){
    tr[x].nm=tr[x<<1].nm+tr[x<<1|1].nm;
    tr[x].cut=tr[x<<1].cut|tr[x<<1|1].cut;
}
inline void paint(int x){
    tr[x].cov=1;
    tr[x].nm=0;
}
inline void pushdown(int x){
    if(tr[x].cov){
        paint(x<<1),paint(x<<1|1);
        tr[x].cov=0;
    }
}
void add(int x,int l,int r,int pur,int val){
    tr[x].nm+=val;
    if (l==r) return; 
    int mid=(l+r)>>1;
    pushdown(x);
    if(pur<=mid)
        add(x<<1,l,mid,pur,val);
    else 
        add(x<<1|1,mid+1,r,pur,val);
    pushup(x);
}
void cov(int x,int l,int r,int L,int R){
    if(L<=l&&r<=R){
        paint(x);
        return;
    }
    pushdown(x);
    int mid=(l+r)>>1;
    if(L<=mid)cov(x<<1,l,mid,L,R);
    if(R>mid)cov(x<<1|1,mid+1,r,L,R);
    pushup(x);
}
int query(int x,int l,int r,int L,int R)
{
    if(L<=l&&r<=R)
    {
        return tr[x].nm;
    }
    int mid=(l+r)>>1,ans=0;
    pushdown(x);
    if(L<=mid)ans+=query(x<<1,l,mid,L,R);
    if(R>mid)ans+=query(x<<1|1,mid+1,r,L,R);
    return ans;
}
void update(int x,int l,int r,int pur)
{
    if(l==r)
    {
        tr[x].cut^=1;
        return; 
    }
    int mid=l+r>>1;
    pushdown(x);
    if(pur<=mid)
        update(x<<1,l,mid,pur);
    else 
        update(x<<1|1,mid+1,r,pur);
    pushup(x);
}
int next(int x,int l,int r,int L)
{
    if(l>=L)
    {
        if(tr[x].cut)
        {
            while(l!=r)
                if(tr[x<<1].cut)
                    x<<=1,r=l+r>>1;
                else 
                    x=x<<1|1,l=(l+r>>1)+1;
            return l;
        }
        else return 0;
    }
    int tmp,mid=(l+r)>>1;
    pushdown(x);
    if(L<=mid&&(tmp=next(x<<1,l,mid,L)))
        return tmp;
    else 
        return next(x<<1|1,mid+1,r,L);
}
int main()
{
	//freopen("tt.in","r",stdin);
    fread(cp,1,20000000,stdin);
    int f,m,n,x1,y1,x2,y2;
    in(f);
    for(int i=f;i--;)
    {
        in(x1),in(y1),in(x2),in(y2);
        fen[i<<1]=(FEN){x1,x2,y1-1,i,0};
        fen[i<<1|1]=(FEN){x1,x2,y2,i,1};
    }
    sort(fen,fen+(f<<1));
    in(m);
    for(int i=m;i--;)
        in(flo[i].x),in(flo[i].y);
    sort(flo,flo+m);
    in(n);
    for(int i=0;i<n;++i)
    {
        in(cow[i].x),in(cow[i].y);
        cow[i].i=i;
    }
    sort(cow,cow+n);
    f=m=n=0;
    update(1,1,Y,Y);
    int sum,cut;
    for(int i=Y;i;--i)
    {
        for(;fen[f].y==i;++f)
            if(fen[f].flag==0)
            {
                cov(1,1,Y,fen[f].xl,fen[f].xr);
                if(fen[f].xl!=1)
                    add(1,1,Y,fen[f].xl-1,-fs[fen[f].i]);
                if(fen[f].xl!=1)
                    update(1,1,Y,fen[f].xl-1);
                if(fen[f].xr!=Y)
                    update(1,1,Y,fen[f].xr);
            }else
            {
                cut=next(1,1,Y,fen[f].xr);
                sum=query(1,1,Y,fen[f].xl,fen[f].xr);
                fs[fen[f].i]=query(1,1,Y,fen[f].xr+1,cut);
                cov(1,1,Y,fen[f].xl,fen[f].xr);
                if(fen[f].xl>1)
                    add(1,1,Y,fen[f].xl-1,sum+fs[fen[f].i]);
                if(fen[f].xl!=1)
                    update(1,1,Y,fen[f].xl-1);
                if(fen[f].xr!=Y)
                    update(1,1,Y,fen[f].xr);
            }
        for(;flo[m].y==i;++m)
            add(1,1,Y,flo[m].x,1);
        for(;cow[n].y==i;++n)
        {
            cut=next(1,1,Y,cow[n].x);
            ans[cow[n].i]=query(1,1,Y,cow[n].x,cut);
        }
    }
    for(int i=0;i<n;++i)
        printf("%d\n",ans[i]);
    return 0;
}
Problem4425

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int n,m,ans;
struct stuff
{int l,r;}s[N];
inline bool cmp(const stuff &a,const stuff &b){return a.l<b.l;}
struct pro
{
	int x;
	bool operator <(const pro &a)const{return x>a.x;}
};
priority_queue<pro>heap;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&s[i].l,&s[i].r),s[i].r+=s[i].l;
	sort(s+1,s+n+1,cmp);
	heap.push((pro){s[1].r+m});
	for(int i = 2;i<= n;i++)
	{
		while(!heap.empty()&&heap.top().x<s[i].l)heap.pop();
		int t = heap.top().x;
		if(t-m<=s[i].l&&s[i].l<=t)ans++,heap.pop();
		heap.push((pro){s[i].r+m});
	}
	printf("%d\n",ans);
	return 0;
}
Problem4426

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 210;
const int INF = 0x3f3f3f3f;
struct data
{
	int l,r;
	data(){}
	data(int _l,int _r):l(_l),r(_r){}
}s[N],q[2][N];
int cnt[2],ans = -INF;
bool cmp1(const data &a,const data &b)
{return a.l<b.l;}
bool cmp2(const data &a,const data &b)
{return a.r-a.l+1>b.r-b.l+1;}
int f[N][N],sum[N];
void solve(int now,int l,int r,int dl,int dr)
{
	int mid = (l+r)>>1,dmid = dl,maxn = ans;
	for(int i = min(dr,mid-1);i>=dl;i--)
	{
		if(q[0][i+1].r<=q[0][mid].l)break;
		int tmp = f[now-1][i]+q[0][i+1].r-q[0][mid].l;
		if(tmp>=maxn)maxn = tmp,dmid = i;
	}
	f[now][mid] = maxn;
	if(l<mid)solve(now,l,mid-1,dl,dmid);
	if(r>mid)solve(now,mid+1,r,dmid,dr);
}
int main()
{
	int n,p;
	scanf("%d%d",&n,&p);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&s[i].l,&s[i].r);
	for(int i = 1;i<= n;i++)
	{
		int flag = 0;
		for(int j = 1;j<= n;j++)
			if(s[i].l<=s[j].l&&s[i].r>=s[j].r&&(s[i].l!=s[j].l||s[i].r!=s[j].r||i<j))
				flag = 1;
		q[flag][++cnt[flag]] = s[i];
	}
	sort(q[0]+1,q[0]+cnt[0]+1,cmp1);
	for(int i = 1;i<= cnt[0];i++)f[0][i]=-INF;
	for(int i = 1;i<= p;i++)f[i][0] = -INF;
	for(int i = 1;i<= p;i++)solve(i,1,cnt[0],0,cnt[0]);
	sort(q[1]+1,q[1]+cnt[1]+1,cmp2);
	for(int i = 1;i<= cnt[1];i++)sum[i] = sum[i-1]+q[1][i].r-q[1][i].l;
	for(int i = 1;i<= p;i++)
		if((p-i)<=cnt[1]&&f[i][cnt[0]]>=0)
			ans = max(ans,f[i][cnt[0]]+sum[p-i]);
	printf("%d\n",ans);
	return 0;
}
Problem4427

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-9;
const int N = 1005;
inline int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	return x>0?1:-1;
}
inline int sqr(int x)
{
	return x*x;
}
struct Point
{
	double x,y;
	Point(){}
	Point(double _x,double _y):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend double operator *(const Point &a,const Point &b)
	{return a.x*b.y-a.y*b.x;}
	friend bool operator !=(const Point &a,const Point &b)
	{return a.x!=b.x||a.y!=b.y;}
	friend bool operator ==(const Point &a,const Point &b)
	{return a.x==b.x&&a.y==b.y;} 
}poi[N];
struct Line
{
	Point a,b;
	Line(){}
	Line(const Point &_a,const Point &_b):a(_a),b(_b){}
}line[N];
struct E
{int next,to;}e[N*N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool Inter(const Line &l1,const Line &l2)
{
	return dcmp((l1.b-l1.a)*(l2.a-l1.a))*dcmp((l1.b-l1.a)*(l2.b-l1.a))<0
			&& dcmp((l2.b-l2.a)*(l1.a-l2.a))*dcmp((l2.b-l2.a)*(l1.b-l2.a))<0;
}
int col[N];
queue<int>Q;
int main()
{
	int n,m,x,y,id;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		poi[i] = Point(x,y);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&id,&x,&y);
		line[i].a = poi[id];
		line[i].b = Point(x,y);
	}
	for(int i = 1;i<= m;i++)
		for(int j = i+1;j<= m;j++)
			if((Inter(line[i],line[j])||line[i].b==line[j].b)&&
				line[i].a!=line[j].a&&line[i].a!=line[j].b&&line[i].b!=line[j].a)
					add(i,j),add(j,i);
	for(int i = 1;i<= m;i++)
	{
		if(col[i])continue;
		col[i] = 1;
		Q.push(i);
		while(!Q.empty())
		{
			int x = Q.front();
			Q.pop();
			for(int j = head[x];j;j=e[j].next)
			{
				if(col[e[j].to])
				{
					if(col[e[j].to]==col[x])
					{
						printf("impossible\n");
						return 0;
					}
				}else
				{
					col[e[j].to] = col[x]==1?2:1;
					Q.push(e[j].to);
				}
			}
		}
	}
	printf("possible\n");
	return 0;
}
Problem4432

#include <stdio.h>
#include <math.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
const int mx = 3e5;
int Tim,n,m,top,tp;
int cnt[N][4];
char s[N];
struct seg;
struct edge;
vector<edge*>now[N][4];
struct edge
{
	seg *pre,*nxt;
	inline void solve();
	inline void merge();
}List[N<<1];
struct seg
{
	int l,r,flag,h0,t0;
	edge *pre,*nxt;
	inline int calc()
	{return h0+cnt[Tim][flag]-cnt[t0][flag];}
	inline bool checka()
	{return pre&&pre->pre->calc()>calc();}
	inline bool checkb()
	{return nxt&&nxt->nxt->calc()>calc();}
	inline void update()
	{flag = checka()|(checkb()<<1);}
}list[N<<1],*last,*first;
inline void edge::solve()
{
	int delta = abs(pre->calc()-nxt->calc()),flag = pre->flag^nxt->flag;
	if(delta && flag && delta+cnt[Tim][flag]<=mx)
		now[delta+cnt[Tim][flag]][flag].push_back(this);
}
inline void edge::merge()
{
	if(!(pre&&nxt))return ;
	int h = pre->calc();
	if(nxt->calc()!=h)return ;
	seg* ret = pre;
	ret->l = pre->l,ret->r = nxt->r,ret->h0 = h,ret->t0 = Tim;
	ret->pre = pre->pre,ret->nxt = nxt->nxt,ret->update();
	if(ret->pre)ret->pre->nxt = ret;
	if(ret->nxt)ret->nxt->pre = ret;
	if(ret->pre)ret->pre->solve();
	if(ret->nxt)ret->nxt->solve();
	pre = NULL,nxt = NULL;
}

int main()
{
	int h;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&h);
		if(last && last->h0==h)
			{last->r=i;continue;}
		++top;
		list[top].l = list[top].r = i;list[top].h0 = h,list[top].t0 = 0;
		if(last)
		{
			++tp;
			List[tp].pre = last,List[tp].nxt = &list[top];
			last->nxt = &List[tp];list[top].pre = &List[tp],last->update();
		}else first = &list[top];
		last = &list[top];
	}
	last->update();
	for(seg *i = first;i->nxt;i=i->nxt->nxt)
		i->nxt->solve();
	scanf("%s",s+1);
	for(Tim = 1;Tim<=m;Tim++)
	{
		cnt[Tim][1]=cnt[Tim-1][1]+(s[Tim]=='A'),cnt[Tim][2]=cnt[Tim-1][2]+(s[Tim]=='B');
		cnt[Tim][3]=cnt[Tim-1][3]+1;
		for(int f = 1;f<= 3;f++)
		{
			int sz = now[cnt[Tim][f]][f].size();
			for(int i = 0;i<sz;i++)now[cnt[Tim][f]][f][i]->merge();
		}
	}
	Tim = m;
	for (seg* i=first;i;i=i->nxt?i->nxt->nxt:NULL)
   	    for (int j=i->l;j<=i->r;++j)
        {
            if (j>1) putchar(' ');
            printf("%d",i->calc());
        }
    putchar('\n');
	return 0;
}
Problem4435

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3005;
const int M = 9005;
const int INF = 0x3f3f3f3f;
typedef unsigned long long ull;
struct E
{int next,to,f;}e[M];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = f;
}
int d[N],n,m;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(s);
	d[s] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(e[i].f&&d[e[i].to]==d[s]+1)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
bool vis[N];
int a[N],b[N];
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!vis[e[i].to])
			dfs(e[i].to);
}
void reset()
{
	for(int i = 2;i<=tot;i+=2)
		e[i].f=e[i^1].f=(e[i].f+e[i^1].f)>>1;
}
ull BASE = 1,hash[4][N];
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(vis,0,sizeof(vis));
	dfs(s);
	BASE *= 131;
	for(int i = 1;i<= n;i++)
		if(~d[i])
			hash[tmp][i]+=BASE;
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(vis[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)a[i]=i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y,1);
	}
	solve(1,n);
	int Ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			for(int k = 0;k<= 3;k++)if(hash[k][i]!=hash[k][j])
			{
				Ans+=k;
				break;
			}
	printf("%d\n",Ans);
	return 0;
}
Problem4436

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
int nxt[N];
bool ins[N],vis[N];
int head[N],tot,ind[N];
queue<int>Q;
void getans(int x,int c)
{
	vis[x] = true;
	ins[x] = c;
	if(!vis[nxt[x]])getans(nxt[x],c^1);
}
int main()
{
	int n,x;
	scanf("%d",&n);
	n<<=1;
	for(int i = 1;i<= n;i++)
		scanf("%d",&nxt[i]),ind[nxt[i]]++;
	for(int i = 1;i<= n;i++)
		if(!ind[i])
			Q.push(i),vis[i]=true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		ins[x] = true;
		int y = nxt[x];
		if(vis[y])continue;
		vis[y] = true;
		int z = nxt[y];
		if(!--ind[z])
		{
			Q.push(z);
			vis[z] = true;
		}
	}
	for(int i = 1;i<= n;i++)
		if(!vis[i])
			getans(i,1);
	for(int i = 1;i<= n;i++)
		if(ins[i])printf("%d ",i);
	return 0;
}
Problem4437

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
const int M=2000000;
const int P=(1<<24)-1;
char map[105][105];
struct E
{int x,y,next;}e[M+5];
int head[P+1],tot,n,m;
void add(int x,int y)
{
	int p = ++tot;
	e[p].x = x;
	e[p].y = y;
	e[p].next = head[((x<<9)^y)&P];
	head[((x<<9)^y)&P] = p;
}
bool ask(int x,int y)
{
	for(int i = head[((x<<9)^y)&P];i;i=e[i].next)
		if(x==e[i].x&&y==e[i].y)
			return true;
	return false;
}
int _dx[]={0,0,1,-1};
int _dy[]={1,-1,0,0};
int l,r,Qx[M],Qy[M];
const int lim = 10000;
int cnt;
void bfs()
{
	l=r=-1;Qx[++r]=0,Qy[r]=0;
	add(0,0);
	int x,y,sx,sy;
	while(l<r&&cnt<lim)
	{
		x = Qx[++l],y = Qy[l];
		for(int d = 0;d<4;d++)
		{
			sx = x+_dx[d],sy = y+_dy[d];
			if(!ask(sx,sy)&&map[(sx%n+n)%n][(sy%m+m)%m]=='.')
			{
				Qx[++r] = sx,Qy[r] = sy;
				add(sx,sy);
				if(sx%n==0&&sy%m==0)cnt++;
				if(r==M-1)return ;
			}
		}
	}
}
inline ll Abs(ll x){return x>0?x:-x;}
int flag;
ll dx,dy;
void getans(int x,int y)
{
	if(cnt<lim&&r<M-1){printf("%s\n",ask(x,y)?"yes":"no");return ;}
	if(flag){printf("%s\n",ask((x%n+n)%n,(y%m+m)%m)?"yes":"no");return ;}
	int L = -1e9,R = 1e9;
	while(L+5<R)
	{
		int m1 = (L+L+R)/3,m2 = (L+R+R)/3;
		ll f1 = Abs(dx*m1+x)+Abs(dy*m1+y);
		ll f2 = Abs(dx*m2+x)+Abs(dy*m2+y);
		if(f1<f2)R = m2;
		else L = m1;
	}
	int k = L;
	for(int i = L;i<= R;i++)
		if(Abs(dx*k+x)+Abs(dy*k+y)>=Abs(dx*i+x)+Abs(dy*i+y))
		{
			if (ask(x+dx*i,y+dy*i)) return void(printf("yes\n"));
			k=i;
		}
	printf("no\n");
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i< n;i++)
		scanf("%s",map[i]);
	bfs();
	if(cnt>=lim||r==M-1)
	{
		if(ask(n,0)&&ask(0,m))
			flag = 1;
		else
		{
			dx = 1ll<<40,dy = 1ll<<40;
			for (int i=1;i<=r;i++)
				if (Qx[i]%n==0 && Qy[i]%m==0)
					if (Qx[i]+Qy[i]<dx+dy)
						dx=Qx[i],dy=Qy[i];
		}
	}
	int Q,x,y;
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%d%d",&x,&y);
		getans(x,y);
	}
	return 0;
}
Problem4444

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int INF = 1e9;
const int N = 400020;
struct yts { int x,t,ne;} e[N];
struct PP { int l,r,id;} p[N];
int head[N],dep[N],st[N],ans[N],w;
int m,num;
 
bool cmp(PP a,PP b) { return a.l<b.l;}
void put(int x,int y)
{
	num++; e[num].x=x; e[num].t=y;
	e[num].ne=head[x]; head[x]=num;
}
 
void dfs(int x,int h)
{
	st[++w]=x;
	if (p[x].id!=-1)
	{
		while (h<w&&p[st[h+1]].r>=p[x].l+m) h++;
		ans[p[x].id]=dep[x]-dep[st[h]]+1;
	}
	for (int i=head[x];i;i=e[i].ne)
	{
		int y=e[i].t;
		dep[y]=dep[x]+1;
		dfs(y,h);
	}
	w--;
}
 
int main()
{
	int n;
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		if (r<l) r+=m;
		p[i]=(PP){l,r,i}; p[i+n]=(PP){l+m,r+m,-1};
	}
	n<<=1;
	sort(p+1,p+n+1,cmp);
	int now=1;
	for (int i=1;i<n;i++)
	{
		while (now<n&&p[now+1].l<=p[i].r) now++;
		put(now,i);
	}
	n>>=1;
	dep[2*n]=1; dfs(2*n,1);
	for (int i=1;i<=n;i++) printf("%d ",ans[i]);
	printf("\n");
	return 0;
}
Problem4445

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
const double eps = 1e-10;
int dcmp(double x)
{
	if(fabs(x)<eps)return 0;
	if(x>0)return 1;else return -1;
}
struct Point
{
	double x,y;
	Point(double _x=0,double _y=0):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend Point operator *(const Point &a,const double &k)
	{return Point(a.x*k,a.y*k);}
	friend double operator *(const Point &a,const Point &b)
	{return a.x*b.x+a.y*b.y;}
	friend double operator ^(const Point &a,const Point &b)
	{return a.x*b.y-a.y*b.x;}

};
struct Line
{
	Point p,v;
	double ang;
	Line(){}
	Line(Point _p,Point _v):p(_p),v(_v)
	{ang = atan2(v.y,v.x);}
	bool operator <(const Line &s)const
	{return ang<s.ang;}
};
bool on_left(const Line &l,const Point &p)
{return dcmp(l.v^(p-l.p))>0;}
Point Get_intersection(const Line &l1,const Line &l2)
{
	double x = ((l2.p-l1.p)^l2.v)/(l1.v^l2.v);
	return l1.p+l1.v*x;
}
double pans;
Line l[N],q[N];
Point t[N],p[N];
void Get_Half_Plane_Intersection(int n)
{
	sort(l+1,l+n+1);
	int hd = 1,tl = 0;
	q[++tl]=l[1];
	for(int i = 2;i<= n;i++)
	{
		while(hd<tl&& !on_left(l[i],p[tl-1]))tl--;
		while(hd<tl&& !on_left(l[i],p[hd]))hd++;
		q[++tl]=l[i];
		if(dcmp(q[tl].v^q[tl-1].v)==0)
		{
			tl--;
			if(hd<tl && !on_left(l[i],p[tl-1]))q[tl]=l[i];
		}
		if(hd<tl)p[tl-1] = Get_intersection(q[tl],q[tl-1]);
	}
	while(hd<tl && !on_left(q[hd],p[tl-1]))tl--;
	if(tl-hd<=1)
	{
		printf("0.0000");
		return ;
	}
	p[tl] = Get_intersection(q[tl],q[hd]);
	double ans = 0;
	for(int i = hd+1;i< tl;i++)
		ans+=((p[i]-p[hd])^(p[i+1]-p[hd]));
	ans = ans*0.5;
	printf("%.4f\n",ans/pans);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf",&t[i].x,&t[i].y);
	t[n+1]=t[1];
	for(int i = 2;i<n;i++)
		pans+=((t[i]-t[1])^(t[i+1]-t[1]));
	pans*=0.5;
	int cnt = 0;
	double x1 = t[1].x,y1 = t[1].y;
	double x2 = t[2].x,y2 = t[2].y;
	for(int i = 2;i<= n;i++)
	{
		double x3 = t[i].x,y3 = t[i].y;
		double x4 = t[i+1].x,y4 = t[i+1].y;
		double a = y1+y4-y2-y3;
		double b = x2+x3-x1-x4;
		double c = (t[1]^t[2])+(t[i+1]^t[i]);
		Point p,v;
		if(dcmp(b)!=0)p=Point(0,-c/b);  
        else p=Point(-c/a,0);  
       	v=Point(-b,a);
       	l[++cnt]=Line(p,v);
	}
	for(int i = 1;i<= n;i++)l[++cnt]=Line(t[i],t[i+1]-t[i]);
	Get_Half_Plane_Intersection(cnt);
	return 0;
}
Problem4446

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
ll f[N][20],g[N][20],A[N],B[N],dep[N],dis[N];
int ls[N],rs[N],fa[N];
void dp(int x)
{
	if(!ls[x]&&!rs[x])
	{
		for(int y = 2;y<=dep[x];y++)
		{
			int lca = x>>(dep[x]-y+1),z = x>>(dep[x]-y)^1;
			f[x][y]=(dis[x]+dis[z]-2*dis[lca])*A[z];
		}
	}else if(ls[x]&&!rs[x])
	{
		dp(ls[x]);
		for(int y = 2;y<= dep[x];y++)
			f[x][y]=A[ls[x]]*B[ls[x]]+f[ls[x]][y];
	}else
	{
		dp(ls[x]),dp(rs[x]);
		for(int y = 2;y<= dep[x];y++)
			f[x][y]=min(A[ls[x]]*B[ls[x]]+f[ls[x]][dep[x]+1]+f[rs[x]][y],
						A[rs[x]]*B[rs[x]]+f[rs[x]][dep[x]+1]+f[ls[x]][y]);
	}
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
		scanf("%lld",&A[i]);
	dep[1]=1;
	for(int i = 2;i<= n;i++)
	{
		scanf("%lld",&B[i]);
		fa[i]=i>>1;
		dep[i]=dep[fa[i]]+1;
		dis[i]=dis[fa[i]]+B[i];
		if(ls[fa[i]])rs[fa[i]]=i;
		else ls[fa[i]]=i;
	}
	dp(1);
	for(int x = n;x>=1;x--)
		for(int y = 0;y<=dep[x];y++)
		{
			if(!rs[x])
			{
				if(!ls[x])
				{
					if(!y)g[x][y]=0;
					else
					{
						int z=x>>(dep[x]-y);
						g[x][y]=(dis[x]-dis[z])*A[z];
					}
				}else
					g[x][y]=A[ls[x]]*B[ls[x]]+g[ls[x]][y];
			}else
			{
				g[x][y]=min(A[ls[x]]*B[ls[x]]+f[ls[x]][dep[x]+1]+g[rs[x]][y],
							A[rs[x]]*B[rs[x]]+f[rs[x]][dep[x]+1]+g[ls[x]][y]);
			}
		}
	ll ans = g[1][0];
	for(int i = 2;i<= n;i++)
	{
		int x = i;ll sum = g[x][dep[x]-1];
		while(x!=1)
		{
			if((x^1)>n)
				sum+=A[x>>2]*B[x>>1];
			else 
				sum+=A[x^1]*B[x^1]+g[x^1][dep[x>>1]-1];
			x=x>>1;
		}
		ans = min(ans,sum);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4447

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
int n,m,s,t,a[N];
char opt[N];
struct Seg
{
	int x,y,z,s1,s2,t1,t2;
	void init(int i)
	{
		x = y = i;z = 1;
		s1 = t1 = i?-1:0;
		s2 = t2 = -1;
	}
	friend Seg operator +(const Seg &a,const Seg &b)
	{
		Seg res={a.x,b.y,a.z+b.z};
		int j = (a.y||b.x)?-1:0;
		if(b.s1==j)res.s1=a.s1,res.s2=a.s2;
		else 
			res.s1 = b.s1+a.z,res.s2=(b.s2!=j)?b.s2+a.z:a.s1;
		if(a.t1==j)res.t1=b.t1,res.t2=b.t2;
		else
			res.t1 = a.t1+b.z,res.t2=(a.t2!=j)?a.t2+b.z:b.t1;
		return res;
	}
}tr[N<<3];
int cal(int i)
{
	int s = i%n,t=(s+n-1)%n;
	if(opt[s]=='+')return (a[s]+a[t])%10;
	else return a[s]*a[t]%10;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].init(cal(l));
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p]=tr[p<<1]+tr[p<<1|1];
}
void update(int p,int l,int r,int pos,int val)
{
	if(l==r)
	{
		tr[p].init(val);
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos,val);
	else update(p<<1|1,mid+1,r,pos,val);
	tr[p] = tr[p<<1]+tr[p<<1|1];
}
Seg getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(p<<1,l,mid,a,b);
	else if(a>mid)return getans(p<<1|1,mid+1,r,a,b);
	else return getans(p<<1,l,mid,a,b)+getans(p<<1|1,mid+1,r,a,b);
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 0;i<n;i++)
		scanf("%d %c",&a[i],&opt[i]);
	build(1,0,2*n-1);
	int s,t;
	while(m--)
	{
		scanf("%d%d",&s,&t);
		if(s==1)
		{
			scanf("%d %c",&a[t],&opt[t]);
			update(1,0,2*n-1,t,cal(t));
			update(1,0,2*n-1,t+n,cal(t));
			update(1,0,2*n-1,t+1,cal(t+1));
			if(t!=n-1)
				update(1,0,2*n-1,t+n+1,cal(t+1));
		}else
		{
			update(1,0,2*n-1,t,a[t]);
			Seg a=getans(1,0,2*n-1,t,t+(n-1)/2);
			Seg b=getans(1,0,2*n-1,t+(n+1)/2,t+n-1);
			if(~b.t1&&(a.x||b.t1))++b.t1;
            if(~b.t2&&(a.x||b.t2))++b.t2;
            printf("%d\n",a.y||b.x?max(a.s1,b.t1):max(max(a.s2,b.t2),min(a.s1,b.t1)));
            update(1,0,2*n-1,t,cal(t));
		}
	}
	return 0;
}
Problem4448

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],size[N],son[N],top[N],fa[N],dfn[N],seq[N],Dfn,cnt;
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x]=e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x]=tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=son[x]&&e[i].to!=fa[x])
			dfs2(e[i].to,e[i].to);
}
struct Ask
{
	int x,y,c;
	int dat;
}ask[N];
int root[N],sum[N*100],TOT,ls[N*100],rs[N*100],val[N];
int mx = 2e5;
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++TOT;
	sum[p]=sum[pre]+1;
	if(l==r)return ;
	ls[p]=ls[pre],rs[p]=rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
int getans(int p1,int p2,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p2]-sum[p1];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p1],ls[p2],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p1],rs[p2],mid+1,r,a,b);
	return ans;
}
int lth;
int getans(int x,int y,int c)
{
	int ans = 0;
	lth = dep[x]+dep[y];
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans+=getans(root[dfn[top[x]]-1],root[dfn[x]],0,mx,c,mx);
		x = fa[top[x]];
	}
	if(dep[y]<dep[x])swap(x,y);
	ans+=getans(root[dfn[x]-1],root[dfn[y]],0,mx,c,mx);
	lth-=dep[x]+dep[fa[x]];
	return ans;
}
int main()
{
	int n,m,rot;
	int k,x,y,c;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		if(!x)rot=i;
		else add(x,i);
	}
	dfs1(rot);
	dfs2(rot,rot);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&k,&x);
		if(k==1)
		{
			scanf("%d%d",&y,&c);
			cnt++;
			ask[cnt].x=x,ask[cnt].y=y,ask[cnt].c=c;ask[cnt].dat=i;
		}else
			val[x] = m-i;
	}
	for(int i = 1;i<= n;i++)
		update(root[i],root[i-1],0,mx,val[seq[i]]);
	for(int i = 1;i<= cnt;i++)
	{
		int ans2 = getans(ask[i].x,ask[i].y,ask[i].c+m-ask[i].dat+1);
		int ans1 = lth;
		printf("%d %d\n",ans1,ans2);
	}
	return 0;
}
Problem4451

#include <bits/stdc++.h>

const int N = 400005;
const int mod = 1000003;
typedef long long ll;
int toA[N],toB[N];
int ny[N],jc[N];
int n,a,b,c,w;
int pow(int x,int y)
{
	int ans = 1;
	while (y)
	{
		if (y & 1)
			ans = (ll) ans * x % mod;
		x = (ll) x * x % mod;
		y >>= 1;
	}
	return ans;
}

void getJc()
{
	jc[0] = ny[0] = 1;
	for (int i = 1; i <= N - 5; i++)
	{
		jc[i] = (ll) jc[i - 1] * i % mod;
		ny[i] = pow(jc[i],mod - 2);
	}
}

int getW(int x1,int y1)
{
	return (ll)jc[x1 + y1] % mod * ny[x1] % mod * ny[y1] % mod * toB[x1] % mod * toA[y1] % mod;
}

int main()
{
	getJc();
	scanf("%d%d%d%d",&n,&a,&b,&c);
	int ans=0;
	toA[0]=toB[0]=1;
	for (int i = 1; i <= n; i++)
		toA[i] = (ll)toA[i - 1] * a % mod, toB[i] = (ll)toB[i - 1] * b % mod;
	for (int i = 1; i <= n; i++)
	{
		scanf("%d",&w);
		int x = n - i,y = n - 1;
		if (i > 1)
			ans = (ans + (ll)toB[x] * toA[y] % mod * jc[x + y - 1] % mod * ny[x] % mod * ny[y - 1] % mod * w % mod) % mod;
	}
	for (int i = 1; i <= n; i++)
	{
		scanf("%d",&w);
		int x = n - 1, y = n - i;
		if (i > 1)
			ans = (ans + (ll)toB[x] * toA[y] % mod * jc[x + y - 1] % mod * ny[x - 1] % mod * ny[y] % mod * w % mod) % mod;
	}
	n--;
	int now = 1, w = (a + b) % mod;
	ans = (ans + c) % mod;
	for (int i = 1; i < n; i++)
	{
		now = (ll)now * w % mod;
		ans = (ans + (ll)now * c % mod) % mod;
	}
	int x1 = 0, y1 = n-1, x2 = n-1, y2 = 0;
	for (int i = 1; i < n; i++)
	{
		int w1 = getW(x1,y1);
		int w2 = getW(x2,y2);
		now = (now - (ll)w1 + mod) % mod;
		now = (now - (ll)w2 + mod) % mod;
		now = (ll)now * w % mod;
		now = (now + (ll)w1 * b % mod) % mod;
		now = (now + (ll)w2 * a % mod) % mod;
		ans = (ans + (ll)now * c % mod) % mod;
		x1++;
		y2++;
	}
	printf("%d\n",ans);
}
Problem4452

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e5+5;
int fa[N],size[N],deg[N],size2[N],num0,num2,numc;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x] = getfa(fa[x]);
}
void del(int x)
{
	if(deg[x]==0)num0--;
	if(deg[x]==2)num2--,size2[getfa(x)]--;
}
void add(int x)
{
	if(deg[x]==0)num0++;
	if(deg[x]==2)num2++,size2[getfa(x)]++;
}
void delc(int x){if(size[x]==size2[x])numc--;}
void addc(int x){if(size[x]==size2[x])numc++;}
void merge(int u,int v)
{
	int x = getfa(u),y = getfa(v);
	if(x^y)
	{
		delc(x),delc(y),del(u),del(v);
		deg[u]++,deg[v]++;
		add(u),add(v);
		fa[x] = y,size[y]+=size[x],size2[y]+=size2[x];
		addc(y);
	}else
	{
		delc(x),del(u),del(v);
		deg[u]++,deg[v]++;
		add(u),add(v),addc(x);
	}
}
int a[N],idx[N],ans1[N],ans2[N];
bool cmp(int x,int y)
{
	return a[x]>a[y];
}
struct E
{
	int x,y,w;
	bool operator <(const E &s)const
	{
		return w>s.w;
	}
}e[N];
int main()
{
	int n,m,q;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&e[i].x,&e[i].y,&e[i].w);
	sort(e+1,e+m+1);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)scanf("%d",&a[i]),idx[i]=i;
	sort(idx+1,idx+q+1,cmp);
	for(int i = 1;i<= n;i++)
		deg[i]=0,fa[i]=i,size[i]=1,size2[i]=0;
	num0 = n;
	int pnt = 1;
	int curm = 0;
	for(int i = 1;i<= q;i++)
	{
		while(pnt<=m&&e[pnt].w>=a[idx[i]])
			merge(e[pnt].x,e[pnt].y),pnt++,curm++;
		ans1[idx[i]] = n-num0-num2+numc;
		ans2[idx[i]] = curm-num2+numc;
	}
	for(int i = 1;i<= q;i++)
		printf("%d %d\n",ans1[i],ans2[i]);
	return 0;
}
Problem4453

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
char s[N];
int len;
namespace SA
{
	int sa[N],val[N],nv[N],h[N],rnk[N],cnt[N],q[N];
	bool is_same(int a,int b,int hl,int len)
	{
		return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
	}
	void build_sa(int lim,int len)
	{
		int i,j,k;
		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]] = i;
		for(int d = 1;;d++)
		{
			int hl = 1<<(d-1);
			int id = 0;
			for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
			for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

			for(i = 0;i<lim;i++)cnt[i] = 0;
			for(i = 0;i<len;i++)cnt[val[q[i]]]++;
			for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
			for(i = len-1;i>= 0;i--)sa[--cnt[val[q[i]]]] = q[i];

			lim = 0;
			for(i = 0;i<len;lim++)
			{
				for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
				for(k = i,i = j+1;k<=j;k++)nv[sa[k]] = lim;
			}
			for(i = 0;i<len;i++)val[i] = nv[i];
			if(lim==len)break;
		}
	}
	void build_rank(int len)
	{
		for(int i = 0;i<len;i++)
			rnk[sa[i]] = i;
	}
	void build_height(int len)
	{
		for(int i = 0;i<len;i++)
			if(rnk[i])
			{
				int j = 0;
				if(i)j = max(h[rnk[i-1]]-1,0);
				while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])
					j++;
				h[rnk[i]] = j;
			}
	}
	int st[N][20];
	int lg2[N];
	void build_st(int len)
	{
		for(int i = 2;i<N;i++)
			lg2[i] = lg2[i>>1]+1;
		for(int i = 0;i<len;i++)
			st[i][0] = h[i];
		for(int j = 1;j<= 18;j++)
			for(int i = 0;i+(1<<(j-1))<=len;i++)
				st[i][j] = min(st[i][j-1],st[i+(1<<(j-1))][j-1]);
	}
	int lcp(int i,int j)
	{
		i = rnk[i],j = rnk[j];
		if(i>j)swap(i,j);
		i++;
		int lth = lg2[j-i+1];
		return min(st[i][lth],st[j-(1<<lth)+1][lth]);
	}
}
struct E{int next,to,id;};
struct List
{
	E e[N];
	int h[N],tot;
	void insert(int x,int y)
	{
		e[++tot].to = y;
		e[tot].next = h[x];
		h[x] = tot;
	}
}g,list;
struct Q
{int next,to,id;}q[N];
int head[N],tot;
void addq(int x,int y,int id)
{
	q[++tot].to = y;
	q[tot].next = head[x];
	q[tot].id = id;
	head[x] = tot;
}
int vis[N];
set<int>S;
void dfs(int x)
{
	vis[x] = 1;
	S.erase(x);
	for(int i = g.h[x];i;i=g.e[i].next)
	{
		int to = g.e[i].to;
		if(vis[to])continue;
		dfs(to);
	}
}
int stack[N],top,ans[N];
void solve()
{
	for(int r = 0;r< len;r++)
	{
		S.insert(r);
		while(top)
		{
			int lth = SA::lcp(r,stack[top]);
			if(s[r+lth]<s[stack[top]+lth])break;
			list.insert(r+lth,stack[top]);
			g.insert(r,stack[top]);
			top--;
		}
		stack[++top] = r;
		for(int i = list.h[r];i;i=list.e[i].next)
		{
			int to = list.e[i].to;
			if(!vis[to])dfs(to);
		}
		for(int i = head[r];i;i=q[i].next)
			ans[q[i].id] = *S.lower_bound(q[i].to);
	}
}
int main()
{
	scanf("%s",s);
	len = strlen(s);
	SA::build_sa(255,len);
	SA::build_rank(len);
	SA::build_height(len);
	SA::build_st(len);
	int q,l,r;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&l,&r);
		l--,r--;
		addq(r,l,i);
	}
	solve();
	for(int i = 1;i<= q;i++)printf("%d\n",ans[i]+1);
	return 0;
}
Problem4455

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 20;
int mp[N][N],fa[N],n,m;
bool islf[N];
ll f[N][N];
struct E
{int next,to;}e[N*N];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int p[N],q[N];
void dfs(int s)
{
	q[1] = s;
	int l = 1,r = 1;
	while(l<=r)
	{
		int x = q[l++];
		islf[x] = true;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x])
			{
				fa[e[i].to] = x;
				islf[x] = false;
				q[++r] = e[i].to;
			}
	}
}
int get_point(int x)
{
	int j = 0,cnt = 0;
	while(x)
	{
		j++;
		if(x&1)p[++cnt] = j;
		x>>=1;
	}
	return cnt;
}
void dp(int cnt)
{
	for(int i = n;i>= 1;i--)
	{
		int x = q[i];
		if(islf[x])continue;
		for(int j = 1;j<= cnt;j++)
		{
			for(int o = head[x];o;o=e[o].next)
			{
				ll num = 0;int to = e[o].to;
				if(fa[to]!=x)continue;
				for(int k = 1;k<= cnt;k++)
					if(mp[p[j]][p[k]])
						num+=f[to][k];
				f[x][j]*=num;
			}
		}
	}
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)mp[i][i]=1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		mp[x][y] = mp[y][x] = 1;
	}
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1);
	ll ans = 0;int tmp = n%2;
	for(int i = 0;i<(1<<n);i++)
	{
		int cnt = get_point(i);
		int flag = (cnt%2==tmp)?1:-1;
		ll tans = 0;
		for(int j = 1;j<= n;j++)
			for(int k =1;k<= cnt;k++)
				f[j][k] = 1;
		dp(cnt);
		for(int j = 1;j<= cnt;j++)tans+=f[1][j];
		ans+=(ll)flag*tans;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4456

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int M = 1e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,val;}e[M];
struct Ask
{
	int id;
	int x1,y1,x2,y2;
	Ask(){}
}a[M],b[M];
int head[M],tot;
int n,m;
inline int getid(int i,int j)
{
	return i*m-m+j;
}
void add(int x,int y,int f)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	e[tot].val = f;
	head[x] = tot;
}
bool cmp(const int &a,const int &b)
{
	return a>b;
}
int d[M],id[M],cnt,ans[M],q[M];
void goup(int x)
{
	int y=q[x],t=d[y];
	for (; x>1 && t<d[q[x>>1]]; x>>=1)
	{
		q[x]=q[x>>1]; id[q[x]]=x;
	}
	q[x]=y; id[y]=x;
}
void godown(int x)
{
	int y=x<<1,z=q[x],t=d[z];
	if (y<cnt && d[q[y|1]]<d[q[y]]) y|=1;
	while (y<=cnt && d[q[y]]<t)
	{
		q[x]=q[y]; id[q[x]]=x;
		x=y; y<<=1; if (y<cnt && d[q[y|1]]<d[q[y]]) y|=1;
	}
	q[x]=z; id[z]=x;
}
void dijk(int s,int x1,int y1,int x2,int y2)
{
	register int i,j;
	d[s] = 0,id[s] =1,cnt=0;
	q[++cnt] =s;
	for(i = x1;i<= x2;i++)
		for(j = y1;j<= y2;j++)
			if(getid(i,j)!=s)
			{
				int no = getid(i,j);
				q[++cnt] = no;
				d[no] = INF;id[no] = cnt;
			}
	while(cnt)
	{
		int x=q[1];
		q[1]=q[cnt--];
		id[q[1]]=1;
		godown(1);
		for(i = head[x];i;i=e[i].next)
		{
			int to = e[i].to,u = (to-1)/m+1,v = (to-1)%m+1;
			if(u<=x2&&u>=x1&&v<=y2&&v>=y1&&d[x]+e[i].val<d[to])
				{d[to]=d[x]+e[i].val;goup(id[to]);}
		}
	}
}
/*queue<int>Q;
bool vis[M];
void dijk(int s,int x1,int y1,int x2,int y2)
{
	for(int i = x1;i<=x2;i++)
		for(int j = y1;j<= y2;j++)
			d[getid(i,j)] = INF;
	Q.push(s);d[s] = 0;vis[s] =true;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] =false;
		for(int i = head[x];i;i=e[i].next)
		{
			int no = e[i].to;
			int u = (no-1)/m+1,v = (no-1)%m+1;
			if(u<=x2&&u>=x1&&v<=y2&&v>=y1&&d[no]>d[x]+e[i].val)
			{
				d[no] =d[x]+e[i].val;
				if(!vis[no])
					Q.push(no);
			}
		}
	}
}*/
void solve(int x1,int y1,int x2,int y2,int l,int r)
{
	int i,j,k;
	int mid;
	if(l>r)return ;
	if(x2-x1>y2-y1)
	{
		mid = (x1+x2)>>1;
		for(i = y1;i<= y2;i++)
		{
			dijk(getid(mid,i),x1,y1,x2,y2);
			for(j = l;j<= r;j++)
				ans[a[j].id] = min(ans[a[j].id],d[getid(a[j].x1,a[j].y1)]+d[getid(a[j].x2,a[j].y2)]);
		}
		j = l-1,k = r+1;
		for(i = l;i<= r;i++)
			if(a[i].x1<mid&&a[i].x2<mid)b[++j]=a[i];
			else if(a[i].x1>mid&&a[i].x2>mid)b[--k]=a[i];
		for(i = l;i<= j;i++)a[i]=b[i];solve(x1,y1,mid-1,y2,l,j);
		for(i = r;i>= k;i--)a[i]=b[i];solve(mid+1,y1,x2,y2,k,r);
	}else
	{
		mid = (y1+y2)>>1;
		for(i = x1;i<= x2;i++)
		{
			dijk(getid(i,mid),x1,y1,x2,y2);
			for(j = l;j<= r;j++)
				ans[a[j].id] = min(ans[a[j].id],d[getid(a[j].x1,a[j].y1)]+d[getid(a[j].x2,a[j].y2)]);
		}
		j = l-1,k = r+1;
		for(i = l;i<= r;i++)
			if(a[i].y1<mid&&a[i].y2<mid)b[++j]=a[i];
			else if(a[i].y1>mid&&a[i].y2>mid)b[--k]=a[i];
		for(i = l;i<= j;i++)a[i]=b[i];solve(x1,y1,x2,mid-1,l,j);
		for(i = r;i>= k;i--)a[i]=b[i];solve(x1,mid+1,x2,y2,k,r);
	}
}
int main()
{
	//freopen("ex_tourist3.in","r",stdin);
	memset(ans,0x3f,sizeof(ans));
	int q,x;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),getid(i,j+1),x);
			add(getid(i,j+1),getid(i,j),x);
		}
	for(int i = 1;i< n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&x);
			add(getid(i,j),getid(i+1,j),x);
			add(getid(i+1,j),getid(i,j),x);
		}
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d%d",&a[i].x1,&a[i].y1,&a[i].x2,&a[i].y2);
		a[i].id = i;
	}
	solve(1,1,n,m,1,q);
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4472

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct data
{
	int val,x;
	data(){}
	data(int val,int x):val(val),x(x){}
	bool operator <(const data &a)const
	{
		return val>a.val;
	}
}stack[N];
int f[N],n;
bool can[N];
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot,top,lim[N],val[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	top = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			stack[++top] = data(f[e[i].to],e[i].to);
	sort(stack+1,stack+top+1);
	int i;
	for(i = 1;i<= top;i++)
	{
		if(stack[i].val<0||i==lim[x])break;
		f[x]+=stack[i].val;
		if(can[stack[i].x])can[x] = true;
		if(stack[i].val==0)can[x] = true;
	}
	if(i<lim[x]&&i<=top&&i!=0&&stack[i].val==stack[i-1].val)
		can[x] = true;
	f[x]+=val[x];
}
int main()
{
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
		scanf("%d",&val[i]);
	for(int i = 2;i<= n;i++)
		scanf("%d",&lim[i]);
	lim[1] = 10*n;
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	printf("%d\n",f[1]);
	if(!can[1])printf("solution is unique\n");
	else printf("solution is not unique\n");
	return 0;
}
Problem4484

#include <stdio.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int M = 1e5+5;
bitset<N>bit[N];
struct E
{int next,to;}e[M];
struct data
{
	int en,v;
	bool operator <(const data &a)const
	{
		return v>a.v;
	}
}a[N];
int head[N],tot,d[N],n,m,len[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
	d[y]++;
}
int q[N],s,t,ans=0;
void getans()
{
	s = 1,t = 0;
	for(int i = 1;i<= n;i++)
		if(!d[i])
			q[++t] = i;
	while(s<=t)
	{
		int x = q[s++];
		for(int i = head[x];i;i=e[i].next)
			if(!(--d[e[i].to]))
				q[++t] = e[i].to;
	}
	int num;
	for(int i = t;i>= 1;i--)
	{
		int x = q[i];
		bit[x][x] = 1,num = 0,len[x] = 1;
		for(int j = head[x];j;j=e[j].next)
		{
			a[++num] = (data){e[j].to,len[e[j].to]};
			len[x] = max(len[x],len[e[j].to]+1);
		}
		sort(a+1,a+num+1);
		for(int j = 1;j<= num;j++)
		{
			int y = a[j].en;
			if(bit[x][y])ans++;
			bit[x]|=bit[y];
		}
	}	
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	getans();
	printf("%d\n",ans);
	return 0;
}
Problem4485

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 2e6+5;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[M];
int head[N],tot = 1,n,m;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].f = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].f = f;head[y] = tot;
}
int d[N];
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t] = 0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
inline int getid(int x,int y)
{
	return (x-1)*m+y;
}
int main()
{
	int d,sum = 0;
	scanf("%d%d",&n,&m);
	int S = 0,T = n*m+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&d);
			if(d>0)add(S,getid(i,j),d),sum+=d;
			else add(getid(i,j),T,-d),sum+=-d;
		}
	for(int i = 1;i<n;i++)
		for(int j = 1;j<= m;j++)
		{
			scanf("%d",&d);
			add(getid(i,j),getid(i+1,j),d);
		}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<m;j++)
		{
			scanf("%d",&d);
			add(getid(i,j),getid(i,j+1),d);
		}
	printf("%d\n",sum-dinic(S,T));
	return 0;
}
Problem4487

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 405;
int c[N][N];
ll quick_pow(ll x,ll y)
{
	if(y==0)return 1;
	ll tmp = quick_pow(x,y>>1);
	if(y&1)return tmp*tmp%mod*x%mod;
	else return tmp*tmp%mod;
}
void init()
{
	c[0][0] = 1;
	for(int i = 1;i<N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
}
int main()
{
	int n,m,p;
	ll ans = 0;
	init();
	scanf("%d%d%d",&n,&m,&p);
	for(int i = 0;i<= n;i++)
		for(int k = 0;k<= p;k++)
		{
			ans+=(ll)c[n][i]*c[p][k]%mod*((n+m+p-i-k)%2?-1:1)*quick_pow(1-quick_pow(k+1,i),m)%mod;
			ans=(ans%mod+mod)%mod;
		}
	printf("%lld\n",ans);
	return 0;
}
Problem4488

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
struct data
{
	ll num;int pos;
	bool operator <(const data &a)const
	{
		if(num==a.num)return pos<a.pos;
		return num<a.num;
	}
};
ll gcd(ll x,ll y)
{
	if(y==0)return x;
	else return gcd(y,x%y);
}
data tmp,f[2][N];
ll a[N];
int main()
{
	int n;
	ll ans = 0;
	scanf("%d",&n);
	int now = 1,pre = 0;
	int cntn = 0,cntp = 0;
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&a[i]);
		for(int j = 1;j <= cntp;j++)
			f[pre][j].num = gcd(f[pre][j].num,a[i]);
		tmp.num = a[i];
		tmp.pos = i;
		cntp++;
		f[pre][cntp] = tmp;
		sort(f[pre]+1,f[pre]+cntp+1);
		cntn = 0;
		for(int j = 1;j<= cntp;j++)
			if(f[pre][j].num!=f[pre][j-1].num)
				f[now][++cntn] = f[pre][j];
		for(int j = 1;j<= cntn;j++)
			ans = max(ans,f[now][j].num*(i-f[now][j].pos+1));
		swap(now,pre);
		cntp = cntn;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4503

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
const double pi = 3.14159265358979323;
#define N 300005
using namespace std;

struct cpx{ double r,i; }a[N],b[N],c[N]; int n1,n2,m,f[N],g[N],pos[N];
char s1[N],s2[N];
cpx operator +(cpx x,cpx y){ x.r+=y.r; x.i+=y.i; return x; }
cpx operator -(cpx x,cpx y){ x.r-=y.r; x.i-=y.i; return x; }
cpx operator *(cpx x,cpx y){
	cpx t; t.r=x.r*y.r-x.i*y.i; t.i=x.r*y.i+x.i*y.r; return t;
}
void dft(cpx *a,int flag){
	int i,j,k; cpx w,wn,u,v;
	if (flag>0) for (i=0; i<m; i++) a[i].i=0;
	for (k=1; k<m; k<<=1){
		wn.r=cos(pi*flag/k); wn.i=sin(pi*flag/k);
		for (i=0; i<m; i+=(k<<1)){
			w.r=1; w.i=0;
			for (j=i; j<i+k; j++){
				u=a[j]; v=a[j+k]*w;
				a[j]=u+v; a[j+k]=u-v; w=w*wn;
			}
		}
	}
	if (flag<0) for (i=0; i<m; i++) a[i].r/=m;
}
int main(){
	scanf("%s%s",s1+1,s2+1); int i,j,k,cnt=0;
	n1=strlen(s1+1); n2=strlen(s2+1);
	for (i=1; i<=n1; i++) f[i]=s1[i]-'a'+1;
	for (i=1; i<=n2; i++) g[n2-i+1]=(s2[i]=='?')?0:s2[i]-'a'+1;
	m=n1+n2+1;
	for (i=1; i<m; i<<=1) cnt++; m=i;
	for (i=0; i<m; i++)
		for (k=i,j=1; j<=cnt; j++,k>>=1) pos[i]=pos[i]<<1|(k&1);
	for (i=0; i<m; i++){ a[pos[i]].r=f[i]*f[i]; b[pos[i]].r=g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=a[i]*b[i];
	for (i=0; i<m; i++){ a[pos[i]].r=1;  b[pos[i]].r=g[i]*g[i]*g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=c[pos[i]]+a[i]*b[i];
	for (i=0; i<m; i++){ a[pos[i]].r=f[i]*2; b[pos[i]].r=g[i]*g[i]; }
	dft(a,1); dft(b,1);
	for (i=0; i<m; i++) c[pos[i]]=c[pos[i]]-a[i]*b[i];
	dft(c,-1); cnt=0;/*
	for(int i = 0;i<m;i++)
		printf("%.2f ",c[i].r);*/
	for (i=1; i<=n1-n2+1; i++) if (c[i+n2].r<0.5) f[++cnt]=i;
	printf("%d\n",cnt);
	for (i=1; i<=cnt; i++) printf("%d\n",f[i]-1);
	return 0;
}
Problem4511

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int pre[7];
int main()
{
	int sum = 0;
	int n,x,ans = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);
		(sum+=x)%=7;
		if(pre[sum])ans = max(ans,i-pre[sum]);
		else pre[sum] = i;
	}
	printf("%d\n",ans);
	return 0;
}
Problem4512

#include <stdio.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2050;
bitset<N>r[N],u[N],v[N];
char s[N];
int main()
{
	int n;
	scanf("%d",&n);
	scanf("%s",s+1);
	int x =1024,y = 1024,ans = 0;
	for(int i = 1;i<= n;i++)
	{
		v[x][y] = true;
		if(s[i]=='E')
		{
			x++;
			if(!r[x-1][y]&&v[x][y])
				ans++;
			r[x-1][y] = true;
		}else if(s[i]=='W')
		{
			x--;
			if(!r[x][y]&&v[x][y])
				ans++;
			r[x][y] = true;
		}else if(s[i]=='N')
		{
			y--;
			if(!u[x][y]&&v[x][y])
				ans++;
			u[x][y] = true;
		}else
		{
			y++;
			if(!u[x][y-1]&&v[x][y])
				ans++;
			u[x][y-1] = true;
		}
	}
	printf("%d\n",ans);
	return 0;
}
Problem4513

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
ll pow2[64];
ll f[100][2][2][2],g[100][2][2][2];
ll mod;
void work()
{
	ll N,M,K;
	scanf("%lld%lld%lld%lld",&N,&M,&K,&mod);
	N--,M--;
	ll ans = 0;
	memset(f,0,sizeof(f));
	memset(g,0,sizeof(g));
	f[0][1][1][1] = 1;
	for(int i=0;i<=63;i++)
		for(int a=0;a<2;a++)
		for(int b=0;b<2;b++)
		for(int c=0;c<2;c++)
			if(f[i][a][b][c])
			{
				int p = ((N&pow2[63-i])==0)?0:1;
				int q = ((M&pow2[63-i])==0)?0:1;
				int t = ((K&pow2[63-i])==0)?0:1;
				for(int x = 0;x<2;x++)
				{
					if(a&&x>p)continue;
					for(int y = 0;y<2;y++)
					{
						if(b&&y>q)continue;
						int z = x^y;
						if(c&&z<t)continue;
						int A = (a&&x==p);
						int B = (b&&y==q);
						int C = (c&&z==t);
						(f[i+1][A][B][C]+=f[i][a][b][c])%=mod;
						g[i+1][A][B][C]=(g[i+1][A][B][C]+g[i][a][b][c]+((z==0)?0:pow2[63-i]%mod)*f[i][a][b][c]%mod)%mod;
					}
				}
			}
	K%=mod;
	for(int a=0;a<2;a++)
		for(int b=0;b<2;b++)
			for(int c=0;c<2;c++)
		    	ans=(ans+g[64][a][b][c]-K*f[64][a][b][c]%mod+mod)%mod;
	printf("%lld\n",ans);
}
int main()
{
	pow2[0] = 1;
	for(int i = 1;i<64;i++)
		pow2[i] = pow2[i-1]*2;
	int t;
	scanf("%d",&t);
	while(t--)
		work();
	return 0;
}
Problem4514

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll INF = 1e18;
const int N = 305;
const int M = N*N+10*N;
const int maxX = 1e5+5;
int prime[maxX],cnt;
bool vis[maxX];
struct E
{
	int next,to,from;
	ll c,f;
}e[M];
int head[N],tot = 1,from[N];
void add(int x,int y,ll f,ll c)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;e[tot].c = c;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;e[tot].c = -c;
	e[tot].from = y,e[tot-1].from = x;
}
queue<int>Q;
bool v[N];
ll dis[N],rl[N];
void spfa(int S,int T)
{
	for(int i = S;i<= T;i++)dis[i] = -INF;
	Q.push(S);
	dis[S] = 0,vis[S] = true;
	rl[S] = INF;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		v[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[x]+e[i].c>dis[e[i].to])
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				rl[e[i].to] = min(rl[x],e[i].f);
				if(!v[e[i].to])
				{
					Q.push(e[i].to);
					v[e[i].to] = true;
				}
			}
	}
}
void init()
{
	for(int i = 2;i<maxX;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<= cnt&&i*prime[j]<maxX;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int a[N],b[N],c[N],f[N];
int main()
{
	init();
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		ll tmp = a[i];
		for(int j = 1;(ll)prime[j]*prime[j]<=(ll)tmp;j++)
			while(tmp%prime[j]==0)f[i]++,tmp/=prime[j];
		if(tmp!=1&&tmp!=-1)f[i]++;
	}
	for(int i = 1;i<= n;i++)scanf("%d",&b[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&c[i]);
	for(int i = 1;i<= n;i++)
		if(f[i]&1)
			for(int j = 1;j<= n;j++)
				if(f[j]==f[i]-1&&a[i]%a[j]==0||f[j]==f[i]+1&&a[j]%a[i]==0)
					add(i,j,INF,(ll)c[i]*c[j]);
	int S = 0,T = n+1;
	for(int i = 1;i<= n;i++)
		if(f[i]&1)
			add(S,i,b[i],0);
		else add(i,T,b[i],0);
	ll now = 0,ans = 0;
	ll tmp = 0;
	while(true)
	{
		spfa(S,T);
		if(dis[T]==-INF||now+dis[T]<0)break;
		if(dis[T]>=0)tmp = rl[T];
		else tmp = min(rl[T],now/(-dis[T]));
		ans+=tmp;
		now+=dis[T]*tmp;
		for(int i = from[T];i;i=from[e[i].from])
			e[i].f-=tmp,e[i^1].f+=tmp;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4515

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
typedef long long ll;
const ll INF = 123456789123456789ll;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];e[tot].val = f;head[y] = tot;
}
int dep[N],top[N],size[N],son[N],fa[N],n,m;
ll dis[N];
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dis[e[i].to] = dis[x]+e[i].val;
			dfs1(e[i].to);
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
			size[x]+=size[e[i].to];
		}
}
int dfn[N],seq[N],Dfn;
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct Seg
{ll a,b,mn;}tr[N<<2];
void build(int p,int l,int r)
{
	tr[p].a=0,tr[p].b=INF,tr[p].mn = INF;
	if(l==r)return;
	int mid = (l+r)>>1;
	build(p<<1,l,mid),build(p<<1|1,mid+1,r);
}
ll calc(ll a,ll b,ll x)
{
	return a*dis[seq[x]]+b;
}
void Update(int p,int l,int r,ll a,ll b)
{
	ll xl = calc(tr[p].a,tr[p].b,l);
	ll xr = calc(tr[p].a,tr[p].b,r);
	ll yl = calc(a,b,l),yr = calc(a,b,r);
	if(xl<=yl&&xr<=yr)return ;
	if(xl>=yl&&xr>=yr){tr[p].a=a,tr[p].b=b;return ;}
	int mid = (l+r)>>1;
	ll xm = calc(tr[p].a,tr[p].b,mid);
	ll ym = calc(a,b,mid);
	if(xm>=ym)
	{
		swap(a,tr[p].a),swap(b,tr[p].b);
		swap(xl,yl),swap(xr,yr),swap(xm,ym);
	}
	if(xl>=yl)Update(p<<1,l,mid,a,b);
	else Update(p<<1|1,mid+1,r,a,b);
}
void update(int p,int l,int r,int a,int b,ll A,ll B)
{
	tr[p].mn = min(tr[p].mn,min(calc(A,B,a),calc(A,B,b)));
	if(l>=a&&r<=b){Update(p,l,r,A,B);return ;}
	int mid = (l+r)>>1;
	if(b<=mid)update(p<<1,l,mid,a,b,A,B);
	else if(a >mid)update(p<<1|1,mid+1,r,a,b,A,B);
	else update(p<<1,l,mid,a,mid,A,B),update(p<<1|1,mid+1,r,mid+1,b,A,B);
}
ll ans;
void getans(int p,int l,int r,int a,int b)
{
	ans = min(ans,min(calc(tr[p].a,tr[p].b,a),calc(tr[p].a,tr[p].b,b)));
	if(l>=a&&r<=b){ans = min(ans,tr[p].mn);return ;}
	int mid = (l+r)>>1;
	if(b<=mid)getans(p<<1,l,mid,a,b);
	else if(a >mid)getans(p<<1|1,mid+1,r,a,b);
	else getans(p<<1,l,mid,a,mid),getans(p<<1|1,mid+1,r,mid+1,b);
	return ;
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
void update(int f,int x,ll a,ll b)
{
	while(top[x]!=top[f])
	{
		update(1,1,n,dfn[top[x]],dfn[x],a,b);
		x = fa[top[x]];
	}
	update(1,1,n,dfn[f],dfn[x],a,b);
}
void getans(int f,int x)
{
	while(top[x]!=top[f])
	{
		getans(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	getans(1,1,n,dfn[f],dfn[x]);
}
int main()
{
	int x,y;
	ll z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d%lld",&x,&y,&z);
		add(x,y,z);
	}
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	int opt;
	while(m--)
	{
		scanf("%d%d%d",&opt,&x,&y);
		if(opt==1)
		{
			ll a,b;
			scanf("%lld%lld",&a,&b);
			int lca = getlca(x,y);
			update(lca,x,-a,a*dis[x]+b);
			update(lca,y,a,a*(dis[x]-dis[lca]*2)+b);
		}else
		{
			int lca = getlca(x,y);
			ans = INF;
			getans(lca,x);
			getans(lca,y);
			printf("%lld\n",ans);
		}
	}
	return 0;
}
Problem4516

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct SAM
{
	map<int,int>trs[N];
	int fa[N],len[N];
	int cnt,last;
	long long ans;
	void init(){cnt = last = 1,ans = 0;}
	void insert(int x)
	{
		int p = last,newp = ++cnt,q,newq;
		last = newp,len[newp] = len[p]+1;
		for(;p&&!trs[p][x];p=fa[p])trs[p][x] = newp;
		if(!p)fa[newp] = 1;
		else
		{
			q = trs[p][x];
			if(len[q]==len[p]+1)fa[newp] = q;
			else
			{
				fa[newq=++cnt]=fa[q];
				len[newq] = len[p]+1;
				trs[newq] = trs[q];
				fa[newp] = fa[q] = newq;
				for(;p&&trs[p][x]==q;p=fa[p])trs[p][x]=newq;
			}
		}
		ans+=len[newp]-len[fa[newp]];
	}
}sam;
int d[N];
int main()
{
	int n;
	scanf("%d",&n);
	sam.init();
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&d[i]);
		sam.insert(d[i]);
		printf("%lld\n",sam.ans);
	}
	return 0;
}
Problem4519

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 900;
const int M = 9000;
const int INF = 0x3f3f3f3f;
struct E
{int next,to,f;}e[M<<1];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f=f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f=f;
}
int d[N],n;
queue<int>Q;
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	d[t]=0;
	Q.push(t);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to]=d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]-1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(mx,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
bool vis[N];
int ans[N][N],a[N],b[N];
void dfs(int x)
{
	vis[x] = true;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].f&&!vis[e[i].to])
			dfs(e[i].to);
}
void reset()
{
	for(int i = 2;i<= tot;i+=2)
		e[i].f=e[i^1].f=(e[i].f+e[i^1].f)>>1;
}
void solve(int l,int r)
{
	if(l==r)return ;
	int s = a[l],t = a[r];
	reset();
	int tmp = dinic(s,t);
	memset(vis,0,sizeof(vis));
	dfs(s);
	for(int i = 1;i<= n;i++)
		if(vis[i])
			for(int j = 1;j<= n;j++)
				if(!vis[j])
					ans[i][j]=ans[j][i]=min(ans[i][j],tmp);
	int j = l,k = r;
	for(int i = l;i<= r;i++)
		if(vis[a[i]])b[j++]=a[i];
		else b[k--]=a[i];
	for(int i = l;i<= r;i++)
		a[i]=b[i];
	solve(l,j-1);
	solve(k+1,r);
}
int q[N*N],cnt;
int main()
{
	memset(ans,0x3f,sizeof(ans));
	int m,u,v,w;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	for(int i = 1;i<= n;i++)a[i]=i;
	solve(1,n);
	cnt = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i+1;j<= n;j++)
			q[++cnt]=ans[i][j];
	sort(q+1,q+cnt+1);
	cnt = unique(q+1,q+cnt+1)-q-1;
	printf("%d\n",cnt);
	return 0;
}
Problem4521

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;

ll f[20][2][10][10][4][2];
ll pow10[20];
int sta(int a,int b)
{
	return ((a==8||b==8)<<1)|((a==4||b==4));
}
ll dp(ll x)
{
	if(x<pow10[10])return 0;
	int s[20]={};
	int cnt = 0;
	while(x){s[11-cnt]=x%10;x/=10;cnt++;}
	memset(f,0,sizeof(f));
	int ap = sta(s[1],s[2]),fg = 0;
	f[2][0][s[1]][s[2]][ap][0]=1;
	for(int i = 1;i<= s[1];i++)
		for(int j = 0;j<= 9;j++)
		{
			if(i==s[1]&&j>=s[2])continue;
			f[2][1][i][j][sta(i,j)][0]=1;
		}
	for(int i = 3;i<= 11;i++)
	{
		ap|=sta(s[i],s[i]),fg|=(s[i]==s[i-1]&&s[i-1]==s[i-2]);
		if(ap!=3)f[i][0][s[i-1]][s[i]][ap][fg] = 1;
		for(int j = 0;j<= 9;j++)
		for(int k = 0;k<= 9;k++)
		for(int a = 0;a<= 2;a++)
			for(int b = 0;b<= 9;b++)
			{	
				int t1 = a|sta(b,b),t2 = j==k&&k==b;
				if(t1==3)continue;
				f[i][1][k][b][t1][1]+=(b<s[i])*f[i-1][0][j][k][a][1]+f[i-1][1][j][k][a][1];
				f[i][1][k][b][t1][t2]+=(b<s[i])*f[i-1][0][j][k][a][0]+f[i-1][1][j][k][a][0];
			}
	}
	ll ans = 0;
	for(int i = 0;i<= 9;i++)for(int j = 0;j<= 9;j++)
	for(int a = 0;a<= 2;a++)for(int b = 0;b<= 1;b++)
		ans+=f[11][b][i][j][a][1];
	return ans;
}

int main()
{
	ll l,r;
	scanf("%lld%lld",&l,&r);
	pow10[0]=1;
	for(int i = 1;i<= 11;i++)pow10[i]=pow10[i-1]*10;
	printf("%lld\n",dp(r)-dp(l-1));
	return 0;
}
Problem4522

#include<cstdio>
#include<algorithm>
#include<cmath>
#define fo(i,a,b) for(i=a;i<=b;i++)
using namespace std;
typedef long long ll;
ll e,d,n,nn,r,c,a,xx,yy,t,p,q,mod;
void gcd(ll a,ll b)
{
    if (!b)
    {
        xx=1;
        yy=0;
        t=a;
    }
    else
    {
        gcd(b,a%b);
        swap(xx,yy);
        yy-=xx*(a/b);
    }
}
ll getny(ll x,ll y)
{
    gcd(x,y);
    xx=(xx%y+y)%y;
    return xx;
}
int rand() 
{
    static int rand_seed=1542071823;
    rand_seed+=rand_seed<<1|1;
    return rand_seed;
}
ll quick_plus(ll x,ll y)
{
    if (!y) return 0;
    ll t=quick_plus(x,y/2);
    t=(t+t)%mod;
    if (y%2) t=(t+x)%mod;
    return t;
}
ll quick_pow(ll x,ll y)
{
    if (!y) return 1;
    ll t=quick_pow(x,y/2);
    t=quick_plus(t,t);
    if (y%2) t=quick_plus(t,x);
    return t;
}
ll f(ll x)
{
    return (quick_plus(x,x)+a)%mod;
}
ll pollard_rho(ll n)
{
    ll r1,r2,p;
    while (1)
    {
        a=rand()%100;
        r1=r2=2;
        do{
            r1=f(r1);
            r2=f(f(r2));
            gcd(abs(r2-r1),n);
            p=t;
            if (p>1) return p;
        }while (r1!=r2);
    }
}
int main()
{
    scanf("%lld%lld%lld",&e,&n,&c);
    mod=n;
    p=pollard_rho(n);
    q=n/p;
    r=(p-1)*(q-1);
    d=getny(e,r);
    nn=quick_pow(c,d);
    printf("%lld %lld\n",d,nn);
}
Problem4522

#include<cstdio>
#include<algorithm>
#include<cmath>
#define fo(i,a,b) for(i=a;i<=b;i++)
using namespace std;
typedef long long ll;
ll e,d,n,nn,r,c,a,xx,yy,t,p,q,mod;
void gcd(ll a,ll b)
{
    if (!b)
    {
        xx=1;
        yy=0;
        t=a;
    }
    else
    {
        gcd(b,a%b);
        swap(xx,yy);
        yy-=xx*(a/b);
    }
}
ll getny(ll x,ll y)
{
    gcd(x,y);
    xx=(xx%y+y)%y;
    return xx;
}
int rand() 
{
    static int rand_seed=1e9+7;
    rand_seed+=rand_seed<<1|1;
    return rand_seed;
}
ll quick_plus(ll x,ll y)
{
    if (!y) return 0;
    ll t=quick_plus(x,y/2);
    t=(t+t)%mod;
    if (y%2) t=(t+x)%mod;
    return t;
}
ll quick_pow(ll x,ll y)
{
    if (!y) return 1;
    ll t=quick_pow(x,y/2);
    t=quick_plus(t,t);
    if (y%2) t=quick_plus(t,x);
    return t;
}
ll f(ll x)
{
    return (quick_plus(x,x)+a)%mod;
}
ll pollard_rho(ll n)
{
    ll r1,r2,p;
    while (1)
    {
        a=rand()%100;
        r1=r2=2;
        do{
            r1=f(r1);
            r2=f(f(r2));
            gcd(abs(r2-r1),n);
            p=t;
            if (p>1) return p;
        }while (r1!=r2);
    }
}
int main()
{
    scanf("%lld%lld%lld",&e,&n,&c);
    mod=n;
    p=pollard_rho(n);
    q=n/p;
    r=(p-1)*(q-1);
    d=getny(e,r);
    nn=quick_pow(c,d);
    printf("%lld %lld\n",d,nn);
}
Problem4524

#include <stdio.h>
#include <set>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 18000000+5;
struct Heap
{
	int ls,rs;
	int dis;ll key,mul;
}tr[N];
int tot;
ll n;int E;
ll quick_pow(ll x,ll y)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res=res*x;
		x = x*x;
		y>>=1;
	}
	return res;
}
int newnode(int x)
{
	if(!x)return 0;
	int t = ++tot;
	tr[t] = tr[x];
	return t;
}
int multi(int x,ll y)
{
	int t = newnode(x);
	tr[t].mul*=y,tr[t].key*=y;
	return t;
}
void Push_down(int x)
{
	if(tr[x].mul>1)
	{
		tr[x].ls = multi(tr[x].ls,tr[x].mul);
		tr[x].rs = multi(tr[x].rs,tr[x].mul);
		tr[x].mul = 1;
	}
}
int merge(int x,int y)
{
	if(!x)return newnode(y);
	if(!y)return newnode(x);
	Push_down(x),Push_down(y);
	if(tr[x].key<tr[y].key)swap(x,y);
	int t = newnode(x);
	tr[t].rs = merge(tr[x].rs,y);
	if(tr[tr[t].rs].dis>tr[tr[t].ls].dis)
		swap(tr[t].ls,tr[t].rs);
	tr[t].dis = tr[tr[t].rs].dis+1;
	return t;
}
int pop(int x)
{
	Push_down(x);
	return merge(tr[x].ls,tr[x].rs);
}
struct Int
{
	int id;
	Int(int _id):id(_id){}
	bool operator <(const Int &s)const
	{
		return tr[id].key>tr[s.id].key||tr[id].key==tr[s.id].key&&id<s.id;
	}
};
multiset<Int>ans;
int prime[200],cnt;
bool vis[200];
int f[200][100],g[200][200];
void get_prime()
{
	for(int i = 2;i<= 127&&i<= n;i++)
	{
		if(!vis[i])prime[++cnt]=i;
		for(int j = 1;j<=cnt&&i*prime[j]<=127;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	scanf("%lld%d",&n,&E);
	get_prime();
	f[0][0]=g[0][0]=1;
	tr[1].dis = tr[1].key = tr[1].mul = tot = 1;
	for(int i = 1;i<= cnt;i++)
	{
		for(int j = 1;j<= (int)floor(log(n)/log(prime[i]));j++)
		{
			for(int k = 1;k<= j;k++)
			{
				int t = multi(g[i-1][j-k],quick_pow(prime[i],k));
				f[i][j] =merge(f[i][j],t);
			}
			ans.insert(Int(f[i][j]));
			g[i][j] = merge(g[i-1][j],f[i][j]);
		}
		g[i][0]=g[i-1][0];
	}
	E--;
	while(E--)
	{
		int t = (*ans.begin()).id;
		ans.erase(ans.begin());
		ans.insert(Int(merge(tr[t].ls,tr[t].rs)));
	}
	printf("%lld\n",tr[(*ans.begin()).id].key);
	return 0;
}
Problem4525

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int pos[N],n,k;
bool check(int x)
{
	int last = 1,ans = 0;
	for(int i= 1;i<= n;i++)
		if(pos[i]-pos[last]>x)
			ans++,last = i;
	ans++;
	return ans<=k;
}
int main()
{		
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&pos[i]);
	sort(pos+1,pos+n+1);
	int l = 0,r = pos[n]+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(check(2*mid))r = mid;
		else l = mid+1;
	}
	printf("%d\n",l);
	return 0;
}
Problem4530

#include <bits/stdc++.h>
#define N 100005
typedef long long ll;
using namespace std;
int n,q,ans,tot,num;
struct Link_Cut_Tree
{
    int c[N][2],fa[N],size1[N],size2[N],q[N],top;
    bool rev[N];
    inline void pushup(int x)
    {
        int l=c[x][0],r=c[x][1];
        size1[x]=size1[l]+size1[r]+size2[x];
    }
    inline bool isroot(int x)
    {return c[fa[x]][1]!=x&&c[fa[x]][0]!=x;}
    inline void pushdown(int x)
    {
        int l=c[x][0],r=c[x][1];
        if(rev[x])
        {
            rev[l]^=1;rev[r]^=1;rev[x]^=1;
            swap(c[x][0],c[x][1]);
        }
    }
    inline void rotate(int x)
    {
        int y=fa[x],z=fa[y],l,r;
        if(c[y][0]==x)l=0;else l=1;r=l^1;
        if(!isroot(y)){if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;}
        fa[x]=z;fa[y]=x;fa[c[x][r]]=y;
        c[y][l]=c[x][r];c[x][r]=y;
        pushup(y);pushup(x);
    }
    inline void splay(int x)
    {
        top=1;q[top]=x;
        for(int i=x;!isroot(i);i=fa[i])q[++top]=fa[i];
        for(int i=top;i;i--)pushdown(q[i]);
        while(!isroot(x))
        {
            int y=fa[x],z=fa[y];
            if(!isroot(y))
            {
                if((c[z][0]==y)^(c[y][0]==x))rotate(x);
                else rotate(y);
            }
            rotate(x);
        }
        pushup(x);
    }
    void access(int x)
    {
        for(int t=0;x;t=x,x=fa[x])
        {
            splay(x);size2[x]+=size1[c[x][1]];
            c[x][1]=t;size2[x]-=size1[t];pushup(x);
        }
    }
    void makeroot(int x){access(x);splay(x);rev[x]^=1;}
    int find(int x){access(x);splay(x);while(c[x][0])x=c[x][0];return x;}
    void split(int x,int y){makeroot(x);access(y);splay(y);}
    void link(int x,int y)
    {
        makeroot(x);makeroot(y);fa[x]=y;size2[y]+=size1[x];
        pushup(y);
    }
    void cut(int x,int y){split(x,y);if(c[y][0]==x)c[y][0]=0,fa[x]=0;}
    void init(int n)
    {
        for(int i=1;i<=n;i++)size1[i]=size2[i]=1;
    }
}T;
int main()
{
    scanf("%d%d",&n,&q);
    T.init(n);char s[10];
    while(q--)
    {
        scanf("%s",s);
        int x,y;
        scanf("%d%d",&x,&y);
        if(s[0]=='A')T.link(x,y);
        else
        {
            T.makeroot(x);T.access(y);T.splay(x);
            printf("%lld\n",(ll)((T.size2[y])*(T.size1[x]-T.size2[y])));
        }
    }
    return 0;
}
Problem4537

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
const int M = 1e5+5;
const int Q = 5e4+5;
struct E
{
	int x,y,a,b,id;
	void read(int no)
	{
		scanf("%d%d%d%d",&x,&y,&a,&b);
		id = no;
	}
	bool operator <(const E &s)const
	{
		if(a==s.a)return b<s.b;
		return a<s.a;
	}
}e[M],ask[Q],tmp[Q];
struct Opt
{
	int x,y,fa,mxa,mxb,sz;
}opt[Q];
bool cmp(const E &x,const E &y)
{
	if(x.b==y.b)return x.a<y.a;
	return x.b<y.b;
}
int tot,top;
int fa[N],size[N],mxa[Q],mxb[Q],ans[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return getfa(fa[x]);
}
void merge(int x,int y,int a,int b)
{
	x = getfa(x),y = getfa(y);
	if(size[x]>size[y])swap(x,y);
	opt[++tot].x = x,opt[tot].mxa = mxa[y],opt[tot].mxb = mxb[y];
	opt[tot].y = y,opt[tot].fa = fa[x],opt[tot].sz = size[y];
	if(x==y)
	{
		mxa[x] = max(mxa[x],a);
		mxb[x] = max(mxb[x],b);
		return ;
	}
	fa[x] = y,size[y]+=size[x];
	mxa[y] = max(mxa[y],max(mxa[x],a));
	mxb[y] = max(mxb[y],max(mxb[x],b));
}
void go_back()
{
	while(tot)
	{
		fa[opt[tot].x] = opt[tot].fa;
		mxa[opt[tot].y] = opt[tot].mxa;
		mxb[opt[tot].y] = opt[tot].mxb;
		size[opt[tot].y] = opt[tot].sz;
		tot--;
	}
}
int main()
{
	int n,m,q;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
		e[i].read(i);
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
		ask[i].read(i);
	sort(e+1,e+m+1);
	sort(ask+1,ask+q+1,cmp);
	int block = sqrt(m);
	for(int i = 1;i<= m;i+=block)
	{
		top = 0;
		for(int j = 1;j<= q;j++)
			if(ask[j].a>=e[i].a&&(i+block>m||ask[j].a<e[i+block].a))
				tmp[++top] = ask[j];
		sort(e+1,e+i,cmp);
		for(int j = 1;j<= n;j++)fa[j]=j,size[j]=1,mxa[j]=mxb[j]=-1;
		for(int j = 1,k = 1;j<= top;j++)
		{
			for(;k<i&&e[k].b<=tmp[j].b;k++)
				merge(e[k].x,e[k].y,e[k].a,e[k].b);
			tot = 0;
			for(int l = i;l<i+block&&l<=m;l++)
				if(e[l].a<=tmp[j].a&&e[l].b<=tmp[j].b)
					merge(e[l].x,e[l].y,e[l].a,e[l].b);
			int x = getfa(tmp[j].x),y = getfa(tmp[j].y);
			ans[tmp[j].id] = x==y&&mxa[x]==tmp[j].a&&mxb[x]==tmp[j].b;
			go_back();
		}
	}
	for(int i = 1;i<= q;i++)
		if(ans[i])printf("Yes\n");
		else printf("No\n");
	return 0;
}
Problem4538

#include <stdio.h>
#include <queue>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,m;

struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;
}
int son[N],size[N],dfn[N],top[N],Dfn,fa[N],dep[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] =dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>=size[son[x]])son[x]=e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}

struct Heap
{
	priority_queue<int>a,b;
	void del(int val){b.push(val);}
	void push(int val){a.push(val);}
	int top()
	{
		while(!b.empty()&&a.top()==b.top()) a.pop(),b.pop();
        if(a.empty()) return -1;
        return a.top();
	}
}t[270005];
void update(int p,int l,int r,int a,int b,int val,bool flag)
{
	if(a>b)return ;
	if(l>=a&&r<=b)
	{
		if(!flag)t[p].push(val);
		else t[p].del(val);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,val,flag);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,val,flag);
}
int getans(int p,int l,int r,int pos)
{
	if(l==r)
		return t[p].top();
	int mid = (l+r)>>1;
	if(pos<=mid)return max(t[p].top(),getans(p<<1,l,mid,pos));
	else return max(t[p].top(),getans(p<<1|1,mid+1,r,pos));
}

vector<pair<int,int> >stack;
void Update(int x,int y,int val,bool flag)
{
	stack.clear();
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		stack.push_back(make_pair(dfn[top[x]],dfn[x]));
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	stack.push_back(make_pair(dfn[y],dfn[x]));
	sort(stack.begin(),stack.end());
	x = 1;
	int sz = stack.size();
	for(int i = 0;i<sz;i++)
	{
		update(1,1,n,x,stack[i].first-1,val,flag);
		x = stack[i].second+1;
	}
	update(1,1,n,x,n,val,flag);
	return ;
}

int X[N<<1],Y[N<<1],Z[N<<1];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&X[0],&Y[0]);
		add(X[0],Y[0]);
	}
	int root = rand()%n+1;
	dfs1(root);
	dfs2(root,root);
	int tp;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&tp);
		if(tp==0)
		{
			scanf("%d%d%d",&X[i],&Y[i],&Z[i]);
			Update(X[i],Y[i],Z[i],(bool)tp);
		}else if(tp==1)
		{
			scanf("%d",&X[i]);
			Update(X[X[i]],Y[X[i]],Z[X[i]],(bool)tp);
		}else
		{
			scanf("%d",&X[i]);
			printf("%d\n",getans(1,1,n,dfn[X[i]]));
		}
	}
	return 0;
}
Problem4539

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int maxn = 2e5+5;
const int M = 2e6+5;
ll N;
int idx,n,m,q,root[maxn],from[maxn];
namespace seg
{
	int sz[M],ls[M],rs[M],root[maxn],tot;
	void Insert(int &p,int pre,int l,int r,int v)
	{
		p = ++tot;
		sz[p] = sz[pre]+1;
		if(l==r)return ;
		int mid = (l+r)>>1;
		ls[p] = ls[pre],rs[p] = rs[pre];
		if(v<=mid)Insert(ls[p],ls[pre],l,mid,v);
		else Insert(rs[p],rs[pre],mid+1,r,v);
	}
	void insert(int idx,int x)
	{
		Insert(root[idx],root[idx-1],1,n,x);
	}
	int calc(int x,int y,int k)
	{
		x = root[x-1],y = root[y];
		int l= 1,r = n;
		while(l<r)
		{
			int mid = (l+r)>>1;
			if(sz[ls[y]]-sz[ls[x]]>=k)r=mid,y = ls[y],x = ls[x];
			else k-=sz[ls[y]]-sz[ls[x]],l=mid+1,y = rs[y],x = rs[x];
		}
		return l;
	}
}
int size[maxn],dfn[maxn],last[maxn];
struct Gragh
{
	struct E
	{int next,to;ll val;}e[maxn<<1];
	int head[maxn],tot;
	void add(int x,int y,ll f)
	{
		e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
		e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
	}
	int dep[maxn],fa[maxn][18],Dfn;
	ll dis[maxn];
	void dfs1(int x)
	{
		dep[x] = dep[fa[x][0]]+1;
		for(int i = 1;i<= 17;i++)
			fa[x][i] = fa[fa[x][i-1]][i-1];
		for(int i = head[x];i;i=e[i].next)if(e[i].to!=fa[x][0])
		{
			dis[e[i].to] = dis[x]+e[i].val;
			fa[e[i].to][0] = x;
			dfs1(e[i].to);
		}
	}
	void dfs2(int x)
	{
		dfn[x] = ++Dfn;
		seg::insert(Dfn,x);
		size[x] = 1;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].to!=fa[x][0])
			{
				dfs2(e[i].to);
				size[x] += size[e[i].to];
			}
		last[x] = Dfn;
	}
	int go_up(int x,int d)
	{
		for(int i = 17;i>= 0;i--)
			if((d>>i)&1)x=fa[x][i];
		return x;
	}
	int getlca(int x,int y)
	{
		if(dep[x]<dep[y])swap(x,y);
		for(int i =17;i>= 0;i--)
			if(dep[fa[x][i]]>=dep[y])
				x = fa[x][i];
		if(x==y)return x;
		for(int i = 17;i>= 0;i--)
			if(fa[x][i]!=fa[y][i])
				x = fa[x][i],y = fa[y][i];
		return fa[x][0];
	}
	ll getdis(int x,int y)
	{
		return dis[x]+dis[y]-dis[getlca(x,y)]*2;
	}
	int find(int x,int v)
	{
		return go_up(x,dep[x]-dep[v]-1);
	}
}G[2];
ll list[maxn];
int getpos(ll x)
{
	return lower_bound(list+1,list+idx+1,x)-list;
}
int main()
{
	ll x,y;
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1;i<n;i++)
	{
		scanf("%lld%lld",&x,&y);
		G[0].add(x,y,1);
	}
	G[0].dfs1(1);
	G[0].dfs2(1);
	N = n,idx = 1;
	root[1] = 1;
	list[1] = N;
	for(int i = 1;i<= m;i++)
	{
		scanf("%lld%lld",&x,&y);
		int t = getpos(y),r=root[t],yy=seg::calc(dfn[r],last[r],y-list[t-1]);
		G[1].add(t,idx+1,G[0].dis[yy]-G[0].dis[r]+1);
		N+=size[x],root[++idx] = x,list[idx] = N,from[idx] = yy;
	}
	G[1].dfs1(1);
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld%lld",&x,&y);
		int tx = getpos(x),rx = root[tx],xx = seg::calc(dfn[rx],last[rx],x-list[tx-1]);
		int ty = getpos(y),ry = root[ty],yy = seg::calc(dfn[ry],last[ry],y-list[ty-1]);
		int lca = G[1].getlca(tx,ty);
		ll ans = G[0].dis[xx]+G[0].dis[yy]-G[0].dis[rx]-G[0].dis[ry]+G[1].getdis(tx,ty);
		if(tx==ty)
		{
			printf("%lld\n",G[0].getdis(xx,yy));
		}else if(tx==lca)
		{
			int fry = from[G[1].find(ty,lca)];
			printf("%lld\n",ans-(G[0].dis[xx]+G[0].dis[fry]-G[0].getdis(xx,fry)-2*G[0].dis[rx]));
		}else if(ty==lca)
		{
			int frx = from[G[1].find(tx,lca)];
			printf("%lld\n",ans-(G[0].dis[yy]+G[0].dis[frx]-G[0].getdis(yy,frx)-2*G[0].dis[ry]));
		}else
		{
			int frx = from[G[1].find(tx,lca)];
			int fry = from[G[1].find(ty,lca)];
			printf("%lld\n",ans-(G[0].dis[frx]+G[0].dis[fry]-G[0].getdis(frx,fry)-2*G[0].dis[root[lca]]));
		}
	}
	return 0;
}
Problem4540

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
int a[N],lg2[N];
int st[N][18],n,q;
int Min(int x,int y)
{
	return a[x]<a[y]?x:y;
}
void build_st()
{
	for(int i = 2;i<= n;i++)
		lg2[i] = lg2[i>>1]+1;
	for(int i = 1;i<= n;i++)
		st[i][0] = i;
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<=n;i++)
		{
			st[i][j] = st[i][j-1];
			if(i+(1<<(j-1))<=n)
				st[i][j] = Min(st[i][j],st[i+(1<<(j-1))][j-1]);
		}
}
int Ask(int l,int r)
{
	if(l>r)swap(l,r);
	int lth = lg2[r-l+1];
	return Min(st[l][lth],st[r-(1<<lth)+1][lth]);
}

ll left[N],right[N];
int stack[N],top;
void init()
{
	stack[top=0]=0;
	for(int i = 1;i<= n;i++)
	{
		while(top&&a[stack[top]]>=a[i])top--;
		right[i] = right[stack[top]]+(ll)a[i]*(i-stack[top]);
		stack[++top] = i;
	}
	stack[top=0]=n+1;
	for(int i = n;i;i--)
	{
		while(top&&a[stack[top]]>=a[i])top--;
		left[i] = left[stack[top]]+(ll)a[i]*(stack[top]-i);
		stack[++top] = i;
	}
}
ll getleft(int l,int r)
{
	int t = Ask(l,r);
	return (ll)a[t]*(r-t+1)+left[l]-left[t];
}
ll getright(int l,int r)
{
	int t = Ask(l,r);
	return (ll)a[t]*(t-l+1)+right[r]-right[t];
}

struct Ask
{
	int l,r,lpos,id;
	bool operator <(const Ask &s)const
	{
		if(lpos==s.lpos)return r<s.r;
		return lpos<s.lpos;
	}
}ask[N];
ll ans;
ll Ans[N];
void solve()
{
	int l = 1,r = 0;
	for(int i = 1;i<= q;i++)
	{
		while(r<ask[i].r)ans+=getright(l,++r);
		while(r>ask[i].r)ans-=getright(l,r--);
		while(l<ask[i].l)ans-=getleft(l++,r);
		while(l>ask[i].l)ans+=getleft(--l,r);
		Ans[ask[i].id] = ans;
	}
}

int main()
{
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	build_st();
	init();
	int block = sqrt(q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].lpos = (ask[i].l-1)/block+1;
		ask[i].id = i;
	}
	sort(ask+1,ask+q+1);
	solve();
	for(int i = 1;i<= q;i++)
		printf("%lld\n",Ans[i]);
	return 0;
}
Problem4541

#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <math.h>
#include <vector>
using namespace std;
const int N=200010;
typedef long long ll;
struct point
{
    int x,y;
    friend ll operator *(const point &a,const point &b)
    {
        return (ll)a.x*b.y-(ll)b.x*a.y;
    }
    friend point operator -(const point &a,const point &b)
    {
        point tmp;
        tmp.x=a.x-b.x; tmp.y=a.y-b.y;
        return tmp;
    }
}p[N];
struct edge
{
    int u,v,id;
    double ang;
    edge(){}
    edge(int a,int b,int k)
    {
        u=a; v=b; id=k;
        ang=atan2((double)p[b].y-p[a].y,(double)p[b].x-p[a].x);
    }
    friend bool operator <(const edge &a,const edge &b)
    {
        return a.ang<b.ang;
    }
}e[6*N];
vector<edge> E[N],TE[N*2];
int Nex[N*6],v[N*6],cnt=1,num,rt;
int vi[N*2],fa[N*2],flag[N*6];
int n,m,k,x,y,rec,q[N];
ll ans1,ans2,P,S[N*2],S1[N*2];

int Find(int x,const edge &a)
{
    int mid,l=0,r=E[x].size();
    while(r-l>1)
    {
        mid=(l+r)>>1;
        if(a<E[x][mid]) r=mid;
        else l=mid;
    }
    return l;
}
ll gcd(ll a,ll b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}
void solve()
{
    int now,tmp,st; ll s;
    for(int i=2;i<=cnt;i++)
    if(!v[i])
    {
        s=0; now=i; v[i]=++num; st=e[i].u;
        while(1)
        {
            tmp=Nex[now]; v[tmp]=num;
            if(e[tmp].v==st) break;
            s+=(p[e[tmp].u]-p[st])*(p[e[tmp].v]-p[st]);
            now=tmp;
        }
        S[num]=s;
        if(s<=0) rt=num;
    }
    for(int i=2;i<=cnt;i++) 
    TE[v[i]].push_back(edge(v[i],v[i^1],i));
}
void dfs(int x)
{
    vi[x]=1; S1[x]=S[x]*S[x]; S[x]*=2;
    for(int i=0;i<(int)TE[x].size();i++)
    if(!vi[TE[x][i].v])
    {
        fa[TE[x][i].v]=x;
        flag[TE[x][i].id]=1;
        flag[TE[x][i].id^1]=1;
        dfs(TE[x][i].v);
        S[x]+=S[TE[x][i].v];
        S1[x]+=S1[TE[x][i].v];
    }
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=n;i++) scanf("%d%d",&p[i].x,&p[i].y);
    for(int i=1;i<=m;i++) 
    {
        scanf("%d%d",&x,&y);
        ++cnt; e[cnt]=edge(x,y,cnt);
        E[x].push_back(e[cnt]);
        ++cnt; e[cnt]=edge(y,x,cnt);
        E[y].push_back(e[cnt]);
    }
    for(int i=1;i<=n;i++) sort(E[i].begin(),E[i].end());
    for(int i=2;i<=cnt;i++)
    {
        Nex[i]=Find(e[i].v,e[i^1])-1;
        if(Nex[i]<0) Nex[i]=E[e[i].v].size()-1;
        Nex[i]=E[e[i].v][Nex[i]].id;
    }
    solve(); dfs(rt);
    for(int i=1;i<=k;i++)
    {
        scanf("%d",&q[0]);q[0]=(q[0]+P)%n+1;
        for(int j=1;j<=q[0];j++) scanf("%d",&q[j]),q[j]=(q[j]+P)%n+1;
        ans1=ans2=0; q[++q[0]]=q[1];
        for(int j=1;j<q[0];j++)
        {
            x=q[j]; y=q[j+1];
            int tmp=Find(x,edge(x,y,0));
            tmp=E[x][tmp].id;
            if(!flag[tmp]) continue;
            if(v[tmp]==fa[v[tmp^1]]) ans1+=S[v[tmp^1]],ans2+=S1[v[tmp^1]];
            else ans1-=S[v[tmp]],ans2-=S1[v[tmp]];
        }
        if(ans1<0) ans1=-ans1,ans2=-ans2;
        ll d=gcd(ans1,ans2); ans1/=d; ans2/=d;
        printf("%lld %lld\n",P=ans2,ans1);
    }
    return 0;
}
Problem4542

#include <stdio.h>
#include <math.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
struct Ask
{
	int l,r,lpos,id;
	bool operator <(const Ask &s)const
	{
		if(lpos==s.lpos)return r<s.r;
		return lpos<s.lpos;
	}
}ask[N];
ll s[N],cd[N],ba[N],Ans[N];
char str[N];
map<ll,ll>tt;
int main()
{
	ll p;
	int n,m;
	scanf("%lld",&p);
	scanf("%s",str+1);
	scanf("%d",&m);
	n = strlen(str+1);
	if(p!=2&&p!=5)
	{
		ll pow10 = 1;
		for(int i = n;i;i--)
		{
			pow10 = pow10*10%p;
			s[i] = (s[i+1]+(ll)(str[i]-'0')*pow10%p)%p;
			cd[i] = s[i];
		}
		sort(cd+1,cd+n+1);
		for(int i= 1;i<= n+1;i++)
			tt[cd[i]]=i;
		for(int i = 1;i<= n+1;i++)
			s[i] = tt[s[i]];
		int block = sqrt(n);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&ask[i].l,&ask[i].r);
			ask[i].r++;
			ask[i].lpos = ask[i].l/block;
			ask[i].id = i;
		}
		sort(ask+1,ask+m+1);
		ll ans = 0;
		int l = 1,r = 0;
		for(int i = 1;i<= m;i++)
		{
			while(r<ask[i].r)ans+=ba[s[++r]]++;
			while(r>ask[i].r)ans-=--ba[s[r--]];
			while(l<ask[i].l)ans-=--ba[s[l++]];
			while(l>ask[i].l)ans+=ba[s[--l]]++;
			Ans[ask[i].id] = ans;
		}
		for(int i = 1;i<= m;i++)
			printf("%lld\n",Ans[i]);
	}else
	{
		for(int i = 1;i<= n;i++)
		{
			if(!((str[i]-'0')%p))
				ba[i] = ba[i-1]+1,cd[i] = cd[i-1]+i;
			else ba[i] = ba[i-1],cd[i] = cd[i-1];
		}
		for(int i = 1;i<= m;i++)
		{
			int l,r;
			scanf("%d%d",&l,&r);
			printf("%lld\n",cd[r]-cd[l-1]-(ba[r]-ba[l-1])*(l-1));
		}
	}
	return 0;
}
Problem4551

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int mx[N<<2],lazy[N<<2],dep[N];
struct E
{int next,to;}e[N<<1];
int head[N],tot,in[N],out[N],Dfn;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x,int fa)
{
	in[x] = ++Dfn;
	dep[x] = dep[fa]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
			dfs(e[i].to,x);
	out[x] = Dfn;
}
inline int merge(int x,int y)
{
	return dep[x]>dep[y]?x:y;
}
inline void Push_down(int p)
{
	if(!lazy[p])return ;
	mx[p<<1] = merge(mx[p<<1],lazy[p]),mx[p<<1|1] = merge(mx[p<<1|1],lazy[p]);
	lazy[p<<1] = merge(lazy[p<<1],lazy[p]),lazy[p<<1|1] = merge(lazy[p<<1|1],lazy[p]);
	lazy[p] = 0;
}
void build(int p,int l,int r)
{
	lazy[p] = 0;
	if(l==r){mx[p]=1;return ;}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);build(p<<1|1,mid+1,r);
	mx[p] = merge(mx[p<<1],mx[p<<1|1]);
}
void update(int p,int l,int r,int a,int b,int id)
{
	if(l>=a&&r<=b)
	{
		mx[p] = merge(mx[p],id);lazy[p] = merge(lazy[p],id);
		return ;
	}
	Push_down(p);
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,id);
	if(b >mid)update(p<<1|1,mid+1,r,a,b,id);
	mx[p] = merge(mx[p<<1],mx[p<<1|1]);
}
int getans(int p,int l,int r,int pos)
{
	if(l==r)return mx[p];
	Push_down(p);
	int mid = (l+r)>>1;
	if(pos<=mid)return getans(p<<1,l,mid,pos);
	else return getans(p<<1|1,mid+1,r,pos);
}
int main()
{
	//freopen("x.in","r",stdin);
	int n,q,x,y;
	scanf("%d%d",&n,&q);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	build(1,1,n);
	char opt[3];
	while(q--)
	{
		scanf("%s%d",opt,&x);
		if(opt[0]=='Q')printf("%d\n",getans(1,1,n,in[x]));
		else update(1,1,n,in[x],out[x],x);
	}
	return 0;
}
Problem4552

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int sum[N<<2],cov[N<<2];
int a[N];
int MID;
void build(int p,int l,int r)
{
	cov[p] = -1;
	if(l==r)
	{
		sum[p] = a[l]>=MID;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
inline void Push_down(int p,int l,int r)
{
	if(cov[p]==-1)return ;
	int mid = (l+r)>>1;
	if(cov[p]==1)
	{
		sum[p<<1] = mid-l+1;sum[p<<1|1] = r-mid;
		cov[p<<1] = cov[p],cov[p<<1|1] = cov[p];
	}else
	{
		sum[p<<1] = sum[p<<1|1] = cov[p<<1] = cov[p<<1|1] = 0;
	}
	cov[p] = -1;
}
void Update(int p,int l,int r,int a,int b,int v)
{
	if(a>b)return ;
	if(l>=a&&r<=b)
	{
		sum[p] = (r-l+1)*v;
		cov[p] = v;
		return ;
	}
	Push_down(p,l,r);
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,v);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,v);
	sum[p] = sum[p<<1]+sum[p<<1|1];
}
int Getsum(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[p];
	Push_down(p,l,r);
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getsum(p<<1,l,mid,a,b);
	if(b >mid)ans+=Getsum(p<<1|1,mid+1,r,a,b);
	return ans;
}
int opt[N],l[N],r[N];
int n,m,q;
bool check(int mid)
{
	MID = mid;
	build(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		int tmp = Getsum(1,1,n,l[i],r[i]);
		int lth = r[i]-l[i]+1;
		if(!opt[i])
		{
			Update(1,1,n,l[i],l[i]+lth-tmp-1,0);
			Update(1,1,n,l[i]+lth-tmp,r[i],1);
		}else
		{
			Update(1,1,n,l[i],l[i]+tmp-1,1);
			Update(1,1,n,l[i]+tmp,r[i],0);
		}
	}
	return Getsum(1,1,n,q,q)==1;
}
int main()
{
	//freopen("x.in","r",stdin);
	//freopen("x.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= m;i++)
		scanf("%d%d%d",&opt[i],&l[i],&r[i]);
	scanf("%d",&q);
	int L = 1,R = n+1;
	while(L<R)
	{
		int mid = (L+R)>>1;
		if(check(mid))L = mid+1;
		else R = mid;
	}
	printf("%d\n",L-1);
	return 0;
}
Problem4553

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int MX = 1e5;
const int N = 1e5+5;
const int M = 1e7+5;
int rot[N],ls[M],rs[M],mx[M],tot,f[N],a[N];
void update(int &p,int l,int r,int pos,int val)
{
	if(!p)p = ++tot;
	mx[p] = max(mx[p],val);
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],l,mid,pos,val);
	else update(rs[p],mid+1,r,pos,val);
}
int getans(int p,int l,int r,int a,int b)
{
	if(!p)return 0;
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getans(ls[p],l,mid,a,b);
	else if(a>mid)return getans(rs[p],mid+1,r,a,b);
	else return max(getans(ls[p],l,mid,a,b),getans(rs[p],mid+1,r,a,b));
}
void Update(int x,int y)
{
	for(int i = x;i<=MX;i+=i&(-i))
		update(rot[i],1,MX,a[y],f[y]);
}
int Getans(int x,int y)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))
		ans = max(ans,getans(rot[i],1,MX,1,y));
	return ans;
}
int Mx[N],Mn[N];
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),Mx[i]=Mn[i]=a[i];
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		Mx[x] = max(Mx[x],y);Mn[x] = min(Mn[x],y); 
	}
	//for(int i = 1;i<= n;i++)f[i] = 1;
	for(int i = 1;i<= n;i++)
	{
		f[i] = Getans(a[i],Mn[i])+1;
		Update(Mx[i],i);
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)ans = max(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
Problem4554

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 6005;
const int INF = 0x3f3f3f3f;
struct E
{
	int next,to,f;
}e[N*10];
int head[N],tot=1;
int d[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
bool bfs(int s,int t)
{
	for(int i = s;i<=t;i++)d[i]=-1;
	d[s] = 0;
	Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[t]!=-1;
}
int get_mxf(int s,int t,int mx)
{
	if(s==t)return mx;
	int last = mx;
	for(int i = head[s];i;i=e[i].next)
		if(d[e[i].to]==d[s]+1&&e[i].f)
		{
			int tof = get_mxf(e[i].to,t,min(last,e[i].f));
			if(tof)
			{
				e[i].f-=tof;
				e[i^1].f+=tof;
				if(!(last-=tof))return mx;
			}
		}
	d[s] = -1;
	return mx-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int n,m;
char s[55][55];
inline int id(int x,int y)
{
	return (x-1)*m+y;
}
int bl1[N],bl2[N];
int main()
{
	int cnt1=1,cnt2=1;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
		scanf("%s",s[i]+1);
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= m;j++)
			if(s[i][j]=='#')cnt1++;
			else bl1[id(i,j)] = cnt1;
		cnt1++;
	}
	for(int j = 1;j<= m;j++)
	{
		for(int i = 1;i<= n;i++)
			if(s[i][j]=='#')cnt2++;
			else bl2[id(i,j)]=cnt2;
		cnt2++;
	}
	int S =0,T = cnt1+cnt2+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= m;j++)
			if(s[i][j]=='*')add(bl1[id(i,j)],bl2[id(i,j)]+cnt1,1);
	for(int i = 1;i<= cnt1;i++)add(S,i,1);
	for(int i = 1;i<= cnt2;i++)add(i+cnt1,T,1);
	printf("%d\n",dinic(S,T));
	return 0;
}
Problem4555

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 261244*2;
const int mod = 998244353;
int quick_pow(int x,int y)
{
    int res = 1;
    while(y)
    {
        if(y&1)res = (ll)res*x%mod;
        x = (ll)x*x%mod;
        y>>=1;
    }
    return res;
}
void NTT(int *a,int len,int type)
{
	//for(int i = 0;i<len;i++)printf("%d ",a[i]);
	//printf("\n");
    int t = 0;
    for(int i = 0;i<len;i++)
    {
        if(t<i)swap(a[t],a[i]);
        for(int j = len>>1;(t^=j)<j;j>>=1);
    }
    for(int i = 2;i<= len;i<<=1)
    {
        int wn = quick_pow(3,(mod-1)/i);
        for(int j = 0;j<len;j+=i)
        {
            int w = 1,tmp;
            for(int k = 0;k<(i>>1);k++,w=(ll)w*wn%mod)
            {
                tmp = (ll)a[j+k+(i>>1)]*w%mod;
                a[j+k+(i>>1)] = (a[j+k]-tmp)%mod;
                a[j+k] = (a[j+k]+tmp)%mod;
            }
        }
    }
    if(type==-1)
    {
        for(int i = 1;i<len>>1;i++)swap(a[i],a[len-i]);
        int Inv = quick_pow(len,mod-2);
        for(int i = 0;i<len;i++)
            a[i] = (ll)a[i]*Inv%mod;
    }
	//for(int i = 0;i<len;i++)printf("%d ",a[i]);
	//printf("\n");
}
void conv(int *a,int *b,int *c,int len)
{
    NTT(a,len,1),NTT(b,len,1);
    for(int i = 0;i<len;i++)c[i]=(ll)a[i]*b[i]%mod;
    NTT(c,len,-1);
}
int fac[N],env[N],a[N],b[N],c[N];
int main()
{
    int n,len=1;
    scanf("%d",&n);
    for(;len<=2*n;len<<=1);
    fac[0] = 1;
    for(int i = 1;i<= n;i++)fac[i]=(ll)fac[i-1]*i%mod;
    env[n] = quick_pow(fac[n],mod-2);
    for(int i = n-1;i>=0;i--)env[i] = (ll)env[i+1]*(i+1)%mod;
    for(int i = 0;i<= n;i++)a[i]=i%2?-env[i]:env[i];
    b[0]=1,b[1]=n+1;
    for(int i = 2;i<= n;i++)b[i]=(ll)(quick_pow(i,n+1)-1)*quick_pow(i-1,mod-2)%mod*env[i]%mod;
    conv(a,b,c,len);
    int j = 1,ans=0;
    for(int i = 0;i<=n;i++)
    {
        if(i)j=(ll)j*i%mod;
        ans=(ans+(ll)quick_pow(2,i)*fac[i]%mod*c[i]%mod)%mod;
        ans = (ans+mod)%mod;
    }
    printf("%d\n",(ans%mod+mod)%mod);
    return 0;
}
Problem4556

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 5e6+5;
int ls[M],rs[M],sum[M];
int rot[N],Cnt,n,m;
void update(int &p,int pre,int l,int r,int pos)
{
	p = ++Cnt;
	sum[p] = sum[pre]+1;
	if(l==r)return ;
	ls[p] = ls[pre],rs[p] = rs[pre];
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos);
	else update(rs[p],rs[pre],mid+1,r,pos);
}
int getans(int L,int R,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return sum[R]-sum[L];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[L],ls[R],l,mid,a,b);
	if(b >mid)ans+=getans(rs[L],rs[R],mid+1,r,a,b);
	return ans;
}
int sa[N],cnt[N],val[N],rnk[N],h[N],q[N],nv[N];
char s[N];
inline bool is_same(int a,int b,int hl,int len)
{return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>=0;i--)sa[--cnt[val[i]]] = i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[i]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>=0;i--)sa[--cnt[val[q[i]]]] = q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i=j+1;k<=j;k++)nv[sa[k]] = lim;
		}
		if(lim==len)break;
		for(i = 0;i<len;i++)val[i]=nv[i];
	}
}
void build_rank(int len)
{for(int i = 0;i<=len;i++)rnk[sa[i]]=i;}
int mn[N][18];
void build_height(int len)
{
	for(int i = 0;i<len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]] = j;
		}
}
int lg2[N];
void build_st(int len)
{
	for(int i = 2;i<= len;i++)lg2[i] = lg2[i>>1]+1;
	for(int i = 0;i<=len;i++)mn[i][0] = h[i];
	for(int j = 1;j<= 18;j++)
		for(int i = 0;i+(1<<j)-1<= len;i++)
			mn[i][j] = min(mn[i][j-1],mn[i+(1<<(j-1))][j-1]);
}
int main()
{
	//freopen("x.in","r",stdin);
	scanf("%d%d",&n,&m);
	scanf("%s",s);
	int a,b,c,d;
	build_sa(n+1,256);
	build_rank(n);build_height(n);
	build_st(n);
	for(int i = 1;i<= n;i++)
		update(rot[i],rot[i-1],1,n,sa[i]+1);
	while(m--)
	{
		scanf("%d%d%d%d",&a,&b,&c,&d);
		int l = 1,r = min(d-c+1,b-a+1),ans=0,mid;
		while(l<=r)
		{
			mid = (l+r)>>1;
			int lp = rnk[c-1],rp = lp;
			for(int k = lg2[n];k>=0;k--)
			{
				if(lp>=(1<<k) && mn[lp-(1<<k)+1][k]>=mid)lp-=(1<<k);
				if(rp<=n-(1<<k) && mn[rp+1][k]>=mid)rp+=(1<<k);
			}
			if(getans(rot[lp-1],rot[rp],1,n,a,b-mid+1)>0)ans = mid,l=mid+1;
			else r = mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem4557

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int INF = 0x3f3f3f3f;
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,d,m;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][25],g[N][25];
int w[N];bool need[N];
void dfs(int x,int fa)
{
	f[x][0] = g[x][0] = need[x]?w[x]:0;
	for(int i = 1;i<= d;i++)g[x][i]=w[x];
	g[x][d+1] = INF; 
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			for(int j = 0;j<= d;j++)
				g[x][j] = min(g[x][j]+f[e[i].to][j],g[e[i].to][j+1]+f[x][j+1]);
			for(int j = d;j>=0;j--)g[x][j] = min(g[x][j+1],g[x][j]);
			f[x][0]=g[x][0];
			for(int j = 1;j<=d;j++)f[x][j]+=f[e[i].to][j-1];
			for(int j = 1;j<=d;j++)f[x][j] = min(f[x][j-1],f[x][j]);
		}
}
int main()
{
	scanf("%d%d",&n,&d);
	for(int i = 1;i<= n;i++)
		scanf("%d",&w[i]);
	scanf("%d",&m);
	for(int i = 1;i<= m;i++)
	{
		int x;
		scanf("%d",&x);
		need[x] = true;
	}
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	printf("%d\n",f[1][0]);
	return 0;
}
Problem4558

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int mod = 1e8+7;
typedef long long ll;
const int N = 2005;
const int MOD = 1880213;
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
}p[N];
int n,m,k;
bool inmap(const Point &s)
{
	return s.x<=n&&s.x>=0&&s.y<=m&&s.y>=0;
}
struct Hash
{
	int head[MOD],tot;
	int nxt[N],x[N],y[N];
	void add(int a,int b)
	{
		int tmp = ((ll)a*37+b)%MOD;
		++tot;
		nxt[tot] = head[tmp];
		x[tot] = a,y[tot] = b;
		head[tmp] = tot;
	}
	bool check(int a,int b)
	{
		int tmp = ((ll)a*37+b)%MOD;
		for(int i = head[tmp];i;i=nxt[i])
			if(x[i]==a&&y[i]==b)
				return true;
		return false;
	}
}hash;
ll calc(ll x,ll y)
{
	return (x+y)*(y-x+1)>>1;
}
ll Calc(ll x,ll y,ll z)
{
	if(!x || !y || z<2)return 0;
	z = min(z,x+y);
	x = min(x,z-1),y = min(y,z-1);
	ll sum = 0;
	sum = (sum+(ll)(z-y)*y%mod)%mod;
	sum = (sum+calc(z-x,y-1))%mod;
	return sum;
}
ll t1=0,t2=0,t3=0,t4=0;
void calc(const Point &p3,const Point &p4)
{
	if(inmap(p3)&&inmap(p4))
	{
		int tmp = hash.check(p3.x,p3.y)+hash.check(p4.x,p4.y);
		t2++;
		t3+=tmp;
		if(tmp>1)t4++;
	}
}
void Calc(const Point &p1,const Point &p2)
{
	int dx = p2.x-p1.x,dy = p2.y-p1.y;
	calc(Point(p1.x+dy,p1.y-dx),Point(p2.x+dy,p2.y-dx));
	calc(Point(p1.x-dy,p1.y+dx),Point(p2.x-dy,p2.y+dx));
	if(abs(dx+dy)&1)return ;
	dy = (dx+dy)>>1;
	dx-=dy;
	calc(Point(p1.x+dx,p1.y+dy),Point(p2.x-dx,p2.y-dy));
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= k;i++)
	{
		scanf("%d%d",&p[i].x,&p[i].y);
		hash.add(p[i].x,p[i].y);
	}
	ll ans = 0;
	for(int i = 1;i<= n&&i<= m;i++)
		ans = (ans+(ll)i*(n-i+1)%mod*(m-i+1)%mod)%mod;
	for(int i = 1;i<= k;i++)
	{
		(t1+=Calc(p[i].x,n-p[i].x,p[i].y))%=mod;
		(t1+=Calc(p[i].x,n-p[i].x,m-p[i].y))%=mod;
		(t1+=Calc(p[i].y,m-p[i].y,p[i].x))%=mod;
		(t1+=Calc(p[i].y,m-p[i].y,n-p[i].x))%=mod;
		t1 = t1+min(p[i].x,p[i].y)+min(n-p[i].x,p[i].y)+min(p[i].x,m-p[i].y)+min(n-p[i].x,m-p[i].y);
		t1 = t1%mod;
		for(int j = 1;j<i;j++)
			Calc(p[i],p[j]);
	}
	ans = ((((ans-t1+mod)%mod+t2)%mod-t3/3)%mod+mod+t4/6)%mod;
	ans = (ans+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4559

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 105;
const int mod = 1e9+7;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int fac[N*N],env[N*N],Pow[N];
void init()
{
	fac[0] = env[0] = 1;
	for(int i = 1;i<= 10000;i++)
		fac[i] = (ll)fac[i-1]*i%mod;
	env[10000] = quick_pow(fac[10000],mod-2);
	for(int i = 9999;i>=1;i--)
		env[i] = (ll)env[i+1]*(i+1)%mod;
}
ll C(int n,int m)
{
	if(m>n)return 0;
	return (ll)fac[n]*env[m]%mod*env[n-m]%mod;
}
int f[N],g[N],rnk[N],s[N];
int n,m,k;
int main()
{
	init();
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= m;i++)scanf("%d",&s[i]);
	int mxrnk=0;
	for(int i = 1;i<= m;i++)scanf("%d",&rnk[i]),mxrnk=max(mxrnk,rnk[i]);
	for(int i = n-mxrnk;i>= k;i--)
	{
		f[i] = C(n-1,i);
		for(int j = 1;j<= m;j++)
			f[i] = (ll)f[i]*C(n-i-1,rnk[j]-1)%mod;
		for(int j = i+1;j<= n-mxrnk;j++)
			f[i] = (f[i]-(ll)f[j]*C(j,i)%mod+mod)%mod;
	}
	int ans = 1;
	for(int i = 1;i<= m;i++)
	{
		g[0] = s[i];
		Pow[0] = 1;
		for(int j = 1;j<= n;j++)
		{
			Pow[j] = (ll)Pow[j-1]*s[i]%mod;
			g[j] = quick_pow(s[i]+1,j+1)-1;
			for(int k = 1;k<= j;k++)
				(g[j]+=mod-C(j+1,k+1)*g[j-k]%mod)%=mod;
			g[j]=(ll)g[j]*quick_pow(C(j+1,1),mod-2)%mod;
		}
		int now = 0;
		for(int j = 0,k = 1;j<rnk[i];j++,k = -k)
			now = (now+(ll)(mod+k)*C(rnk[i]-1,j)%mod*g[n-rnk[i]+j]%mod*Pow[rnk[i]-j-1]%mod)%mod;
		ans = (ll)ans*now%mod;
	}
	printf("%lld\n",(ll)ans*f[k]%mod);
	return 0;
}
Problem4561

#include <stdio.h>
#include <math.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
ll sqr(ll x){return x*x;}
struct Cir
{
	ll x,y,r;
}c[N];
ll T;
struct data
{
	ll num,x,o;
	data(){}
	data(ll _num,ll _x,ll _o):num(_num),x(_x),o(_o){}
	bool operator <(const data &s)const
	{
		double xx = c[num].y+o*sqrt(sqr(c[num].r)-sqr(T-c[num].x));
		double yy = c[s.num].y+s.o*sqrt(sqr(c[s.num].r)-sqr(T-c[s.num].x));
		if(xx!=yy)return xx<yy;
		return o<s.o;
	}
}poi[N<<1];
bool cmp(const data &a,const data &b)
{
	return a.x<b.x;
}
set<data>S;
ll f[N];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld%lld%lld",&c[i].x,&c[i].y,&c[i].r);
		poi[(i<<1)-1] = data(i,c[i].x-c[i].r,1);
		poi[i<<1] = data(i,c[i].x+c[i].r,-1);
	}
	sort(poi+1,poi+2*n+1,cmp);
	set<data>::iterator it;
	for(int i = 1;i<= 2*n;i++)
	{
		T = poi[i].x;
		if(poi[i].o==1)
		{
			it = S.upper_bound(data(poi[i].num,0,-1));
			if(it==S.end())f[poi[i].num] = 1;
			else
			{
				if((*it).o==1)f[poi[i].num] = -f[(*it).num];
				else f[poi[i].num] = f[(*it).num];
			}
			S.insert(data(poi[i].num,0,-1));
			S.insert(data(poi[i].num,0,1));
		}else
		{
			S.erase(data(poi[i].num,0,-1));
			S.erase(data(poi[i].num,0,1));
		}
	}
	ll ans = 0;
	for(int i = 1;i<= n;i++)
		ans = ans+f[i]*sqr(c[i].r);
	printf("%lld\n",ans);
	return 0;
}
Problem4563

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int B = 2000;
const int mod = 10000;
struct BigNum
{
	int d[B],len;
	BigNum(){memset(d,0,sizeof(d));len = 1;}
	BigNum(int x)
	{
		memset(d,0,sizeof(d));
		len = 1;
		while(x)d[len] = x%mod,x/=mod,len++;
		len--;
	}
	void print()
	{
		printf("%d",d[len]);
		for(int i = len-1;i;i--)
			printf("%04d",d[i]);
	}
	void operator +=(const BigNum &s)
	{
		len = max(len,s.len);
		for(int i = 1;i<=len;i++)
		{
			d[i] = d[i]+s.d[i];
			if(d[i]>=mod)
				d[i+1]++,d[i]%=mod;
		}
		if(d[len+1])len++;
	}
	friend BigNum operator +(const BigNum &a,const BigNum &b)
	{
		BigNum res = a;res+=b;
		return res;
	}
	void operator *=(const int &s)
	{
		int num = 0;
		for(int i = 1;i<= len;i++)
		{
			num = num+d[i]*s;
			d[i] = num%mod;
			num/=mod;
		}
		if(num)d[++len] = num;
	}
}f[205];
int main()
{
	f[0] = BigNum(1);f[1] = BigNum(0);
	int n;
	scanf("%d",&n);
	for(int i = 2;i<= n;i++)
		f[i] = f[i-1]+f[i-2],f[i]*=(i-1);
	f[n].print();
	return 0;
}
Problem4564

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int M = 3e5+5;
const int Asiz = 1005;
const int Siz = 300;
const int maxA = 1e6+5;
int cnt[maxA],bcnt[Asiz][2];
struct E
{int next,to;}e[M];
int head[N],tot=1,A[N],a[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dfn[N],DFN[N],low[N],seq[N],Dfn,size[N];
void dfs(int x,int pre)
{
	DFN[x] = low[x] = ++Dfn;
	seq[Dfn] = x;
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!DFN[e[i].to])
		{
			dfs(e[i].to,i);
			low[x] = min(low[e[i].to],low[x]);
		}else 
			low[x] = min(low[e[i].to],DFN[x]);
	}
}
void dfs2(int x,int pre)
{
	size[x] = 1;
	dfn[x] = ++Dfn;
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!dfn[e[i].to]&&low[e[i].to]>=DFN[x])
		{
			dfs2(e[i].to,i);
			if(low[e[i].to]>DFN[x])
				size[x]+=size[e[i].to];
		}
	}
	for(int i = head[x];i;i=e[i].next)if(pre^1^i)
	{
		if(!dfn[e[i].to]&&low[e[i].to]<DFN[x])
			dfs2(e[i].to,i);
	}
	if(low[x]!=DFN[x])
		size[seq[low[x]]]+=size[x];
}
struct Ask
{
	int l,r,pl;
	int o,p,id;
	bool operator <(const Ask &s)const
	{
		return pl<s.pl||pl==s.pl&&r<s.r;
	}
}ask[N];
int ans[N];
void Delete(int x)
{
	int tx = (a[x]-1)/Asiz+1;
	bcnt[tx][cnt[a[x]]&1]--;
	cnt[a[x]]--;
	if(cnt[a[x]])
		bcnt[tx][cnt[a[x]]&1]++;
}
void Insert(int x)
{
	int tx = (a[x]-1)/Asiz+1;
	if(cnt[a[x]])
		bcnt[tx][cnt[a[x]]&1]--;
	cnt[a[x]]++;
	bcnt[tx][cnt[a[x]]&1]++;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&A[i]);
	int x,y;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1,0);
	Dfn = 0;
	dfs2(1,0);
	for(int i = 1;i<= n;i++)a[dfn[i]]=A[i];
	int q;
	scanf("%d",&q);
	for(int i = 1;i<= q;i++)
	{
		scanf("%d%d%d",&ask[i].o,&ask[i].l,&ask[i].p);
		ask[i].r = dfn[ask[i].l]+size[ask[i].l]-1;
		ask[i].l = dfn[ask[i].l];
		ask[i].pl = ask[i].l/Siz;
		ask[i].id = i;
	}
	sort(ask+1,ask+q+1);
	int L = 1,R = 0;
	for(int i = 1;i<= q;i++)
	{
		while(L<ask[i].l)Delete(L),L++;
		while(L>ask[i].l)L--,Insert(L);
		while(R<ask[i].r)R++,Insert(R);
		while(R>ask[i].r)Delete(R),R--;
		x=(ask[i].p-1)/Asiz+1;
		for(int j = 1;j< x;j++)
			ans[ask[i].id]+=bcnt[j][ask[i].o];
		for(int j = (x-1)*Asiz+1;j<= ask[i].p;j++)
			if(cnt[j]&&(cnt[j]&1)==ask[i].o)
				ans[ask[i].id]++;
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4565

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<8;
const int N = 305;
ll f[N][N][S];
ll inf;
int val[S],c[S];
char s[N];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	scanf("%s",s+1);
	for(int i = 0;i<1<<k;i++)scanf("%d%d",&c[i],&val[i]);
	memset(f,0xef,sizeof(f));inf = f[0][0][0];
	for(int i = 1;i<= n;i++)f[i][i][s[i]-'0'] = 0;
	for(int lth = 2;lth<= n;lth++)
	{
		for(int i = 1;i+lth-1<=n;i++)
		{
			int j = i+lth-1;
			int len = j-i;ll now,t;
			while(len>=k)len-=k-1;
			for(int m = j;m>i;m-=k-1)
				for(int S = 0;S<(1<<len);S++)
					if(f[i][m-1][S]!=inf)
					{
						if(f[m][j][0]!=inf)f[i][j][S<<1] = max(f[i][j][S<<1],f[i][m-1][S]+f[m][j][0]);
						if(f[m][j][1]!=inf)f[i][j][S<<1|1] = max(f[i][j][S<<1|1],f[i][m-1][S]+f[m][j][1]);
					}
			if(len==k-1)
			{
				ll g[2];
				g[0] = g[1] = inf;
				for(int S = 0;S<1<<k;S++)
					if(f[i][j][S]!=inf)
						g[c[S]]=max(g[c[S]],f[i][j][S]+val[S]);
				memcpy(f[i][j],g,sizeof(g));
			}
		}
	}
	ll ans = 0;
	for(int i = 0;i<1<<k;i++)
		ans = max(ans,f[1][n][i]);
	printf("%lld\n",ans);
	return 0;
}
Problem4566

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 4e5+5;
char s1[N>>1],s2[N>>1],s[N];
int sa[N],rnk[N],val[N],nv[N],q[N],cnt[N],h[N],a[N];
inline bool is_same(int a,int b,int hl,int len)
{
	return val[a]==val[b]&&((a+hl>len&&b+hl>len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));
}
void build_sa(int len,int lim)
{
	int i,j,k;
	for(i = 0;i<lim;i++)cnt[i] = 0;
	for(i = 0;i<len;i++)cnt[val[i]=s[i]]++;
	for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i = len-1;i>= 0;i--)sa[--cnt[val[i]]] = i;
	for(int d = 1;;d++)
	{
		int hl = 1<<(d-1),id = 0;
		for(i = 0;i<len;i++)if(sa[i]+hl>=len)q[id++] = sa[i];
		for(i = 0;i<len;i++)if(sa[i]>=hl)q[id++] = sa[i]-hl;

		for(i = 0;i<lim;i++)cnt[i] = 0;
		for(i = 0;i<len;i++)cnt[val[q[i]]]++;
		for(i = 1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i = len-1;i>= 0;i--)sa[--cnt[val[q[i]]]] = q[i];

		lim = 0;
		for(i = 0;i<len;lim++)
		{
			for(j = i;j<len-1&&is_same(sa[j],sa[j+1],hl,len);j++);
			for(k = i,i=j+1;k<= j;k++)nv[sa[k]] = lim;
		}
		if(lim==len)return ;
		for(i = 0;i<len;i++)val[i] = nv[i];
	}
}
void build_height(int len)
{
	for(int i = 0;i< len;i++)rnk[sa[i]]=i;
	for(int i = 0;i< len;i++)
		if(rnk[i])
		{
			int j = 0;
			if(i)j = max(h[rnk[i-1]]-1,0);
			while(i+j<len&&sa[rnk[i]-1]+j<len&&s[i+j]==s[sa[rnk[i]-1]+j])j++;
			h[rnk[i]] = j;
		}
}
inline bool cmp(int a,int b){return h[a]>h[b];}
int fa[N];
ll st[N],en[N];
long long ans;
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x] = getfa(fa[x]);
}
void calc(int x)
{
	if(!x)return ;
	int r1 = getfa(x),r2 = getfa(x-1);
	ans+=(ll)(st[r1]*en[r2]+st[r2]*en[r1])*h[x];
	st[r1]+=st[r2],en[r1]+=en[r2],fa[r2] = r1;
}

int main()
{
	scanf("%s",s1);
	int l1 = strlen(s1);
	scanf("%s",s2);
	int l2 = strlen(s2);
	for(int i = 0;i<l1;i++)
		s[i] = s1[i];
	s[l1] = 'z'+1;
	for(int i = 0;i<l2;i++)s[i+l1+1]=s2[i];
	int len = l1+l2+1;
	build_sa(len,256);
	build_height(len);
	for(int i = 0;i<len;i++)a[i]=fa[i]=i,st[i]=(sa[i]<l1),en[i] = 1-st[i];
	sort(a,a+len,cmp);
	for(int i = 0;i<len;i++)calc(a[i]);
	printf("%lld\n",ans);
	return 0;
}
Problem4568

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 20005;
struct Seg
{
	ll p[61];
	Seg(){memset(p,0,sizeof(p));}
	void init()
	{
		memset(p,0,sizeof(p));
	}
}tr[N<<2];
struct E
{int next,to;}e[N<<1];
int head[N],tot,n,Q;
ll val[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],top[N],size[N],son[N],dfn[N],Dfn,seq[N],fa[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	seq[++Dfn] = x;
	dfn[x] = Dfn;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void insert(Seg &a,ll x)
{
	for(int i = 60;i>=0;i--)
		if((x>>i)&1)
		{
			if(!a.p[i]){a.p[i] = x;break;}
			else x^=a.p[i];
		}
}
void merge(Seg &a,Seg &b,Seg &c)
{
	for(int i = 0;i<= 60;i++)a.p[i]=b.p[i];
	for(int i = 60;i>=0;i--)if(c.p[i])insert(a,c.p[i]);
}
ll getans(const Seg &ans)
{
	ll Ans = 0;
	for(int i = 60;i>=0;i--)if((Ans^ans.p[i])>Ans)Ans = Ans^ans.p[i];
	return Ans;
}
void Build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].init();
		insert(tr[p],val[seq[l]]);
		return ;
	}
	int mid = (l+r)>>1;
	Build(p<<1,l,mid);
	Build(p<<1|1,mid+1,r);
	merge(tr[p],tr[p<<1],tr[p<<1|1]);
}
Seg ret;
void Getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		{merge(ret,ret,tr[p]);return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Getans(p<<1,l,mid,a,b);
	if(b >mid)Getans(p<<1|1,mid+1,r,a,b);
}
ll Getans(int x,int y)
{
	ret.init();
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		Getans(1,1,n,dfn[top[x]],dfn[x]);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	Getans(1,1,n,dfn[y],dfn[x]);
	return getans(ret);
}
int main()
{
	scanf("%d%d",&n,&Q);
	for(int i = 1;i<= n;i++)
		scanf("%lld",&val[i]);
	int x,y;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	Build(1,1,n);
	while(Q--)
	{
		scanf("%d%d",&x,&y);
		printf("%lld\n",Getans(x,y));
	}
	return 0;
}
Problem4569

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int mod = 1e9+7;
int fa[N*20],id[N][20],idx[N*20][2];
int getfa(int x)
{
	if(fa[x]==x||!fa[x])return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void merge(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	fa[y] = x;
}
int pow2[20];
int main()
{
	pow2[0] = 1;
	for(int i = 1;i<= 18;i++)pow2[i]=pow2[i-1]*2;
	int n,cnt = 0,m;
	scanf("%d",&n);
	if(n==1){printf("10\n");return 0;}
	for(int i = 1;i<= n;i++)
		for(int j = 0;j<=18;j++)
			id[i][j]=++cnt,idx[cnt][0]=i,idx[cnt][1]=j;
	scanf("%d",&m);
	int l1,r1,l2,r2;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
		for(int j = 18;j>= 0;j--)
		{
			if(l1+pow2[j]-1<=r1)
			{
				merge(id[l1][j],id[l2][j]);
				l1+=pow2[j],l2+=pow2[j];
			}
		}
	}
	for(int j = 18;j>= 1;j--)
	{
		for(int i = 1;i<= n;i++)
		{
			int k = getfa(id[i][j]);
			int s = idx[k][0];int t = idx[k][1];
			merge(id[s][t-1],id[i][j-1]);
			merge(id[s+pow2[t-1]][t-1],id[i+pow2[j-1]][j-1]);
		}
	}
	int tot = 0;
	for(int i = 1;i<= n;i++)
		if(getfa(id[i][0])==id[i][0])tot++;
	long long ans = 9;
	for(int i = 1;i< tot;i++)ans = ans*10%mod;
	printf("%lld\n",ans);
	return 0;
}
Problem4570

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
const double eps = 1e-8;
const double INF = 1e20;
typedef long long ll;
struct P
{
	double x,y;
	P(double _x=0,double _y=0):x(_x),y(_y){}
	bool operator <(const P &s)const
	{
		if(x==s.x)return y>s.y;
		return x<s.x;
	}
	friend P operator -(const P &a,const P &b)
	{
		return P(a.x-b.x,a.y-b.y);
	}
	friend double operator *(const P &a,const P &b)
	{
		return a.x*b.y-a.y*b.x;
	}
}p[N],stack[N];
int top;
double slope(const P &a,const P &b)
{
	if(fabs(a.x-b.x)<eps)return -INF;
	else return (b.y-a.y)/(b.x-a.x);
}
double slope(const P &a)
{
	return -sqrt(a.y/a.x);
}
double calc(const P &a,double k)
{
	if(k>-eps)return INF;
	else return a.x+a.y-a.x*k-a.y/k;
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf",&p[i].x,&p[i].y);
	sort(p+1,p+n+1);
	stack[++top] = p[1];
	for(int i = 2;i<= n;i++)
	{
		while(top>1&&(p[i]-stack[top])*(stack[top]-stack[top-1])<-eps)
			top--;
		stack[++top] = p[i];
	}
	double ans;
	if(top==1)ans = calc(stack[1],slope(stack[1]));
	else
	{
		double sp,sp1,sp2;
		ans = INF;
		sp2 = slope(stack[1],stack[2]),sp = slope(stack[1]);
		if(sp+eps>sp2)ans = min(ans,calc(stack[1],sp));
		for(int i = 2;i<top;i++)
		{
			sp1 = slope(stack[i-1],stack[i]);
			sp2 = slope(stack[i],stack[i+1]);
			sp = slope(stack[i]);
			ans = min(ans,calc(stack[i],sp1));
			if(sp1+eps>sp&&sp+eps>sp2)ans = min(ans,calc(stack[i],sp));
		}
		sp1 = slope(stack[top-1],stack[top]),sp = slope(stack[top]);
		ans = min(ans,calc(stack[top],sp1));
		if(sp1+eps>sp)ans = min(ans,calc(stack[top],sp));
	}
	printf("%.4f\n",ans);
	return 0;
}
Problem4571

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2e5+5;
int root[N],size[N*100],ls[N*100],rs[N*100],cnt,a[N];
void Update(int &p,int pre,int l,int r,int pos)
{
	p = ++cnt;
	size[p] = size[pre]+1;
	ls[p] = ls[pre],rs[p] = rs[pre];
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)Update(ls[p],ls[pre],l,mid,pos);
	else Update(rs[p],rs[pre],mid+1,r,pos);
}
int Getans(int L,int R,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)
		return size[R]-size[L];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=Getans(ls[L],ls[R],l,mid,a,b);
	if(b >mid)ans+=Getans(rs[L],rs[R],mid+1,r,a,b);
	return ans;
}
int L,R,D;
int mx = (1<<19)-1;
int getans(int l,int r,int x,int y)
{
	if(l==r)
		return x^l;
	int mid = (l+r)>>1;
	D--;
	if(x&(1<<D))
	{
		if(Getans(L,R,0,mx,max(0,l-y),max(0,mid-y)))
			return getans(l,mid,x,y);
		else 
			return getans(mid+1,r,x,y);
	}
	else
	{
		if(Getans(L,R,0,mx,max(0,mid+1-y),max(0,r-y)))
			return getans(mid+1,r,x,y);
		else 
			return getans(l,mid,x,y);
	}
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)
		Update(root[i],root[i-1],0,mx,a[i]);
	int x,y,l,r;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d%d",&x,&y,&l,&r);
		D = 19;
		L = root[l-1],R = root[r];
		printf("%d\n",getans(0,mx,x,y));
	}
	return 0;
}
Problem4573

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
const int M = 4e5+5;
struct List
{int next,to,opt;}e[M];
struct data
{
	int t,ca,x,y,z,ans;
	bool operator <(const data &s)const
	{return t<s.t;}
}ask[N],zlt;
int head[N],TOT;
void add(int x,int y,int o)
{e[++TOT].to=y;e[TOT].next=head[x];e[TOT].opt=o;head[x]=TOT;}
int fa[M],ch[M][2],size[M],sum[M],val[M],pp[M],sta[M],tot,top;
int lt[N],rt[N],gs[N],b[M],n,m;
bool rev[M];
inline int pd(int x)
{return ch[fa[x]][1]==x;}
inline void Push_up(int p)
{sum[p]=sum[ch[p][0]]+val[p]+sum[ch[p][1]];}
void rotate(int x)
{
	int y = fa[x];
	int d = ch[y][1]==x;
	fa[x] = fa[y];
	if(fa[y])ch[fa[y]][pd(y)] = x;
	ch[y][d]=ch[x][d^1];
	if(ch[x][d^1])fa[ch[x][d^1]] = y;
	ch[x][d^1] = y;
	fa[y] = x;
	Push_up(y);Push_up(x);
	if(pp[y])pp[x]=pp[y],pp[y]=0;
}
void Push_down(int p)
{
	if(rev[p])
	{
		if(ch[p][0])rev[ch[p][0]]^=1;
		if(ch[p][1])rev[ch[p][1]]^=1;
		swap(ch[p][0],ch[p][1]);
		rev[p] = false;
	}
}
void relax(int x,int y)
{
	top = 0;
	while(x!=y)
	{
		sta[++top] = x;
		x = fa[x];
	}
	while(top)
	{
		x = sta[top--];
		Push_down(x);
	}
}
void splay(int x,int y)
{
	relax(x,y);
	while(fa[x]!=y)
	{
		if(fa[fa[x]]!=y)
		{
			if(pd(x)==pd(fa[x]))rotate(fa[x]);
			else rotate(x);
		}
		rotate(x);
	}
}
int access(int x)
{
	int y,z,p = x;
	splay(x,0);
	z = ch[x][1];
	ch[x][1] = 0;
	if(z)
	{
		fa[z] = 0;
		pp[z] = x;
	}
	Push_up(x);
	while(pp[x])
	{
		p = y = pp[x];
		splay(y,0);
		z = ch[y][1];
		if(z)
		{
			fa[z] = 0;
			pp[z] = y;
		}
		ch[y][1] = x;
		fa[x] = y;pp[x] = 0;
		Push_up(y);
		splay(x,0);
	}
	return p;
}
void make_root(int x)
{
	access(x);
	splay(x,0);
	rev[x]^=1;
}
void Link(int x,int y)
{
	make_root(y);
	splay(y,0);
	pp[y] = x;
}
void Cut(int x)
{
	make_root(1);
	access(x);
	splay(x,0);
	int y = ch[x][0];
	ch[x][0] = 0;
	if(y)
	{
		fa[y] = pp[y] = 0;
	}
	Push_up(x);
}
void Insert1(int x)
{
	int j = b[ask[x].y-1],k = b[ask[x].y];
	Cut(k);
	Link(k,ask[x].x);
}
void Delete1(int x)
{
	int j = b[ask[x].y-1],k = b[ask[x].y];
	Cut(k);
	Link(k,j);
}
void Insert0(int x)
{
	int j = gs[ask[x].x];
	val[ask[x].x] = 1;
	Push_up(ask[x].x);
	Link(ask[x].x,b[j]);
}
void Delete0(int x)
{
	Cut(ask[x].x);
}

int main()
{
	int l,r,x,y,ans;
	scanf("%d%d",&n,&m);
	tot = top = 1;
	lt[1] = 1,rt[1] = n;
	for(int i = 1;i<= m;i++)
	{
		ask[i].t = i;
		scanf("%d",&ask[i].ca);
		if(ask[i].ca==0)
		{
			scanf("%d%d",&l,&r);
			add(l,i,1),add(r+1,i,-1);
			ask[i].x=++tot;
			lt[tot]=l,rt[tot]=r;
			gs[tot] = top;
		}else if(ask[i].ca==1)
		{
			scanf("%d%d%d",&l,&r,&ask[i].x);
			l = max(l,lt[ask[i].x]),r = min(r,rt[ask[i].x]);
			if(l<=r)
			{
				add(l,i,1),add(r+1,i,-1);
				ask[i].y=++top;
			}
		}else
		{
			scanf("%d%d%d",&ask[i].z,&ask[i].x,&ask[i].y);
			l = ask[i].z;
			add(l,i,1);
		}
	}
	zlt.t=0;
    zlt.ca=1;
    zlt.x=1;
    zlt.y=1;
    ask[0]=zlt;
    for(int i = 1;i<= top;i++)b[i]=++tot;
    val[1] = 1;
	Push_up(1);
	pp[b[1]] = 1;
	for(int i = 2;i<= top;i++)pp[b[i]]=b[i-1];
	for(int i = 1;i<= n;i++)
	{
		for(int t = head[i];t;t=e[t].next)
		{
			if(ask[e[t].to].ca==0)
				{if(e[t].opt==1)Insert0(e[t].to);else Delete0(e[t].to);}
			else if(ask[e[t].to].ca==1)
				{if(e[t].opt==1)Insert1(e[t].to);else Delete1(e[t].to);}
		}
		for(int t = head[i];t;t=e[t].next)
		{
			if(ask[e[t].to].ca==2)
			{
				x = ask[e[t].to].x,y = ask[e[t].to].y;
				if(x==y){ask[e[t].to].ans = 0;continue;}
				make_root(1);
                access(x);
                splay(x,0);
                ans=sum[x];
                x=access(y);
                splay(y,0);
                ans+=sum[y];
                access(x);
                splay(x,0);
                ans-=sum[x]*2;
                ask[e[t].to].ans=ans;
			}
		}
	}
	for(int i = 1;i<= m;i++)
		if(ask[i].ca==2)printf("%d\n",ask[i].ans);
	return 0;
}
Problem4574

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 405;
const int mod = 1e9+7;
int dp[2][N][N],ans[N][N],A[N][N];
int a[N],idx[N],y[N],num[N];
int n,Q;
void solve(int l,int r,int pos)
{
	int i,j;
	for(i = l;i<= r;i++)
		for(j = l;j<= r;j++)
			dp[0][i][j]=dp[1][i][j]=0;
	int now = 1,pre = 0;
	ll k1;
	dp[0][l][r] = 1;
	for(int t = 1;t<= Q;t++)
	{
		for(i = l;i<= r;i++)
		{
			k1 = 0;
			for(j = r;j>= i;j--)
				dp[now][i][j] = k1%mod,k1 += 1ll*dp[pre][i][j]*(n-j);
		}
		for(j = l;j<= r;j++)
		{
			k1 = 0;
			for(i = l;i<= j;i++)
				dp[now][i][j]= (dp[now][i][j]+k1)%mod,k1 += 1ll*dp[pre][i][j]*(i-1);
		}
		for(j = l;j<= r;j++)
			for(i = l;i<= j;i++)
				dp[now][i][j]=(dp[now][i][j]+1ll*dp[pre][i][j]*A[i][j])%mod;
		pre^=1,now^=1;
	}
	for(i = l;i<= r;i++)
	{
		k1 = 0;
		for(j = r;j>= i;j--)
		{
			k1 += dp[pre][i][j];
			ans[j][y[pos]] = (ans[j][y[pos]]+k1)%mod;
		}
	}
}
bool cmp(int x,int y)
{
	return a[x]<a[y];
}
int main()
{
	scanf("%d%d",&n,&Q);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)idx[i]=i;
	sort(idx+1,idx+n+1,cmp);
	for(int i = 1;i<= n;i++)y[idx[i]]=i;
	for(int i = 1;i<= n;i++)num[i] = (i*(i+1))>>1;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)A[i][j] = num[i-1]+num[j-i+1]+num[n-j];
	int l,r,Ans;
	for(int i = 1;i<= n;i++)
	{
		l = i,r = i;
		while(l&&a[l]<=a[i])l--;
		while(r<=n&&a[r]<=a[i])r++;
		solve(l+1,r-1,i);
	}
	int i,j,k;
	for(i = 1;i<= n;i++)
	{
		Ans = 0;
		for(j = 1;j<= n;j++)
		{
			if(!ans[i][j])continue;
			for(k = 1;k<j;k++)
				ans[i][j] = (ans[i][j]-ans[i][k]+mod)%mod;
			Ans = (Ans+1ll*a[idx[j]]*ans[i][j])%mod;
		}
		printf("%d",Ans);
		if(i!=n)printf(" ");
	}
	return 0;
}
Problem4576

#include <stdio.h>
#include <cctype>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 262145;
int f[60][N];
char getc()
{
	static const int LEN = 4096;
	static char buf[LEN],*S=buf,*T=buf;
	if(S == T)
	{
		T = (S=buf)+fread(buf,1,LEN,stdin);
		if(S == T)return EOF;
	}
	return *S++;
}
int read()
{
	static char ch;
	static int D;
	while(!isdigit(ch=getc()));
	for(D=ch-'0'; isdigit(ch=getc());)
		D=(D<<3)+(D<<1)+(ch-'0');
	return D;
}
int main()
{
	int n,x,ans = 0;
	n=read();
	for(int i = 1;i<= n;i++){x=read();f[x][i] = i+1;}
	for(int i= 2;i<= 58;i++)
		for(int j = 1;j<= n;j++)
		{
			if(!f[i][j])f[i][j] = f[i-1][f[i-1][j]];
			if(f[i][j])ans = i;
		}
	printf("%d",ans);
	return 0;
}
Problem4578

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 5e4+5;
const int INF = 0x3f3f3f3f;
int pmx[N],hmx[N],pmn[N],hmn[N],n;
struct Pos
{int x,y;}pos[N];
bool cmp1(Pos a,Pos b){return a.x<b.x;}
bool cmp2(Pos a,Pos b){return a.y<b.y;}
void init1()
{
	pmn[0] = INF,hmn[n+1] = INF;
	for(int i = 1;i<= n;i++)
	{
		pmx[i] = max(pmx[i-1],pos[i].x);
		pmn[i] = min(pmn[i-1],pos[i].x);
	}for(int i = n;i>= 1;i--)
	{
		hmx[i] = max(hmx[i+1],pos[i].x);
		hmn[i] = min(hmn[i+1],pos[i].x);
	}
}
void init2()
{
	pmn[0] = INF,hmn[n+1] = INF;
	for(int i = 1;i<= n;i++)
	{
		pmx[i] = max(pmx[i-1],pos[i].y);
		pmn[i] = min(pmn[i-1],pos[i].y);
	}for(int i = n;i>= 1;i--)
	{
		hmx[i] = max(hmx[i+1],pos[i].y);
		hmn[i] = min(hmn[i+1],pos[i].y);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&pos[i].x,&pos[i].y);
	sort(pos+1,pos+n+1,cmp1);
	init2();
	LL ans = 1e18+5;
	for(int i = 1;i< n;i++)
	{
		LL tmp = (LL)(pos[i].x-pos[1].x)*(pmx[i]-pmn[i]);
		tmp+=(LL)(pos[n].x-pos[i+1].x)*(hmx[i+1]-hmn[i+1]);
		ans = min(ans,tmp);
	}
	sort(pos+1,pos+n+1,cmp2);
	init1();
	for(int i = 1;i< n;i++)
	{
		LL tmp = (LL)(pos[i].y-pos[1].y)*(pmx[i]-pmn[i]);
		tmp+=(LL)(pos[n].y-pos[i+1].y)*(hmx[i+1]-hmn[i+1]);
		ans = min(ans,tmp);
	}
	printf("%lld\n",(LL)(pos[n].y-pos[1].y)*(hmx[1]-hmn[1])-ans);
	return 0;
}
Problem4579

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 400005;
struct E
{int next,to;}e[N];
int head[N],tot,fa[N],ask[N],size[N];
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
bool ans[N],used[N];
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x] = getfa(fa[x]);
}
void uni(int x,int y)
{
	x = getfa(x),y = getfa(y);
	if(x==y)return ;
	if(size[x]>size[y])
		fa[y] = x;
	else fa[x] = y; 
	size[x] = size[y] = size[x]+size[y];
}
int cnt = 0;
void solve(int x)
{
	for(int i = head[x];i;i = e[i].next)
		if(used[e[i].to])
			uni(e[i].to,x);
	used[x] = true;
	cnt++;
}
int main()
{
	int n,m,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)size[fa[i] = i] = 1;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	for(int i = 1;i<= n;i++)
		scanf("%d",&ask[i]);
	for(int i = n;i>=1;i--)
	{
		solve(ask[i]);
		if(size[getfa(ask[i])]==cnt)ans[i] =true;
		else ans[i] = false;
	}
	for(int i = 1;i<= n;i++)
	{
		if(ans[i])printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
Problem4580

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
int num[250];
int f[250][250];
int uni(int l,int r)
{
	if(f[l][r]!=0)return f[l][r];
	for(int i = l;i<r;i++)
		if(uni(l,i)==uni(i+1,r))
			f[l][r] = max(f[l][i]+1,f[l][r]);
	if(f[l][r]==0)f[l][r] = -1;
	return f[l][r];
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<=n;i++)
	{
		scanf("%d",&num[i]);
		f[i][i] = num[i];
	}
	int ans = 0;
	for(int i = 1;i<= n;i++)
		for(int j = i;j<= n;j++)
			ans = max(ans,uni(i,j));
	printf("%d\n",ans);
	return 0;
}
Problem4581

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 50005;
int maxx[5],maxy[5],minx[5],miny[5];
int x[N],y[N];
int main()
{
	int n;
	scanf("%d",&n);
	memset(minx,0x3f,sizeof(minx));
	memset(miny,0x3f,sizeof(miny));
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
		maxx[4] = max(maxx[4],x[i]);
		for(int j = 4;j>1;j--)
			if(maxx[j]>maxx[j-1])swap(maxx[j],maxx[j-1]);
		minx[4] = min(minx[4],x[i]);
		for(int j = 4;j>1;j--)
			if(minx[j]<minx[j-1])swap(minx[j],minx[j-1]);
		maxy[4] = max(maxy[4],y[i]);
		for(int j = 4;j>1;j--)
			if(maxy[j]>maxy[j-1])swap(maxy[j],maxy[j-1]);
		miny[4] = min(miny[4],y[i]);
		for(int j = 4;j>1;j--)
			if(miny[j]<miny[j-1])swap(miny[j],miny[j-1]);
	}
	int ans = (1<<30)-1+(1<<30);
	for(int x1 = 1;x1<=4;x1++)
	for(int x2 = 1;x2<=4;x2++)
		if(minx[x1]<maxx[x2])
		for(int y1 = 1;y1<=4;y1++)
		for(int y2 = 1;y2<=4;y2++)
		if(miny[y1]<maxy[y2])
		{
			int cnt = 0;
			for(int i = 1;i<= n;i++)
				if(x[i]>=minx[x1]&&x[i]<=maxx[x2]&&y[i]>=miny[y1]&&y[i]<=maxy[y2])
					cnt++;
			if(cnt>=n-3)
				ans = min(ans,(maxx[x2]-minx[x1])*(maxy[y2]-miny[y1]));
		}
	printf("%d\n",ans);
	return 0;
}
Problem4582

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e4+5;
int ans[N<<1],num[N<<1];
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&num[i]);
	sort(num+1,num+n+1);
	int j = 0;
	for(int i = 1;i<=n;i++)
	{
		while(num[j]-num[i]<=k&&j<=n)j++;
		ans[i] = j-i;
	}
	int Tans = 0;
	for(int i = n;i>=1;i--)
	{
		Tans = max(Tans,ans[i]+ans[i+ans[i]]);
		ans[i] = max(ans[i],ans[i+1]);
	}
	printf("%d\n",Tans);
	return 0;
}
Problem4590

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 100005;
int opt[N],n;
int check(LL l)
{
	LL now = 0;int cnt = 0;
	for(int i = 1;i<= n;i++)
	{
		now+=opt[i];
		if(now<0)now = 0;
		if(now>=l){cnt++;now = 0;}
	}
	return cnt;
}
int main()
{
	int k;
	scanf("%d%d",&n,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d",&opt[i]);
	LL l = 1,r = 1e15,lans = 0,rans = 0;
	while(l<r)
	{
		LL mid = (l+r)>>1;
		if(check(mid)>k)l = mid+1;
		else r = mid;
	}
	lans = l;
	l = 1;r = 1e15;
	while(l<r)
	{
		LL mid = (l+r)>>1;
		if(check(mid)>=k)l = mid+1;
		else r = mid;
	}
	rans = l-1;
	if(check(lans)!=k||check(rans)!=k||lans<=0||rans<=0)printf("-1\n");
	else printf("%lld %lld\n",lans,rans);
	return 0;
}
Problem4592

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std; 
#define maxn 200005 
  
struct Seg  
{  
    int l,r;  
    int lmx,rmx,ans,size,tag;  
}t[maxn<<2];  
  
int n,T;  
  
inline void add(int i,int x)  
{  
    t[i].tag=x;  
    if (x==1) t[i].lmx=t[i].rmx=t[i].ans=t[i].size=0;  
    else t[i].lmx=t[i].rmx=t[i].ans=t[i].size=t[i].r-t[i].l+1;  
}  
  
inline void release(int i) 
{
    if (t[i].tag==-1) return;  
    add(i*2,t[i].tag);add(i*2+1,t[i].tag);  
    t[i].tag=-1;  
}  
  
Seg merge(Seg x,Seg y)  
{  
    Seg ans;  
    ans.l=x.l;ans.r=y.r;  
    ans.size=x.size+y.size;  
    if (x.size==x.r-x.l+1) ans.lmx=x.size+y.lmx; else ans.lmx=x.lmx;  
    if (y.size==y.r-y.l+1) ans.rmx=y.size+x.rmx; else ans.rmx=y.rmx;  
    ans.ans=max(x.rmx+y.lmx,max(x.ans,y.ans));  
    ans.tag=-1;  
    return ans;  
}  
  
void build(int i,int l,int r)  
{  
    t[i].l=l;t[i].r=r;t[i].lmx=t[i].rmx=t[i].ans=t[i].size=0;t[i].tag=-1;  
    if (l==r) return;  
    int mid=(t[i].l+t[i].r)/2;  
    build(i*2,l,mid);build(i*2+1,mid+1,r);  
}  
  
void modify(int i,int l,int r,int d)  
{  
    if (l<=t[i].l && t[i].r<=r) {add(i,d);return;}  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (l<=mid) modify(i*2,l,r,d);  
    if (mid<r) modify(i*2+1,l,r,d);  
    t[i]=merge(t[i*2],t[i*2+1]);  
}  
  
int Query(int i,int l,int r)  
{  
    if (l<=t[i].l && t[i].r<=r) return t[i].size;  
    release(i);  
    int mid=(t[i].l+t[i].r)/2,ans=0;  
    if (l<=mid) ans+=Query(i*2,l,r);  
    if (mid<r) ans+=Query(i*2+1,l,r);  
    return ans;  
}  
  
void change(int i,int l,int r,int x)  
{  
    if (!x) return;  
    if (l<=t[i].l && t[i].r<=r && t[i].size<=x) {add(i,1);return;}  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (l<=mid)  
    {  
        int num=Query(i*2,l,r);  
        if (x>num) {modify(i*2,l,r,1);if (mid<r) change(i*2+1,l,r,x-num);}  
        else change(i*2,l,r,x);  
    }  
    else change(i*2+1,l,r,x);   
    t[i]=merge(t[i*2],t[i*2+1]);  
}  
  
Seg query(int i,int l,int r)  
{  
    if (l<=t[i].l && t[i].r<=r) return t[i];  
    release(i);  
    int mid=(t[i].l+t[i].r)/2;  
    if (r<=mid) return query(i*2,l,r);  
    else if (l>mid) return query(i*2+1,l,r);  
    else return merge(query(i*2,l,r),query(i*2+1,l,r));  
}  
  
int main()  
{  
    scanf("%d%d",&n,&T);  
    build(1,1,n);  
    while (T--)  
    {  
        int op,l1,l2,r1,r2;  
        scanf("%d%d%d",&op,&l1,&r1);  
        if (op==0) modify(1,l1,r1,0);  
        else if (op==1)  
        {  
            scanf("%d%d",&l2,&r2);  
            int num=r1-l1+1-Query(1,l1,r1);  
            modify(1,l1,r1,0);  
            change(1,l2,r2,num);  
        }  
        else   
        {  
            Seg ans=query(1,l1,r1);  
            printf("%d\n",ans.ans);  
        }  
    }  
    return 0;  
}  
Problem4593

#include <iostream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <ctime>
using namespace std;
struct node {int to;int next;};node bian[200005];
int first[100005],size,f[100005],h[100005],g[1000010];
int father[100005],d[100005],c[100005],n,a,b,maxc;
void inser(int x,int y) {
	size ++;
	bian[size].to = y;
	bian[size].next = first[x];
	first[x] = size;
}
void dfs(int x,int Anc) {
	father[x] = Anc;
	int _d1 = d[x],_d2 = d[x] - c[father[x]],ret = 0;
	for(int u = first[x];u;u = bian[u].next)
	{
		if(bian[u].to == Anc) continue;
		dfs(bian[u].to,x);
		if(f[bian[u].to] == h[bian[u].to])
		{
			_d1 -= c[bian[u].to];
			_d2 -= c[bian[u].to];
			ret += f[bian[u].to];
		}
		else ret += h[bian[u].to];
	}
	f[x] = ret + max(_d1,0);
	h[x] = ret + max(_d2,0);
}
void bfs(int x,int Anc) {
	father[x] = Anc;
	int _d1 = d[x],_d2 = d[x] - c[father[x]],ret = 0;
	for(int u = first[x];u;u = bian[u].next)
	{
		if(bian[u].to == Anc) continue;
		bfs(bian[u].to,x);
		if(f[bian[u].to] - h[bian[u].to] < c[bian[u].to])
		{
			_d1 -= c[bian[u].to];
			_d2 -= c[bian[u].to];
			ret += f[bian[u].to];
		}
		else ret += h[bian[u].to];
	}
	if(_d1 < 0) 
	{
		int _n = 0;g[0] = 0;
		for(int u = first[x];u;u = bian[u].next)
		{
			if(bian[u].to == Anc) continue;
			if(f[bian[u].to] - h[bian[u].to] >= c[bian[u].to]) continue;
			for(int i = _n + 1;i <= _n + c[bian[u].to];i ++)
				g[i] = 0;
			_n = _n + c[bian[u].to];
			int C = c[bian[u].to],D = f[bian[u].to] - h[bian[u].to];
			for(int i = 0;i + C <= _n;i ++)
				g[i + C] = ((g[i + C] > g[i] + D) ? g[i + C] : g[i] + D);
		}
		f[x] = ret;
		for(int i = 1;i <= _n;i ++)
			f[x] = min(f[x],max(0,_d1 + i) + ret - g[i]);
		//f[x] = ret - g[_n];
	}
	else f[x] = ret + max(_d1,0);
	if(_d2 < 0) 
	{
		int _n = 0;g[0] = 0;
		for(int u = first[x];u;u = bian[u].next)
		{
			if(bian[u].to == Anc) continue;
			if(f[bian[u].to] - h[bian[u].to] >= c[bian[u].to]) continue;
			for(int i = _n + 1;i <= _n + c[bian[u].to];i ++)
				g[i] = 0;
			_n = _n + c[bian[u].to];
			int C = c[bian[u].to],D = f[bian[u].to] - h[bian[u].to];
			for(int i = 0;i + C <= _n;i ++)
				g[i + C] = ((g[i + C] > g[i] + D) ? g[i + C] : g[i] + D);
		}
		h[x] = ret;
		for(int i = 1;i <= _n;i ++)
			h[x] = min(h[x],max(0,_d1 + i) + ret - g[i]);	
	}
	else h[x] = ret + max(_d2,0);
}
int main() {
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++)
		scanf("%d",&d[i]);
	for(int i = 1;i <= n;i ++)
		scanf("%d",&c[i]),maxc = max(maxc,c[i]);
	for(int i = 2;i <= n;i ++)
	{
		scanf("%d%d",&a,&b);
		inser(a,b);
		inser(b,a);
	}
	if(maxc <= 1) dfs(1,0); else bfs(1,0);
	printf("%d",f[1]);
}
Problem4594

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int pre[N],fi[N],n,m;
struct E
{
	int x,y;
	E(int _x=0,int _y=0):x(_x),y(_y){}
	bool operator <(const E &s)const
	{
		if(x!=s.x)return x<s.x;
		return y<s.y;
	}
}e[N];
bool check(int x,int l,int r)
{
	if(x<=0)return false;
	for(int i = l+x;i<= r;i++)
	{
		if((i-l)%x!=pre[i]-l)return false;
		if(e[fi[i]].x==i&&e[fi[i]].y<l+x&&fi[i]<=m)return false;
	}
	return true;
}
bool judge(int l,int r)
{
	if(l==r)return true;
	int x=0;
	for(int i = l;i<= r;i++)
	{
		if(pre[i]>=l)continue;
		for(;fi[i]<=m&&e[fi[i]].x==i&&e[fi[i]].y<l;fi[i]++);
		if(fi[i]<=m&&e[fi[i]].x==i){pre[i]=e[fi[i]].y;++fi[i];}
	}
	pre[l] = l;
	for(int i = r;i>l;i--)
		if(pre[i]==l&&r-l+1>=(pre[i-1]-l+1)*2)
			{x = pre[i-1]-l+1;break;}
	if(!check(x,l,r)&&(r-pre[r])*2>=r-l+1&&pre[r]>=l)x = r-pre[r];
	if(check(x,l,r)&&judge(l,l+x-1)&&judge(l+x,r))return true;
	return false;
}
int main()
{
	int cas,x,y;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		bool flag = false;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			if(x<y)swap(x,y);
			e[i] = E(x,y);
			if(x==y)flag = true;
		}
		if(flag){puts("NO");continue;}
		sort(e+1,e+m+1);
		for(int i = 0;i<n;i++)pre[i] = -1;
		int j = 1;
		for(int i = 0;i< n;i++)
		{
			fi[i] = j;
			for(;e[j].x==i&&j<=m;j++);
		}
		if(judge(0,n-1))puts("YES");
		else puts("NO");
	}
	return 0;
}
Problem4596

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 20;
const int M = 1005;
ll d[N][N];
int m[N];
int v1[N][N*N],v2[N][N*N];
int n;ll ans;
ll Gauss()
{
	ll res = 1,f = 1;
	for(int i = 1;i<n;i++)
		for(int j = 1;j<n;j++)
			(d[i][j]+=mod)%=mod;
	for(int i = 1;i<n;i++)
	{
		for(int j = i+1;j<n;j++)
		{
			ll A = d[i][i],B = d[j][i];
			while(B)
			{
				ll C = A/B;
				A%=B;
				swap(A,B);
				for(int k = i;k<n;k++)
					d[i][k] = (d[i][k]-C*d[j][k]%mod+mod)%mod;
				for(int k = i;k<n;k++)
					swap(d[i][k],d[j][k]);
				f = -f;
			}
		}
		if(!d[i][i])return 0;
		res = res*d[i][i]%mod;
	}
	return (mod+f*res)%mod;
}
int main()
{
	scanf("%d",&n);
	for(int i = 0;i< n-1;i++)
	{
		scanf("%d",&m[i]);
		for(int j = 1;j<= m[i];j++)
			scanf("%d%d",&v1[i][j],&v2[i][j]);
	}
	for(int sta = 1;sta<1<<(n-1);sta++)
	{
		memset(d,0,sizeof(d));
		int cnt = 0;
		for(int i = 0;i< n-1;i++)
			if(sta&(1<<i))
			{
				cnt++;
				for(int k = 1;k<= m[i];k++)
					d[v1[i][k]][v2[i][k]]--,  
                    d[v2[i][k]][v1[i][k]]--,  
                    d[v1[i][k]][v1[i][k]]++,  
                    d[v2[i][k]][v2[i][k]]++; 
			}
		if((n-cnt)&1)(ans+=Gauss())%=mod;
		else (ans+=mod-Gauss())%=mod;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4597

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int N = 1e5+5;
typedef long long ll;
int n,T;
ll tr[N<<2],lazy[N<<2];
ll sum[N],a[N],inv[10005];
ll quick_pow(ll x,ll y)
{
	ll res = 1;
	while(y)
	{
		if(y&1)res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
void Push_down(int p,int l,int r)
{
	if(l==r||lazy[p]==1)return ;
	tr[p<<1] = tr[p<<1]*lazy[p]%mod;lazy[p<<1] = lazy[p<<1]*lazy[p]%mod;
	tr[p<<1|1] = tr[p<<1|1]*lazy[p]%mod;lazy[p<<1|1] = lazy[p<<1|1]*lazy[p]%mod;
	lazy[p] = 1;
}
void build(int p,int l,int r)
{
	lazy[p] = 1;
	if(l==r)
	{
		if(l!=n)tr[p] = 2ll*quick_pow(3,n-l-1)%mod*sum[l]%mod;
		else tr[p] = sum[n];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	tr[p] = (tr[p<<1]+tr[p<<1|1])%mod;
}
void Update(int p,int l,int r,int a,int b,int x)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		tr[p]=tr[p]*x%mod;
		lazy[p]=lazy[p]*x%mod;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,x);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,x);
	tr[p] = (tr[p<<1]+tr[p<<1|1])%mod;
}

int main()
{
	for(int i = 1;i<= 10000;i++)inv[i]=quick_pow(i,mod-2);
	scanf("%d%d",&n,&T);
	for(int i = 1;i<= n;i++)scanf("%lld",&a[i]);
	sum[0]=1;
	for(int i = 1;i<= n;i++)sum[i]=sum[i-1]*a[i]%mod;
	build(1,1,n);
	while(T--)
	{
		int pos;ll x;
		scanf("%d%lld",&pos,&x);
		Update(1,1,n,pos,n,inv[a[pos]]*x%mod);
		a[pos] = x;
		printf("%lld\n",tr[1]);
	}
	return 0;
}
Problem4598

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef unsigned long long ull;
typedef long long ll;
const int sed = 37;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int size[N],f[N],sum,maxd,root,n,m;
bool used[N];
void get_root(int x,int fa,int dep)
{
	maxd = max(maxd,dep);
	size[x] = 1,f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
		{
			get_root(e[i].to,x,dep+1);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}
int cntz[N],cntd[N],tcz[N],tcd[N],mod[N],val[N];
ull hz[N],hd[N];
void dfs(int x,int fa,ull hash,int dep)
{
	hash = hash*sed+val[x];
	if(hash==hz[dep])cntz[mod[dep]]++;
	if(hash==hd[dep])cntd[mod[dep]]++;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa&&!used[e[i].to])
			dfs(e[i].to,x,hash,dep+1);
}
ll ans;
void work(int x)
{
	root = 0;
	sum = size[x];
	maxd = 0;
	get_root(x,0,1);
	if(sum<m||2*maxd<m)return ;
	x = root;
	used[x] = true;
	memset(tcz,0,sizeof(int)*(m+1));
	memset(tcd,0,sizeof(int)*(m+1));
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
		{
			memset(cntz,0,sizeof(int)*(m+1));
			memset(cntd,0,sizeof(int)*(m+1));
			dfs(e[i].to,x,val[x],2);
			cntz[m] = cntz[0],cntd[m] = cntd[0];
			cntz[m+1] = cntz[1],cntd[m+1] = cntd[1];
			ans+=cntz[0]+cntd[0];
			for(int x = 0;x<m;x++)
			{
				ans+=(ll)cntz[m-x+1]*tcd[x];
				ans+=(ll)cntd[m-x+1]*tcz[x];
			}
			for(int x = 0;x<m;x++)
				tcz[x]+=cntz[x],tcd[x]+=cntd[x];
		}
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
			work(e[i].to);
}
char P[N],s[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		tot = 0;
		memset(head,0,sizeof(head));
		ans = 0;
		memset(used,0,sizeof(used));
		scanf("%d%d",&n,&m);
		scanf("%s",s+1);
		for(int i = 1;i<= n;i++)
			val[i] = s[i]-'A'+1;
		int x,y;
		for(int i = 1;i< n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
		}
		scanf("%s",P+1);
		ull pp = 1;
		for(int i = 1,j = 1,k = m;i<= n;i++,pp = pp*sed)
		{
			mod[i] = i%m;
			hz[i] = (P[j]-'A'+1)*pp+hz[i-1];
			hd[i] = (P[k]-'A'+1)*pp+hd[i-1];
			j++;if(j==m+1)j=1;
			k--;if(k==0)k=m;
		}
		f[0] = size[1] = n;
		if(m>1)work(1);
		else 
		{
			for(int i = 1;i<= n;i++)ans+=(val[i]==P[1]-'A'+1);
		}
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4600

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 505;
bool vis[N];
int sg[25][25];
void init(int n,int maxQ)
{
	int tmp,x = 0,y = 0;
	tmp = n;while(tmp>=2)x++,tmp/=2;
	tmp = n;while(tmp>=3)y++,tmp/=3;
	for(int i = 0;i<= x;i++)
		for(int j = 0;j<= y;j++)
		{
			memset(vis,0,sizeof(vis));
			for(int p = 1;p<= i;p++)
				for(int q = 1;q*p<=i&&q<=maxQ;q++)
				{
					tmp = -1;
					for(int k = 1;k<= q;k++)
						if(tmp==-1)tmp = sg[i-k*p][j];
						else tmp = tmp^sg[i-p*k][j];
					if(tmp!=-1)vis[tmp] = true;
				}
			for(int p = 1;p<= j;p++)
				for(int q = 1;q*p<=j&&q<=maxQ;q++)
				{
					tmp = -1;
					for(int k = 1;k<= q;k++)
						if(tmp==-1)tmp = sg[i][j-p*k];
						else tmp = tmp^sg[i][j-p*k];
					if(tmp!=-1)vis[tmp] = true;
				}
			for(int k=0;;k++)
				if(!vis[k])
					{sg[i][j] =k;break;}
		}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n,maxQ;
		scanf("%d%d",&n,&maxQ);
		init(n,maxQ);
		int ans = 0;
		int s;
		for(int i = 1;i<= n;i++)
		{
			scanf("%d",&s);
			if(!s)
			{
				int x,y,tmp;
				x = y = 0;
				tmp = i;while(tmp%2==0)x++,tmp/=2;
				tmp = i;while(tmp%3==0)y++,tmp/=3;
				ans = ans^sg[x][y];
			}
		}
		if(!ans)printf("lose\n");
		else printf("win\n");
	}
	return 0;
}
Problem4603

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
const double pi = 3.14159265358979323;
struct Point
{
	double x,y,z;
	Point(){}
	Point(double _x,double _y,double _z):x(_x),y(_y),z(_z){}
	friend Point operator +(const Point &a,const Point &b)
	{
		return Point(a.x+b.x,a.y+b.y,a.z+b.z);
	}
	friend Point operator -(const Point &a,const Point &b)
	{
		return Point(a.x-b.x,a.y-b.y,a.z-b.z);
	}
	friend Point operator *(const Point &a,double b)
	{
		return Point(a.x*b,a.y*b,a.z*b);
	}
	friend Point operator /(const Point &a,double b)
	{
		return Point(a.x/b,a.y/b,a.z/b);
	} 
	friend double operator &(const Point &a,const Point &b)
	{
		return a.x*b.x+a.y*b.y+a.z*b.z;
	}
	friend Point operator |(const Point &a,const Point &b)
	{
		return Point(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);
	}
	friend double getdis(const Point &a)
	{
		return sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
	}
}poi[N],centre;
struct Shape
{
	int num;
	Point vec[N];
}sur[N];
int n,f;
double getV(Point p,Point a,Point b,Point c)
{
	a = a-p,b = b-p,c = c-p;
	double ans = (a|b)&c;
	ans = ans/6.0;
	return fabs(ans);
}
Point getC(const Point &p,const Point &a,const Point &b,const Point &c)
{
	Point C;
	C = p+a+b+c;
	return C/4.0;
}
void getcentre()
{
	double sumv = 0;
	Point t = Point(0,0,0);
	for(int i = 1;i<= f;i++)
	{
		int num = sur[i].num;
		for(int j = 1;j<= num-2;j++)
		{
			double v = getV(centre,sur[i].vec[0],sur[i].vec[j],sur[i].vec[j+1]);
			Point c = getC(centre,sur[i].vec[0],sur[i].vec[j],sur[i].vec[j+1]);
			c = c*v,sumv+=v,t = t+c;
		}
	}
	centre = t/sumv;
}
double getAngle(Point p,Point x,Point y,Point z)
{
	x = x-p,y = y-p,z = z-p;
	x = x/getdis(x),y = y/getdis(x),z = z/getdis(x);
	Point a = x|y,b = x|z;
	double ans = (a&b)/getdis(a)/getdis(b);
	return acos(ans);
}
double getS(const Shape &x,const Point &y)
{
	double ans = -(x.num-2)*pi;
	for(int i = 0;i<x.num;i++)
		ans+=getAngle(y,x.vec[i],x.vec[(i+1)%x.num],x.vec[(i-1+x.num)%x.num]);
	return ans;
}
int main()
{
	int x;
	scanf("%d%d",&n,&f);
	for(int i = 1;i<= n;i++)
		scanf("%lf%lf%lf",&poi[i].x,&poi[i].y,&poi[i].z);
	for(int i = 1;i<= f;i++)
	{
		scanf("%d",&sur[i].num);
		for(int j = 0;j<sur[i].num;j++)
			scanf("%d",&x),sur[i].vec[j]=poi[x];
	}
	centre = Point(0,0,0);
	for(int i = 1;i<= n;i++)
		centre = centre+poi[i];
	centre = centre/(double)n;
	getcentre();
	for(int i = 1;i<= f;i++)
	{
		double ans = getS(sur[i],centre);
		ans /= 4.0*pi;
		printf("%.7lf\n",ans);
	}
	return 0;
}
Problem4605

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const int M = 4e6+5;
const double alpha = 0.81;
const int INF = 1e9+1;
struct P
{
	int mn[2],mx[2],d[2],l,r,sz;
	int& operator[](int x){return d[x];}
	P(int x,int y){l = r = 0;d[0] = x,d[1] = y;}
	P(){l=r=0;}
};
int D,pt[N];
int dcnt,tot;
namespace KD_tree
{
	P t[M];
	bool cmp(int a,int b)
	{
	return t[a][D]<t[b][D];
	}
	void update(int k)
	{
		P &l = t[t[k].l],&r = t[t[k].r];
		for(int i = 0;i<2;i++)
			t[k].mn[i] = t[k].mx[i] = t[k][i];
		for(int i = 0;i<2;i++)
		{
			if(t[k].l)t[k].mn[i] = min(t[k].mn[i],l.mn[i]);t[k].mx[i] = max(t[k].mx[i],l.mx[i]);
			if(t[k].r)t[k].mn[i] = min(t[k].mn[i],r.mn[i]);t[k].mx[i] = max(t[k].mx[i],r.mx[i]);
		}
		t[k].sz = l.sz+r.sz+1;
	}
	int NewPoint(int x,int y)
	{
		++dcnt;
		t[dcnt][0] = x;t[dcnt][1]= y;
		update(dcnt);
		return dcnt;
	}
	bool ned_rebuild(int k)
	{
		return max(t[t[k].l].sz,t[t[k].r].sz)>t[k].sz*alpha;
	}
	int query(int p,int x0,int y0,int x1,int y1)
	{
		if(!p||t[p].mn[0]>x1||t[p].mx[0]<x0||t[p].mn[1]>y1||t[p].mx[1]<y0)return 0;
		if(t[p].mn[0]>=x0&&t[p].mx[0]<=x1&&t[p].mn[1]>=y0&&t[p].mx[1]<=y1)return t[p].sz;
		int ans = 0;
		if(t[p][0]>=x0&&t[p][0]<=x1&&t[p][1]>=y0&&t[p][1]<=y1)ans++;
		return ans+query(t[p].l,x0,y0,x1,y1)+query(t[p].r,x0,y0,x1,y1);
	}
	int tmpx,tmpd,tmpf;
	void Insert(int &x,int now,const P &p)
	{
		if(!x){x = NewPoint(p.d[0],p.d[1]);return ;}
		if(p.d[now]>t[x][now])Insert(t[x].l,now^1,p);
		else Insert(t[x].r,now^1,p);
		update(x);
		if(ned_rebuild(x))tmpx = x,tmpd = now,tmpf = 0;
		else if(tmpx==t[x].l||tmpx==t[x].r)tmpf = x;
	}
	void travel(int &x)
	{
		if(!x)return ;
		pt[++tot] = x;
		travel(t[x].l),travel(t[x].r);
	}
	int build(int l,int r,int now)
	{
		if(l>r)return 0;
		int mid = (l+r)>>1,x;
		D = now;
		nth_element(pt+l,pt+mid,pt+r+1,cmp);
		x = pt[mid];
		t[x].l = build(l,mid-1,now^1);
		t[x].r = build(mid+1,r,now^1);
		update(x);
		return x;
	}
	void Insert(int &x,const P &p)
	{
		tmpx = tmpf = 0;
		Insert(x,0,p);
		if(!tmpx)return ;
		tot = 0,travel(tmpx);
		if(!tmpf){x = build(1,tot,tmpd);return ;}
		if(tmpx == t[tmpf].l)t[tmpf].l=build(1,tot,tmpd);
		else t[tmpf].r=build(1,tot,tmpd);
	}
}
struct Node
{int ls,rs,rt;}ti[M];
int ncnt,root;
void Insert(int &x,const P &p,int pos,int L = 1,int R = INF)
{
	if(!x)x = ++ncnt;
	KD_tree::Insert(ti[x].rt,p);
	if(L==R)return ;
	int mid = (L+R)>>1;
	if(pos<=mid)Insert(ti[x].ls,p,pos,L,mid);
	else Insert(ti[x].rs,p,pos,mid+1,R);
}
int query(int &x,int &x0,int &y0,int &x1,int &y1,int k,int L=1,int R=INF)
{
	if(L==R)return L;
	int rcnt = KD_tree::query(ti[ti[x].rs].rt,x0,y0,x1,y1);
	int mid = (L+R)>>1;
	if(k<=rcnt)return query(ti[x].rs,x0,y0,x1,y1,k,mid+1,R);
	else return query(ti[x].ls,x0,y0,x1,y1,k-rcnt,L,mid);
}
int n,q,ans;
int main()
{
	scanf("%d%d",&n,&q);
	int x0,y0,x1,y1,opt,k,tmp;
	for(int i = 1;i<= q;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&x0,&y0,&k);
			x0 = x0^ans,y0 = y0^ans,k = k^ans;
			P p = P(x0,y0);
			Insert(root,p,k);
		}else
		{
			scanf("%d%d%d%d%d",&x0,&y0,&x1,&y1,&k);
			x0 = x0^ans,y0 = y0^ans,x1 = x1^ans,y1 = y1^ans,k = k^ans;
			tmp = KD_tree::query(ti[root].rt,x0,y0,x1,y1);
			if(tmp<k){printf("NAIVE!ORZzyz.\n");ans = 0;}
			else printf("%d\n",ans = query(root,x0,y0,x1,y1,k));
		}
	}
	return 0;
}
Problem4607

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e6+5;
const int M = 30;
int f[30][1<<13][3];
int cnt[M][M],deg[M],w[M][M],fa[M],d[M],g[M],id[M],n,c,m;
bool vis[M],del[M];
char a[N],b[N];
int getfa(int x)
{
	if(fa[x]==x)return fa[x]=x;
	else return fa[x]=getfa(fa[x]);
}
void Up(int &a,int b){a=a<b?a:b;}
int Cnt(int x)
{
	int cnt = 0;
	while(x)cnt++,x-=x&(-x);
	return cnt;
}
int main()
{
	scanf("%d%d",&n,&c);
	scanf("%s",a);scanf("%s",b);
	for(int i = 0;i<n;i++)
		cnt[a[i]-'a'][b[i]-'a']++,deg[a[i]-'a']++;
	for(int i = 0;i<26;i++)
		for(int j = 0;j<26;j++)
		{
			w[i][j] = deg[i]-cnt[i][j];
			if(i!=j)w[i][j]+=c;
		}
	for(int i = 0;i<26;i++)fa[i]=i,id[i]=-1;
	for(int i = 0;i<26;i++)
	{
		int k = 0;
		for(int j=0;j<26;j++)
			if(w[i][j]<w[i][k])k=j;
		d[g[i]=k]++;
		if(getfa(i)!=getfa(k))fa[fa[i]]=fa[k];
	}
	int ans = 0;
	for(int i = 0;i<26;i++)
		if(!del[getfa(i)])
		{
			del[fa[i]]=vis[i]=true;
			int j;
			for(j = g[i];!vis[j];j=g[j])vis[j]=true;
			if(g[j]==j)continue;id[j]=m;
			for(int k = g[j];k!=j;k=g[k])id[k]=m;
			m++;
		}
	if(!m)
	{
		for(int i = 0;i<26;i++)ans+=w[i][g[i]];
		printf("%d\n",ans);
		return 0;
	}
	int flag = 1;
	for(int i = 0;i<26;i++)
		if(d[i]!=1)flag = 0;
	for(int i = 0;i<= 26;i++)
		for(int S = 0;S < 1<<m;S++)
			for(int j = 0;j<2;j++)
				f[i][S][j]=INF;
	f[0][0][0]=0;
	for(int i = 0;i<26;i++)
		for(int S = 0;S< 1<<m;S++)
			for(int j = 0;j<2;j++)
				if(f[i][S][j]<INF)
				{
					for(int k = 0;k<26;k++)
					{
						int sta = S;
						if(~id[i] && k!=g[i])sta|=1<<id[i];
						if(~id[k] && (k!=g[i] || id[i]!=id[k] ))sta|=1<<id[k];
						Up(f[i+1][sta][j||k!=g[i]],f[i][S][j]+w[i][k]);
					}
				}
	ans = INF;
	for(int S = 0;S<1<<m;S++)
		for(int j = flag;j<2;j++)
			if(f[26][S][j]<INF)
				Up(ans,f[26][S][j]+(m-Cnt(S))*c);
	printf("%d\n",ans);
	return 0;
}
Problem4613

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#define fir first
#define sec second
using namespace std;
typedef long long ll;
typedef pair<ll,int> pil;
const int N = 1e6+5;
const ll INF = 1e18;
priority_queue<pil, vector<pil> , greater<pil> >Q;
struct E
{int next,to,val;}e[N];
int head[N],tot,cnt;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];
	head[x] = tot;e[tot].val = f;
}
int n,m,fa[N],a[N],deg[N],ans[N];
ll dis[N],f[N];
void dfs(int x,int pre)
{
	f[x] = x<=n?0:INF;
	for(int i = head[x];i;i=e[i].next)
	{
		fa[e[i].to] = x;
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to,i);
		if(f[e[i].to]<f[x])f[x] = f[e[i].to];
		deg[x]++;
	}
	f[x]+=e[pre].val;
}
char name[N>>1][15];
bool cmp(int a,int b)
{return dis[a]<dis[b];}
void Push(int x)
{
	if(x==n+1)return ;
	if(--deg[x])return ;
	cnt++;
	Q.push(pil(f[x],x));
}
int main()
{
	int x,d;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",name[i]+1);
		scanf("%d%d",&x,&d);
		add(x+n+1,i,d);
	}
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&d);
		add(x+n+1,i+n+1,d);
	}
	dfs(n+1,0);
	f[n+1] = INF;
	for(int i = 1;i<= n;i++)a[i]=i;
	sort(a+1,a+n+1,cmp);
	cnt = n;
	for(int i = 1;i<= n;i++)Q.push(pil(f[i],i));
	for(int i = 1;i<= n;ans[a[i++]]=cnt)
		while(!Q.empty())
		{
			pil t = Q.top();
			if(t.fir>dis[a[i]])break;
			Q.pop();
			cnt--;
			Push(fa[t.sec]);
		}
	for(int i = 1;i<= n;i++)
		printf("%s %d\n",name[i]+1,ans[i]+1);
	return 0;
}
Problem4617

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2.5e5+5;
struct Point
{
	int x,y;
	Point(){}
	Point(int _x,int _y):x(_x),y(_y){}
	friend Point operator +(const Point &a,const Point &b)
	{return Point(a.x+b.x,a.y+b.y);}
	friend Point operator -(const Point &a,const Point &b)
	{return Point(a.x-b.x,a.y-b.y);}
	friend void operator -=(Point &a,const Point &b)
	{a = a-b;}
	friend ll operator *(const Point &a,const Point &b)
	{return 1ll*a.x*b.y-1ll*a.y*b.x;}
	friend Point operator *(const Point &a,int k)
	{return Point(a.x*k,a.y*k);} 
	friend bool operator ==(const Point &a,const Point &b)
	{return a.x==b.x&&a.y==b.y;}
	friend bool operator !=(const Point &a,const Point &b)
	{return a.x!=b.x||a.y!=b.y;}
}a[N],b[N],c[N<<1];
int cnta,cntb,m,n,cnt,ce;
struct E
{
	Point o;int t;
	E(){}
	E(Point _o,int _t):o(_o),t(_t)
	{
		if(o.x<0)o = o*-1;
	}
}e[N<<1];
inline bool cmp1(const Point &x,const Point &y)
{return x.x==y.x?x.y<y.y:x.x<y.x;}
inline bool cmp2(const E &a,const E &b)
{return a.o*b.o<0ll;}
int get_convexhull(Point *p,int n,Point *q)
{
	int k,m;
	m = 0;
	for(int i = 0;i<n;q[m++]=p[i++])
		while(m>1&&(q[m-1]-q[m-2])*(p[i]-q[m-2])<=0)m--;
	k = m;
	for(int i = n-2;~i;q[m++]=p[i--])
		while(m>k&&(q[m-1]-q[m-2])*(p[i]-q[m-2])<=0)m--;
	return --m;
}
bool P_on_Seg(const Point &p,const Point &a,const Point &b)
{
	return (b-a)*(p-a)==0&&
	1ll*(p.x-a.x)*(p.x-b.x)+1ll*(p.y-a.y)*(p.y-b.y)<=0;
}
int getl(int l,int r,const Point &p)
{
	int ret = l++,mid;
	while(l<=r)
	{
		mid = (l+r)>>1;
		if((c[mid]-p)*(c[(mid-1+n)%n]-c[mid])<=0)l=(ret=mid)+1;
		else r = mid-1;
	}
	return ret;
}
int getr(int l,int r,const Point &p)
{
	int ret = r--,mid;
	while(l<=r)
	{
		mid = (l+r)>>1;
		if((c[mid]-p)*(c[(mid+1)%n]-c[mid])>=0)r=(ret=mid)-1;
		else l = mid+1;
	}
	return ret;
}
void solve(const Point &p)
{
	if(P_on_Seg(p,c[0],c[n-1]))
		{cnt++;return ;}
	int o = 0;
	if(p.x>0)
	{
		int l = 1,r = n-1,mid;
		while(l<=r)
		{
			mid = (l+r)>>1;
			if(c[mid]*p>=0)l=(o=mid)+1;
			else r = mid-1;
		}
	}else if(p.y>0)o = n-1;
	if(p.x>=0&&(p-c[o])*(c[o+1]-p)<0){cnt++;return ;}
	if(p.x>=0&&P_on_Seg(p,c[o],c[o+1])){cnt++;return ;}
	int l,r;
	if(p.x>0)l = getl(0,o,p),r = getr(o,n,p);
	else l = getl(m,n,p),r = getr(0,m,p);
	e[++ce] = E(p-c[l],1);
	e[++ce] = E(p-c[r],-1);
	if(cmp2(e[ce],e[ce-1]))cnt++;
}
int main()
{
	int x,y,opt;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d%d%d",&x,&y,&opt);
		if(opt)a[++cnta] = Point(x,y);
		else b[++cntb] = Point(x,y);
	}
	if(cnta==1)
	{
		printf("1");
		return 0;
	}
	sort(a+1,a+cnta+1,cmp1);
	cnt = cnta;cnta = 0;
	for(int i = 1;i<= cnt;i++)
		if(a[i]!=a[i-1]||i==1)
			a[++cnta]=a[i];
	if(cnta==1)
	{
		for(int i = 1;i<= cntb;i++)
			if(a[1]==b[i])cnt++;
		printf("%d\n",cnt);return 0;
	}
	if(cnta==2)
	{
		for(int i = 1;i<= cntb;i++)
			if(P_on_Seg(b[i],a[1],a[2]))
				cnt++;
		printf("%d\n",cnt);return 0;
	}
	n = get_convexhull(a+1,cnta,c);
	for(int i = 1;i<n;i++)c[i]-=c[0];
	for(int i = 1;i<= cntb;i++)b[i]-=c[0];
	c[0]-=c[0];
	for(int i = 0;i<n;i++)if(c[i].x>=c[m].x)m=i;
	for(int i = 0;i<n;i++)c[i+n]=c[i];
	for(int i = 1;i<= cntb;i++)solve(b[i]);
	sort(e+1,e+ce+1,cmp2);
	int ret=0,mv=0,j;
	for(int i = 1;i<= ce;i=j)
	{
		for(j=i;j<=ce&&e[i].o*e[j].o==0;j++)
			ret+=e[j].t;
		if(ret<mv)mv = ret;
	}
	printf("%d\n",cnt+mv);
	return 0;
}
Problem4619

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
struct E
{
	int pre,nxt;
	E(){}
	E(int _pre,int _nxt):pre(_pre),nxt(_nxt){}
}a[N],b[N];
bool cmp1(const E &x,const E &y)
{return x.pre<y.pre;}
bool cmp2(const E &x,const E &y)
{return x.nxt>y.nxt;}
int main()
{
	int n;
	int cnt1=0,cnt2 = 0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		int pr,nx;
		scanf("%d%d",&pr,&nx);
		if(nx>pr)a[++cnt1] = E(pr,nx);
		else b[++cnt2] = E(pr,nx);
	}
	sort(a+1,a+cnt1+1,cmp1);
	sort(b+1,b+cnt2+1,cmp2);
	long long ans = 0,rem = 0;
	for(int i = 1;i<= cnt1;i++)
	{
		if(rem<1ll*a[i].pre)
		{
			ans+=a[i].pre-rem;
			rem = 0;
		}
		else rem-=a[i].pre;
		rem+=a[i].nxt;
	}
	for(int i = 1;i<= cnt2;i++)
	{
		if(rem<1ll*b[i].pre)
		{
			ans+=b[i].pre-rem;
			rem = 0;
		}
		else rem-=b[i].pre;
		rem+=b[i].nxt;
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4624

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 8e5+5;
const double PI = 3.14159265358979323;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{return cp(a.x+b.x,a.y+b.y);}
	friend cp operator -(const cp &a,const cp &b)
	{return cp(a.x-b.x,a.y-b.y);}
	friend cp operator *(const cp &a,const cp &b)
	{return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
}a[N],b[N],c[N];
const int R = 505;
char s[R][R],s2[R][R];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = (len>>1);(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(2*PI*type/i),sin(2*PI*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp w(1,0),tmp;
			for(int k = 0;k<i>>1;w=w*wn,k++)
			{
				tmp = w*a[j+k+(i>>1)];
				a[j+k+(i>>1)] = a[j+k]-tmp;
				a[j+k] = a[j+k]+tmp;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
int ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i]=a[i]*b[i];
	FFT(c,len,-1);
}
int main()
{
	int row,col,h,w,len,l;
	scanf("%d%d",&row,&col);
	for(int i = 0;i<row;i++)scanf("%s",s[i]);
	for(len=1;len<=row*col*2+2;len<<=1);
	l = row*col-1;
	int cas,Ans;
	scanf("%d",&cas);
	for(int Cas = 1;Cas<=cas;Cas++)
	{
		Ans = 0;
		scanf("%d%d",&h,&w);
		for(int i = 0;i<h;i++)scanf("%s",s2[i]);
		for(int i = 0;i<row;i++)
			for(int j = 0;j<col;j++)a[i*col+j]=cp(s[i][j]=='G'?1:-1,0);
		for(int i = l+1;i<len;i++)a[i]=cp();
		for(int i = 0;i<len;i++)b[i]=cp();
		for(int i = 0;i<h;i++)
			for(int j = 0;j<w;j++)b[l-i*col-j]=cp(s2[i][j]=='G'?1:-1,0);
		for(int i = 0;i<len;i++)c[i]=cp();
		conv(a,b,c,len);
		for(int i = 0;i<len-l;i++)ans[i]=(int)(c[l+i].x+0.5);
		int px=0,py=0,t1=0,t2=0;
		for(int i = 0;i<= row-h;i++)for(int j = 0;j<= col-w;j++)
			if(ans[i*col+j]>Ans){Ans=ans[i*col+j],px=i,py=j;}
		for(int i = 0;i<h;i++)for(int j = 0;j<w;j++)
			if(s[px+i][py+j]==s2[i][j])
			{
				if(s2[i][j]=='G')t1++;else t2++;
			}
		printf("Case #%d: %d %d %d %d\n",Cas,px+1,py+1,t1,t2);
	}
	return 0;
}
Problem4625

#include <stdio.h>
#include <map>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5+5;
const int BASE = 30000;
typedef long long ll;
map<pair<int,int>,int>val,vis;
int ex[N],x[N],y[N],c[N];
int dx[]={0,0,1,-1,1,-1};
int dy[]={1,-1,0,0,1,-1};
struct E
{
	int next,to,f;
}e[N*100];
int head[N],tot=1;
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].f = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].f = 0;
}
queue<int>Q;
int d[N];
bool bfs(int s,int t)
{
	memset(d,-1,sizeof(d));
	Q.push(t);
	d[t] = 0;
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		for(int i = head[x];i;i=e[i].next)
			if(d[e[i].to]==-1&&e[i^1].f)
			{
				d[e[i].to] = d[x]+1;
				Q.push(e[i].to);
			}
	}
	return d[s]!=-1;
}
int get_mxf(int s,int t,int mf)
{
	if(s==t)return mf;
	int last = mf;
	for(int i = head[s];i;i=e[i].next)
	if(d[e[i].to]==d[s]-1&&e[i].f)
	{
		int tof = get_mxf(e[i].to,t,min(e[i].f,last));
		if(tof)
		{
			e[i].f-=tof;
			e[i^1].f+=tof;
			if(!(last-=tof))return mf;
		}
	}
	return mf-last;
}
int dinic(int s,int t)
{
	int ans = 0;
	while(bfs(s,t))
		ans+=get_mxf(s,t,INF);
	return ans;
}
int l[N],r[N];
int main()
{
	int n,z,C,cnt = 0,ans=0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d%d%d",&x[i],&y[i],&z,&C);
		x[i]-=z,y[i]-=z;
		c[i] = (x[i]+y[i])%3==0?C*11:C*10;
		ans+=c[i];
		if(!vis[make_pair(x[i],y[i])])
			vis[make_pair(x[i],y[i])]=i,val[make_pair(x[i],y[i])]=c[i];
		else
			val[make_pair(x[i],y[i])]+=c[i],ex[i]=true;
	}
	int idx = 0;
	for(int i = 1;i<= n;i++)
		l[i]=++idx,r[i]=++idx;
	int S = ++idx,T = ++idx;
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==0)
			add(l[i],r[i],val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==1)
			add(S,r[i],val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i]&&(x[i]+y[i]+BASE)%3==2)
			add(l[i],T,val[make_pair(x[i],y[i])]);
	for(int i = 1;i<= n;i++)
		if(!ex[i])
		{
			for(int j = 0;j<6;j++)
			{
				int xx = x[i]+dx[j],yy = y[i]+dy[j];
				int tmp = vis[make_pair(xx,yy)];
				if(!tmp)continue;
				if ((xx+yy+BASE) % 3 == 0 && (x[i]+y[i]+BASE)%3 == 1) add(r[i],l[tmp],INF);
            	if ((xx+yy+BASE) % 3 == 2 && (x[i]+y[i]+BASE)%3 == 0) add(r[i],l[tmp],INF);

			}
		}
	ans-=dinic(S,T);
	printf("%d.%d\n",ans/10,ans%10);
	return 0;
}
Problem4627

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef long long ll;
int a[N],cnt;
ll sum[N],pos[N];
int c[N];
void update(int x)
{
	for(int i = x;i<N;i+=i&(-i))
		c[i]++;
}
int getans(int x)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))
		ans+=c[i];
	return ans;
}
int getans(int l,int r)
{
	return getans(r)-getans(l-1);
}
int upper(ll x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<=x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
int lower(ll x)
{
	int l = 1,r = cnt+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(pos[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,L,R;
	scanf("%d%d%d",&n,&L,&R);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		sum[i] = sum[i-1]+a[i];
		pos[i] = sum[i];
	}
	sort(pos+1,pos+n+2);
	cnt = 1;
	for(int i = 2;i<= n+1;i++)
		if(pos[i]!=pos[cnt])
			pos[++cnt]=pos[i];
	ll ans = 0;
	update(lower(0));
	for(int i = 1;i<= n;i++)
	{
		ans+=getans(lower(sum[i]-R),upper(sum[i]-L));
		update(lower(sum[i]));
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4628

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int M = N*64;
struct data
{
	int t,i,f;
	data(int _t=0,int _i=0,int _f=0):t(_t),i(_i),f(_f){}
	bool operator <(const data &s)const
	{
		return t<s.t;
	}
}s[N<<1];
int ans[N];
struct Trie
{
	int lazy,s,f;
	int ch[2];
}tr[M];
void Push_down(int p)
{
	int ls = tr[p].ch[0],rs = tr[p].ch[1];
	if(tr[p].lazy)
	{
		if(!tr[ls].f)
		{
			tr[ls].lazy+=tr[p].lazy;
			tr[ls].s+=tr[p].lazy;
		}
		if(!tr[rs].f)
		{
			tr[rs].lazy+=tr[p].lazy;
			tr[rs].s+=tr[p].lazy;
		}
		tr[p].lazy = 0;
	}
}
char opt[N][10],str[N][35];
char ip[N][35];
int l[N],r[N],top=1;
void Update(int now)
{
	int kind = 1;
	if(opt[now][0]=='D')kind = -1;
	int l = strlen(str[now]+1);
	int j = 1;
	for(int i = 1;i<= l;i++)
	{
		if(!tr[j].ch[0])tr[j].ch[0] = ++top;
		if(!tr[j].ch[1])tr[j].ch[1] = ++top;
		Push_down(j);
		j = tr[j].ch[str[now][i]-'0'];
	}
	tr[j].lazy++,tr[j].s++,tr[j].f+=kind;
}
int Getans(int now)
{
	int j = 1;
	for(int i = 1;i<= 32;i++)
	{
		if(!tr[j].ch[0])tr[j].ch[0]=++top;
		if(!tr[j].ch[1])tr[j].ch[1]=++top;
		Push_down(j);
		j = tr[j].ch[ip[now][i]-'0'];
	}
	return tr[j].s;
}
int main()
{
	int n,q;
	scanf("%d%d",&n,&q);
	for(int i = 1;i<= n;i++)
		scanf("%s%s",opt[i],str[i]+1);
	for(int i = 1;i<= q;i++)
	{
		scanf("%s%d%d",ip[i]+1,&l[i],&r[i]);
		s[(i<<1)-1] = data(l[i],i,-1);
		s[i<<1] = data(r[i],i,1);
	}
	sort(s+1,s+q*2+1);
	int j = 1;
	for(int i = 1;i<= 2*q;i++)
	{
		while(j<=s[i].t)
		{
			Update(j);
			j++;
		}
		ans[s[i].i]+=s[i].f*Getans(s[i].i);
	}
	for(int i = 1;i<= q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
Problem4629

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 505;
int ch[N][26];
char s[N];
int a[110],fail[N],last[N],w[N],cnt;
void addnew(int v)
{
	int i = 1,now = 0;
	while(s[i])
	{
		if(!ch[now][s[i]-'a'])ch[now][s[i]-'a'] = ++cnt;
		now = ch[now][s[i]-'a'];
		i++;
	}
	w[now]+=v;
}
int q[N],hd,tl;
void Build_fail()
{
	hd = 1,tl = 0;
	for(int i = 0;i<26;i++)
		if(ch[0][i])q[++tl]=ch[0][i];
	while(hd<=tl)
	{
		int x = q[hd++];
		for(int i = 0;i<26;i++)
		{
			int j = ch[x][i];
			if(!j){ch[x][i]=ch[fail[x]][i];continue;}
			int k = fail[x];
			while(k&&!ch[k][i])k=fail[k];
			fail[j] = ch[k][i];
			w[j]+=w[fail[j]];
			if(w[fail[j]])last[j] = fail[j];
			else last[j]=last[fail[j]];
			q[++tl]=j;
		}
	}
}
int f[N][N][6];
bool used[N][N][6];
int K,m;
void dp(int n,int x,int k)
{
	if(k>K||used[n][x][k])return;
	used[n][x][k]=true;
	f[n][x][k]=w[x];
	if(n==m)return ;
	int maxn = -707185547707185547LL,maxb = 0;
	for(int i = 0;i<26;i++)
	{
		dp(n+1,ch[x][i],k);
		if(k<K)
			dp(n+1,ch[x][i],k+1);
		if(f[n+1][ch[x][i]][k]>maxn)
		{
			maxn = f[n+1][ch[x][i]][k];
			maxb = i;
		}
	}
	maxn = 707185547707185547LL;
	for(int i = 0;i<26;i++)
	{
		if(i==maxb)maxn = min(maxn,f[n+1][ch[x][i]][k]);
		else if(k<K)maxn = min(maxn,f[n+1][ch[x][i]][k+1]);
	}
	f[n][x][k]+=maxn;
}
ll di[205][205],tmp[205][205],ret[205][205];
ll ans;
void solve1(int M,bool chu)
{
	ans = 0;
	if(chu)
	{
		memset(di,0xef,sizeof(di));
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<26;j++)
				di[i][ch[i][j]]=w[ch[i][j]];
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
				ret[i][j]=di[i][j];
		M--;
		while(M)
		{
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					tmp[i][j]=-707185547707185547LL;
			if(M&1)
			{
				for(int i = 0;i<= cnt;i++)
					for(int k = 0;k<= cnt;k++)
						for(int j = 0;j<= cnt;j++)
							tmp[i][j]=max(tmp[i][j],ret[i][k]+di[k][j]);
				for(int i = 0;i<= cnt;i++)
					for(int j = 0;j<= cnt;j++)
						ret[i][j]=tmp[i][j];
			}
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					tmp[i][j]=-707185547707185547LL;
			for(int i = 0;i<= cnt;i++)
				for(int k = 0;k<= cnt;k++)
					for(int j = 0;j<= cnt;j++)
						tmp[i][j]=max(tmp[i][j],di[i][k]+di[k][j]);
			for(int i = 0;i<= cnt;i++)
				for(int j = 0;j<= cnt;j++)
					di[i][j]=tmp[i][j];
			M>>=1;
		}
		memset(di,0xef,sizeof(di));
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<26;j++)
				di[i][ch[i][j]]=w[ch[i][j]];
	}
	else
	{
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
			{
				tmp[i][j]=-707185547707185547LL;
				for(int k = 0;k<= cnt;k++)
					tmp[i][j]=max(tmp[i][j],ret[i][k]+di[k][j]);
			}
		for(int i = 0;i<= cnt;i++)
			for(int j = 0;j<= cnt;j++)
				ret[i][j]=tmp[i][j];
	}
	for(int i = 0;i<= cnt;i++)
		ans = max(ans,ret[0][i]);
}
void solve2()
{
	int M = m;
	int P = M-300;
	ll res = 0;
	int st;
	for(;P<=M-250;P++)
	{
		for(int i = 0;i<= 300;i++)
			for(int j = 0;j<= cnt;j++)
				for(int k = 0;k<= K;k++)
					used[i][j][k]=false;
		m = M-P;
		dp(0,0,0);
		solve1(P,(P==M-300));
		res = max(res,f[0][0][0]+ans);
	}
	printf("%lld\n",res+1);
}
int main()
{
	int n;
	scanf("%d%d%d",&n,&m,&K);
	for(int i = 1;i<= n;i++)
	{
		scanf("%s%d",s+1,&a[i]);
		addnew(a[i]);
	}
	Build_fail();
	if(m>500&&K==0&&cnt<=200){solve1(m,true);printf("%lld\n",ans);}
	else if(m>500&&K!=0&&cnt<=51){solve2();}
	else
	{
		dp(0,0,0);
		printf("%d\n",f[0][0][0]);
	}
	return 0;
}
Problem4631

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int pre[N],nxt[N];
struct C
{int l,r,i;}cld[N];
bool operator <(const C &a,const C &b)
{return a.r<b.r;}
int tr[N<<2],a[N],c[N],n,m;
inline int Push_up(int x,int y)
{
	return cld[x].l>cld[y].l?x:y;
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p] = l;
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);build(p<<1|1,mid+1,r);
	tr[p] = Push_up(tr[p<<1],tr[p<<1|1]);
}
void update(int p,int l,int r,int pos)
{
	if(l==r){tr[p]=0;return ;}
	int mid = (l+r)>>1;
	if(pos<=mid)update(p<<1,l,mid,pos);
	else update(p<<1|1,mid+1,r,pos);
	tr[p] = Push_up(tr[p<<1],tr[p<<1|1]);
}
int getans(int p,int l,int r,int d)
{
	if(r<=d)return tr[p];
	int mid = (l+r)>>1,t = getans(p<<1,l,mid,d);
	if(d>mid)t = Push_up(t,getans(p<<1|1,mid+1,r,d));
	return t;
}
int ans = 0;
void Delete(int x)
{
	a[x]--;if(a[x])return ;
	int l = pre[x],r = nxt[x];
	pre[r] = l,nxt[l] = r;r = c[r-1];
	if(!r)return ;
	while(true)
	{
		int t = getans(1,1,m,r);
		if(cld[t].l<=l)return ;
		ans++;update(1,1,m,t);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),pre[i]=i-1,nxt[i]=i+1;
	int lastans = 0;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&cld[i].l,&cld[i].r);
		cld[i].i=i;
	}
	sort(cld+1,cld+m+1);
	for(int i = 1;i<= m;i++)
		if(cld[i].r!=cld[i-1].r)
			for(int j = cld[i-1].r;j<cld[i].r;j++)c[j] = i-1;
	for(int i = cld[m].r;i<= n;i++)c[i]=m;
	build(1,1,m);
	int Q,x;
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%d",&x);x = (x+ans-1)%n+1;
		Delete(x);printf("%d\n",ans);
	}
	return 0;
}
Problem4641

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
int a[N],b[N],col[N],nxt[N];
int ans[N],tot,j;
inline bool check(int x,int y)
{
	if(b[x]==-1)
	{
		if(y>=x||y==-1)return true;
	}
	return b[x]==y;
}
int main()
{
	int cas,C;
	scanf("%d%d",&cas,&C);
	while(cas--)
	{
		int n,m,x;
		scanf("%d%d",&n,&m);
		memset(col,0,sizeof(col));
		for(int i = 1;i<= n;i++)
		{
			scanf("%d",&x);
			a[i] = i-col[x];
			col[x] = i;
		}
		memset(col,0,sizeof(col));
		for(int i = 1;i<= m;i++)
		{
			scanf("%d",&x);
			if(!col[x])b[i]=-1;
			else b[i]=i-col[x];
			col[x] = i;
		}
		j = tot = 0;
		for(int i = 2;i<= m;i++)
		{
			while(j && !check(j+1,b[i]))j = nxt[j];
			if(check(j+1,b[i]))j++;nxt[i]=j;
		}
		j = 0;
		for(int i = 1;i<= n;i++)
		{
			while(j && !check(j+1,a[i]))j = nxt[j];
			if(check(j+1,a[i]))j++;
			if(j==m)
			{
				ans[++tot] = i-m+1;
				j = nxt[j];
			}
		}
		printf("%d\n",tot);
		for(int i = 1;i<= tot;i++)
			printf("%d ",ans[i]);
		puts("");
	}
	return 0;
}
Problem4650

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int sed = 237;
const int N = 3e4+5;
int u[N],v[N];
char s[N];
int hash[N],pow[N];
void pre()
{
	pow[0]=1;
	for(int i =1;i<N;i++)
		pow[i]=(ll)pow[i-1]*sed%mod;
}
int Hash(int l,int r)
{
	return (hash[r]-(ll)hash[l]*pow[r-l]%mod+mod)%mod;
}
int main()
{
	int cas,p,q,l,r,mid;
	long long ans = 0;
	scanf("%d",&cas);
	pre();
	while(cas--)
	{
		scanf("%s",s+1);int n = strlen(s+1);
		for(int i = 1;i<= n;i++)
			u[i]=v[i]=0,hash[i] = ((ll)hash[i-1]*sed+s[i]-'a')%mod;
		for(int i = 1;2*i<= n;i++)
			for(int j = 1;j+i<= n;j+=i)
			{
				l = 0,r = min(i,j);
				while(l^r)
				{
					mid = (l+r+1)>>1;
					if(Hash(j+i-mid,j+i)==Hash(j-mid,j))l=mid;
					else r = mid-1;
				}
				p = j-l+1;
				l = 0,r = min(i-1,n-j-i);
				while(l^r)
				{
					mid = (l+r+1)>>1;
					if(Hash(j+i,j+i+mid)==Hash(j,j+mid))l=mid;
					else r = mid-1;
				}
				q = j+l+1;
				if(p+i<=q)
				{
					++u[p],--v[q+i];
					--u[q-i+1];++v[p+i*2-1];
				}
			}
		ans = 0;
		for(int i = 1;i<= n;i++)
			u[i]+=u[i-1],v[i]+=v[i-1],ans+=(ll)u[i]*v[i-1];
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4651

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int P = N*25;
const int M = P*4;
const int bas = 2e9;
struct E
{int next,to;}e[M];
struct P
{int x,y,lev;}p[P];
int head[P],tot=1;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
map<ll,int>pos;
int dfn[P],low[P],Dfn,cnt;
bool flag;
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	int son = 0;
	for(int i = head[x];i;i=e[i].next)
		if(p[e[i].to].lev)
		{
			if(!dfn[e[i].to])
			{
				son++;
				tarjan(e[i].to);
				low[x] = min(low[x],low[e[i].to]);
				if(p[x].lev==2)continue;
				if(dfn[x]==1&&son>=2)flag = true;
				if(dfn[x]!=1&&dfn[x]<=low[e[i].to])flag = true;
			}else
				low[x] = min(low[x],dfn[e[i].to]);
		}
}
bool vis[P];int vt;
void dfs(int x)
{
	vis[x] = true;
	if(p[x].lev)vt++;
	for(int i = head[x];i;i=e[i].next)if(!vis[e[i].to])dfs(e[i].to);
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		for(int i = 0;i<= cnt;i++)head[i]=dfn[i]=low[i]=vis[i]=0;tot=1;
		pos.clear();
		int n,m,c,tmp;cnt = 0;
		bool ans0=false;
		ll x,y;
		scanf("%d%d%d",&n,&m,&c);
		for(int i = 1;i<= c;i++)
		{
			scanf("%lld%lld",&x,&y);
			pos[x*bas+y]=i;
			p[i].x = x,p[i].y = y;p[i].lev = 0;
		}
		cnt = c;
		if(1ll*n*m-c<=1){puts("-1");continue;}
   		if(1ll*n*m==2&&!c){puts("-1");continue;}
		for(int i = 1;i<= c;i++)
			for(int nx = max(1,p[i].x-1);nx<=min(n,p[i].x+1);nx++)
				for(int ny = max(1,p[i].y-1);ny<=min(m,p[i].y+1);ny++)
				{
					if(pos[(ll)nx*bas+ny])continue;
					p[++cnt].x = nx,p[cnt].y = ny;p[cnt].lev = 1;
					pos[(ll)nx*bas+ny]=cnt;
				}
		for(int i = 1;i<= c;i++)
			for(int nx = max(1,p[i].x-2);nx<=min(n,p[i].x+2);nx++)
				for(int ny = max(1,p[i].y-2);ny<=min(m,p[i].y+2);ny++)
				{
					if(pos[(ll)nx*bas+ny])continue;
					p[++cnt].x = nx,p[cnt].y = ny;p[cnt].lev = 2;
					pos[(ll)nx*bas+ny]=cnt;
				}
		for(int i = 1;i<= cnt;i++)
		{
			if((tmp=pos[((ll)(p[i].x+1)*bas+p[i].y)]))
				add(i,tmp);
			if((tmp=pos[((ll)p[i].x*bas+p[i].y+1)]))
				add(i,tmp);
		}
		flag = false;
		for(int i = c+1;i<= cnt;i++)
		{
			if(vis[i])continue;
			vt = 0;dfs(i);
			Dfn = 0;tarjan(i);
			if(Dfn!=vt){ans0=true;break;}
		}
		if(ans0){puts("0");continue;}
		if(1ll*n*m-c==2&&Dfn==2){puts("-1");continue;}
    	if(n==1||m==1){puts("1");continue;}
    	if(flag){puts("1");continue;}
    	puts("2");
	}
	return 0;
}
Problem4652

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int mu[N],prime[N/10],cnt,f[2005],g[2005],k,stack[2005],top;
bool vis[N];
int gcd(int a,int b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}
void get_mu()
{
	mu[1] = 1;
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0)break;
			else
				mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i = 1;i<= k;i++)
		f[i] = f[i-1]+(gcd(i,k)==1),g[i]=g[i-1]+(gcd(i,k)==1)*mu[i];
	for(int i = 2;i<= k;i++)if(k%i==0&&mu[i])stack[++top]=i;
	for(int i = 1;i<N;i++)mu[i]+=mu[i-1];
}
map<ll,int>mp,mp2;
inline int calc_mu(int x)
{
	if(x<N)return mu[x];
	if(mp.count(x))mp[x];
	int t = 1;
	for(int i = 2,last;i<= x;i=last+1)
	{
		last = x/(x/i);
		t-=(last-i+1)*calc_mu(x/i);
	}
	return mp[x] = t;
}
inline int calc(int x)
{
	if(x<=k)return g[x];
	if(mp2.count(x))return mp2[x];
	int tmp = calc_mu(x);
	for(int i = 1;i<= top && stack[i]<=x;i++)
	{
		tmp = tmp-(mu[stack[i]]-mu[stack[i]-1])*calc(x/stack[i]);
	}
	return mp2[x] = tmp;
}
inline int F(int x)
{
	return (x/k)*f[k]+f[x%k];
}
int main()
{
	int n,m;
	scanf("%d%d%d",&n,&m,&k);
	get_mu();
	ll ans = 0;
	for(int i = 1,last;i<=min(n,m);i=last+1)
	{
		last = min(n/(n/i),m/(m/i));
		ans += (ll)(calc(last) - calc(i-1)) * F(m/i) * (n/i);
	}
	printf("%lld\n",ans);
	return 0;
}
Problem4653

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1000005;
const int M = 200005;
const int INF = (1<<30)+((1<<30)-1);
int maxn[N<<2],lazy[N<<2];
int p[N],tot;
inline int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
struct Q
{
	int l,r,len;
}qu[N>>1];
bool cmp(Q a,Q b)
{
	return a.len<b.len;
}
void push_down(int p,int l,int r)
{
	if(l==r||!lazy[p])return ;
	lazy[p<<1]+=lazy[p];
	lazy[p<<1|1]+=lazy[p];
	maxn[p<<1]+=lazy[p];
	maxn[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void update(int p,int l,int r,int a,int b,int c)
{
	push_down(p,l,r);
	if(l>=a&&r<=b)
	{
		lazy[p]+=c;
		maxn[p]+=c;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)update(p<<1,l,mid,a,b,c);
	if(b>mid) update(p<<1|1,mid+1,r,a,b,c);
	maxn[p] = max(maxn[p<<1],maxn[p<<1|1]);
}
int find(int x)
{
	int l = 1,r = tot+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(p[mid]<x)l = mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)
	{
		qu[i].l = read();
		qu[i].r = read();
		qu[i].len = qu[i].r-qu[i].l+1;
		p[++tot] = qu[i].l;p[++tot] = qu[i].r;
	}
	sort(p+1,p+tot+1);
	int tmp = tot;tot = 0;
	for(int i = 1;i<= tmp;i++)
		if(p[i]!=p[tot])
			p[++tot] = p[i];
	for(int i = 1;i<= n;i++)
		qu[i].l = find(qu[i].l),qu[i].r = find(qu[i].r);
	sort(qu+1,qu+n+1,cmp);
	int now = 0;
	int ans = INF;
	for(int i = 1;i<= n;i++)
	{
		while(maxn[1]<m)
		{
			if(now==n)break;
			now++;
			update(1,1,tot,qu[now].l,qu[now].r,1);
		}
		//if(now==n)break;
		if(maxn[1]>=m)ans = min(ans,qu[now].len-qu[i].len);
		update(1,1,tot,qu[i].l,qu[i].r,-1);
	}
	if(ans==INF)printf("-1\n");
	else printf("%d\n",ans);
	return 0;
}
Problem4654

#include <bits/stdc++.h>
using namespace std;
typedef long double ld;
typedef long long ll;
const int N = 8005;
// ---------- decimal lib start ----------
const int PREC=3010;
class Dec{
public:
    Dec();
    Dec(int x);
    bool is_zero() const;
    string to_string(int p) const;
    friend Dec operator + (const Dec &a,const Dec &b);
    friend Dec operator - (const Dec &a,const Dec &b);
    Dec & operator += (int x);
    Dec & operator += (ll x);
    Dec & operator -= (int x);
    Dec & operator /= (int x);
    friend Dec operator - (const Dec &a);
private:
    static const int len=PREC/9+1;
    static const int mo=1000000000;
    static void append_to_string(string &s,ll x);
    bool is_neg;
    ll integer;
    int data[len];
    void init_zero();
    void init(const char *s);
};
Dec::Dec(){init_zero();}
Dec::Dec(int x){
    init_zero();
    if(x<0){is_neg=1;x=-x;}
    integer=x;
}
void Dec::init_zero(){
    is_neg=0;
    integer=0;
    memset(data,0,len*sizeof(int));
}
bool Dec::is_zero()const{
    if(integer)return 0;
    for(int i=0;i<len;i++)if(data[i])return 0;
    return 1;
}
void Dec::init(const char *s){
    init_zero();
    is_neg=0;
    integer=0;
    while(*s!=0){
        if(*s=='-'){is_neg=1;++s;break;}
        else if(*s>=48&&*s<=57)break;
        ++s;
    }
    while(*s>=48&&*s<=57){integer=integer*10+*s-48;++s;}
    if(*s=='.'){
        int pos=0,x=mo/10;
        ++s;
        while(pos<len&&*s>=48&&*s<=57){
            data[pos]+=(*s-48)*x;
            ++s;x/=10;
            if(!x){++pos;x=mo/10;}
        }
    }
}
void Dec::append_to_string(string &s,ll x){
    if(x==0){s.append(1,48);return;}
    char _[30];
    int cnt=0;
    while(x){_[cnt++]=x%10;x/=10;}
    while(cnt--){s.append(1,_[cnt]+48);}
}
string Dec::to_string(int p)const{
    string ret;
    if(is_neg&&!is_zero())ret="-";
    append_to_string(ret,integer);
    ret.append(1,'.');
    for(int i=0;i<len;i++){
        int x=mo/10,tmp=data[i];
        while(x){
            ret.append(1,48+tmp/x);
            tmp%=x;x/=10;
            if(!--p)break;
        }
        if(!p)break;
    }
    if(p>0)ret.append(p,'0');
    return ret;
}
Dec & Dec::operator +=(ll x){
    if(!is_neg){
        if(integer+x>=0){integer+=x;}
        else{
            bool last=0;
            for(int i=len-1;i>=0;i--)
                if(last||data[i]){data[i]=mo-data[i]-last;last=1;}
                else last=0;
            integer=-x-integer-last;
            is_neg=1;
        }
    }else{
        if(integer-x>=0)integer-=x;
        else{
            bool last=0;
            for(int i=len-1;i>=0;i--)
                if(last||data[i]){data[i]=mo-data[i]-last;last=1;}
                else last=0;
            integer=x-integer-last;
            is_neg=0;
        }
    }
    return *this;
}
Dec & Dec::operator +=(int x){return *this+=(ll)x;}
Dec & Dec::operator -=(int x){return *this+=(ll)-x;}
Dec & Dec::operator /=(int x){
    if(x<0){is_neg^=1;x=-x;}
    int last=integer%x;
    integer/=x;
    for(int i=0;i<len;i++){
        ll tmp=1LL*last*mo+data[i];
        data[i]=tmp/x;
        last=tmp-1LL*data[i]*x;
    }
    if(is_neg&&!integer){
        int i;
        for(i=0;i<len;i++)if(data[i]!=0)break;
        if(i==len)is_neg=0;
    }
    return *this;
}
Dec operator -(const Dec &a){
    Dec ret=a;
    if(!ret.is_neg&&!ret.integer){
        int i;
        for(i=0;i<Dec::len;i++)if(!ret.data[i])break;
        if(i<Dec::len)ret.is_neg=1;
    }else ret.is_neg^=1;
    return ret;
}
Dec operator +(const Dec &a,int x){Dec ret=a;return ret+=x;}
Dec operator -(const Dec &a,int x){Dec ret=a;return ret-=x;}
Dec operator /(const Dec &a,int x){Dec ret=a;return ret/=x;}
Dec operator +(const Dec &a,const Dec &b){
    if(a.is_neg==b.is_neg){
        Dec ret=a;
        bool last=0;
        for(int i=Dec::len-1;i>=0;i--){
            ret.data[i]+=b.data[i]+last;
            if(ret.data[i]>=Dec::mo){ret.data[i]-=Dec::mo;last=1;}
            else last=0;
        }
        ret.integer+=b.integer+last;
        return ret;
    }else if(!a.is_neg)return a- -b;
    else return b- -a;
}
Dec operator -(const Dec &a,const Dec &b){return a+-b;}
// ---------- decimal lib end ----------
ld f[15][N],y[N];
int q[N],g[15][N],end[N];
ll h[N];
inline ld slope(int a,int b)
{
	return (y[b]-y[a])/(b-a);
}
int main()
{
	int n,k,p;
	scanf("%d%d%d",&n,&k,&p);
	scanf("%lld",&h[1]);
	for(int i = 2;i<= n;i++)
	{
		scanf("%lld",&h[i]);
		if(h[i]<=h[1])n--,i--;
	}
	sort(h+1,h+n+1);
	for(int i = 2;i<= n;i++)h[i]+=h[i-1];
	for(int i = 1;i<= n;i++)f[0][i] = h[1];
	k = min(k,n-1);int W = min(k,14);
	for(int i = 1;i<= W;i++)
	{
		int l = 1,r = 0;
		for(int j = 2;j<= n;j++)
		{
			y[j-1] = h[j-1]-f[i-1][j-1];
			while(l<r&&slope(q[r-1],q[r])>=slope(q[r],j-1))r--;
			q[++r] = j-1;
			y[j+1] = h[j];
			while(l<r&&slope(q[l],j+1)<=slope(q[l+1],j+1))l++;
			f[i][j] = slope(q[l],j+1);
			g[i][j] = q[l];
		}
	}
	end[W]=n-(k-W);
	for(int i = W;i;i--)end[i-1] = g[i][end[i]];
	Dec ans = Dec(h[1]);
	for(int i = 1;i<= W;i++)ans = (ans+h[end[i]]-h[end[i-1]])/(end[i]-end[i-1]+1);
	for(int i=end[W]+1;i<=n;i++)ans=(ans+h[i]-h[i-1])/2;
    cout<<ans.to_string(p+1);
}
Problem4668

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
int fa[N],h[N],v[N],dep[N],cnt;
int getfa(int x)
{
	if(fa[x] == x) return  x;
	else return getfa(fa[x]);
}
void pre(int x)
{
	if(fa[x]==x)return ;
	pre(fa[x]);
	dep[x] = dep[fa[x]]+1;
}
int Ask(int x,int y)
{
	pre(x),pre(y);
	if(dep[x]<dep[y])swap(x,y);
	int re = 0;
	while(dep[x]>dep[y]&&x!=y)
	{
		re = max(re,v[x]);
		x = fa[x];
	}
	while(x!=y)
	{
		re = max(re,max(v[x],v[y]));
		x = fa[x],y = fa[y];
	}
	return re;
}
int main()
{
	int n,m,lastans = 0;
	int opt,x,y;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)fa[i]=i;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&opt,&x,&y);
		x^=lastans,y^=lastans;
		int fx = getfa(x),fy = getfa(y);
		if(opt==0)
		{
			cnt++;
			if(fx!=fy)
			{
				if(h[fx]<=h[fy])
				{
					fa[fx] = fy;v[fx] = cnt;
					h[fy]+=(h[fx]==h[fy]);
				}else
				{
					fa[fy] = fx;v[fy] = cnt;
				}
			}
		}else
		{
			if(fx!=fy)printf("%d\n",lastans = 0);
			else printf("%d\n",lastans=Ask(x,y));
		}
	}
}
Problem4724

#include <stdio.h>
#include <algorithm>
using namespace std;
const int N = 1e6+5;
typedef long long ll;
int n,q;
ll a[N];
int main()
{
	ll sum = 0;
	scanf("%d%d",&n,&q);
	for(int i = 0;i<n;i++)
	{
		scanf("%lld",&a[i]);
		(sum+=a[i]*i)%=(n-1);
	}
	if(sum)a[sum]--;
	for(int i = 1;i<n;i++)
		a[i]+=a[i-1];
	ll tmp = 0;
	for(int i = 1;i<= q;i++)
	{
		scanf("%lld",&tmp);
		int ans = upper_bound(a,a+n,tmp)-a;
		if(ans==n)ans=-1;
		printf("%d\n",ans);
	}
	return 0;
}
Problem4725

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 10005;
ll a[N],r[N];
ll dec[N];
struct Ans
{
	int j,i;ll val;
	bool operator<(const Ans &s)const
	{
		return val<s.val;
	}
}e[N];
int getans(ll x,int n)
{
	int l = 1,r = n+1;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(e[mid].val<x)l=mid+1;
		else r = mid;
	}
	return l;
}
int main()
{
	int cnt = 0,tot=0;
	a[1] = 1,a[2] = 2;
	dec[++cnt] = 0,dec[++cnt]=1;
	for(int i = 3;;i++)
	{
		if(i&1)a[i] = a[i-1]*2;
		else a[i] = a[i-1]+r[i-1];
		for(int j = i;j;j--)
			dec[++cnt] = a[i]-a[j];
		sort(dec+1,dec+cnt+1);
		cnt = unique(dec+1,dec+cnt+1)-dec-1;
		for(int j = 1;j<=cnt;j++)
			if(dec[j]!=j-1)
				{r[i] = j-1;break;}
		if(!r[i])r[i]=cnt;
		if(a[i]-a[i-1]>10000000000ll){tot=i;break;}
	}
	int tmp = 0;
	for(int i = 1;i<= tot;i++)
		for(int j = 1;j<i;j++)
			e[++tmp] = (Ans){i,j,a[i]-a[j]};
	sort(e+1,e+tmp+1);
	int n;
	ll q;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lld",&q);
		int t = getans(q,tmp);
		if(e[t].val==q)printf("%d %d\n",e[t].j,e[t].i);
		else
		{
			ll ans = q-t+1;
			printf("%lld %lld\n",tot+ans*2-1,tot+ans*2-2);
		}
	}
	return 0;
}
Problem4726

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
const double eps = 1e-7;
struct E
{int next,to;}e[N<<1];
double f[N],ans;
int head[N],tot,n,k;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int size[N];
void get_size(int x)
{
	size[x] = 1;
	bool lef = true;
	for(int i = head[x];i;i=e[i].next)
	{
		lef = false;
		get_size(e[i].to);
		size[x]+=size[e[i].to];
	}
	if(lef)f[x] = 1;
	else
	{
		for(int i = head[x];i;i=e[i].next)
			f[x] = max(f[x],min(1.0*size[e[i].to]/(size[x]-1),f[e[i].to]));
	}
	if(size[x]>k)ans = max(ans,f[x]);
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i = 2;i<=n;i++)
	{
		int x;scanf("%d",&x);
		add(x,i);
	}
	get_size(1);
	printf("%.7lf",ans);
	return 0;
}
Problem4727

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2005;
bool a[N][N],b[N][N],vis[N],bo[N];
int stack[N],top,dfn[N],low[N],nxt[N],Dfn,dcc,bel[N],que[N],size[N],m,p[N],n;
bool ins[N];
void join(int x)
{
	vis[x]=true;
	for(int i = 1;i<= m;i++)if(a[que[i]][x])bo[que[i]]=true;
}
void work()
{
	int head=que[1],tail=que[1];
	int x,y,i,j;
	for(i = 2;i<= m;i++)
	{
		x = que[i];
		if(a[x][head])
		{
			nxt[x] = head;
			head = x;
			continue;
		}
		for(j=head,y=0;y!=tail&&a[j][x];y=j,j=nxt[j]);
		if(y==tail)
		{
			nxt[tail]=x;
			tail = x;
		}else
		{
			nxt[x] = j,nxt[y] = x;
		}
	}
	int mid = head;
	join(head);
	while(mid!=tail)
	{
		x = nxt[mid];
		if(a[x][head])
		{
			mid = x;join(x);
			continue;
		}
		for(i=head;i!=mid && a[i][x];j=i,i=nxt[i]);
		if(i!=mid)
		{
			nxt[j]=x,nxt[mid]=head;
			mid = x,head = i;join(x);
		}else
		{
			for(i = 1;i<= m;i++)if(!vis[que[i]] && bo[que[i]])break;
			for(j=head;j!=mid && a[j][que[i]];j = nxt[j]);
			for(y = nxt[mid];;y=nxt[y])
			{
				join(y);
				if(y==que[i])break;
			}
			nxt[mid] = head;head = j;mid = que[i];
			for(j=head,i=nxt[head];i!=head;j=i,i=nxt[i]);
			nxt[j] = x;
		}
	}
	for(int i = 1;i<= m;i++)bo[que[i]]=vis[que[i]]= false;
	nxt[tail]=head;
}
void tarjan(int x)
{
	dfn[x] = low[x] = ++Dfn;
	stack[++top] = x;
	ins[x] = true;
	for(int i = 1;i<=n;i++)if(a[x][i])
	{
		if(!dfn[i])
		{
			tarjan(i);
			low[x] = min(low[x],low[i]);
		}else if(ins[i])
			low[x] = min(low[x],dfn[i]);
	}
	if(dfn[x]==low[x])
	{
		dcc++;p[dcc]=x;
		int tmp;m=0;
		do
		{
			tmp = stack[top--];
			ins[tmp]=false;
			bel[tmp]=dcc;
			size[dcc]++;que[++m]=tmp;
		}while(tmp!=x);
		work();
	}
}
int f[N],g[N];
int dp(int x)
{
	if(f[x])return f[x];
	int y,z;
	for(y=1;y<=dcc;y++)if(b[x][y])
	{
		z=dp(y);
		if(z>f[x])
		{
			g[x] = y;
			f[x] = z;
		}
	}f[x]+=size[x];
	return f[x];
}
void print(int x)
{
	if(!x)return ;
	int y;printf(" %d",x);
	for(y =nxt[x];y!=x;y=nxt[y])
	{
		printf(" %d",y);
	}
	print(p[g[bel[x]]]);
}
int main()
{
	scanf("%d",&n);
	for(int j = 2;j<=n;j++)
		for(int i = 1;i<j;i++)
		{
			scanf("%d",&a[i][j]);
			a[j][i]=!a[i][j];
		}
	for(int i = 1;i<= n;i++)if(!dfn[i])tarjan(i);
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			if(bel[i]!=bel[j])
				b[bel[i]][bel[j]]|=a[i][j];
	for(int i = 1;i<= dcc;i++)f[i]=dp(i);
	for(int i = 1;i<= n;i++)
	{
		printf("%d",f[bel[i]]);
		print(i);printf("\n");
	}
	return 0;
}
Problem4731

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;  
#define MAXN 1000005  
#define MAXM 1000005  
#define INF 1000000000  
#define MOD 1000000007  
#define eps 1e-8  
#define ll long long  
int n,m;  
int M=1;  
int a[MAXN];  
ll c[MAXN];  
ll len[MAXN];  
int tot;  
int L[MAXN],R[MAXN];  
int ta[MAXN];  
void cal(int l,int r,int d){  
    int i,j;  
    if(!d)
        return ;  
    int t=0;  
    int lst=l;  
    for(i=l;i<=r;i++)
    {  
        t++;  
        if(t==len[d-1]||i==r)
        {  
            cal(lst,i,d-1);  
            lst=i+1;  
            t=0;  
        }  
    }  
    t=0;  
    lst=l;  
    tot=0;  
    for(i=l;i<=r;i++)
    {  
        t++;  
        if(t==len[d-1]||i==r)
        {  
            tot++;  
            L[tot]=lst;  
            R[tot]=i;  
            lst=i+1;  
            t=0;  
        }  
    }  
    for(i=tot;i>1;i--)
    {  
        for(j=L[i];j<=R[i];j++)
        {  
            c[j]-=c[j-len[d-1]];  
        }  
    }  
}  
int main()
{  
    int i;  
    scanf("%d",&n);  
    for(i=1;i<=n;i++)
    {  
        scanf("%d",&a[i]);  
    }  
    int tn=0;  
    for(i=1;i<=n;i++)
    {  
        if(a[i]!=1)
        {  
            ta[++tn]=a[i];  
        }  
    }  
    scanf("%d",&m);  
    ta[tn+1]=m;  
    for(i=1;i<=m;i++)
    {  
        scanf("%lld",&c[i]);  
    }  
    len[0]=1;  
    for(i=1;i<=tn+1;i++)
    {  
        len[i]=len[i-1]*ta[i];  
        if(len[i]>=m)
        {  
            cal(1,m,i);  
            break;  
        }  
    }  
    printf("%d\n",n);  
    for(i=1;i<=n;i++)
    {  
        printf(i==n?"%d\n":"%d ",a[i]);  
    }  
    printf("%d\n",m);  
    for(i=1;i<=m;i++)
    {  
        printf(i==m?"%lld\n":"%lld ",c[i]);  
    }  
    return 0;  
}  
Problem4753

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2505;
const double eps = 1e-8;
const double INF = 1e9;
struct E
{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
double dp[N][N],ans,p[N],s[N],size[N],g[N];
int K;
void dfs(int x)
{
	size[x] = 0;
	dp[x][0] = 0;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		for(int j = 0;j<= size[x]+size[e[i].to];j++)g[j] = -INF;
		for(int j = 0;j<= size[x];j++)
			for(int k = 0;k<= size[e[i].to];k++)
				g[j+k] = max(g[j+k],dp[x][j]+dp[e[i].to][k]);
		for(int j = 0;j<= size[x]+size[e[i].to];j++)dp[x][j] = max(dp[x][j],g[j]);
		size[x]+=size[e[i].to];
	}
	for(int j = size[x];j>= 0;j--)
		dp[x][j+1]=dp[x][j]+p[x]-s[x]*ans;
	dp[x][0] = 0;
	size[x]++;
}
int main()
{
	int n,fa;
	scanf("%d%d",&K,&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%lf%lf%d",&s[i],&p[i],&fa);
		add(fa,i);
	}
	double l = 0,r = 10001;
	while(fabs(l-r)>0.0001)
	{
		double mid = (l+r)/2;
		ans = mid;
		for(int i = 0;i<= n;i++)
			for(int j = 0;j<=n;j++)dp[i][j]=-INF;
		dfs(0);
		if(dp[0][K+1]>0)l=mid;
		else r = mid;
	}
	printf("%.3lf\n",l);
	return 0;
}
Problem4755

#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 1e5+5;
const int mod1 = 130117;
const int mod2 = 600011;
const int seed = 37;
int a[N<<1], b[N<<1], sum[N<<1][2], num[N<<1][2], mi[N<<1][2], F[N<<1], G[N<<1];
int n, m, ans, l, r;
bool judge(int l1,int r1,int l2,int r2) 
{
    int x,y;
    int mod = mod1;
    x = (LL)(sum[r1][0]-(LL)sum[l1-1][0]*mi[r1-l1+1][0]%mod)%mod;
    y = (LL)(num[l2][0]-(LL)num[r2+1][0]*mi[r2-l2+1][0]%mod)%mod;
    (x+=mod)%=mod, (y+=mod)%=mod;
    if(x!=y) return 0;
    mod = mod2;
    x = (LL)(sum[r1][1]-(LL)sum[l1-1][1]*mi[r1-l1+1][1]%mod)%mod;
    y = (LL)(num[l2][1]-(LL)num[r2+1][1]*mi[r2-l2+1][1]%mod)%mod;
    (x+=mod)%=mod, (y+=mod)%=mod;
    if(x!=y) return 0;
    return 1;
}
inline int solve(int j,int k) 
{
    int l = 0, r = min( j, n-k+1);
    while(l < r) 
    {
        int mid = (l+r+1)>>1;
        if(judge(j-mid+1,j,k,k+mid-1)) l = mid;
        else r = mid - 1;
    }
    return l;
}
char s[N];
int main() 
{
    scanf("%d",&n);
    mi[0][0] = mi[0][1] = 1;
    for(int i=1;i<=n;++i) 
    {
        mi[i][0] = (LL)mi[i-1][0]*seed%mod1;
        mi[i][1] = (LL)mi[i-1][1]*seed%mod2;
    }
    a[0] = b[0] = 0; 
    a[2*n+2] = b[2*n+2] = 28;
    a[1] = b[1] = 27;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i) 
        a[i<<1] = s[i] - 'A' + 1,a[i<<1|1] = 27;
    scanf("%s",s+1);
    for(int i=1;i<=n;++i) 
        b[i<<1] = s[i] - 'A' + 1,b[i<<1|1] = 27;
    int j = 0;
    for(int i=2;i<=(n<<1);++i) 
    {
        if(i <= F[j]+j) F[i] = min(F[2*j-i],j+F[j]-i);
        while(a[i-F[i]-1] == a[i+F[i]+1]) F[i] ++;
        if(i+F[i]>j+F[j]) j = i;
    }
    j = 0;
    for(int i=2;i<=(n<<1);++i) 
    {
        if(i <= j+G[j]) G[i] = min(G[2*j-i],j+G[j]-i);
        while(b[i-G[i]-1] == b[i+G[i]+1]) G[i] ++;
        if(i+G[i]>j+G[j]) j = i;
    }
    for(int i=2;i<=(n<<1);++i) ans = max(ans,max(F[i],G[i]));
    for(int i=1;i<=n;++i) 
    {
        sum[i][0] = (LL)((LL)sum[i-1][0]*seed%mod1+a[i<<1])%mod1;
        sum[i][1] = (LL)((LL)sum[i-1][1]*seed%mod2+a[i<<1])%mod2;
    }
    for(int i=n;i>=1;--i) 
    {
        num[i][0] = (LL)((LL)num[i+1][0]*seed%mod1+b[i<<1])%mod1;
        num[i][1] = (LL)((LL)num[i+1][1]*seed%mod2+b[i<<1])%mod2;
    }
    for(int i=2;i<=(n<<1);++i) 
    {
        l = i - F[i], r = i + F[i];
        l = (l+1) >> 1; r >>= 1;
        ans = max(ans,F[i]+solve(l-1,r)*2);
    }
    for(int i=2;i<=(n<<1);++i) 
    {
        l = i - G[i], r = i + G[i];
        l = (l+1) >> 1, r >>= 1;
        ans = max(ans,G[i]+solve(l,r+1)*2);
    }
    printf("%d\n",ans);
}
Problem4762

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 1e9+7;
const int S = 1<<10;
struct data
{
	int f;
	void operator +=(const data &s)
	{
		f = f+s.f>=mod?f+s.f-mod:f+s.f;
	}
	void operator -=(const data &s)
	{
		f = f-s.f>=0?f-s.f:f-s.f+mod;
	}
}f[2][S][S];
int a[S];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]),a[i] = (S-1)^a[i];
	int now = 1,pre = 0,i,j,k;
	f[0][0][0].f=1;
	for(i = 1;i<= n;i++)
	{
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[now][j][k].f = 0;
				if(!k)break;
			}
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[now][j|a[i]][k^(k&a[i])]+=f[pre][j][k];
				f[now][j|a[i]][k^(k&a[i])|a[i]^(a[i]&j)]-=f[pre][j][k];
				if(!k)break;
			}
		for(j = 0;j<S;j++)
			for(k = j;;k = (k-1)&j)
			{
				f[pre][j][k] += f[now][j][k];
				if(!k)break;
			}
		//swap(now,pre);
	}
	printf("%d\n",f[pre][S-1][0].f);
	return 0;
}
Problem4763

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int MD = 320;
const int S = 65540;
const int ss = 65535;
int cnt[S];
typedef unsigned long long ull;
ull MAXN = 0;
struct Bitset
{
	ull s[470];
	int len;
	void clear()
	{memset(s,0,sizeof(s));len = 0;}
	void operator |=(const int &x){s[x>>6] |= 1ll<<(x&63);len = max(len,x>>6);}
	void operator |=(const Bitset &y)
	{
		len = max(len,y.len);
		for(int i = 0;i<=len;i++)
			s[i]|=y.s[i];
	}
	int num()
	{
		int res = 0;
		for(int i = 0;i<=len;i++)
			res+=cnt[s[i]>>48]+cnt[(s[i]>>32)&ss]+cnt[(s[i]>>16)&ss]+cnt[s[i]&ss];
		return res;
	}
	int getans()
	{
		for(int i = 0;i<470;i++)if(s[i]!=MAXN)
			for(int j = 0;j<64;j++)
				if(!(s[i]&((ull)1<<j)))
					return i*64+j;
	}
}b[325][325],ans;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int mark[N],rtnum,rt[N],n,m,flag;
int size[N],dep[N],mx[N],top[N],fa[N][18],w[N];
void dfs(int x)
{
	mx[x] = dep[x];
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			dep[e[i].to] = dep[x]+1;
			fa[e[i].to][0] = x;
			dfs(e[i].to);
			mx[x] = max(mx[x],mx[e[i].to]);
		}
	if(mx[x]-dep[x]>=MD||x==1)
	{
		mark[x] = ++rtnum;
		rt[rtnum] = x;
		mx[x] = 0;
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])
			x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}

int main()
{
	int x,y;
	scanf("%d%d%d",&n,&m,&flag);
	for(int i = 0;i<64;i++)MAXN = MAXN<<1|1;
	for(int i = 0;i<S;i++)
		for(int j = i;j;j-=j&(-j))
			cnt[i]++;
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dep[1] = 1;
	dfs(1);
	for(int j = 1;j<= 17;j++)
		for(int i = 1;i<= n;i++)
			fa[i][j] = fa[fa[i][j-1]][j-1];
	for(int i = 1;i<= rtnum;i++)
	{
		Bitset now;
		now.clear();
		now|=w[rt[i]];b[i][i] = now;
		for(int t = fa[rt[i]][0];t;t=fa[t][0])
		{
			now|=w[t];
			if(mark[t])
			{
				b[i][mark[t]] = now;
				if(!top[rt[i]])top[rt[i]] = t;
			}
		}
	}
	int nn,last = 0;
    for(int i=1;i<=m;++i)
    {
        ans.clear();scanf("%d",&nn);
        for(int j=1;j<=nn;++j)
        {
        	scanf("%d%d",&x,&y);
            int xx,yy;
            if(flag) x^=last,y^=last;
            int z=lca(x,y);ans|=w[x];ans|=w[y];
            for(;!mark[x]&&dep[x]>dep[z];)
                x=fa[x][0],ans|=w[x];
            for(;!mark[y]&&dep[y]>dep[z];)
                y=fa[y][0],ans|=w[y];
            for(xx=x;dep[top[xx]]>=dep[z];xx=top[xx]);
            for(yy=y;dep[top[yy]]>=dep[z];yy=top[yy]);
            ans|=b[mark[x]][mark[xx]];
            ans|=b[mark[y]][mark[yy]];
            for(;xx!=yy;)
            {
                if(dep[xx]<dep[yy]) swap(xx,yy);
                xx=fa[xx][0];ans|=w[xx];
            }
        }
        int x=ans.num(),y=ans.getans();
        last=x+y;
        printf("%d %d\n",x,y);
    }
	return 0;
}
Problem4770

#include<cstdio>
#include<algorithm>
using namespace std;
#define MAXN 1010
#define MAXM 1010
typedef long long ll;
ll biao[MAXN][MAXN]={{},{0,0,0,0,0,0,0,0,0,},{0,129140164,129140165,129140167,129140171,129140179,129140195,129140227,129140291,},{0,193710246,64570084,24213786,236084373,77181450,157515737,140774228,215031499,},{0,225995287,121068906,238102183,203547108,218712265,116264831,99443036,79121964,},{0,112997644,108962016,46788094,36549268,117877184,14509798,100438248,107231500,},{0,185638986,53976556,134689163,96426552,194242540,153639990,120659378,101104631,},{0,221959657,227256424,124881873,171543395,157647025,162557411,23785165,258144187,},{0,110979829,87995657,38609442,206828800,253024756,206227824,141710270,10320181,},{0,55489915,109955160,56272067,231265411,63090854,237048705,171426005,85709662,},{0,27744958,238738659,7008635,102222843,120595225,256801988,235521295,180619543,},{0,143012643,24411822,194556475,215231251,130161896,73648531,208001599,170619964,},{0,71506322,157216049,153352677,156238751,192264872,27770309,226347497,54161031,},{0,164893325,184923874,246796406,52697789,171780083,21983921,223228206,185664220,},{0,82446663,171588386,198224372,24087433,169856546,85584783,15039313,51032118,},{0,41223332,233770283,237290397,226108046,172324917,242546032,177098806,40173324,},{0,149751830,40172257,206855876,234897786,42845559,190284536,34527590,26337201,},{0,204016079,44767891,130125758,198580206,248091586,33588797,142939578,109276637,},{0,102008040,53378114,117153053,140321556,207663118,231585645,18039713,42557731,},{0,180144184,222551860,141542926,124678758,256378666,58621640,169814611,164503795,},{0,219212256,51118260,22017057,107400239,71063488,208194809,141040710,82368253,},{0,238746292,9389787,73404282,197290983,187666354,33421568,243481387,230191654,},{0,248513310,258085441,206092103,175865014,46934405,238338656,34885039,160507772,},{0,253396819,46472091,52427070,10622380,31557757,78236842,121818911,78588165,},{0,126698410,14223592,100655489,4793966,28513326,106020021,130112147,61905360,},{0,192489369,53937637,55392462,243667232,206236595,2350355,2101084,238304638,},{0,96244685,115840796,252931583,12885294,108834416,142226001,41501066,77317254,},{0,48122343,186440092,145791627,175931570,191171533,54681626,171376190,8284899,},{0,24061172,35579780,244199696,219925978,194916377,159910040,18680912,56283054,},{0,141170750,129762427,191545910,85767863,96762108,75032252,68489928,100763661,},{0,199725539,123091219,123096044,64432902,33418232,219199667,205120656,160043295,},{0,99862770,147188326,236754524,80629277,18247771,18374728,15226623,146765106,},{0,179071549,43396121,1036568,86131407,196354204,129359671,55657413,95474816,},{0,89535775,177223515,164355065,176671379,141757722,64001077,97905256,148393376,},{0,44767888,56089100,9744293,28759687,254183618,187978963,48484166,10384133,},{0,151524108,71287253,195783672,235105036,63372602,48706668,248893454,173302144,},{0,204902218,189910711,57376262,237466820,231810127,127325080,116537614,29856382,},{0,231591273,257256954,207490218,200639665,46244374,29857601,109793313,58979680,},{0,115795637,205506176,45896798,234868496,29541064,251294633,256749187,63816439,},{0,57897819,124985457,245728025,115443775,144062289,195058805,171514012,53312683,},{0,28948910,21882968,223817069,76823424,21491759,227107331,131344269,97420818,},{0,143614619,14590716,250142242,217871110,158025913,120380172,59940904,105696964,},{0,71807310,75057742,38795205,80612780,246470934,120257251,3687048,158432457,},{0,165043819,201462147,168744597,172739460,61176618,38568071,97892751,11175058,},{0,82521910,219673862,27383363,66850809,196775038,6183180,92038631,31326683,},{0,170401119,101187108,75392768,51235977,45924565,86039077,51855151,254177214,},{0,85200560,221423464,251701329,91563073,211230946,180879303,101994951,244856176,},{0,171740444,202450882,103638399,9527704,148889553,41207463,141727928,145038853,},{0,215010386,225504065,114480260,68277350,11820640,1248372,121446262,9716295,},{0,236645357,26119321,236275454,147928086,206426334,162743844,101312146,105149937,},{0,118322679,258260157,59715480,13946009,169602037,225439100,30268418,150919282,},};
int n,m;
int main(){
    scanf("%d%d",&n,&m);
    printf("%lld\n",biao[n][m]);
}
Problem4771

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
set<int>S[N];
set<int>::iterator it;
int fa[N][18],dep[N],col[N],in[N],out[N],Dfn,seq[N],a[N];
struct E
{int next,to;}e[N];
int head[N],tot,mx;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
void dfs(int x)
{
	dep[x] = dep[fa[x][0]]+1;
	mx = max(mx,dep[x]);
	in[x] = ++Dfn;seq[Dfn] = x;
	for(int i = 1;i<= 17;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to);
	out[x] = Dfn;
}
int lca(int x,int y)
{
	if(dep[y]>dep[x])swap(x,y);
	for(int i = 17;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y])x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>= 0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int tr[N*100],ls[N*100],rs[N*100],cnt,root[N],n,m;
void update(int &p,int pre,int l,int r,int pos,int val)
{
	p = ++cnt;
	ls[p] = ls[pre],rs[p] = rs[pre];
	tr[p] = tr[pre]+val;
	if(l==r)return ;
	int mid = (l+r)>>1;
	if(pos<=mid)update(ls[p],ls[pre],l,mid,pos,val);
	else update(rs[p],rs[pre],mid+1,r,pos,val);
}
int getans(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return tr[p];
	int mid = (l+r)>>1,ans = 0;
	if(a<=mid)ans+=getans(ls[p],l,mid,a,b);
	if(b >mid)ans+=getans(rs[p],mid+1,r,a,b);
	return ans;
}
void init()
{
	for(int i = 1;i<= cnt;i++)tr[i]=ls[i]=rs[i]=0;
	cnt = 0;
	Dfn = 0;tot = 0;
	for(int i = 1;i<= n;i++)head[i]=0,root[i]=0;
	for(int i = 1;i<= n;i++)S[i].clear();
	mx = 0;
}
bool cmp(int x,int y)
{
	return dep[x]==dep[y]?in[x]<in[y]:dep[x]<dep[y];
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)scanf("%d",&col[i]),a[i]=i;
		for(int i = 2;i<= n;i++)scanf("%d",&fa[i][0]),add(fa[i][0],i);
		dfs(1);
		sort(a+1,a+n+1,cmp);
		int tmp1,tmp2;
		for(int i = 1;i<= n;i++)
		{
			if(dep[a[i]]==dep[a[i-1]])
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[a[i]],1);
			else 
				update(root[dep[a[i]]],root[dep[a[i]]-1],1,n,in[a[i]],1);
			it = S[col[a[i]]].upper_bound(in[a[i]]);
			tmp1 = tmp2 = 0;
			if(it!=S[col[a[i]]].end())
			{
				tmp1 = (*it);
				tmp1 = seq[tmp1];
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp1,a[i])],-1);
			}
			if(it!=S[col[a[i]]].begin())
			{
				it--;
				tmp2 = (*it);
				tmp2 = seq[tmp2];
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp2,a[i])],-1);
			}
			if(tmp1&&tmp2)
				update(root[dep[a[i]]],root[dep[a[i]]],1,n,in[lca(tmp1,tmp2)],1);
			S[col[a[i]]].insert(in[a[i]]);
		}
		int x,d,ans=0;
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&d);
			x = x^ans,d = d^ans;
			ans = getans(root[min(dep[x]+d,mx)],1,n,in[x],out[x]);
			printf("%d\n",ans);
		}
		init();
	}
	return 0;
}
Problem4772

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 2001;
const int mod = 1e9+7;
const int S = 1e7;
int gcd[N][N],pow[N][N],f[N][N],sum[N],b[N];
int g[S+5],tmp[S+5];
bool vis[S+5];
int prime[S/10],cnt,a[100005],n,K,p;
void Pre()
{
	sum[n] = 1;
	for(int i = 1;i<= n;i++)
	{
		for(int j = 1;j<= n;j++)
		{
			if(i==1||j==1)f[i][j] = 1;
			else if(i==j)f[i][j] = (f[i][j-1]+1)%mod;
			else if(i<j)f[i][j] = f[i][j-1];
			else f[i][j] = (f[i-j][j]+f[i][j-1])%mod;
		}
		sum[n-i]=f[i][i];
	}
	g[0] = 0,g[1] = 1;
	for(int i = 2;i<= S;i++)
	{
		if(!vis[i])
		{
			prime[++cnt]=tmp[i]=i;
			g[i] = 2*i-2;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<=S;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
			{
				tmp[i*prime[j]] = prime[j];
				g[i*prime[j]] = (ll)g[i]*g[prime[j]]%mod; 
			}else
			{
				tmp[i*prime[j]] = tmp[i]*prime[j];
				if(tmp[i]!=i)g[i*prime[j]] = (ll)g[i/tmp[i]]*g[tmp[i]*prime[j]]%mod;
				else g[i*prime[j]] = ((ll)g[i]*prime[j]+i*(prime[j]-1))%mod;
				break;
			}
		}
	}
	for(int i = 1;i<= n;i++)gcd[i][0]=gcd[0][i]=gcd[i][i]=i,gcd[i][1]=gcd[1][i]=1;
	for(int i = 2;i<= n;i++)
		for(int j = 2;j<= i;j++)
		{
			if(!gcd[i][j])gcd[i][j] = gcd[j][i-j];
			gcd[j][i] = gcd[i][j];
		}
	for(int i = 1;i<= n;i++)pow[i][0]=1,pow[i][1] = i;
	for(int i = 1;i<= n;i++)
		for(int j = 2;j<= n;j++)
			pow[i][j] = 1ll*pow[i][j-1]*i%K;
}
int F(int x,int y)
{
	if(p==1)return 1%K;
	if(p==2)return gcd[x][y]%K;
	if(p==3)return (pow[x][y]+pow[y][x]+(x^y))%K;
}
inline void add(int &x,const int &y)
{
	x+=y;
	if(x>=mod)x-=mod;
}
int Cnt[S+5];
int main()
{
	scanf("%d%d%d",&p,&n,&K);
	for(int i = 0;i<K;i++)scanf("%d",&a[i]);
	Pre();
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n-i;j++)
            for(int muli=1;muli*i+j<=n;muli++)
                for(int mulj=1;mulj*j+muli*i<=n;mulj++)
                    add(Cnt[F(i,j)],sum[muli*i+mulj*j]);
	int ans = 0;
    for(int i=0;i<K;i++) ans+=1LL*g[a[i]]*Cnt[i]%mod,ans%=mod;
    for(int i=1;i<=n;i++)
    {
        for(int muli=1;muli*i<=n;muli++)
        {
            int Tmp=1LL*muli*(muli-1)/2*(sum[muli*i]-sum[(muli+1)*i]+mod)%mod;
            add(ans,1LL*g[a[F(i,i)]]*Tmp%mod);
        }
    }
    printf("%d\n",ans);
	return 0;
}
Problem4773

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
struct E
{int next,to,val;}e[N*N];
int head[N],tot;
void add(int x,int y,int f)
{e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;}
int f[2][N][N];
int main()
{
	int n,m,x,y,z;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	memset(f,0x3f,sizeof(f));
	int now = 0,pre = 1;
	for(int i = 1;i<= n;i++)f[pre][i][i]=0;
	for(int ans = 1;ans<= n;ans++)
	{
		memset(f[now],0x3f,sizeof(f[now]));
		for(int st = 1;st<= n;st++)
			for(int pe = 1;pe<= n;pe++)
				for(int i = head[pe];i;i=e[i].next)
					f[now][st][e[i].to] = min(f[now][st][e[i].to],f[pre][st][pe]+e[i].val);
		for(int i = 1;i<= n;i++)
			if(f[now][i][i]<0)
			{
				printf("%d\n",ans);
				return 0;
			}
		swap(now,pre);
	}
	printf("0");
	return 0;
}
Problem4774

#include <stdio.h>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int S = 1<<8;
const int N = 1e4+5;
const int INF = 0x3f3f3f3f;
int dis[S][N];
bool vis[N];
queue<int>Q;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot,ans[S];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;e[tot].val = f;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;e[tot].val = f;
}

void spfa(int dis[])
{
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(dis[e[i].to]>dis[x]+e[i].val)
			{
				dis[e[i].to] = dis[x]+e[i].val;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
}
int n,m,d;
bool check_sta(int s)
{
	bool flag = true;
	for(int i = 1;i<= d;i++)
		flag&= ((s>>(i-1))&1)==((s>>(2*d-i))&1);
	return flag;
}
int main()
{
	int x,y,z;
	scanf("%d%d%d",&n,&m,&d);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	memset(dis,0x3f,sizeof(dis));
	for(int i = 1;i<= d;i++)dis[1<<(i-1)][i] = 0;
	for(int i = 1;i<= d;i++)dis[1<<(2*d-i)][n-i+1] = 0;
	int end = 1<<(2*d);
	for(int s = 0;s<end;s++)
	{
		for(int i = 1;i<= n;i++)
		{
			for(int t = s;t;t=(t-1)&s)
				dis[s][i] = min(dis[s][i],dis[t][i]+dis[s^t][i]);
			if(dis[s][i]!=INF)Q.push(i),vis[i]=true;
		}
		spfa(dis[s]);
	}
	memset(ans,0x3f,sizeof(ans));
	for(int s = 0;s<end;s++)
		if(check_sta(s))
			for(int i = 1;i<= n;i++)
				ans[s] = min(ans[s],dis[s][i]);
	for(int s = 0;s<end;s++)
		for(int t = s;t;t = (t-1)&s)
			ans[s] = min(ans[s],ans[s^t]+ans[t]);
	if(ans[end-1]!=INF)printf("%d\n",ans[end-1]);
	else puts("-1");
	return 0;
}
Problem4775

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#define fir first
#define sec second
using namespace std;

const int N = 1e5+5;
struct E
{int next,to;}e[N<<1];
int head[N],tot,dep[N],fa[N][18];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
void dfs(int x)
{
	dep[x] = dep[fa[x][0]]+1;
	for(int i = 1;i<= 17;i++)fa[x][i]=fa[fa[x][i-1]][i-1];
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x][0])
		{
			fa[e[i].to][0] = x;
			dfs(e[i].to);
		}
}
int getlca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i = 17;i>= 0;i--)
		if(dep[fa[x][i]]>=dep[y])x = fa[x][i];
	if(x==y)return x;
	for(int i = 17;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x = fa[x][i],y = fa[y][i];
	return fa[x][0];
}
int getdis(int x,int y)
{
	return dep[x]+dep[y]-2*dep[getlca(x,y)];
}
bool used[N];
int size[N],f[N],sum,root;
void get_root(int x,int pre)
{
	size[x] = 1;
	f[x] = 0;
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to]&&e[i].to!=pre)
		{
			get_root(e[i].to,x);
			size[x]+=size[e[i].to];
			f[x] = max(f[x],size[e[i].to]);
		}
	f[x] = max(f[x],sum-size[x]);
	if(f[x]<f[root])root = x;
}	
void get_size(int x,int pre)
{
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=pre&&!used[e[i].to])
		{
			get_size(e[i].to,x);
			size[x]+=size[e[i].to];
		}
}
vector<int>E[N];
int father[N];
pair<double,double>A[N];
double w[N],d[N],pw[N],pd[N],A1[N],pA1[N],A2[N],pA2[N],A3[N],pA3[N];
void build(int x,int pre)
{
	get_size(x,0);
	sum = size[x];
	f[root = 0]=sum;
	get_root(x,0);
	x = root;
	father[x] = pre;
	used[x] = true;
	E[pre].push_back(x);
	for(int i = head[x];i;i=e[i].next)
		if(!used[e[i].to])
			build(e[i].to,x);
}
inline void Add(int x)
{
	double y = A[x].fir*(1-A[x].fir);
	w[x]+=A[x].fir,A3[x]+=y;
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		d[father[i]]+=D*A[x].fir;pd[i]+=D*A[x].fir;
		w[father[i]]+=A[x].fir;pw[i]+=A[x].fir;

		A1[father[i]]+=D*D*y;pA1[i]+=D*D*y;
		A2[father[i]]+=D*2*y;pA2[i]+=D*2*y;
		A3[father[i]]+=y;pA3[i]+=y;
	}
}
inline void Del(int x)
{
	double y = A[x].fir*(1-A[x].fir);
	w[x]-=A[x].fir,A3[x]-=y;
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		d[father[i]]-=D*A[x].fir;pd[i]-=D*A[x].fir;
		w[father[i]]-=A[x].fir;pw[i]-=A[x].fir;

		A1[father[i]]-=D*D*y;pA1[i]-=D*D*y;
		A2[father[i]]-=D*2*y;pA2[i]-=D*2*y;
		A3[father[i]]-=y;pA3[i]-=y;
	}
}
inline void update(int x,double p)
{
	double k0 = p/100.0,k1 = (100.0-p)/100.0;
	Del(x);
	A[x] = make_pair(A[x].fir*k1+A[x].sec*k0,A[x].fir*k0+A[x].sec*k1);
	Add(x);
}
inline void getans(int x)
{
	double ans1 = d[x],ans2 = A1[x];
	for(int i = x;father[i];i=father[i])
	{
		double D = getdis(x,father[i]);
		ans1 += d[father[i]]-pd[i]+D*w[father[i]]-D*pw[i];
		ans2 += A1[father[i]]-pA1[i]+D*A2[father[i]]-D*pA2[i]+D*D*A3[father[i]]-D*D*pA3[i];
	}
	printf("%.13f\n",ans1*ans1+ans2);
}
int main()
{
	//freopen("x.in","r",stdin);
	//freopen("x.out","w",stdout);
	int n,m,x,y,id;
	double p;
	scanf("%d%d%d",&id,&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&x),A[i]=make_pair(x,x^1);
	for(int i = 1;i< n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(1);
	build(1,0);
	for(int i = 1;i<= n;i++)Add(i);
	int opt;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%lf",&x,&p);
			update(x,p);
		}else
		{
			scanf("%d",&x);
			getans(x);
		}
	}
	return 0;
}
Problem4796

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <algorithm>
using namespace std;
const int N = 5e5+5;
char str[N];
int s[N];
int check(vector<int> &a)
{
	int ans = 0;
	for(int i = 0;i+1<a.size();i++)
		ans+=a[i]^a[i+1];
	return ans+1;
}
int main()
{
	scanf("%s",str);
	int n = strlen(str)/3;
	for(int i = 0;i<3*n;i++)
		s[i] = str[i]-'0';
	vector<int>ans;
	for(int i = 0;i<n;i++)
	{
		vector<int>a;
	  	a.clear();
		for(int j = -1;j<= 2;j++)
		{
			if(i==0&&j==-1)a.push_back(0);
			else a.push_back(s[i*3+j]);
		}
		if(check(a)>=3)continue;
		a[1]^=1,a[2]^=1;
		if(check(a)>=3)
		{
			s[i*3]^=1;s[i*3+1]^=1;
			ans.push_back(i*3);
			continue;
		}
		a[1]^=1,a[2]^=1;

		a[2]^=1,a[3]^=1;
		assert(check(a)>=3);
		s[i*3+1]^=1,s[i*3+2]^=1;
		ans.push_back(3*i+1);
	}
	int sz = ans.size();
	printf("%d\n",sz);
	for(int i = 0;i<sz;i++)
	{
		printf("%d",ans[i]+1);
		if(i==sz-1)printf("\n");
		else printf(" ");
	}
	return 0;
}
Problem4804

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e7+5;
int prime[N/10],cnt;
bool vis[N];ll F[N];
void quick_shai()
{
	F[1] = 1;
	for(int i = 2;i< N;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			F[i] = i-2;
		}
		for(int j = 1;j<= cnt&&(ll)i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)
			{
				if((i/prime[j])%prime[j]!=0)
					F[i*prime[j]] = F[i/prime[j]]*(prime[j]-1)*(prime[j]-1);
				else 
					F[i*prime[j]] = F[i]*prime[j];
				break;
			}
			else 
				F[i*prime[j]] = F[i]*F[prime[j]];
		}
	}
	for(int i = 1;i<N;i++)F[i]+=F[i-1];
}
ll Solve(int n)
{
	int l,r,t; 
	ll ret=0;
	for(l = 1;l*l<= n;l++)
		t=n/l,ret+=(ll)t*t*(F[l]-F[l-1]);
	for(t = n/l;l<= n;l=r+1,t--)
		r=n/t,ret+=(ll)t*t*(F[r]-F[l-1]);
	return ret;
}
int main()
{
	int cas,n;
	quick_shai();
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d",&n);
		printf("%lld\n",Solve(n));
	}
	return 0;
}
Problem4810

#include <stdio.h>
#include <math.h>
#include <bitset>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int bel[N];
bitset<N>f,g;
struct Ask
{
	int opt,l,r,x,id;
	Ask(){}
	Ask(int _opt,int _l,int _r,int _x,int _id):opt(_opt),l(_l),r(_r),x(_x),id(_id){}
	bool operator<(const Ask &s)const 
	{
		if(bel[l]==bel[s.l])return r<s.r;
		return bel[l]<bel[s.l];
	}
}ask[N];
int cnt[N],ans[N],a[N];
void Del(int x)
{
	cnt[x]--;
	if(cnt[x]==0)f[x]=0,g[100000-x]=0;
}
void Add(int x)
{
	cnt[x]++;
	if(cnt[x]==1)f[x]=1,g[100000-x]=1;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int bl = sqrt(n)+1;
	for(int i = 1;i<= n;i++)bel[i] = i/bl+1;
	for(int i = 1;i<= m;i++)
	{
		int l,r,opt,x;
		scanf("%d%d%d%d",&opt,&l,&r,&x);
		ask[i] = Ask(opt,l,r,x,i);
	}
	sort(ask+1,ask+m+1);
	int l = 0,r = 0;
	for(int i = 1;i<= m;i++)
	{
		while(l<ask[i].l)Del(a[l]),l++;
		while(l>ask[i].l)l--,Add(a[l]);
		while(r<ask[i].r)r++,Add(a[r]);
		while(r>ask[i].r)Del(a[r]),r--;
		if(ask[i].opt==1)
		{
			if(((f>>ask[i].x)&f).any())ans[ask[i].id] = 1;
			else ans[ask[i].id] =0;
		}
		else if(ask[i].opt==2)
		{
			if(((g>>(100000-ask[i].x))&f).any())ans[ask[i].id] = 1;
			else ans[ask[i].id] =0;
		}
		else
		{
			for(int j = 1;j*j<=ask[i].x;j++)
				if(ask[i].x%j==0)
					if(f[j]==1&&f[ask[i].x/j]==1)
						{ans[ask[i].id] = 1;break;}
			if(ask[i].x==0&&f[0]==1)
				ans[ask[i].id] = 1;
		}
	}
	for(int i= 1;i<= m;i++)
		if(ans[i])printf("yuno\n");
		else printf("yumi\n");
	return 0;
}
Problem4811

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
typedef unsigned long long ull;
int Opt[N],n,m,k;ull Val[N];
struct Seg
{
	ull v0,v1;
	Seg(){}
	Seg(int opt,ull x)
	{
		if(opt==1)
		{
			v0 = 0&x;
			v1 = (~0)&x;
		}else if(opt==2)
		{
			v0 = 0|x;
			v1 = (~0)|x;
		}else
		{
			v0 = 0^x;
			v1 = (~0)^x;
		}
	}
	Seg operator +(const Seg &s)const
	{
		Seg ans;
		ans.v0 = (v0&s.v1)|((~v0)&s.v0);
		ans.v1 = (v1&s.v1)|((~v1)&s.v0);
		return ans;
	}
}trl[N<<2],trr[N<<2];
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int dep[N],fa[N],top[N],son[N],size[N];
void dfs1(int x)
{
	size[x] = 1;
	dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			if(size[e[i].to]>size[son[x]])son[x]=e[i].to;
			size[x]+=size[e[i].to];
		}
}
int Dfn,dfn[N],seq[N];
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
void build(int p,int l,int r)
{
	if(l==r)
	{
		trl[p] = trr[p] = Seg(Opt[seq[l]],Val[seq[l]]);
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	trl[p] = trl[p<<1]+trl[p<<1|1];
	trr[p] = trr[p<<1|1]+trr[p<<1];
}
void Update(int p,int l,int r,int pos,ull val)
{
	if(l==r)
	{
		trl[p] = trr[p] = Seg(Opt[seq[pos]],val);
		Val[seq[pos]] = val;
		return ;
	}
	int mid = (l+r)>>1;
	if(pos<=mid)Update(p<<1,l,mid,pos,val);
	else Update(p<<1|1,mid+1,r,pos,val);
	trl[p] = trl[p<<1]+trl[p<<1|1];
	trr[p] = trr[p<<1|1]+trr[p<<1];
}
Seg getansL(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return trl[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getansL(p<<1,l,mid,a,b);
	else if(a>mid)return getansL(p<<1|1,mid+1,r,a,b);
	else return getansL(p<<1,l,mid,a,b)+getansL(p<<1|1,mid+1,r,a,b);
}
Seg getansR(int p,int l,int r,int a,int b)
{
	if(l>=a&&r<=b)return trr[p];
	int mid = (l+r)>>1;
	if(b<=mid)return getansR(p<<1,l,mid,a,b);
	else if(a>mid)return getansR(p<<1|1,mid+1,r,a,b);
	else return getansR(p<<1|1,mid+1,r,a,b)+getansR(p<<1,l,mid,a,b);
}
Seg getans(int x,int y)
{
	Seg vx(3,0),vy(3,0);
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>=dep[top[y]])
		{
			vx = vx+getansR(1,1,n,dfn[top[x]],dfn[x]);
			x = fa[top[x]];
		}else
		{
			vy = getansL(1,1,n,dfn[top[y]],dfn[y])+vy;
			y = fa[top[y]];
		}
	}
	if(dep[x]>dep[y])
		return vx+getansR(1,1,n,dfn[y],dfn[x])+vy;
	else return vx+getansL(1,1,n,dfn[x],dfn[y])+vy;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	for(int i = 1;i<= n;i++)
		scanf("%d%llu",&Opt[i],&Val[i]);
	int opt,x,y;
	ull z;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	build(1,1,n);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%llu",&x,&y,&z);
			Seg ans = getans(x,y);
			ull Ans = 0,now = 0;
			for(int j = k-1;j>=0;j--)
			{
				if((ans.v0>>j)&1)
					Ans+=1ull<<j;
				else if(((ans.v1>>j)&1)&&(now+(1ull<<j))<=z)
					Ans+=1ull<<j,now+=1ull<<j;
			}
			printf("%llu\n",Ans);
		}else
		{
			scanf("%d%d%llu",&x,&y,&z);
			Opt[x] = y;
			Update(1,1,n,dfn[x],z);
		}
	}
	return 0;
}
Problem4813

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 105;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int f[N][N],g[N][N],m,n;
void dfs(int x,int fa)
{
	f[x][0] = g[x][0] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa)
		{
			dfs(e[i].to,x);
			for(int j = m;~j;j--)
				for(int k = 0;k<=j-1;k++)
				{
					if(j-k-2>=0)f[x][j] = max(f[x][j],f[e[i].to][k]+f[x][j-k-2]);
					g[x][j] = max(g[x][j],g[e[i].to][k]+f[x][j-k-1]);
					if(j-k-2>=0)g[x][j] = max(g[x][j],f[e[i].to][k]+g[x][j-k-2]);
				}
		}
	for(int i = 0;i<m;i++)f[x][i+1] = max(f[x][i],f[x][i+1]);
	for(int i = 0;i<m;i++)g[x][i+1] = max(g[x][i],g[x][i+1]);
}
int main()
{
	int x,y;
	scanf("%d%d",&n,&m);
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs(0,0);
	printf("%d\n",g[0][m]);
	return 0;
}
Problem4814

#include <bits/stdc++.h>

using namespace std;

#define LL long long
#define inf 0x3f3f3f3f
#define Pi acos(-1.0)
#define eps 1e-12
#define N 6020
#define M 400020

int dcmp(double x)
{
	if(fabs(x) < eps) return 0;
	return x < 0 ? -1 : 1;
}
int sgn(LL x)
{
	if(x == 0) return 0;
	return x < 0 ? -1 : 1;
}
struct point
{
	double x, y, ang;
	point(double x = 0, double y = 0) : x(x), y(y) {}
	point operator - (const point &b) const 
	{
		return point(x - b.x, y - b.y);
	}
	point operator + (const point &b) const 
	{
		return point(x + b.x, y + b.y);
	}
	point operator * (const double &k) const 
	{
		return point(x * k, y * k);
	}
	bool operator < (const point &b) const 
	{
		return ang < b.ang;
	}
	bool operator == (const point &b) const 
	{
		return x == b.x && y == b.y;
	}
	inline double len()
	{
		return sqrt(x * x + y * y);
	}
	inline void get_ang()
	{
		ang = atan2(y, x);
	}
	inline void input()
	{
		int xx, yy;
		scanf("%d%d", &xx, &yy);
		x = 1.0 * xx, y = 1.0 * yy;
	}
};
double dot(point a, point b)
{
	return a.x * b.x + a.y * b.y;
}
double cross(point a, point b)
{
	return a.x * b.y - a.y * b.x;
}
point get_intersection(point a1, point a2, point b1, point b2)
{
	point u = a1 - b1, av = a2 - a1, bv = b2 - b1;
	double t = cross(bv, u) / cross(av, bv);
	return a1 + av * t;
}
const point O = point(0, 0);
point base;
struct Seg{
	point u, v;
	int id, in;
	double ang;
	Seg(){}
	Seg(point u, point v, int in, int id, double ang) : u(u), v(v), in(in), id(id), ang(ang) {}
	bool operator < (const Seg &b) const 
	{
		if(u == b.u)
		{
			return cross(v - u, b.v - u) < 0;
		}
		point aa = get_intersection(u, v, O, base);
		point bb = get_intersection(b.u, b.v, O, base);
		return aa.len() < bb.len();
	}
}L[N];
bool cmp(Seg a, Seg b)
{
	return dcmp(a.ang - b.ang) < 0 || dcmp(a.ang - b.ang) == 0 && a.in > b.in;
}

int all, tot;
multiset<Seg> S;
multiset<Seg>::iterator it[N];
point pp[N], p[N];
point tri[N][3], t[N][4];
void add(point u, point v, int id)
{
	if(u.ang > v.ang) swap(u, v);
	L[all++] = Seg(u, v, 1, id, u.ang);
	L[all++] = Seg(v, u, 0, id, v.ang);
}
double calc(Seg s)
{
	point a = get_intersection(s.u, s.v, O, base);
	return a.len();
}
int solve(int n)
{
	sort(p, p + n);
	sort(L, L + all, cmp);
	S.clear();
	int ret = 0, i = 0, j = 0;
	for(; i < n; ++i)
	{
		while(j < all && (dcmp(L[j].ang - p[i].ang) < 0 || (dcmp(L[j].ang - p[i].ang) == 0 && L[j].in)))
		{
			base = L[j].u;
			if(L[j].in)
				it[L[j].id] = S.insert(L[j]);
			else
				S.erase(it[L[j].id]);
			++j;
		}
		if(S.empty()){++ret; continue;}
		base = p[i];
		double dis = calc(*S.begin());
		if(dcmp(p[i].len() - dis) <= 0) ++ret;
	}
	return ret;
}

int main()
{
	int V, T;
	scanf("%d%d", &V, &T);
		for(int i = 1; i <= V; ++i)
			pp[i].input();
		for(int i = 1; i <= T; ++i)
			for(int j = 0; j < 3; ++j)
				tri[i][j].input();

		int ans = 0;
		for(int i = 1; i <= V; ++i){
			int cnt = 0;
			for(int j = i + 1; j <= V; ++j){
				p[cnt++] = pp[j] - pp[i];
				p[cnt-1].get_ang();
			}
			tot = all = 0;
			for(int j = 1; j <= T; ++j){
				for(int k = 0; k < 3; ++k)
					t[j][k] = tri[j][k] - pp[i];
				t[j][3] = t[j][0];
				point u, v;
				double mx = 0;
				for(int k = 0; k < 3; ++k){
					double ang = dot(t[j][k], t[j][k+1]) / t[j][k].len() / t[j][k+1].len();
					ang = acos(ang);
					if(ang > mx)
						mx = ang, u = t[j][k], v = t[j][k+1];
				}
				u.get_ang(), v.get_ang();
				double d = fabs(u.ang - v.ang);
				if(d < Pi)
					add(u, v, tot++);
				else{
					point tmp = get_intersection(u, v, O, point(-1.0, 0));
					tmp.ang = Pi * dcmp(u.ang);
					add(u, tmp, tot++);
					tmp.ang = Pi * dcmp(v.ang);
					add(v, tmp, tot++);
				}
			}
			int ret = solve(cnt);
			ans += ret;
		}
		printf("%d\n", ans);
	return 0;
}
Problem4815

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 4e6+5;
const int mod = 1e9+7;
typedef long long ll;
struct P
{int l,r;}pos[2010];
int prime[N],inv[N],mu[N],g[N],f[N],w[N],sum[2010],P[N],s[N];
bool vis[N];
int cnt;
void quick_shai(int n)
{
	inv[0] = inv[1] = 1;
	for(int i = 2;i<=n;i++)
		inv[i] = (ll)(mod-mod/i)*inv[mod%i]%mod;
	cnt = 0;
	g[1] = mu[1] = 1;
	for(int i = 2;i<=n;i++)
	{
		if(!vis[i])
		{
			prime[++cnt] = i;
			mu[i] = -1;
			g[i] = (1-inv[i]+mod)%mod;
		}
		for(int j = 1;j<= cnt&&i*prime[j]<=n;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j])
			{
				mu[i*prime[j]] = -mu[i];
				g[i*prime[j]] = (ll)g[i]*(1-inv[prime[j]]+mod)%mod;
			}
			else
			{
				mu[i*prime[j]] = 0;
				g[i*prime[j]] = g[i];
				break;
			}
		}
	}	
	f[0] = 0;
	for(int i = 1;i<=n;i++)
		f[i] = (f[i-1]+(ll)g[i]*i%mod*i%mod*i%mod)%mod;
}

int gcd(int a,int b)
{
	if(b==0)return a;
	return gcd(b,a%b);
}

int check(int n)
{
	if(!n)return 0;
	return (s[n]+sum[P[n]])%mod;
}

int main()
{
	int m,n;
	scanf("%d%d",&m,&n);
	quick_shai(n);
	int block = sqrt(n);
	int last;
	for(int i = 1;i<= n;i++)
		P[i] = (i-1)/block+1;
	last = P[n];
	pos[1].l = 1;
	for(int i = 2;i<= n;i++)
		if(P[i-1]<P[i]){pos[P[i-1]].r = i-1,pos[P[i]].l = i;}
	pos[last].r = n;
	memset(sum,0,sizeof(sum));
	for(int i = 0;i<= n;i++)w[i]=(ll)i*i%mod;
	for(int i = 1;i<= n;i++)s[i] = (s[i-1]+w[i])%mod;
	int a,b,k;
	ll x,y;
	int Last;
	while(m--)
	{
		scanf("%d%d%lld%d",&a,&b,&x,&k);
		int c = gcd(a,b);
		y = (ll)a/c*b/c;
		x/=y;x%=mod;
		int d = (x-w[c]+mod)%mod;w[c] = x;
		for(int i = c;i<= pos[P[c]].r;i++)s[i] = (s[i]+d)%mod;
		for(int i = P[c]+1;i<= last;i++)sum[i] = (sum[i]+d)%mod;
		ll ans = 0;
		for(int i = 1;i<= k;i = Last+1)
		{
			Last = k/(k/i);
			ans = (ans+(ll)(check(Last)-check(i-1)+mod)*f[k/i]%mod)%mod;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
Problem4816

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
const int mod = 1e9+7;
int f[N],g[N],Invg[N];
int quick_pow(int x,ll y)
{
	int res=1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
int getmul(int l,int r)
{
	return (ll)g[r]*Invg[l-1]%mod;
}
int main()
{
	f[0] = 0,f[1] = 1;
	for(int i = 2;i<N;i++)
		f[i] = (f[i-1]+f[i-2])%mod;
	for(int i = 1;i<N;i++)g[i] = f[i];
	Invg[0] = 1,g[0]=1;
	for(int i = 1;i<N;i++)
	{
		Invg[i] = quick_pow(g[i],mod-2);
		for(int j = i+i;j<N;j+=i)
			g[j] = (ll)g[j]*Invg[i]%mod;
		g[i] = (ll)g[i-1]*g[i]%mod;
		Invg[i] = (ll)Invg[i-1]*Invg[i]%mod;
	}
	int cas,n,m;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		int ans = 1,last = 1;
		if(n>m)swap(n,m);
		for(int i = 1;i<= n;i=last+1)
		{
			last = min(n/(n/i),m/(m/i));
			ans = (ll)ans*quick_pow(getmul(i,last),(ll)(n/i)*(m/i))%mod;
		}
		printf("%d\n",ans);
	}
	return 0;
}
Problem4817

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 100005;
int n,m;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].next = head[x];
	head[x] = tot;
}
int Son[N],dfn[N],seq[N],top[N],size[N],dep[N],fa[N],Dfn;
void dfs1(int x)
{
	dep[x] = dep[fa[x]]+1;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[Son[x]])Son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	top[x] = tp;
	dfn[x] = ++Dfn;
	seq[Dfn] = x;
	if(Son[x])dfs2(Son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=Son[x])
			dfs2(e[i].to,e[i].to);
}
int getlca(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x]<dep[y])return x;
	return y;
}
int mx[N<<2],lazy[N<<2];
void build(int p,int l,int r)
{
	lazy[p] = 0;
	if(l==r)
	{
		mx[p] = dep[seq[l]];
		return ;
	}
	int mid = (l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
void Push_down(int p,int l,int r)
{
	if(l==r||!lazy[p])return ;
	mx[p<<1]+=lazy[p],mx[p<<1|1]+=lazy[p];
	lazy[p<<1]+=lazy[p],lazy[p<<1|1]+=lazy[p];
	lazy[p] = 0;
}
void Update(int p,int l,int r,int a,int b,int c)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b){mx[p]+=c;lazy[p]+=c;return ;}
	int mid = (l+r)>>1;
	if(a<=mid)Update(p<<1,l,mid,a,b,c);
	if(b >mid)Update(p<<1|1,mid+1,r,a,b,c);
	mx[p] = max(mx[p<<1],mx[p<<1|1]);
}
int Getans(int p,int l,int r,int a,int b)
{
	Push_down(p,l,r);
	if(l>=a&&r<=b)return mx[p];
	int mid = (l+r)>>1;
	int ans = 0;
	if(a<=mid)ans = max(ans,Getans(p<<1,l,mid,a,b));
	if(b >mid)ans = max(ans,Getans(p<<1|1,mid+1,r,a,b));
	return ans;
}
int son[N][2],father[N],lx[N];
bool is_root(int x)
{
	return son[father[x]][0]!=x&&son[father[x]][1]!=x;
}
void update(int x)
{
	lx[x] = x;
	if(son[x][0])
		lx[x] = lx[son[x][0]];
}
void rotate(int x)
{
	int y = father[x],z = father[y];
	int d = son[y][1]==x;
	if(!is_root(y))
	{
		if(son[z][0]==y)son[z][0] = x;
		else son[z][1] = x;
	}
	father[y] = x,father[x] = z,father[son[x][d^1]] = y;
	son[y][d] = son[x][d^1];son[x][d^1] = y;
	update(x),update(y);
}
void splay(int x)
{
	while(!is_root(x))
	{
		int y = father[x],z = father[y];
		if(!is_root(y))
		{
			if((son[y][0]==x)!=(son[z][0]==y))rotate(x);
			else rotate(y);
		}
		rotate(x);
	}
	update(x);
}
void access(int x)
{
	int t = 0;
	while(x)
	{
		splay(x);
		if(son[x][1])
		{
			int y = lx[son[x][1]];
			Update(1,1,n,dfn[y],dfn[y]+size[y]-1,1);
		}
		son[x][1] = t;
		if(son[x][1])
		{
			int y = lx[son[x][1]];
			Update(1,1,n,dfn[y],dfn[y]+size[y]-1,-1);
		}
		update(x);
		t = x;x = father[x];
	}
}
int col(int x)
{
	splay(x);
	return lx[x];
}
int main()
{
	scanf("%d%d",&n,&m);
	int a,b;
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&a,&b);
		add(a,b),add(b,a);
	}
	dfs1(1),dfs2(1,1);
	build(1,1,n);
	for(int i = 1;i<= n;i++)father[i]=fa[i];
	int opt;
	while(m--)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d",&a);
			access(a);
		}else if(opt==2)
		{
			scanf("%d%d",&a,&b);
			int lca = getlca(a,b);
			int flca = fa[lca];
			int valx = Getans(1,1,n,dfn[a],dfn[a]),valy = Getans(1,1,n,dfn[b],dfn[b]);
			int vall = 0;
			if(flca)
			{
				vall = Getans(1,1,n,dfn[flca],dfn[flca]);
				if(col(lca)==col(flca))
					vall--;
			}
			printf("%d\n",valx+valy-2*vall-1);
		}else
		{
			scanf("%d",&a);
			printf("%d\n",Getans(1,1,n,dfn[a],dfn[a]+size[a]-1));
		}
	}
	return 0;
}
Problem4818

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 20170408;
const int N = 105;
const int M = 2e7+5;
int n,m,p;
struct Martix
{
	int d[N];
	Martix(){memset(d,0,sizeof(d));}
	Martix operator *(const Martix &s)const
	{
		Martix res;
		for(int i = 0;i<p;i++)
			for(int j = 0;j<p;j++)
				(res.d[i]+=(ll)d[j]*s.d[(i-j+p)%p]%mod)%=mod;
		return res;
	}
};
bool vis[M];
int prime[M/10],cnt;
void quick_prime()
{
	vis[1] = true;
	for(int i = 2;i<M;i++)
	{
		if(!vis[i])
			prime[++cnt] = i;
		for(int j = 1;j<=cnt&&prime[j]*i<M;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int main()
{
	quick_prime();
	scanf("%d%d%d",&n,&m,&p);
	Martix go1,go2;
	for(int i = 1;i<= m;i++)
	{
		go1.d[i%p]++;
		if(vis[i])
			go2.d[i%p]++;
	}
	Martix a1,a2;
	a1.d[0] = a2.d[0] = 1;
	while(n)
	{
		if(n&1)
		{
			a1 = a1*go1;
			a2 = a2*go2;
		}
		go1 = go1*go1;go2 = go2*go2;
		n>>=1;
	}
	printf("%d\n",(a1.d[0]-a2.d[0]+mod)%mod);
	return 0;
}
Problem4819

#include <stdio.h>
#include <queue>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double eps = 1e-7;
const int N = 205;
const int M = 3e4+5;
const double INF = 1e9;
struct E
{int next,to,f,from;double c;}e[M];
int head[N],tot=1;
int from[N],a[N][N],b[N][N],n;
void add(int x,int y,int f,double c)
{
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;e[tot].f=f,e[tot].c=c;
	e[++tot].to=x;e[tot].next=head[y];head[y]=tot;e[tot].f=0,e[tot].c=-c;
	e[tot-1].from = x,e[tot].from = y;
}
double dis[N];
bool vis[N];
queue<int>Q;
bool spfa(int s,int t)
{
	for(int i = s;i<= t;i++)dis[i] = INF;
	dis[s] = 0;
	vis[s] = true;Q.push(s);
	while(!Q.empty())
	{
		int x = Q.front();
		Q.pop();
		vis[x] = false;
		for(int i = head[x];i;i=e[i].next)
			if(e[i].f&&dis[e[i].to]>dis[x]+e[i].c)
			{
				dis[e[i].to] = dis[x]+e[i].c;
				from[e[i].to] = i;
				if(!vis[e[i].to])
				{
					Q.push(e[i].to);
					vis[e[i].to] = true;
				}
			}
	}
	return dis[t]!=INF;
}
double mcf(int s,int t)
{
	int x = INF;
	double ans = 0;
	for(int i = from[t];i;i=from[e[i].from])
		x = min(x,e[i].f);
	for(int i = from[t];i;i=from[e[i].from])
		e[i].f-=x,e[i^1].f+=x,ans+=e[i].c*x;
	return ans;
}
void rebuild(double mid)
{
	memset(head,0,sizeof(head));
	tot = 1;
	int s= 0,t = 2*n+1;
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			add(i,j+n,1,mid*b[i][j]-a[i][j]);
	for(int i = 1;i<= n;i++)
		add(s,i,1,0),add(i+n,t,1,0);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
		scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)
		scanf("%d",&b[i][j]);
	double l = 0,r = 10001;
	while(fabs(r-l)>eps)
	{
		double mid = (l+r)/2;
		rebuild(mid);
		double ans = 0;
		while(spfa(0,2*n+1))ans+=mcf(0,2*n+1);
		if(ans<eps)l = mid;
		else r = mid;
	}
	printf("%.6lf\n",l);
	return 0;
}
Problem4820

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 305;
typedef long long ll;
const int sed = 107;
const int mod = 998244353;
double f[N][N],B[N],pw2[N];
int n,m,deg;
char s[N][N];
ll h[N][N],h0[N][N],pws[N],pw0[N];
int main()
{
	scanf("%d%d",&n,&m);
	deg = n+1;
	for(int i = 1;i<= n;i++)
	{
		scanf("%s",s[i]+1);
		for(int j = 1;j<= m;j++)
		{
			h[i][j] = h[i][j-1]*sed+s[i][j];
			h0[i][j] = (h0[i][j-1]*sed+s[i][j])%mod;
		}
	}
	pw2[0] = pws[0] = pw0[0] = 1;
	for(int i = 1;i<= m;i++)
	{
		pw2[i] = pw2[i-1]*0.5;
		pws[i] = pws[i-1]*sed;
		pw0[i] = pw0[i-1]*sed%mod;
	}
	for(int i = 1;i<= n;i++)
		for(int j = 1;j<= n;j++)
			for(int k = 1;k<m;k++)
			if(h[i][k]==h[j][m]-h[j][m-k]*pws[k])
			{
				ll x0 = h0[i][k];
				ll x1 = (h0[j][m]-h0[j][m-k]*pw0[k]%mod+mod)%mod;
				if(x0==x1)
					f[i][j]+=pw2[m-k];
			}
	for(int i = 1;i<= n;i++)f[i][i]++,f[i][n+1]--,f[n+1][i]++;
	B[n+1] = 1;
	for(int i = 1,l;i<= deg;i++)
	{
		for(int j = (l=i)+1;j<=deg;j++)if(fabs(f[j][i])>fabs(f[l][i]))l = j;
		for(int j = i;j<= deg;j++)swap(f[i][j],f[l][j]);
		swap(B[i],B[l]);
		double t = f[i][i];
		for(int j = i;j<= deg;j++)f[i][j]/=t;
		B[i]/=t;
		for(int j = 1;j<= deg;j++)if(j!=i)
		{
			t = f[j][i];
			for(int k = i;k<= deg;k++)f[j][k]-=f[i][k]*t;
			B[j]-=B[i]*t;
		}
	}
	for(int i = 1;i<= n;i++)printf("%.10lf\n",B[i]);
	return 0;
}
Problem4821

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
struct Seg
{
	double sum_x,sum_y,sum_x2,sum_xy;
	double add_x,add_y;
	double cov_x,cov_y;
	bool cover;
}tr[N<<2];
double sum_pre[N<<2],vx[N<<2],vy[N<<2];
struct Res
{
	double sum_x,sum_y,sum_x2,sum_xy;
}res;
int n,m;
void Covers(int p,int l,int r,double S,double T)
{
	if(l>r)return ;
	double len = r-l+1;
	double sum = (l+r)*len/2;
	tr[p].add_x = tr[p].add_y = false;
	tr[p].cov_x = S,tr[p].cov_y = T;
	tr[p].cover = true;
	tr[p].sum_x2 = S*S*len+sum*S+sum*S+sum_pre[r]-sum_pre[l-1];
	tr[p].sum_xy = S*T*len+sum*S+sum*T+sum_pre[r]-sum_pre[l-1];
	tr[p].sum_x = (S+l+S+r)*len/2;
	tr[p].sum_y = (T+l+T+r)*len/2;
}
void Push_Down_cover(int p,int l,int r)
{
	if(l==r)return ;
	if(tr[p].cover)
	{
		int mid =(l+r)>>1;
		Covers(p<<1,l,mid,tr[p].cov_x,tr[p].cov_y);
		Covers(p<<1|1,mid+1,r,tr[p].cov_x,tr[p].cov_y);
		tr[p].cover = false;
	}
}
void Add(int p,int l,int r,double S,double T)
{
	if(l>r)return ;
	Push_Down_cover(p,l,r);
	double len = r-l+1;
	tr[p].add_x+=S,tr[p].add_y+=T;
	tr[p].sum_x2 += 2*S*tr[p].sum_x+S*S*len;
	tr[p].sum_xy += S*tr[p].sum_y+T*tr[p].sum_x+S*T*len;
	tr[p].sum_x+=S*len,tr[p].sum_y+=T*len;
}
void Push_Down_add(int p,int l,int r)
{
	if(l==r)return ;
	if(tr[p].add_x||tr[p].add_y)
	{
		int mid =(l+r)>>1;
		Add(p<<1,l,mid,tr[p].add_x,tr[p].add_y);
		Add(p<<1|1,mid+1,r,tr[p].add_x,tr[p].add_y);
		tr[p].add_x = tr[p].add_y = 0;
	}
}
void Push_Down(int p,int l,int r)
{
	Push_Down_add(p,l,r);
	Push_Down_cover(p,l,r);
}
void Push_Up(int p)
{
	int l = p<<1,r = p<<1|1;
	tr[p].sum_x = tr[l].sum_x+tr[r].sum_x;
	tr[p].sum_y = tr[l].sum_y+tr[r].sum_y;
	tr[p].sum_x2 = tr[l].sum_x2+tr[r].sum_x2;
	tr[p].sum_xy = tr[l].sum_xy+tr[r].sum_xy;
}
void Build(int p,int l,int r)
{
	if(l==r)
	{
		tr[p].sum_x = vx[l];
		tr[p].sum_y = vy[l];
		tr[p].sum_x2 = vx[l]*vx[l];
		tr[p].sum_xy = vx[l]*vy[l];
		return ;
	}
	int mid = (l+r)>>1;
	Build(p<<1,l,mid);
	Build(p<<1|1,mid+1,r);
	Push_Up(p);
}
void Covers(int p,int l,int r,int a,int b,double S,double T)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		Covers(p,l,r,S,T);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Covers(p<<1,l,mid,a,b,S,T);
	if(b >mid)Covers(p<<1|1,mid+1,r,a,b,S,T);
	Push_Up(p);
}
void Add(int p,int l,int r,int a,int b,double S,double T)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		Add(p,l,r,S,T);
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Add(p<<1,l,mid,a,b,S,T);
	if(b >mid)Add(p<<1|1,mid+1,r,a,b,S,T);
	Push_Up(p);
}
void Getans(int p,int l,int r,int a,int b)
{
	Push_Down(p,l,r);
	if(l>=a&&r<=b)
	{
		res.sum_x+=tr[p].sum_x,res.sum_y+=tr[p].sum_y;
		res.sum_x2+=tr[p].sum_x2,res.sum_xy+=tr[p].sum_xy;
		return ;
	}
	int mid = (l+r)>>1;
	if(a<=mid)Getans(p<<1,l,mid,a,b);
	if(b >mid)Getans(p<<1|1,mid+1,r,a,b);
}

int main()
{
	for(int i = 1;i<N;i++)sum_pre[i] = sum_pre[i-1]+(double)i*i;
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%lf",&vx[i]);
	for(int i = 1;i<= n;i++)scanf("%lf",&vy[i]);
	Build(1,1,n);
	int opt,l,r;
	double s,t;
	while(m--)
	{
		scanf("%d%d%d",&opt,&l,&r);
		if(opt==1)
		{
			res.sum_x = res.sum_y = 0;
			res.sum_x2 = res.sum_xy = 0;
			Getans(1,1,n,l,r);
			double len = r-l+1;
			double averx = res.sum_x/len;
			double avery = res.sum_y/len;
			printf("%.10lf\n",(res.sum_xy-len*averx*avery)/(res.sum_x2-len*averx*averx));
		}else if(opt==2)
		{
			scanf("%lf%lf",&s,&t);
			Add(1,1,n,l,r,s,t);
		}else
		{
			scanf("%lf%lf",&s,&t);
			Covers(1,1,n,l,r,s,t);
		}
	}
	return 0;
}
Problem4823

#include <cstdio>
#include <map>
#include <algorithm>
using namespace std;
const int maxn=100005,s=100005,t=100006,oo=0x3f3f3f3f;
int rd()
{
    int x=0;
    char c=getchar();
    while (c<'0'||c>'9') c=getchar();
    while (c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x;
}
int fir[maxn],cur[maxn],ne[20*maxn],to[20*maxn],w[20*maxn],dep[maxn],que[maxn],
xx[maxn],yy[maxn],ww[maxn],
n,num,r,c;
map<pair<int,int>,int> id;
void add(int u,int v,int x)
{
    num++;ne[num*2]=fir[u];fir[u]=num*2;to[num*2]=v;w[num*2]=x;
    ne[num*2+1]=fir[v];fir[v]=num*2+1;to[num*2+1]=u;w[num*2+1]=0;
}
bool bfs()
{
    int u,v,hd,tl;
    for (int i=1;i<=n;i++) dep[i]=0;
    dep[t]=0;
    dep[s]=1;
    que[hd=tl=1]=s;
    while (hd<=tl)
    {
        u=que[hd++];
        for (int i=fir[u];i;i=ne[i])
            if (w[i]&&!dep[v=to[i]])
            {
                dep[v]=dep[u]+1;
                que[++tl]=v;
            }
    }
    return dep[t];
}
int dfs(int u,int lim)
{
    if (u==t) return lim;
    int v,x,ret=0;
    for (int &i=cur[u];i&&ret<lim;i=ne[i])
        if (w[i]&&dep[v=to[i]]==dep[u]+1)
        {
            x=dfs(v,min(lim-ret,w[i]));
            ret+=x;
            w[i]-=x;
            w[i^1]+=x;
        }
    return ret;
}
int main()
{
    int u,ans=0;
    c=rd();
    r=rd();
    n=rd();
    for (int i=1;i<=n;i++)
    {
        xx[i]=rd();
        yy[i]=rd();
        ww[i]=rd();
        id[make_pair(xx[i],yy[i])]=i;
    }
    for (int i=1;i<=n;i++)
        switch (xx[i]%4)
        {
            case 0:
                if (yy[i]&1) add(s,i,ww[i]);
                else
                {
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                        add(id[make_pair(xx[i]+1,yy[i])],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(id[make_pair(xx[i],yy[i]+1)],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(id[make_pair(xx[i],yy[i]-1)],i,oo);
                }
                break;
            case 1:
                if (yy[i]&1)
                {
                    if (id.count(make_pair(xx[i]-1,yy[i])))
                        add(id[make_pair(xx[i]-1,yy[i])],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(id[make_pair(xx[i],yy[i]+1)],i,oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(id[make_pair(xx[i],yy[i]-1)],i,oo);
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                    {
                        u=id[make_pair(xx[i]+1,yy[i])];
                        add(i,u,min(ww[i],ww[u]));
                    }
                }
                else add(s,i,ww[i]);
                break;
            case 2:
                if (yy[i]&1)
                {
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                        add(i,id[make_pair(xx[i]+1,yy[i])],oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(i,id[make_pair(xx[i],yy[i]+1)],oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(i,id[make_pair(xx[i],yy[i]-1)],oo);
                }
                else add(i,t,ww[i]);
                break;
            case 3:
                if (yy[i]&1) add(i,t,ww[i]);
                else
                {
                    if (id.count(make_pair(xx[i]-1,yy[i])))
                        add(i,id[make_pair(xx[i]-1,yy[i])],oo);
                    if (id.count(make_pair(xx[i],yy[i]+1)))
                        add(i,id[make_pair(xx[i],yy[i]+1)],oo);
                    if (id.count(make_pair(xx[i],yy[i]-1)))
                        add(i,id[make_pair(xx[i],yy[i]-1)],oo);
                    if (id.count(make_pair(xx[i]+1,yy[i])))
                    {
                        u=id[make_pair(xx[i]+1,yy[i])];
                        add(u,i,min(ww[i],ww[u]));
                    }
                }
        }
    while (bfs())
    {
        for (int i=1;i<=n;i++) cur[i]=fir[i];
        cur[s]=fir[s];
        cur[t]=fir[t];
        ans+=dfs(s,oo);
    }
    printf("%d\n",ans);
}
Problem4824

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int mod = 1e9+7;
const int N = 105;
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
int c[N][N],f[N][N],g[N][N],size[N],tmp[N],n;
char s[N];
void dfs(int x)
{
	if((x<<1)<=n)add(x,x<<1);
	if((x<<1|1)<=n)add(x,x<<1|1);
	g[x][1] = f[x][1] = size[x] = 1;
	for(int t = head[x];t;t=e[t].next)
	{
		int to = e[t].to;
		dfs(to);
		for(int j = 1;j<= size[to]+size[x];j++)
			tmp[j] = 0;
		for(int i = 1;i<= size[x];i++)
			for(int j = 0;j<= size[to];j++)
				if(s[to]=='>')
					(tmp[i+j]+=(ll)f[x][i]*g[to][j]%mod*c[i+j-1][i-1]%mod
							  *c[size[x]-i+size[to]-j][size[x]-i]%mod)%=mod;
				else
					(tmp[i+j]+=(ll)f[x][i]*(g[to][size[to]]-g[to][j]+mod)%mod
							  *c[i+j-1][i-1]%mod
							  *c[size[x]-i+size[to]-j][size[x]-i]%mod)%=mod;
		for (int i=1; i<=size[x]+size[to]; i++)
            f[x][i] = tmp[i]%mod, g[x][i] = (g[x][i-1]+f[x][i])%mod;
        size[x] += size[to];
	}
}
int main()
{
	scanf("%d",&n);
	scanf("%s",s+2);
	c[0][0] = 1;
	for(int i = 1;i< N;i++)
	{
		c[i][0] = 1;
		for(int j = 1;j<N;j++)
			c[i][j] = (c[i-1][j-1]+c[i-1][j])%mod;
	}
	dfs(1);
	printf("%d\n",g[1][size[1]]);
	return 0;
}
Problem4826

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 200005;
typedef long long ll;
struct List
{
	struct E
	{
		int l,r,type,val,next;
	}e[N*3];
	int head[N],tot;
	void add(int x,int l,int r,int type,int val)
	{
		e[++tot].l = l;e[tot].r = r;e[tot].type = type;
		e[tot].val = val;
		e[tot].next = head[x];
		head[x] = tot;
	}
	void clear()
	{
		memset(head,0,sizeof(head));
		tot = 0;
	}
}ad,as;
struct Ask
{int l,r,id;}ask[N];
struct Seg
{
	ll sum[N<<2],lazy[N<<2];
	void Push_down(int p,int l,int r)
	{
		if(!lazy[p]||l==r)return ;
		int mid = (l+r)>>1;
		sum[p<<1]+=(ll)(mid-l+1)*lazy[p];
		sum[p<<1|1]+=(ll)(r-mid)*lazy[p];
		lazy[p<<1]+=lazy[p],lazy[p<<1|1]+=lazy[p];
		lazy[p] = 0;
	}
	void update(int p,int l,int r,int a,int b,int val)
	{
		if(a>b)return ;
		Push_down(p,l,r);
		if(l>=a&&r<=b)
		{
			sum[p]+=(ll)(r-l+1)*val;
			lazy[p]+=val;
			return ;
		}
		int mid = (l+r)>>1;
		if(a<=mid)update(p<<1,l,mid,a,b,val);
		if(b >mid)update(p<<1|1,mid+1,r,a,b,val);
		sum[p] = sum[p<<1]+sum[p<<1|1];
	}
	ll getans(int p,int l,int r,int a,int b)
	{
		if(a>b)return 0;
		Push_down(p,l,r);
		if(l>=a&&r<=b)return sum[p];
		ll ans = 0;
		int mid = (l+r)>>1;
		if(a<=mid)ans = ans+getans(p<<1,l,mid,a,b);
		if(b >mid)ans = ans+getans(p<<1|1,mid+1,r,a,b);
		return ans;
	}
}tr[2];
ll ans[N];
int l[N],r[N],stack[N],top,a[N];
int main()
{
	//freopen("test.in","r",stdin);
	int n,m,p1,p2;
	scanf("%d%d%d%d",&n,&m,&p1,&p2);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	top = 0;
	for(int i = 1;i<= n;i++)
	{
		while(top&&a[stack[top]]<a[i])r[stack[top]]=i-1,top--;
		stack[++top] = i;
	}
	while(top)r[stack[top]]=n,top--;
	for(int i = n;i>= 1;i--)
	{
		while(top&&a[stack[top]]<a[i])l[stack[top]]=i+1,top--;
		stack[++top] = i;
	}
	while(top)l[stack[top]]=1,top--;
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&ask[i].l,&ask[i].r);
		ask[i].id = i;
		as.add(ask[i].r,ask[i].l,ask[i].r,1,i);
		as.add(ask[i].l-1,ask[i].l,ask[i].r,-1,i);
	}
	for(int i = 1;i<= n;i++)
	{
		ad.add(l[i]-1,r[i]+1,r[i]+1,0,p1);
		ad.add(l[i]-1,i+1,r[i],0,p2);
		ad.add(r[i]+1,l[i],i-1,1,p2);
	}
	for(int i = 1;i<= n;i++)
	{
		for(int j = ad.head[i];j;j=ad.e[j].next)
		{
			int L = ad.e[j].l,R = ad.e[j].r,typ = ad.e[j].type,vl = ad.e[j].val;
			tr[typ].update(1,1,n,max(1,L),min(R,n),vl);
		}
		if(i!=n)tr[0].update(1,1,n,i+1,i+1,p1);
		for(int j = as.head[i];j;j=as.e[j].next)
		{
			int L = as.e[j].l,R = as.e[j].r,typ = as.e[j].type,vl = as.e[j].val;
			for(int k =0;k<2;k++)
				ans[vl]+=(ll)typ*tr[k].getans(1,1,n,L,R);
		}
	}
	for(int i = 1;i<= m;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
Problem4827

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const double PI = 3.14159265358979323;
const int N = 4e5+5;
typedef long long ll;
struct cp
{
	double x,y;
	cp(double _x=0,double _y=0):x(_x),y(_y){}
	friend cp operator +(const cp &a,const cp &b)
	{
		return cp(a.x+b.x,a.y+b.y);
	}
	friend cp operator -(const cp &a,const cp &b)
	{
		return cp(a.x-b.x,a.y-b.y);
	}
	friend cp operator *(const cp &a,const cp &b)
	{
		return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
}a[N],b[N],c[N];
void FFT(cp *a,int len,int type)
{
	int t = 0;
	for(int i = 0;i<len;i++)
	{
		if(t<i)swap(a[t],a[i]);
		for(int j = len>>1;(t^=j)<j;j>>=1);
	}
	for(int i = 2;i<= len;i<<=1)
	{
		cp wn = cp(cos(PI*2*type/i),sin(PI*2*type/i));
		for(int j = 0;j<len;j+=i)
		{
			cp t,w(1,0);
			for(int k = 0;k<(i>>1);k++,w=w*wn)
			{
				t = a[j+k+(i>>1)]*w;
				a[j+k+(i>>1)] = a[j+k]-t;
				a[j+k] = a[j+k]+t;
			}
		}
	}
	if(type==-1)
		for(int i = 0;i<len;i++)
			a[i].x/=len;
}
ll ans[N];
void conv(cp *a,cp *b,cp *c,int len)
{
	FFT(a,len,1),FFT(b,len,1);
	for(int i = 0;i<len;i++)c[i] = a[i]*b[i];
	FFT(c,len,-1);
	for(int i = 0;i<len;i++)ans[i]=(ll)(c[i].x+0.5);
}
int main()
{
	int n,m,x;
	scanf("%d%d",&n,&m);
	ll c2 = 0;
	ll c11 = 0,c12 = 0;
	for(int i = 0;i< n;i++)
	{
		scanf("%d",&x);
		c2 += x*x;
		c11+=x;
		c12-=x;
		a[i].x = x;
	}
	for(int i = 0;i< n;i++)
	{
		scanf("%d",&x);
		c2 += x*x;
		c11-=x;
		c12+=x;
		b[i].x = x;
	}
	for(int i = 0;i<n;i++)
	{
		a[i+n] = a[i];
		if(i<n-i-1)swap(b[n-i-1],b[i]);
	}
	int l = 1;
	for(l=1;l<=n*4;l<<=1);
	conv(a,b,c,l);
	ll Ans = 1e18;
	for(int i = 0;i<n;i++)
		for(int j = 0;j<=m;j++)
		{
			Ans = min(Ans,c2+c11*j*2-ans[n+i-1]*2+n*j*j);
			Ans = min(Ans,c2+c12*j*2-ans[n+i-1]*2+n*j*j);
		}
	printf("%lld\n",Ans);
	return 0;
}
Problem4828

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int N = 105;
const int B = 1e6;
int prime[N],cnt;
bool vis[N];
void get_prime()
{
	for(int i = 2;i<N;i++)
	{
		if(!vis[i])prime[cnt++] = i;
		for(int j = 0;j<cnt&&i*prime[j]<N;j++)
		{
			vis[i*prime[j]] = true;
			if(i%prime[j]==0)break;
		}
	}
}
int S[B+5];
map<int,int>s;
int n,m,mc,k,dp[N][N];
int a[N],w[N],C[N],fl[N],maxc;
int Get(int x)
{
	if(x<=B)return S[x];
	else return s[x];
}
void Update(int x,int ans)
{
	if(x<=B)S[x] = ans;
	else s[x] = ans;
}
int calc(int n)
{
	if(n<0)return INF;
	if(n==0)return 0;
	if(n==1)return 1;
	int tmp = n,end = 1;
	for(int i = 0;i< cnt;i++)
		while(tmp%prime[i]==0)
			tmp/=prime[i],end = prime[i];
	if(tmp>1)return INF;
	if(Get(n))return Get(n);
	int lim = k+1;
	for(int i = end;i<lim-1;i++)if(n%i==0)
	{
		int t = i+1;
		tmp = n;
		for(int j = i;j>=2&&t<=lim&&tmp>1;j--)
			while(tmp%j==0)
				tmp/=j,t++;
		if(tmp==1)lim= min(lim,t);
	}
	Update(n,lim);
	return lim;
}
int tmp;
void solve(int x,int pos)
{
	if(tmp==m)return ;
	int t = calc(x);
	if(t>k/2)return ;
	for(int i = pos;i>=0;i--)if((ll)prime[i]*x<=maxc)solve(x*prime[i],i);
	for(int i = 0;i<= k-2*t;i++)
	{
		for(int j = 1;j<= m;j++)
			if(!fl[j])
			{
				int l = calc(C[j]-i-x);
				if(l+i+t<=k)fl[j]=1,tmp++;
			}
	}
}
int main()
{
	get_prime();
	scanf("%d%d%d",&n,&m,&mc);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= m;i++)scanf("%d",&C[i]),maxc = max(maxc,C[i]);
	memset(dp,-1,sizeof(dp));
	dp[0][0] = mc;
	for(int i = 0;i< n;i++)
	{
		for(int j = 0;j<= i;j++)if(dp[i][j]!=-1)
		{
			if(dp[i][j]<a[i+1])continue;
			dp[i+1][j] = min(mc,max(dp[i+1][j],dp[i][j]-a[i+1]+w[i+1]));
			dp[i+1][j+1] = min(mc,max(dp[i+1][j+1],dp[i][j]-a[i+1]));
		}
		for(int j = 0;j<= n;j++)if(dp[i+1][j]!=-1)k = max(k,j);
	}
	for(int i = 1;i<= m;i++)
	{
		for(int j =0;j<k&&j<C[i];j++)fl[i]|=(calc(C[i]-j)+j<=k);
		tmp+=fl[i];
	}
	solve(1,14);
	for(int i = 1;i<= m;i++)printf("%d\n",fl[i]);
	return 0;
}
Problem4831

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int INF = 0x3f3f3f3f;
const int N = 1e5+5;
const int M = 1e6+5;
int f[2][M][2],mn[M],a[N];
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int n;
		scanf("%d",&n);
		for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
		f[0][0][0] = 0,f[0][0][1] = INF;
		int now = 0,nxt = 1,i,j,s,k;
		for(i = 0;i< n;i++)
		{
			for(j = 0;j<= a[i+1];j++)
				f[nxt][j][0]=f[nxt][j][1]=INF;
			for(j = a[i];j>= 0;j--)
			{
				mn[j] = min(f[now][j][0],j==a[i]?INF:mn[j+1]);
				if(j<=a[i+1])
				{
					for(s = 0;s<2;s++)
					f[nxt][a[i+1]-j][0] = min(f[nxt][a[i+1]-j][0],f[now][j][s]+j);
				}else
					f[nxt][0][1] = min(f[nxt][0][1],f[now][j][0]+a[i+1]);
			}
			for(k = a[i+1];k>=0;k--)
				f[nxt][a[i+1]-k][1] = min(f[nxt][a[i+1]-k][1],(k+1>a[i])?INF:(mn[k+1]+k));
			swap(nxt,now);
		}
		int ans1 = min(f[now][0][0],f[now][0][1]);
		for(j = 0;j<= a[n];j++)
			ans1 = min(ans1,f[now][j][0]);
		f[0][0][0] = 0,f[0][0][1] = -INF;
		now = 0,nxt = 1;
		for(i = 0;i< n;i++)
		{
			for(j = 0;j<= a[i+1];j++)
				f[nxt][j][0]=f[nxt][j][1]=-INF;
			for(j = a[i];j>= 0;j--)
			{
				mn[j] = max(f[now][j][0],j==a[i]?-INF:mn[j+1]);
				if(j<=a[i+1])
				{
					for(s = 0;s<2;s++)
					f[nxt][a[i+1]-j][0] = max(f[nxt][a[i+1]-j][0],f[now][j][s]+j);
				}else
					f[nxt][0][1] = max(f[nxt][0][1],f[now][j][0]+a[i+1]);
			}
			for(k = a[i+1];k>=0;k--)
				f[nxt][a[i+1]-k][1] = max(f[nxt][a[i+1]-k][1],(k+1>a[i])?-INF:(mn[k+1]+k));
			swap(nxt,now);
		}
		int ans2 = max(f[now][0][0],f[now][0][1]);
		for(j = 0;j<= a[n];j++)
			ans2 = max(ans2,f[now][j][0]);
		printf("%d %d\n",ans1,ans2);
	}
	return 0;
}
Problem4833

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
ll f[N],g[N];
int n,p;
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res=(ll)res*x%p;
		x = (ll)x*x%p;
		y>>=1;
	}
	return res;
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&p);
		f[1] = g[1] = 1,f[2] = g[2] = 2;
		for(int i = 3;i<= n;i++)
			f[i] = ((f[i-1]<<1)+f[i-2])%p,g[i] = f[i];
		for(int i = 1;i<= n;i++)
		{
			int inv = quick_pow(g[i],p-2);
			for(int j = i+i;j<= n;j+=i)
				g[j] = (ll)g[j]*inv%p;
		}
		ll lcm = 1,ans = 0;
		for(int i = 1;i<= n;i++)
			lcm = (ll)lcm*g[i]%p,(ans+=lcm*i%p)%=p;
		printf("%lld\n",ans);
	}
}
Problem4835

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 1e9+7;
struct E
{int next,to;}e[N<<1];
int head[N],tot,big[N],f[N],fa[N],size[N];
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
}
void dfs(int x)
{
	f[x] = 1;size[x]=1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		size[x]+=size[e[i].to];
	}
	for(int i = head[x];i;i=e[i].next)
	{
		if(size[e[i].to]<<1==size[x])
			f[x] = (ll)f[x]*big[e[i].to]%mod*f[e[i].to]%mod;
		else
			f[x] = (ll)f[x]*size[e[i].to]%mod*f[e[i].to]%mod;
	}
}
int main()
{
	//freopen("x.in","r",stdin);
	int n,m;
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		scanf("%d%d",&n,&m);
		for(int i = 1;i<= n;i++)head[i]=big[i]=fa[i]=0;tot = 0;
		int x,y;
		for(int i = 1;i<n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);fa[y] = x;
		}
		for(int i = 1;i<= n;i++)
		{
			int now = i;
			while(now)
			{
				if(fa[now]<i)big[now]++;
				now = fa[now];
			}
		}
		for(int i = 1;i<= n;i++)
			if(!fa[i])
			{
				dfs(i);
				printf("%d\n",f[i]);
				break;
			}
	}
	return 0;
}
Problem4849

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int INF = 0x3f3f3f3f;
struct data
{
	int mn,dep,lazy;
	void add(int x)
	{
		mn+=x,dep+=x,lazy+=x;
	}
}a[N];
int ef[N],et[N],n,m;
void Push_up(int p)
{
	int l = p<<1,r = p<<1|1;
	a[p].mn = ef[p]?a[p].dep:INF;
	if(l<=n)a[p].mn = min(a[p].mn,a[l].mn);
	if(r<=n)a[p].mn = min(a[p].mn,a[r].mn);
}
void Push_down(int p)
{
	if(!a[p].lazy)return ;
	int l = p<<1,r = p<<1|1;
	if(l<=n)a[l].add(a[p].lazy);
	if(r<=n)a[r].add(a[p].lazy);
	a[p].lazy = 0;
}
void relax(int p)
{
	if(!p)return ;
	relax(p>>1);
	Push_down(p);
}
void dfs(int x,bool f)
{
	Push_down(x);
	if(ef[x]&&a[x].dep==a[x].mn)
		ef[x]--;
	else
	{
		int to = (x<<1)^(a[x].mn!=a[x<<1].mn);
		dfs(to,1);
	}
	Push_up(x);
	if(f&&!++et[x])a[x].add(2);
}
int ans = 0;
void get_max_flow(int x)
{
	relax(x);
	int mc = INF,mw,c1 = 0;
	for(int i = x;i;i>>=1)
	{
		int c2 = c1+a[i].mn-a[i].dep;
		if(c2<mc)
		{
			mc = c2;
			mw = i;
		}
		c1+=et[i]>0?-1:1;
	}
	for(int i = x;i!=mw;i>>=1)
	{
		Push_up(i);
		if(!et[i]--)a[i].add(-2);
	}
	dfs(mw,0);
	for(;mw;mw>>=1)Push_up(mw);
	ans+=mc;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i<= n;i++)scanf("%d",&ef[i]);
	for(int i = 1;i<= n;i++)a[i].dep = a[i>>1].dep+1;
	int x;
	for(int i = n;i;i--)Push_up(i);
	for(int i = 1;i<= m;i++)
	{
		if(i!=1)printf(" ");
		scanf("%d",&x);
		get_max_flow(x);
		printf("%d",ans);
	}
	return 0;
}
Problem4860

#include <cstdio>
#include <cctype>
#include <algorithm>
const int maxn=400010,inf=2000000010;
int ans,n,x,y,z,i,m,l,r,c[maxn*3],cnt;
inline int max(int a,int b)
{
	return a>b?a:b; 
}
inline void up(int&a,const int&b)
{
	if(a<b)a=b;
}
struct edge{int from,to,color;}e[maxn<<1];
struct data{int dep,sum;};
struct node{int v,lc,rc;}a[maxn*5];
int merge(int x,int y)
{
	if(!x || !y )return x|y;
	a[x].lc=merge(a[x].lc,a[y].lc);
	a[x].rc=merge(a[x].rc,a[y].rc);
	up(a[x].v,a[y].v);
	return x;
}
void add(int&i,int rl,int rr,int x,int v)
{
	if(!i)a[i=++cnt]=(node){v,0,0};
		else up(a[i].v,v);
	if(rl<rr)
	{
		int m=(rl+rr)>>1;
		if(x>m)add(a[i].rc,m+1,rr,x,v);
			else add(a[i].lc,rl,m,x,v);
	}
}
int query(int i,int rl,int rr,int l,int r)
{
	if(!i)return -inf;
	if(rl==l && rr==r)return a[i].v;
	int m=(rl+rr)>>1;
	if(l>m)return query(a[i].rc,m+1,rr,l,r);
		else if(r<=m)return query(a[i].lc,rl,m,l,r);
			else return max(query(a[i].lc,rl,m,l,m),query(a[i].rc,m+1,rr,m+1,r));
}
struct tree
{
	int xb,h[maxn],n,size[maxn],f[maxn],rt,sum,dep[maxn],ll,ss[maxn];
	bool b[maxn];
	data w[maxn];
	void addedge(int x,int y,int z)
	{
		e[++xb]=(edge){y,x,z};
		e[++xb]=(edge){x,y,z};
	}
	void dfs(int x,int fa)
	{
		size[x]=f[x]=1;
		for(int i=h[x];i<h[x+1];++i)
		{
			int y=e[i].to;
			if(y!=fa && !b[y])
			{
				dfs(y,x);
				size[x]+=size[y];
				up(f[x],size[y]);
			}
		}
		up(f[x],sum-size[x]);
		if(f[rt]>f[x])rt=x;
	}
	void got(int x,int fa,int dep,int color,int sum)
	{
		for(int y,i=h[x];i<h[x+1];++i)
		{
			y=e[i].to;
			if(y!=fa && !b[y])
			{
				if(e[i].color==color)w[++ll]=(data){dep+1,sum};
					else w[++ll]=(data){dep+1,sum+c[e[i].color]};
				got(e[i].to,x,dep+1,e[i].color,w[ll].sum);
			}
		}
	}
	void solve(int x)
	{
		b[x]=1;
		int i,rt1=0,rt2=cnt=0,j;
		for(i=h[x];i<h[x+1];++i)
		{   
			if(i>h[x] && e[i].color>e[i-1].color)rt1=merge(rt1,rt2),rt2=0;         
			if(!b[e[i].to])
			{
				w[ll=1]=(data){1,c[e[i].color]};
				got(e[i].to,x,1,e[i].color,c[e[i].color]);
				ss[i]=ll;
				for(j=1;j<=ll;++j)if(w[j].dep<=r)
				{
					if(w[j].dep>=l)up(ans,w[j].sum);
					if(w[j].dep<r)
					{
						up(ans,query(rt1,1,n,max(1,l-w[j].dep),r-w[j].dep)+w[j].sum);
						up(ans,query(rt2,1,n,max(1,l-w[j].dep),r-w[j].dep)-c[e[i].color]+w[j].sum);
					}
				}
				for(j=1;j<=ll;++j)if(w[j].dep<=r)add(rt2,1,n,w[j].dep,w[j].sum);
			}
		}
		for(i=h[x];i<h[x+1];++i)
			if(!b[e[i].to])
			{
				sum=ss[i];
				rt=0;
				dfs(e[i].to,x);
				solve(rt);
			}
	}
}t;
bool cmp(const edge&a,const edge&b)
{
	return a.from==b.from?a.color<b.color:a.from<b.from;
}
int main()
{
	a[0].v=-inf;
	scanf("%d%d%d%d",&n,&m,&l,&r);
	t.n = n;
	for(i=1;i<=m;++i)scanf("%d",&c[i]);
	for(i=1;i<n;++i)
	{
		scanf("%d%d%d",&x,&y,&z);
		t.addedge(x,y,z);
	}
	std::sort(e+1,e+((n-1)*2)+1,cmp);
	for(i=1;i<=((n-1)<<1);++i)
		if(!t.h[e[i].from])t.h[e[i].from]=i;
	t.h[n+1]=(n-1)<<1|1; 
	t.f[t.rt=0]=inf;
	t.sum=n;
	ans=-inf;
	t.dfs(1,0);
	t.solve(t.rt);
	printf("%d\n",ans);
}
Problem4861

#include <bits/stdc++.h>
const int mod = 1e9+7;
using namespace std;
typedef long long LL;
int len[105],cnt,n,m,l,ans;
char s[55][105];
inline void inc(int &x,int y) {x=(x+y)%mod;}

struct Trie{
	int ch[205][27],leef[205],fail[205];
	char s[205];
	void add() {
		scanf("%s",s+1); int n = strlen(s+1);
		int p = 0;
		for (int i=1;i<=n;i++) {
			int c = s[i] - 'a';
			if (!ch[p][c]) ch[p][c] = ++cnt;
			p = ch[p][c];
		}
		leef[p] = 1;
	}

	void set() {
		queue<int> q;
		for (int i=0;i<26;i++) if (ch[0][i])
			fail[ ch[0][i] ] = 0, q.push(ch[0][i]);

		while (!q.empty()) {
			int u=q.front(); q.pop();
			for (int i=0;i<26;i++) if (ch[u][i]) {
				int v = ch[u][i], t = fail[u];
				while (t && !ch[t][i]) t = fail[t];
				fail[v] = ch[t][i];
				leef[v] = leef[v] || leef[ fail[v] ];
				q.push(v);
			}
		}
	}

	int g(int u,char *s) {
		int len = strlen(s+1);
		for (int i=1;i<=len;i++) {
			int c = s[i]-'a';
			while (u && !ch[u][c]) u = fail[u];
			if (ch[u][c]) u = ch[u][c];
			if (leef[u]) return -1;
		}
		return u;
	}

}T;

namespace planA
{
	int F[105][5050];
	void solve() 
	{
		F[0][0] = 1;
		for (int _=0;_<l;_++)
			for (int i=0;i<=cnt;i++) if (F[_][i])
				for (int j=1;j<=n;j++) if (_+len[j]<=l) 
				{
					int ni = T.g(i,s[j]);
					if (ni == -1) continue;
					inc(F[_+len[j]][ni], F[_][i]);
				}
		for (int _=0;_<=cnt;_++) inc(ans, F[l][_]);
		cout << ans << endl;
	}
}

namespace planB
{

	struct Matrix{int a,d[205][205];}A,B,id;

	Matrix operator*(Matrix p1, Matrix p2) 
	{
		Matrix ret = id;ret.a = p1.a;
		for (int i=0;i<=p1.a;i++)
			for (int j=0;j<=p1.a;j++)
				for (int k=0;k<=p1.a;k++)
					inc(ret.d[i][j], 1LL*p1.d[i][k] * p2.d[k][j] % mod);
		return ret;
	}

	Matrix qp(Matrix A, int b) 
	{
		Matrix ret = id;
		ret.a = A.a;
		for (int i=0;i<=A.a;i++) ret.d[i][i] = 1;

		while (b) 
		{
			if (b&1) ret = ret * A;
			b >>= 1, A = A * A;
		}
		return ret;
	}

	void solve() 
	{
		int tp = cnt+1;
		A.a = B.a = 2*tp-1;
		A.d[0][0+tp] = 1;

		for (int i=0;i<=cnt;i++) B.d[i+tp][i] = 1;
		for (int i=0;i<=cnt;i++) 
		{
			for (int j=1;j<=n;j++) 
			{
				int ni = T.g(i,s[j]);
				if (ni == -1) continue;
				if (len[j] == 1)
					B.d[i+tp][ni+tp]++;
				else
					B.d[i][ni+tp]++;
			}
		}
		A = A * B;
		B = qp(B, l);
		A = A * B;
		for (int i=0;i<=cnt;i++) inc(ans, A.d[0][i]);
		cout << ans << endl;
	}
}

int main() 
{
	scanf("%d%d%d",&n,&m,&l);
	for (int i=1;i<=n;i++) 
		scanf("%s",s[i]+1), len[i] = strlen(s[i]+1);
	for (int i=1;i<=m;i++) 
		T.add();
	T.set();
	if (l <= 100) planA::solve(); else planB::solve();
	return 0;
}
Problem4866

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int S = 1<<26;
const int N = 60005;
unsigned short cnt[S+5];
char s[N];
int ans[N],num[N];
int pos[N],pre[N],lb[N],rb[N];
inline char nc(){
	static char buf[100000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline void read(int &x){
	char c=nc(),b=1;
	for (;!(c>='0' && c<='9');c=nc()) if (c=='-') b=-1;
	for (x=0;c>='0' && c<='9';x=x*10+c-'0',c=nc()); x*=b;
}
inline void read(char *s){
	char c=nc(); int len=0;
	for (;!(c>='a' && c<='z');c=nc());
	for (;c>='a' && c<='z';s[++len]=c,c=nc());
}
inline void write(ll x){
	if (x>=10) write(x/10); putchar(x%10+'0');
}

inline void add(int x)
{
	cnt[x]++;
	for(register int i = 0;i<26;i++)cnt[x^(1<<i)]++;
}
inline void del(int x)
{
	cnt[x]--;
	for(register int i = 0;i<26;i++)cnt[x^(1<<i)]--;
}
inline int getans(int x){return cnt[x];}
struct Q
{
	int l,r,id;
	Q(int _l=0,int _r=0,int _id=0):l(_l),r(_r),id(_id){}
	bool operator <(const Q &s)const
	{
		return pos[l]==pos[s.l]?r<s.r:pos[l]<pos[s.l];
	}
}ask[N];
int block;
int main()
{
	//freopen("4866.in","r",stdin);
	//freopen("4866.out","w",stdout);
	int n,m,i,j,k;
	read(n),read(m);
	block = min((int)sqrt(n*28),n);
	read(s);
	for(i = 1;i<= n;i++)pre[i] = pre[i-1]^(1<<(s[i]-'a'));
	int tot = 0;
	for(i = 1;i<= n;i++)
		pos[i] = (i-1)/block+1;
	tot = pos[n];
	for(i = 1;i<= tot;i++)
		lb[i] = (i-1)*block+1,rb[i] = i*block;
	rb[tot] = n;
	for(i =1;i<= tot;i++)
	{
		add(pre[rb[i]]);
		for(j = rb[i]-1;j>=lb[i]-1;j--)
		{
			num[j+1] = num[j+2]+getans(pre[j]);
			add(pre[j]);
		}
		for(j = rb[i];j>=lb[i]-1;j--)
			del(pre[j]);
	}
	int L,R,Cnt = 0;
	for(i = 1;i<= m;i++)
	{
		read(L),read(R);
		if(pos[L]==pos[R])
		{
			add(pre[L-1]);
			for(j = L;j<= R;j++)
				ans[i]+=getans(pre[j]),add(pre[j]);
			for(j = L-1;j<= R;j++)
				del(pre[j]);
		}else
			ask[++Cnt] = Q(L,R,i);
	}
	sort(ask+1,ask+Cnt+1);
	int last = 0,pnt = 0;
	for(i = 1;i<tot;i++)
	{
		last = pnt;
		while(pnt+1<=Cnt&&pos[ask[pnt+1].l]==i)pnt++;
		int r = lb[i+1]-1;
		ll now = 0;
		add(pre[r]);
		for(j = last+1;j<= pnt;j++)
		{
			while(r<ask[j].r)now+=getans(pre[++r]),add(pre[r]);
			ans[ask[j].id] = now+num[ask[j].l];
			del(pre[lb[i+1]-1]);
			for(k = ask[j].l-1;k< rb[i];k++)
				ans[ask[j].id]+=getans(pre[k]);
			add(pre[lb[i+1]-1]);
		}
		for(j = lb[i+1]-1;j<= r;j++)del(pre[j]);
	}	
	for(i = 1;i<= m;i++)write(ans[i]),putchar('\n');
	return 0;
}
Problem4867

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
struct E
{int next,to,val;}e[N<<1];
int head[N],tot;
int dis[N],dfn[N],Dfn,size[N];
void add(int x,int y,int f)
{
	e[++tot].to = y;e[tot].next = head[x];e[tot].val = f;head[x] = tot;
}
void dfs(int x)
{
	dfn[x] = ++Dfn;
	size[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dis[e[i].to] = dis[x]+e[i].val;
		dfs(e[i].to);
		size[x]+=size[e[i].to];
	}
}
const int M = 2e7+5;
const int Bs = 510;
int B;
int n,Q,len;
int pos[N],_a[N],lb[Bs],rb[Bs],mx[Bs],mn[Bs],Size[Bs],cnt,tag[N];
int qo[N],ql[N],qr[N],qk[N];
int F[M];
#define f(i,j) (*(F+Size[(i)-1]+(j)-mn[(i)]))
void Build()
{
	cnt = 0;
	B = sqrt(n);
	for(int i = 1;i<= n;i+=B)
		lb[++cnt] = i,rb[cnt] = i+B-1;
	rb[cnt] = n;
	for(int i = 1;i<= cnt;i++)
		for(int j = lb[i];j<= rb[i];j++)pos[j] = i;
	for(int i = 1;i<= cnt;i++)mx[i]=-1<<30,mn[i]=1<<30;
	for(int i = 1;i<= n;i++)
		mx[pos[i]] = max(mx[pos[i]],_a[i]),mn[pos[i]] = min(mn[pos[i]],_a[i]);
	for(int i = 1;i<= Q;i++)
		if(qo[i]==2)
			mx[pos[ql[i]]]+=qk[i],mx[pos[qr[i]]]+=qk[i];
	for(int i = 1;i<= cnt;i++)
		mn[i]--,Size[i] = Size[i-1]+mx[i]-mn[i];
	for(int i = 1;i<= n;i++)f(pos[i],_a[i])++;
	for(int i = 1;i<= cnt;i++)
		for(int j = mn[i]+2;j<=mx[i];j++)
			f(i,j)+=f(i,j-1);
}
void Add(int l,int r,int d)
{
	int L = pos[l],R = pos[r];
	if(L==R)
	{
		for(int i = l;i<= r;i++)
		{
			for(int j = _a[i]+tag[L];j<= _a[i]+tag[L]+d-1;j++)
				f(L,j)--;
			_a[i]+=d;
		}
		return ;
	}
	for (int i=L+1;i<R;i++) tag[i]+=d,mn[i]+=d;
	for (int i=l;i<=rb[L];i++)
	{
		for (int j=_a[i]+tag[L];j<=_a[i]+tag[L]+d-1;j++)
			f(L,j)--;
		_a[i]+=d;
	}
	for (int i=lb[R];i<=r;i++)
	{
		for (int j=_a[i]+tag[R];j<=_a[i]+tag[R]+d-1;j++)
			f(R,j)--;
		_a[i]+=d;
	}
}
int tmp[N],pnt;

int getans(int l,int r,int K)
{
	if (K>r-l+1) return -1;
	int lbd=pos[l],rbd=pos[r];
	if (lbd==rbd)
	{
		pnt=0;
		for (int i=l;i<=r;i++) tmp[++pnt]=_a[i]+tag[lbd];
		nth_element(tmp+1,tmp+K,tmp+pnt+1);
		return tmp[K];
	}
	pnt=0;
	for (int i=l;i<=rb[lbd];i++) tmp[++pnt]=_a[i]+tag[lbd];
	for (int i=lb[rbd];i<=r;i++) tmp[++pnt]=_a[i]+tag[rbd];
	sort(tmp+1,tmp+pnt+1);
	int L=-1,R=(n+Q)*len;
	while (L+1<R)
	{
		int MID=(L+R)>>1;tot=0;
		if (L<100000 && R>100000) MID=100000;
		for (int i=lbd+1;i<rbd;i++) 
			if (MID>mn[i]) 
				tot+=f(i,min(MID,mx[i]+tag[i]));
		tot+=upper_bound(tmp+1,tmp+pnt+1,MID)-tmp-1;
		if (tot<K)
			L=MID;
		else
			R=MID;
	}
	return R;
}
int main()
{
	scanf("%d%d%d",&n,&Q,&len);
	int p,d;
	for(int i = 2;i<= n;i++)
	{
		scanf("%d%d",&p,&d);
		add(p,i,d);
	}
	dfs(1);
	for(int i = 1;i<= n;i++)_a[dfn[i]]=dis[i];
	for(int i = 1;i<= Q;i++)
	{
		scanf("%d%d%d",&qo[i],&p,&qk[i]);
		ql[i] = dfn[p],qr[i] = dfn[p]+size[p]-1;
	}
	Build();
	for(int i = 1;i<= Q;i++)
		if(qo[i]==2)Add(ql[i],qr[i],qk[i]);
		else printf("%d\n",getans(ql[i],qr[i],qk[i]));
	return 0;
}
Problem4878

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1005;
const int M = 2e4+5;
struct E
{int next,to;}e[M];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int col[N],vis[N],Dfn;
void dfs(int x)
{
	Dfn++;
	for(int i = head[x];i;i=e[i].next)
		vis[col[e[i].to]] = Dfn;
	for(int i = 1;;i++)
		if(vis[i]<Dfn)
		{
			col[x] = i;
			break;
		}
	for(int i = head[x];i;i=e[i].next)
		if(!col[e[i].to])dfs(e[i].to);
}
void init()
{
	memset(vis,0,sizeof(vis));
	memset(col,0,sizeof(col));
	memset(head,0,sizeof(head)),tot = 0,Dfn = 0;
}
int main()
{
	int cas,n,m,k,x,y;
	scanf("%d",&cas);
	while(cas--)
	{
		init();
		scanf("%d%d%d",&n,&m,&k);
		for(int i = 1;i<= m;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);
		}
		for(int i = 1;i<= n;i++)
			if(!col[i])dfs(i);
		bool cola = true;
		for(int i = 1;i<= n;i++)
			if(col[i]>k)
			{
				cola = false;
				if(col[i]==k+1)x = i;
			}
		if(cola)
		{
			printf("color");
			for(int i = 1;i<= n;i++)
				printf(" %d",col[i]);
			printf("\n");
			continue;
		}
		printf("path");
		for(int i =1;i<= k+1;i++)
		{
			printf(" %d",x);
			for(int j = head[x];j;j=e[j].next)
				if(col[e[j].to]==col[x]-1)
				{x = e[j].to;break;}
		}
		printf("\n");
	}
	return 0;
}
Problem4879

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e6+5;
set<int>sx[N],sy[N];
set<int>::iterator it;
int dx[]={1,0,-1,0};
int dy[]={0,1,0,-1};
int n,m,K,opt[N],d[N];
ll L,R;
char s[N];
char ask(int x,int y,int flag)
{
	if(flag)swap(x,y);
	return s[x*m+y];
}
void solve(set<int> &s,int st,int end,ll tl,int wh,bool flag)
{
	int l = st,r = end;
	if(l>r)swap(l,r);
	for(it = s.lower_bound(l);it!=s.end()&&*it<=r;)
	{
		if(flag) sx[*it].erase(sx[*it].find(wh));
        else sy[*it].erase(sy[*it].find(wh));
        if(ask(wh,*it,flag)=='#') L=max(L,tl-abs(*it-st));
        else R=min(R,tl-abs(*it-st)-1);
        s.erase(it++);
	}
}
void debug()
{
	for(int i = 0;i<n&&L<=R;i++)
	{
		for(it=sx[i].begin();it!=sx[i].end();it++)
			printf("%d ",*it);
		puts("");
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for(int i = 0;i<n;i++)
		scanf("%s",s+i*m);
	char op[10];
	for(int i = 1;i<= K;i++)
	{
		scanf("%s",op);
		if(op[0]=='l')opt[i] = 3;
		else if(op[0]=='r')opt[i] = 1;
		else if(op[0]=='u')opt[i] = 2;
		else opt[i] =0;
		scanf("%d",&d[i]);
	}
	for(int i = 0;i<n;i++)for(int j = 0;j<m;j++)sx[i].insert(j);
	for(int i = 0;i<n;i++)for(int j = 0;j<m;j++)sy[j].insert(i);
	int curx = n-1,cury = 0;ll t = 1;
	for(int i = 1;i<= K;i++)
	{
		t+=d[i];
		curx+=d[i]*dx[opt[i]],cury+=d[i]*dy[opt[i]];
	}
	R = t;
	for(int i = K;i;i--)
	{
		int tp = (opt[i]+2)%4;
		int nx = curx+d[i]*dx[tp],ny = cury+d[i]*dy[tp];
		if(tp%2)solve(sx[curx],cury,ny,t,curx,false);
		else solve(sy[cury],curx,nx,t,cury,true);
		t-=d[i],curx=nx,cury=ny;
	}
	for(int i = 0;i<n&&L<=R;i++)
		for(it=sx[i].begin();it!=sx[i].end();it++)
		{
			if(ask(i,*it,false)=='#')
			{
				L = R+1;break;
			}
		}
	if(L>R)L = R = -1;
	printf("%lld %lld\n",L,R);
	return 0;
}
Problem4880

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
int n,X,Y;
struct Line
{
	int x,y;
	Line(){}
	Line(int _x,int _y):x(_x),y(_y){}
	bool operator <(const Line &s)const
	{
		bool pd = ((x<0)^(s.x<0));
		return pd?y*s.x>x*s.y:y*s.x<x*s.y;
	}
}k1[N],k2[N];
int tot1,tot2,L1,L2,ans1,ans2;
int cur0[2],cur1[2];
int main()
{
	int a,b;
	scanf("%d%d%d",&n,&X,&Y);n--;
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a,&b);
		if(a<X)k1[++tot1] = Line(X-a,b-Y);
		else if(a>X)k2[++tot2] = Line(X-a,b-Y);
		else
		{
			if(b<Y)L1++,L2++;
			else if(b==Y)L1++;
		}
		cur1[0]+=a<=X;
		cur1[1]+=a<X;
		cur0[0]+=b<=Y;
		cur0[1]+=b<Y;
	}
	sort(k1+1,k1+tot1+1);sort(k2+1,k2+tot2+1);
	ans1 = 0,ans2 = n+4;
	for(int i = 1;i<= tot1;i++)
	{
		if(k1[i].x*k1[i].y<0)continue;
		a = i-1,b = i;
		int p1 = lower_bound(k2+1,k2+tot2+1,k1[i])-k2;
		int p2 = upper_bound(k2+1,k2+tot2+1,k1[i])-k2;
		a+=(tot2-p2+1),b+=(tot2-p1+1);
		ans1 = max(ans1,b),ans2 = min(ans2,a);
	}
	for(int i = 1;i<= tot2;i++)
	{
		if(k2[i].x*k2[i].y<0)continue;
		a = tot2-i,b = tot2-i+1;
		int p1 = lower_bound(k1+1,k1+tot1+1,k2[i])-k1;
		int p2 = upper_bound(k1+1,k1+tot1+1,k2[i])-k1;
		a+=(p1-1),b+=(p2-1);
		ans1 = max(ans1,b),ans2 = min(ans2,a);
	}
	ans1+=L1,ans2+=L2;
	ans1 = max(ans1,max(cur1[0],cur0[0]));
	ans2 = min(ans2,min(cur1[1],cur0[1]));
	printf("%d %d\n",n+1-ans1,n+1-ans2);
	return 0;
}
Problem4881

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 998244353;
int c[N],a[N],f[N];
int getans(int x)
{
	int ans = 0;
	for(int i = x;i;i-=i&(-i))ans=max(ans,c[i]);
	return ans;
}
void update(int x,int y)
{
	for(int i = x;i<N;i+=i&(-i))c[i] = max(c[i],y);
}
int quick_pow(int x,int y)
{
	int res = 1;
	while(y)
	{
		if(y&1)res = (ll)res*x%mod;
		x = (ll)x*x%mod;
		y>>=1;
	}
	return res;
}
set<int>S;
set<int>::iterator it;
set<int>::iterator tmp;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)scanf("%d",&a[i]);
	int mx = 0;
	for(int i = 1;i<= n;i++)
	{
		f[i] = getans(n-a[i])+1;
		update(n-a[i]+1,f[i]);
		mx = max(mx,f[i]);
	}
	if(mx>2)
	{
		puts("0");
		return 0;
	}
	for(int i = 1;i<= n;i++)
	{
		int mx = a[i];
		it = S.upper_bound(a[i]);
		while(it!=S.end())
		{
			mx = max(mx,*it);
			tmp = it;
			it++;S.erase(tmp);
		}
		S.insert(mx);
	}
	printf("%d\n",quick_pow(2,S.size()));
	return 0;
}
Problem4886

#include <stdio.h>
#include <map>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 250005;
int cnt,mx;
int a[N],b[N],g[N<<1],idx[N<<1],fa[N<<1],mxv[N<<1];
bool d[N<<1];
map<int,int>h;
int getfa(int x)
{
	if(fa[x]==x)return x;
	else return fa[x]=getfa(fa[x]);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
		idx[++cnt]=a[i],idx[++cnt]=b[i];
	}
	sort(idx+1,idx+cnt+1);
	for(int i = 1;i<= cnt;i++)
		if(i==1||idx[i]!=idx[i-1])
			g[h[idx[i]]=++mx] = idx[i];
	long long ans = 0;
	for(int i = 1;i<= mx;i++)
	{
		fa[i] = i;mxv[i] = g[i];
		ans-=g[i];
	}
	for(int i = 1;i<= n;i++)
	{
		ans+=a[i]+b[i];
		int fx = getfa(h[a[i]]),fy = getfa(h[b[i]]);
		if(fx!=fy)
		{
			d[fx]|=d[fy];
			mxv[fx] = max(mxv[fx],mxv[fy]);
			fa[fy] = fx;
		}else
			d[fx] = true;
	}
	for(int i = 1;i<= mx;i++)
		if(getfa(i)==i&& !d[i])ans+=mxv[i];
	printf("%lld\n",ans);
	return 0;
}
Problem4887

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int mod = 2017;
struct Martix
{
	int d[35][35];
	int w,h;
	Martix(int _w=0,int _h=0):w(_w),h(_h){memset(d,0,sizeof(d));}
	Martix operator *(const Martix &s)const
	{
		Martix res(s.w,h);
		for(int i = 1;i<= res.w;i++)
			for(int k = 1;k<= s.h;k++)
				if(s.d[i][k])
					for(int j = 1;j<= res.h;j++)
						(res.d[i][j]+=s.d[i][k]*d[k][j]%mod)%=mod;
		return res;
	}
	friend Martix operator ^(const Martix &a,int s)
	{
		Martix res(a.w,a.h);
		Martix t = a;
		for(int i = 1;i<= a.w;i++)res.d[i][i] = 1;
		while(s)
		{
			if(s&1)res = res*t;
			t = t*t;
			s>>=1;
		}
		return res;
	}
};
int main()
{
	int n,m;
	int x,y;
	scanf("%d%d",&n,&m);
	Martix go(n+1,n+1),ans(n+1,1);
	for(int i = 1;i<= m;i++)
	{
		scanf("%d%d",&x,&y);
		go.d[x][y]++;
		go.d[y][x]++;
	}
	for(int i = 1;i<= n+1;i++)
		go.d[i][i]=1,go.d[n+1][i]=1;
	ans.d[1][1] = 1;
	int t;
	scanf("%d",&t);
	ans = ans*(go^t);
	int Ans = 0;
	for(int i = 1;i<= n+1;i++)(Ans+=ans.d[i][1])%=mod;
	printf("%d\n",Ans);
	return 0;
}
Problem4888

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 1e5+5;
const int Max = 1e6+1e5;
int c[2][Max];
int a[N],ans[N],n;
inline int Get_bit(int x,int y)
{
	return (x>>(y-1))&1;
}
void Update(int id,int x,int y)
{
	for(int i = x;i<Max;i+=i&(-i))
		c[id][i]+=y;
}
int Getans(int id,int x)
{
	int res = 0;
	for(int i = x;i;i-=i&(-i))
		res+=c[id][i];
	return res;
}

int main()
{
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		a[i]+=a[i-1];
	}
	for(int i = 1,ba = 1;i<= 20;i++)
	{
		memset(c,0,sizeof(c));
		for(int j = 1;j<= n;j++)
		{
			ans[i]+=Getans(Get_bit(a[j],i),ba+1)-Getans(Get_bit(a[j],i),a[j]%ba+1)
			+Getans(!Get_bit(a[j],i),a[j]%ba+1)+Get_bit(a[j],i);
			Update(Get_bit(a[j],i),a[j]%ba+1,1);
		}
		ba = ba<<1;
	}
	int Ans = 0;
	for(int i = 1,ba = 1;i<= 20;i++,ba<<=1)Ans+=(ans[i]&1)*ba;
	printf("%d\n",Ans);
	return 0;
}
Problem4889

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e4+5;
const int B = 500;
const int mod = 1e9+7;
int st[B],end[B],bel[N],n;
struct data
{
	int a,v;
	bool operator <(const data &s)const
	{
		if(a==s.a)return v<s.v;
		return a<s.a;
	}
}ord[B][B+5],num[N];
int sum[B][B+5];
ll tot_ans;
struct Bit_array
{
	int c[N];
	int getans(int x)
	{
		int ans = 0;
		for(int i = x;i;i-=i&(-i))
			(ans+=c[i])%=mod;
		return ans;
	}
	void update(int x,int y)
	{
		for(int i = x;i<N;i+=i&(-i))
			(c[i]+=y)%=mod;
	}
	int getans(int x,int y)
	{
		return (getans(y)-getans(x-1)+mod)%mod;
	}
}c1,c2;
int less_than(int x,int block)
{
	int l = 1,r = end[block]-st[block]+2;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(ord[block][mid].a<x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
int bigger_than(int x,int block)
{
	int l = 1,r = end[block]-st[block]+2;
	while(l<r)
	{
		int mid = (l+r)>>1;
		if(ord[block][mid].a<=x)l = mid+1;
		else r = mid;
	}
	return l-1;
}
void rebuild(int i)
{
	for(int j = st[i];j<=end[i];j++)
			ord[i][j-st[i]+1] = num[j];
	sort(ord[i]+1,ord[i]+end[i]-st[i]+2);
	for(int k = 1;k<= end[i]-st[i]+1;k++)
		sum[i][k] = sum[i][k-1]+ord[i][k].v;
}
int main()
{
	int m;
	scanf("%d%d",&n,&m);
	int bsize = sqrt(0.7*n)+1;
	for(int i = 1;i<= n;i++)
		scanf("%d%d",&num[i].a,&num[i].v);
	for(int i = 1;i<= n;i++)
	{
		tot_ans+=(c2.getans(num[i].a+1,n)+(ll)c1.getans(num[i].a+1,n)*num[i].v%mod)%mod;
		tot_ans = (tot_ans%mod+mod)%mod;
		c1.update(num[i].a,1);
		c2.update(num[i].a,num[i].v);
	}
	int bnum = 0;
	for(int i = 1;i<= n;i+=bsize)
		st[++bnum]=i,end[bnum]=i+bsize-1;
	end[bnum] = n;
	int j;
	for(int i = 1;i<= bnum;i++)
	{
		for(j = st[i];j<=end[i];j++)
			ord[i][j-st[i]+1] = num[j],bel[j]=i;
		sort(ord[i]+1,ord[i]+end[i]-st[i]+2);
		for(int k = 1;k<= end[i]-st[i]+1;k++)
			sum[i][k] = sum[i][k-1]+ord[i][k].v;
	}
	int x,y;
	//scanf("%d",&m);
	while(m--)
	{
		scanf("%d%d",&x,&y);
		if(x>y)swap(x,y);
		int L = bel[x],R = bel[y];
		if(L==R)
		{
			for(int i = x+1;i< y;i++)
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;
			for(int i = x+1;i< y;i++)
				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
			if(num[x].a<num[y].a)tot_ans+=num[x].v+num[y].v;
			else if(num[x].a>num[y].a)tot_ans-=num[x].v+num[y].v;
			swap(num[x],num[y]);
			rebuild(L);
		}else
		{
			for(int i = x+1;i<=end[L];i++)
			{
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;

				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			for(int i = st[R];i< y;i++)
			{
				if(num[i].a>num[x].a)
					tot_ans+=num[i].v+num[x].v;
				else if(num[i].a<num[x].a)
					tot_ans-=num[i].v+num[x].v;

				if(num[i].a<num[y].a)
					tot_ans+=num[i].v+num[y].v;
				else if(num[i].a>num[y].a)
					tot_ans-=num[i].v+num[y].v;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			for(int i = L+1;i<= R-1;i++)
			{
				int lx = less_than(num[x].a,i);
				int bx = bigger_than(num[x].a,i);
				int ly = less_than(num[y].a,i);
				int by = bigger_than(num[y].a,i);
				tot_ans-=sum[i][lx]+(ll)lx*num[x].v%mod;
				tot_ans+=sum[i][end[i]-st[i]+1]-sum[i][bx]+(ll)(end[i]-st[i]+1-bx)*num[x].v%mod;
				tot_ans+=sum[i][ly]+(ll)ly*num[y].v%mod;
				tot_ans-=sum[i][end[i]-st[i]+1]-sum[i][by]+(ll)(end[i]-st[i]+1-by)*num[y].v%mod;
				tot_ans = (tot_ans%mod+mod)%mod;
			}
			if(num[x].a<num[y].a)tot_ans+=num[x].v+num[y].v;
			else if(num[x].a>num[y].a)tot_ans-=num[x].v+num[y].v;
			swap(num[x],num[y]);
			rebuild(L),rebuild(R);
		}
		tot_ans = (tot_ans%mod+mod)%mod;
		printf("%lld\n",tot_ans);
	}
	return 0;
}
Problem4891

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef long double ld;
int n,m,k;
ll b[100005],a[22][100005],M;
int fp,ts[100];
ll fs[100];
ll mul(ll a,ll b,ll c)
{
    if(c<=2000000000ll)return a*b%c;
    ll r=a*b-ll(ld(a)/c*b)*c;
    if(r>=c||r<=-c)r%=c;
    return r>=0?r:r+c;
}
ll pw(ll a,ll n,ll P)
{
    ll v=1;
    for(;n;n>>=1,a=mul(a,a,P))if(n&1)v=mul(v,a,P);
    return v;
}
ll gcd(ll a,ll b)
{
    if(a<0)a=-a;
    for(ll c;b;c=a,a=b,b=c%b);
    return a;
}
bool mr(ll n)
{
    ll z=n-1;
    int t=0;
    while(~z&1)z>>=1,++t;
    for(int i=0;i<15;++i)
    {
        ll a=rand()%(n-1)+1;
        ll x=pw(a,z,n);
        for(int j=0;j<t;++j)
        {
            ll y=mul(x,x,n);
            if(y==1&&x!=1&&x!=n-1)return 0;
            x=y;
        }
        if(x!=1)return 0;
    }
    return 1;
}
ll get(ll x,int c)
{
    int i=1,j=2;
    ll a=(rand()^ll(rand())<<31)%(x-1)+1,b=a;
    while(1)
    {
        a=mul(a,a,x);
        if((a+=c)>=x)a%=x;
        ll p=gcd(a-b,x);
        if(p!=1)return p;
        if((++i)==j)j<<=1,b=a;
    }
}
void calc(ll n)
{
    if(n==1)return;
    if(mr(n))
    {
        fs[fp++]=n;
        return;
    }
    for(int c=12347;;++c)
    {
        ll a=get(n,c);
        if(a!=n)
        {
            ll b=gcd(a,n/a);
            calc(a/b);
            calc(n/a/b);
            calc(b);
            return;
        }
    }
}
ll cal(ll*b,ll*a,ll M)
{
    fp=0;
    calc(M);
    std::sort(fs,fs+fp);
    fp=std::unique(fs,fs+fp)-fs;
    ll phi_M=M;
    for(int i=0;i<fp;++i)ts[i]=0,phi_M=phi_M/fs[i]*(fs[i]-1);
    ll B=1,A=1,x;
    for(int i=1;i<=m;++i)
    {
        x=b[i];
        if(fs[0]==2)for(;~x&1;x>>=1,++ts[0]);
        for(int j=(fs[0]==2);j<fp;++j)
        {
            for(ll p=fs[j],y=x/p;y*p==x;x=y,y=y/p,++ts[j]);
        }
        B=mul(B,x,M);
    }
    for(int i=1;i<=m;++i)
    {
        x=a[i];
        if(fs[0]==2)for(;~x&1;x>>=1,--ts[0]);
        for(int j=(fs[0]==2);j<fp;++j)
        {
            for(ll p=fs[j],y=x/p;y*p==x;x=y,y=y/p,--ts[j]);
        }
        A=mul(A,x,M);
    }
    B=mul(B,pw(A,phi_M-1,M),M);
    for(int i=0;i<fp;++i)
    {
        if(ts[i]<0)return -1;
        B=mul(B,pw(fs[i],ts[i],M),M);
    }
    return B;
}
int main()
{
    srand(200037);
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;++i)scanf("%lld",&b[i]);
    for(int t=1;t<=n;++t)
    	for(int i=1;i<=m;++i)
    		scanf("%lld",&a[t][i]);
    for(int i=0;i<k;++i)
    {
    	int x;
    	scanf("%d%lld",&x,&M);
        printf("%lld\n",cal(b,a[x],M));
    }
    return 0;
}
Problem4892

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;
const int sed = 37;
const int N = 1e5+5;
ull Pow[N],h1[N],h2[N];
char s1[N],s2[N];
int l1,l2,T,c;
void check(int l1,int r1,int l2,int r2)
{
	while(c<=3&&l1<=r1)
	{
		if(s1[l1]!=s2[l2])l1++,l2++,c++;
		else if(s1[r1]!=s2[r2])r1--,r2--,c++;
		else break;
	}
	if(l1>r1||c>3)return ;
	if(h1[r1]-h2[r2]==(h1[l1-1]-h2[l2-1])*Pow[r1-l1+1])return ;
	int d = (r1-l1)>>1;
	check(l1,l1+d,l2,l2+d);
	check(l1+d+1,r1,l2+d+1,r2);
}
void work()
{
	l1=strlen(s1+1);
	l2=strlen(s2+1);
	for(int i = 1;i<= l1;i++)h1[i]=h1[i-1]*sed+s1[i];
	for(int i = 1;i<= l2;i++)h2[i]=h2[i-1]*sed+s2[i];
	int ans = 0;
	for(int i = 1;i<= l1-l2+1;i++)
	{
		c = 0;
		check(i,i+l2-1,1,l2);
		if(c<=3)ans++;
	}
	printf("%d\n",ans);
}
int main()
{
	Pow[0] = 1;
	for(int i = 1;i<N;i++)Pow[i] = Pow[i-1]*sed;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%s%s",s1+1,s2+1);
		work();
	}
	return 0;
}
Problem4893

#include <stdio.h>
#include <set>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
#define mp(a,b) make_pair(a,b)
const int N = 1e5+5;
int a[N],b[3],c[3];
set<pair<int,pair<int,int> > >S;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		b[a[i]]++;
	}
	b[0]>>=1,b[1]>>=1,b[2]>>=1;
	for(int i = 1;i<= n;i++)
	{
		c[a[i]]++;
		if(b[0]==c[0]&&b[1]==c[1]&&b[2]==c[2])
			return printf("1\n"),0;
	}
	c[0] = c[1] = c[2] = 0;
	for(int i = 1;i<= n;i++)
	{
		c[a[i]]++;
		if(S.count(mp(c[0]-b[0],mp(c[1]-b[1],c[2]-b[2]))))
			return printf("2\n"),0;
		S.insert(mp(c[0],mp(c[1],c[2])));
	}
	printf("3\n");
	return 0;
}
Problem4896

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 6e6+5;
char s[100];
int ch[N][10],siz[N],cnt;
vector<int>num[N];
void Insert(int id)
{
	int now = 0,i = 1;
	while(s[i])
	{
		if(!ch[now][s[i]-'a'])ch[now][s[i]-'a'] = ++cnt;
		now = ch[now][s[i]-'a'];
		i++;
		siz[now]++;
		if(siz[now]>num[now].size())num[now].push_back(id);
	}
}
void Delete()
{
	int now = 0,i= 1;
	while(s[i])
	{
		now = ch[now][s[i]-'a'];
		siz[now]--;
		i++;
	}
}
int Find()
{
	int now = 0,i = 1;
	while(s[i])
	{
		now = ch[now][s[i]-'a'];
		i++;
	}
	return now;
}
int main()
{
	int n,k,a,b,c,lst=0;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&k);
		if(k==3)
		{
			scanf("%s",s+1);
			scanf("%d%d%d",&a,&b,&c);
			a = ((ll)a*abs(lst)+b)%c;
			int pos = Find();
			if(num[pos].size()<=a)lst = -1;
			else lst = num[pos][a];
			printf("%d\n",lst);
		}else
		{
			scanf("%s",s+1);
			if(k==1)Insert(i);
			else Delete();
		}
	}
	return 0;
}
Problem4897

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 55;
const int INF = 1e9;
int dp[N][N],dp1[N][N][N];
int mx[N][N],mn[N][N];
int n,a,b,w[N];
void DP(int l,int r)
{
	register int i,j,k,o;
	for(i = l;i<= r;i++)
		for(j = l;j<= r;j++)
			for(k = l;k<= r;k++)
				dp1[i][j][k] = INF;
	dp1[l][l][l] = 0;
	for(i = l;i<= r;i++)
	{
		if(i!=l)dp1[i][i][i] = min(dp1[i][i][i],dp[l][i-1]);
		for(j = l;j<= r;j++)
			for(k = l;k<= r;k++)
			{
				if(dp1[i][j][k]==INF)continue;
				dp1[i+1][w[j]>w[i+1]?j:i+1][w[k]<w[i+1]?k:i+1] = min(dp1[i+1][w[j]>w[i+1]?j:i+1][w[k]<w[i+1]?k:i+1] ,dp1[i][j][k]);
				for ( o = i + 1 ; o <= r ; o++ )
                	dp1[o][j][k] = min ( dp1[o][j][k] , dp1[i][j][k] + dp[i+1][o] );  
			}
	}
}
int main()
{
	scanf("%d%d%d",&n,&a,&b);
	for(int i = 1;i<= n;i++)scanf("%d",&w[i]);
	for(int i = 1;i<= n;i++)
	{
		mx[i][i] = mn[i][i] = w[i]; 
		for(int j = i+1;j<= n;j++)
			mx[i][j] = max(mx[i][j-1],w[j]),
			mn[i][j] = min(mn[i][j-1],w[j]);
	}
	for(int l = 1;l<= n;l++)
	{
		for(int i = 1;i<= n-l+1;i++)
		{
			int j = i+l-1;
			dp[i][j] = a+b*(mx[i][j]-mn[i][j])*(mx[i][j]-mn[i][j]);
			DP(i,j);
			for (int k = i ; k <= j ; k++ ) 
				for (int o = i ; o <= j ; o++ ) 
				{  
                	if ( w[k] < w[o] ) continue;  
                	dp[i][j] = min ( dp[i][j] , dp1[j][k][o] + a + b * (w[k]-w[o]) * (w[k]-w[o]) );  
            	}  
		}
	}
	printf ("%d\n",dp[1][n]);  
	return 0;
}
Problem4899

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 705;
const int P = 705;
const int M = 1505;
struct E
{int next,to;}e[M];
int head[M],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
double g[M],dis[N][N],f[N][P];
int d[M],n,m,p;
void dfs(int x)
{
	g[x] = 1;
	for(int i = head[x];i;i=e[i].next)
	{
		dfs(e[i].to);
		g[x]+=g[e[i].to]/d[x];
	}
}
int main()
{
	int cas;
	scanf("%d",&cas);
	while(cas--)
	{
		int x,y;
		scanf("%d%d%d",&n,&m,&p);
		for(int i = 1;i<= m-n;i++)
		{
			scanf("%d%d",&x,&y);
			add(x,y);d[x]++;
		}
		for(int i = 1;i<= n;i++)dfs(i);
		for(int i = 1;i<= n;i++)
			for(int j = i+1;j<= n;j++)
				dis[i][j] = 
			(dis[i][j-1]+1.0/(d[j-1]+1)+1.0*d[j-1]/(d[j-1]+1)*g[j-1])*(d[j-1]+1);
		for(int i = 1;i<= n;i++)
			for(int j = 1;j<= p;j++)
				f[i][j]=1e18;
		f[1][1] = 0;
		int lim = (n+p-1)/p+1;
		for(int i = 1;i<= n;i++)
			for(int j = 1;j< p;j++)
				for(int k = i+1;k<= i+lim&&k<= n;k++)
					f[k][j+1] = min(f[k][j+1],f[i][j]+dis[i][k]);
		printf("%.4f\n",f[n][p]);tot=0;
		for(int i = 1;i<= m;i++)d[i]=0,head[i]=0,g[i]=0;
	}
	return 0;
}
Problem4906

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+20;
struct data
{
	ll f[4][4];
	data(){memset(f,0,sizeof(f));}
	data(ll a,ll b,ll c)
	{
		f[0][0]=f[3][3]=a;f[1][1]=b;f[2][2]=c;
		f[0][1]=max(a,b),f[1][2]=max(b,c),f[2][3]=max(c,a);
		f[0][2]=f[1][3]=f[0][3]=max(max(b,c),a);
	}
	friend data operator +(const data &a,const data &b)
	{
		data c;
		for(int l = 1;l<= 4;l++)
			for(int i = 0;i+l-1<4;i++)
			{
				int j = i+l-1;
				for(int k = i;k<= j;k++)
					c.f[i][j]=max(c.f[i][j],a.f[i][k]+b.f[k][j]);
			}
		return c;
	}
}s[N];
int fa[N],size[N],ch[N][2];
int rt,mark,A[N],B[N],C[N],L[N],n,cnt,q[N],top,tms;
ll Size[N],tot;
void Push_up(int x)
{
	s[x] = data(1ll*A[x]*L[x],1ll*B[x]*L[x],1ll*C[x]*L[x]);
	if(ch[x][0])s[x] = s[ch[x][0]]+s[x];
	if(ch[x][1])s[x] = s[x]+s[ch[x][1]];
	Size[x] = Size[ch[x][0]]+Size[ch[x][1]]+L[x];
	size[x] = size[ch[x][0]]+size[ch[x][1]]+1;
}
int Find(int x,ll pos)
{
	ll Sz1 = Size[ch[x][0]],Sz2 = Sz1+L[x];
	if((Sz1<pos||(!ch[x][0]&&!pos))&&Sz2>=pos)return x;
	else if(Sz1>=pos)return Find(ch[x][0],pos);
	else {tot+=Sz2;return Find(ch[x][1],pos-Sz2);}
}
void Insert(int &x,int ai,int bi,int ci,ll pos,int len,int last=0)
{
	if(!x)
	{
		x = ++cnt;
		s[x] = data(1ll*ai*len,1ll*bi*len,1ll*ci*len);
		L[x]=Size[x]=len;
		A[x]=ai,B[x]=bi,C[x]=ci;fa[x]=last;size[x]=1;
		return ;
	}
	ll Sz = Size[ch[x][0]]+L[x];
	if(pos<Sz)Insert(ch[x][0],ai,bi,ci,pos,len,x);
	else Insert(ch[x][1],ai,bi,ci,pos-Sz,len,x);
	Push_up(x);
	if(max(size[ch[x][0]],size[ch[x][1]])>0.7*size[x])mark=x;
}
void Update(int x,int k,ll pos,int Len)
{
	if(x==k)
	{
		L[x] = Len;
		Push_up(x);
		return ;
	}
	if(Size[ch[x][0]]>=pos)Update(ch[x][0],k,pos,Len);
	else Update(ch[x][1],k,pos-L[x]-Size[ch[x][0]],Len);
	Push_up(x);
}
void Dfs(int x)
{
	if(ch[x][0])Dfs(ch[x][0]);
	q[++top]=x;
	if(ch[x][1])Dfs(ch[x][1]);
}
void Build(int &x,int l,int r,int last)
{
	if(l>r)
	{
		x=0;
		return ;
	}
	int mid = (l+r)>>1;
	x = q[mid];fa[x] = last;
	Build(ch[x][0],l,mid-1,x);
	Build(ch[x][1],mid+1,r,x);
	Push_up(x);
}
void rebuild(int x)
{
    mark=top=0;
    Dfs(x);
    int y=fa[x];
    if(!y) Build(rt,1,top,0);
    else Build(ch[y][ch[y][1]==x],1,top,y);
}

int main()
{
	scanf("%d",&n);
	Insert(rt,0,0,0,0,0);
	ll pre = 0;
	for(int i = 1;i<= n;i++)
	{
		ll pi;int ai,bi,ci,x;
		scanf("%lld%d%d%d%d",&pi,&ai,&bi,&ci,&x);
		tot = tms = 0;
		int k = Find(rt,pi);
		if(tot+Size[ch[k][0]]+L[k]!=pi)
		{
			ll Left=tot+Size[ch[k][0]]+L[k]-pi;
            tms=0;
            Update(rt,k,pi,L[k]-Left);    
            Insert(rt,ai,bi,ci,pi,x);
            if(mark) rebuild(mark);
            Insert(rt,A[k],B[k],C[k],pi+x,Left);
		}else Insert(rt,ai,bi,ci,pi,x);
		printf("%lld\n",s[rt].f[0][3]-pre);
		pre = s[rt].f[0][3];
		if(mark)rebuild(mark);
	}
	return 0;
}
Problem4908

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=200005;
int n;
int a[N],b[N];
int Q,x[N],y[N];
int sx[N],icnt;
inline int Bin(int x)
{
	return lower_bound(sx+1,sx+icnt+1,x)-sx;
}
const int BB=505;
int B,lp[BB],rp[BB];
int pos[N],cnt;
int v[N],c[N];
int idx[N];
int pnt[BB],lc[BB][BB]; 
ll svc[BB][BB],sv[BB][BB];
int p[BB],q[BB];
ll ans[BB];
#define Size(x) (rp[x]-lp[x]+1)
inline ll Sum(int x)
{
	return sv[x][p[x]]*q[x]-svc[x][p[x]]+(svc[x][pnt[x]]-svc[x][p[x]])-(sv[x][pnt[x]]-sv[x][p[x]])*q[x];
}
ll Ans=0;
int _c[512];
int tmp[N],t2[N];
void rsort(int l,int r)
{
	for (int i=l;i<=r;i++) c[i]+=50000;

	for (int i=0;i<512;i++) _c[i]=0;
	for (int i=l;i<=r;i++) _c[c[i]&511]++;
	for (int i=1;i<512;i++) _c[i]+=_c[i-1];
	for (int i=r;i>=l;i--) tmp[_c[c[i]&511]--]=i;

	for (int i=0;i<512;i++) _c[i]=0;
	for (int i=1;i<=r-l+1;i++) _c[c[tmp[i]]>>9]++;
	for (int i=1;i<512;i++) _c[i]+=_c[i-1];
	for (int i=r-l+1;i;i--) t2[_c[c[tmp[i]]>>9]--]=tmp[i];

	for (int i=l;i<=r;i++) idx[i]=t2[i-l+1],c[i]-=50000;
}
void Build(int x)
{
	rsort(lp[x],rp[x]);
	Ans-=ans[x]; pnt[x]=0;
	for (int j=lp[x];j<=rp[x];j++)
		if (j==lp[x] || c[idx[j]]!=c[idx[j-1]])
		{
			pnt[x]++,lc[x][pnt[x]]=c[idx[j]];
			sv[x][pnt[x]]=sv[x][pnt[x]-1]+v[idx[j]];
			svc[x][pnt[x]]=svc[x][pnt[x]-1]+(ll)v[idx[j]]*c[idx[j]];
		}
		else
		{
			sv[x][pnt[x]]+=v[idx[j]];
			svc[x][pnt[x]]+=(ll)v[idx[j]]*c[idx[j]];
		}
	q[x]=0;
	p[x]=upper_bound(lc[x]+1,lc[x]+pnt[x]+1,0)-lc[x]-1;
	Ans+=(ans[x]=Sum(x));
}

void Reb(int x,int l,int r,int t)
{
	if (l>r) return;
	for (int i=lp[x];i<=rp[x];i++) c[i]-=q[x];
	for (int i=l;i<=r;i++) c[i]+=t;
	Build(x);
}
void Add(int l,int r,int t)
{
	int lb=pos[l],rb=pos[r];
	if (lb==rb)
	{
		Reb(lb,l,r,t);
		return;
	}
	Reb(lb,l,rp[lb],t);
	Reb(rb,lp[rb],r,t);
	for (int i=lb+1;i<rb;i++)
	{
		Ans-=ans[i];
		q[i]-=t;
		while (p[i]+1<=pnt[i] && lc[i][p[i]+1]<=q[i]) p[i]++;
		while (p[i]>0 && lc[i][p[i]]>q[i]) p[i]--; 
		Ans+=(ans[i]=Sum(i));
	}
}

int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) 
		scanf("%d",&a[i]),sx[++icnt]=a[i];
	for (int i=1;i<=n;i++) 
		scanf("%d",&b[i]),sx[++icnt]=b[i];
	scanf("%d",&Q); 
	for (int i=1;i<=Q;i++) 
		scanf("%d%d",&x[i],&y[i]),sx[++icnt]=y[i];
	sort(sx+1,sx+icnt+1); 
	icnt=unique(sx+1,sx+icnt+1)-sx-1;
	for (int i=1;i<icnt;i++) 
		v[i]=sx[i+1]-sx[i];
	B=sqrt(icnt);
	for (int i=1;i<=icnt;i++) 
		pos[i]=(i-1)/B+1; cnt=pos[icnt];
	for (int i=1;i<=cnt;i++) 
		lp[i]=(i-1)*B+1,rp[i]=i*B; rp[cnt]=icnt;
	for (int i=1;i<=n;i++) 
		a[i]=Bin(a[i]),b[i]=Bin(b[i]),c[a[i]]++,c[b[i]]--;
	for (int i=1;i<=icnt;i++) 
		c[i]+=c[i-1];
	for (int i=1;i<=cnt;i++)
		Build(i);
	printf("%lld\n",Ans);
	for (int i=1;i<=Q;i++)
	{
		y[i]=Bin(y[i]);
		if (y[i]<a[x[i]])
			Add(y[i],a[x[i]]-1,1),a[x[i]]=y[i];
		else if (a[x[i]]<y[i])
			Add(a[x[i]],y[i]-1,-1),a[x[i]]=y[i];
		printf("%lld\n",Ans);
	}
	return 0;
}
Problem4911

#include <stdio.h>
#include <vector>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
const int N = 3e4+5;
const int mxK = 130;
const int mod = 10007;
const int inv2 = (mod+1)>>1;

inline void FWT(int *a,int n,int type)
{
	for(int i = 1;i<n;i<<=1)
		for(int j = 0;j<n;j+=(i<<1))
			for(int k = 0;k<i;k++)
			{
				int x = a[j+k],y = a[j+k+i];
				a[j+k] = (x+y)%mod;
				a[j+k+i] = (x-y+mod)%mod;
				if(!type)(a[j+k]*=inv2)%=mod,(a[j+k+i]*=inv2)%=mod;
			}
}
int quick_pow(int x,int y)
{int res=1;while(y){if(y&1)res=res*x%mod;x=x*x%mod;y>>=1;}return res;}
int K,kx[mxK][mxK];
int inv[mod];
void pre(int n)
{
	for(int i = 0;i<n;i++)
		kx[i][i]=1,FWT(kx[i],n,1);
	for(int i = 1;i<mod;i++)inv[i]=quick_pow(i,mod-2);
}
struct E
{int next,to;}e[N<<1];
int head[N],tot;
void add(int x,int y)
{
	e[++tot].to = y;e[tot].next = head[x];head[x] = tot;
	e[++tot].to = x;e[tot].next = head[y];head[y] = tot;
}
int fa[N],size[N],top[N];
int dep[N],son[N];
vector<int>P[N];
void dfs1(int x)
{
	size[x] = 1;dep[x] = dep[fa[x]]+1;
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x])
		{
			fa[e[i].to] = x;
			dfs1(e[i].to);
			size[x]+=size[e[i].to];
			if(size[e[i].to]>size[son[x]])son[x] = e[i].to;
		}
}
void dfs2(int x,int tp)
{
	P[tp].push_back(x);
	top[x] = tp;
	if(son[x])dfs2(son[x],tp);
	for(int i = head[x];i;i=e[i].next)
		if(e[i].to!=fa[x]&&e[i].to!=son[x])
			dfs2(e[i].to,e[i].to);
}
struct data
{
	int x,y;
	data(int num=0)
	{
		if(num)x=num,y=0;
		else x=y=1;
	}
	int val(){return y?0:x;}
	data & operator *=(int a)
	{
		if(!a)y++;
		else x = x*a%mod;
		return *this;
	} 
	data & operator /=(int a)
	{
		if(!a)y--;
		else x = x*inv[a]%mod;
		return *this;
	}
};
data Base[N][mxK];
int cnt,pos[N],rt[N];
int ps[N<<2],ls[N<<2],rs[N<<2];
int val[N<<2][mxK],lv[N<<2][mxK],rv[N<<2][mxK],sum[N<<2][mxK];
inline void update(int p)
{
	int l = ls[p],r = rs[p];
	for(int i = 0;i<K;i++)
	{
		val[p][i] = (val[l][i]+val[r][i]+rv[l][i]*lv[r][i])%mod;
		lv[p][i] = (lv[l][i]+lv[r][i]*sum[l][i])%mod;
		rv[p][i] = (rv[r][i]+rv[l][i]*sum[r][i])%mod;
		sum[p][i] = sum[l][i]*sum[r][i]%mod;
	}
}
inline void Build(int &p,int l,int r,int t)
{
	p = ++cnt;
	if(l==r)
	{
		for(int i = 0;i<K;i++)
			val[p][i]=lv[p][i]=rv[p][i]=sum[p][i]=Base[P[t][l-1]][i].val();
		pos[P[t][l-1]] = p;
		return ;
	}
	int mid = (l+r)>>1;
	Build(ls[p],l,mid,t);
	Build(rs[p],mid+1,r,t);
	update(p);ps[ls[p]]=ps[rs[p]]=p;
}
int ans[mxK],tmp[mxK];
void Update(int u)
{
	int t = top[u];
	if (fa[t])
		for (int j=0;j<K;j++)
			Base[fa[t]][j]/=(lv[rt[t]][j]+kx[0][j])%mod;
	for(int j = 0;j<K;j++)
		ans[j] = (ans[j]+mod-val[rt[t]][j])%mod;

	int x = pos[u];
	for(int i = 0;i<K;i++)
		val[x][i]=lv[x][i]=rv[x][i]=sum[x][i]=Base[u][i].val();
	x = ps[x];
	while(x)
		update(x),x=ps[x];

	if (fa[t])
		for (int j=0;j<K;j++)
			Base[fa[t]][j]*=(lv[rt[t]][j]+kx[0][j])%mod;
	for(int j = 0;j<K;j++)
		ans[j] = (ans[j]+val[rt[t]][j])%mod;
}
int n,Val[N],last[N],pnt;
inline bool cmp(int a,int b)
{
	return dep[a]>dep[b];
}
int main()
{
	//freopen("4911.in","r",stdin);
	//freopen("4911.out","w",stdout);
	int x,y,Q;
	char order[10];
	scanf("%d%d",&n,&K);
	int t = 1;
	while(t<K)t<<=1;K = t;
	pre(K);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&x);Val[i] = x;
		for(int j = 0;j<K;j++)Base[i][j]=data(kx[x][j]);
	}
	for(int i = 1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);
	}
	dfs1(1);
	dfs2(1,1);
	for(int i = 1;i<= n;i++)
		if(top[i]==i)
			last[++pnt]=i;
	sort(last+1,last+pnt+1,cmp);
	for(int i = 1;i<= pnt;i++)
	{
		int x = last[i];
		Build(rt[x],1,P[x].size(),x);
		if(fa[x])
		{
			int f = fa[x];
			for(int j = 0;j<K;j++)
				Base[f][j]*=(lv[rt[x]][j]+kx[0][j])%mod;
		}
		for(int j = 0;j<K;j++)
			ans[j] = (ans[j]+val[rt[x]][j])%mod;
	}
	scanf("%d",&Q);
	while(Q--)
	{
		scanf("%s",order);
		if(order[0]=='C')
		{
			scanf("%d%d",&x,&y);
			for(int j=0;j<K;j++)
				Base[x][j]/=kx[Val[x]][j];
			Val[x]=y;
			for (int j=0;j<K;j++)
				Base[x][j]*=kx[Val[x]][j];
			while (x!=0)
				Update(x),x=fa[top[x]];
		}
		else
		{
			scanf("%d",&x);
			for(int j = 0;j<K;j++)tmp[j]=ans[j];
			FWT(tmp,K,0);
			printf("%d\n",tmp[x]);
		}
	}
	return 0;
}
Problem4915

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
int main()
{
	ll l,r;
	scanf("%lld%lld",&l,&r);
	printf("4\n%lld\n",max(r/11-l+1,0ll)+max(r/29-l+1,0ll));
	return 0;
}
Problem4919

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <set>
#include <algorithm>
using namespace std;
const int N = 2e5+5;
typedef long long ll;
int v[N],p[N],idx[N];
multiset<int>heap[N];
multiset<int>::iterator it;
struct E
{int next,to;}e[N];
int head[N],tot;
void add(int x,int y){e[++tot].to=y;e[tot].next=head[x];head[x]=tot;}
int merge(int x,int y)
{
	if(heap[x].size()<heap[y].size())swap(x,y);
	for(it = heap[y].begin();it!=heap[y].end();it++)
		heap[x].insert(*it);
	heap[y].clear();
	return x;
}	
void debug(int x)
{
	printf("Case #%d\n",x);
	for(it = heap[x].begin();it!=heap[x].end();it++)
		printf("%d ",*it);
	printf("\n");
}
int cnt;
void dfs(int x)
{
	bool lef = true;
	for(int i = head[x];i;i=e[i].next)
		dfs(e[i].to),lef = false;
	if(lef)idx[x] = ++cnt;
	else idx[x] = idx[e[head[x]].to];
	for(int i = e[head[x]].next;i;i=e[i].next)
		idx[x] = merge(idx[x],idx[e[i].to]);
	it = heap[idx[x]].lower_bound(v[x]);
	if(it==heap[idx[x]].end())heap[idx[x]].insert(v[x]);
	else heap[idx[x]].erase(it),heap[idx[x]].insert(v[x]);
	//debug(idx[x]);
}
int main()
{
	int n,rot;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d%d",&v[i],&p[i]);
		add(p[i],i);if(p[i]==0)rot=i;
	}
	dfs(rot);
	printf("%d\n",heap[idx[rot]].size());
	return 0;
}
Problem4921

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e5+5;
const int mod = 998244353;
int f[N],ls[N],a[N];
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
int main()
{
	int n;
	scanf("%d",&n);
	for(int i = 1;i<= n;i++)
	{
		scanf("%d",&a[i]);
		f[i] = gcd(f[i-1],a[i]);
	}
	for(int i = 2;i<= n;i++)
		if(f[i]==f[i-1])ls[i] = ls[i-1];
		else ls[i] = i-1;
	ls[0] = -1;
	int ans = 0,now = 0;
	for(int i = n;i>= 2;i--)
	{
		now = gcd(now,a[i]);
		for(int j = i-2;j>= 0;j=ls[j])
			ans = (ans+(ll)(j-ls[j])*gcd(now,f[j])%mod)%mod;
		if(i==n)ans = (ans-now+mod)%mod;
	}
	for(int i = 2;i<= n-1;i++)
		(ans+=f[i])%=mod;
	printf("%d\n",ans);
	return 0;
}
﻿
